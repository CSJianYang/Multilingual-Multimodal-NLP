[
    {
        "title": "Take K of Each Character From Left and Right",
        "question_content": "You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\n&nbsp;\nExample 1:\n\nInput: s = \"aabaaaacaabc\", k = 2\nOutput: 8\nExplanation: \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.\n\nExample 2:\n\nInput: s = \"a\", k = 1\nOutput: -1\nExplanation: It is not possible to take one 'b' or 'c' so return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of only the letters 'a', 'b', and 'c'.\n\t0 <= k <= s.length",
        "solutions": [
            {
                "id": 2948183,
                "title": "python-clean-12-line-sliding-window-solution-with-explanation",
                "content": "**Explanation**\\n\\nInstead of taking `k` of each character from left and right, we take at most `count(c) - k` of each character from middle.\\n\\nFor Example 1, `s = \"aabaaaacaabc\"` with `k = 2`:\\n- we have `freq = {\\'a\\': 8, \\'b\\': 2, \\'c\\': 2}`\\n- this converts to `limits = freq - k = {\\'a\\': 6, \\'b\\': 0, \\'c\\': 0}`\\n- now the problem becomes \"finding the longest substring where the occurrence of each character is within `limits`\"\\n- we can easily solve this new problem using sliding window\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(1)`\\n\\n</br>\\n\\n**Python**\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        limits = {c: s.count(c) - k for c in \\'abc\\'}\\n        if any(x < 0 for x in limits.values()):\\n            return -1\\n\\n        cnts = {c: 0 for c in \\'abc\\'}\\n        ans = l = 0\\n        for r, c in enumerate(s):\\n            cnts[c] += 1\\n            while cnts[c] > limits[c]:\\n                cnts[s[l]] -= 1\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n\\n        return len(s) - ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        limits = {c: s.count(c) - k for c in \\'abc\\'}\\n        if any(x < 0 for x in limits.values()):\\n            return -1\\n\\n        cnts = {c: 0 for c in \\'abc\\'}\\n        ans = l = 0\\n        for r, c in enumerate(s):\\n            cnts[c] += 1\\n            while cnts[c] > limits[c]:\\n                cnts[s[l]] -= 1\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n\\n        return len(s) - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947980,
                "title": "c-two-pointer-solution-o-n",
                "content": "Here we use the two pointer technique - i and j represents the characters we take from left and right respectively.\\nFirst , we count number of \\'a\\',\\'b\\',\\'c\\' in the string to check whether solution is possible or not. Now, as we decrease i pointer, we keep check of count of different alphabets and if any of these count becomes less than k, we start j pointer until the condition is satisfied. \\nTime complexity - O(n)\\nSpace complxity -O(1)\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int ca=0,cb=0,cc=0;\\n        int n=s.size();\\n        int ans=n;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\') ca++;\\n            if(s[i]==\\'b\\') cb++;\\n            if(s[i]==\\'c\\') cc++;\\n        }\\n        if(ca<k||cb<k||cc<k) return -1;\\n        int i=n-1,j=n-1;\\n        while(i>=0){\\n            if(s[i]==\\'a\\') ca--;\\n            if(s[i]==\\'b\\') cb--;\\n            if(s[i]==\\'c\\') cc--;\\n            while(ca<k||cb<k||cc<k){\\n            if(s[j]==\\'a\\') ca++;\\n            if(s[j]==\\'b\\') cb++;\\n            if(s[j]==\\'c\\') cc++;\\n                j--;\\n            }\\n            ans=min(ans,i+n-1-j); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int ca=0,cb=0,cc=0;\\n        int n=s.size();\\n        int ans=n;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\') ca++;\\n            if(s[i]==\\'b\\') cb++;\\n            if(s[i]==\\'c\\') cc++;\\n        }\\n        if(ca<k||cb<k||cc<k) return -1;\\n        int i=n-1,j=n-1;\\n        while(i>=0){\\n            if(s[i]==\\'a\\') ca--;\\n            if(s[i]==\\'b\\') cb--;\\n            if(s[i]==\\'c\\') cc--;\\n            while(ca<k||cb<k||cc<k){\\n            if(s[j]==\\'a\\') ca++;\\n            if(s[j]==\\'b\\') cb++;\\n            if(s[j]==\\'c\\') cc++;\\n                j--;\\n            }\\n            ans=min(ans,i+n-1-j); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947988,
                "title": "sliding-window-maximum-o-n-c-java-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the maximum window size of the string such that count of all **A,B,C** chars in rest of the string is atleast **K**\\n\\n**Why taking maximum ?**\\n\\nBecause we need to find minimum number of minutes taking char from left or right side such all **a, b, c** char are at least **K**.\\n\\nBy taking max. window in middle we get smaller window in left and right side.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n\\n# Diagram  \\n\\n![leetcode perfect diag..JPG](https://assets.leetcode.com/users/images/6f0237b3-c523-4df7-9820-2c8445fb4318_1671979518.0344598.jpeg)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N,window = 0;\\n       unordered_map<char,int>count;\\n\\n       for(auto c : s)\\n            count[c]++;\\n\\n       if(count[\\'a\\'] < k || count[\\'b\\'] <k || count[\\'c\\']<k)  \\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          count[s[i]]--;\\n          window++;\\n\\n            while(count[s[i]]<k){\\n                count[s[j++]]++;\\n                window--;\\n            }\\n            \\n          ans = min(ans,N- window);\\n       }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Java\\n\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N+1,window = 0;\\n       Map<Character,Integer>count = new HashMap<Character,Integer>();\\n\\n       for(int i=0;i<N;i++)\\n            count.put(s.charAt(i),count.getOrDefault(s.charAt(i),0)+1);\\n\\n        if((count.getOrDefault(\\'a\\',0) < k) || (count.getOrDefault(\\'b\\',0) < k) || (count.getOrDefault(\\'c\\',0)<k))\\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          char c = s.charAt(i);\\n          count.put(c,count.get(c)-1);\\n          window++;\\n          \\n            while(count.get(c)<k){\\n                count.put(s.charAt(j),count.get(s.charAt(j))+1);\\n                window--;\\n                j++;\\n            }\\n            \\n            ans = Math.min(ans,N- window);\\n       }\\n\\n        return ans;    \\n    }\\n}\\n\\n```\\n\\n# Python3\\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        j = 0\\n        ans = N\\n        window = 0\\n        count = {}\\n\\n        for c in s:\\n            if c not in count:\\n                count[c] = 0\\n            count[c] += 1\\n\\n        if count.get(\\'a\\', 0) < k or count.get(\\'b\\', 0) < k or count.get(\\'c\\', 0) < k:\\n            return -1\\n\\n        for i in range(N):\\n            count[s[i]] -= 1\\n            window += 1\\n\\n            while count[s[i]] < k:\\n                count[s[j]] += 1\\n                j += 1\\n                window -= 1\\n\\n            ans = min(ans, N - window)\\n\\n        return ans\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N,window = 0;\\n       unordered_map<char,int>count;\\n\\n       for(auto c : s)\\n            count[c]++;\\n\\n       if(count[\\'a\\'] < k || count[\\'b\\'] <k || count[\\'c\\']<k)  \\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          count[s[i]]--;\\n          window++;\\n\\n            while(count[s[i]]<k){\\n                count[s[j++]]++;\\n                window--;\\n            }\\n            \\n          ans = min(ans,N- window);\\n       }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N+1,window = 0;\\n       Map<Character,Integer>count = new HashMap<Character,Integer>();\\n\\n       for(int i=0;i<N;i++)\\n            count.put(s.charAt(i),count.getOrDefault(s.charAt(i),0)+1);\\n\\n        if((count.getOrDefault(\\'a\\',0) < k) || (count.getOrDefault(\\'b\\',0) < k) || (count.getOrDefault(\\'c\\',0)<k))\\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          char c = s.charAt(i);\\n          count.put(c,count.get(c)-1);\\n          window++;\\n          \\n            while(count.get(c)<k){\\n                count.put(s.charAt(j),count.get(s.charAt(j))+1);\\n                window--;\\n                j++;\\n            }\\n            \\n            ans = Math.min(ans,N- window);\\n       }\\n\\n        return ans;    \\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        j = 0\\n        ans = N\\n        window = 0\\n        count = {}\\n\\n        for c in s:\\n            if c not in count:\\n                count[c] = 0\\n            count[c] += 1\\n\\n        if count.get(\\'a\\', 0) < k or count.get(\\'b\\', 0) < k or count.get(\\'c\\', 0) < k:\\n            return -1\\n\\n        for i in range(N):\\n            count[s[i]] -= 1\\n            window += 1\\n\\n            while count[s[i]] < k:\\n                count[s[j]] += 1\\n                j += 1\\n                window -= 1\\n\\n            ans = min(ans, N - window)\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948049,
                "title": "not-a-medium-level-question",
                "content": "i found this much harder than a normal level medium question my 1D dp approach was giving tle no idea why this question was placed in medium.",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2951643,
                "title": "sliding-exclusion-window",
                "content": "Sliding window `[j, i]` here excludes characters from the string. \\n\\n![image](https://assets.leetcode.com/users/images/6994b6c5-e77e-4e9d-953b-e3e96e154f0f_1672020013.1885927.png)\\n\\nFirst, we count all characters. Then, we move `i` forward, trying to extend our window.\\n\\nIf we now have less than `k` characters, we need to move `j` forward to compensate.\\n\\nWe track the widest window, which results in the smallest number of characters we take from left and right.\\n\\n**C++**\\n```cpp\\nint takeCharacters(string s, int k) {\\n    int cnt[3] = {}, sz = s.size(), res = -1;\\n    for (auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    if (*min_element(begin(cnt), end(cnt)) < k)\\n        return -1;\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (--cnt[s[i] - \\'a\\'] < k)\\n            while(cnt[s[i] - \\'a\\'] < k)\\n                ++cnt[s[j++] - \\'a\\'];\\n        res = max(res, i - j + 1);\\n    }\\n    return sz - res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint takeCharacters(string s, int k) {\\n    int cnt[3] = {}, sz = s.size(), res = -1;\\n    for (auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    if (*min_element(begin(cnt), end(cnt)) < k)\\n        return -1;\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (--cnt[s[i] - \\'a\\'] < k)\\n            while(cnt[s[i] - \\'a\\'] < k)\\n                ++cnt[s[j++] - \\'a\\'];\\n        res = max(res, i - j + 1);\\n    }\\n    return sz - res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948008,
                "title": "easy-sliding-window-with-explanation-c",
                "content": "# Intuition\\nNow comes the logic instead of finding the strings from both ends having at least k a,b,c\\nwe find the substring which have atmost [character occurences - k] a,b,c\\nNow we have to slide this string window to get the max length of such a string\\ntotal length - length of this window will be our answer \\nwe calculate the length the total count of a,b,c in the string s\\nthen we subtract this respective count with k i.e, our windowCountA = a-k, windowCountB = b-k, windowCountC = c-k\\nthen we try to find a window which have atmost windowCountA a\\'s, windowCountB b\\'s and windowCountC c\\'s\\n        \\n# Code\\n```\\n\\n\\nint takeCharacters(string s, int k) {\\n        int a = 0, b = 0, c = 0;\\n\\n        // make a check for base case i.e, if we don\\'t have enough characters to match k length\\n        for(auto it: s){\\n            if(it == \\'a\\'){\\n                a++;\\n            }\\n            else if(it == \\'b\\'){\\n              b++;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n        // return -1 if not enough count of at least one variable\\n        if(a < k || b < k || c < k){\\n            return -1;\\n        }\\n\\n        \\n        //Now comes the logic instead of finding the strings from both ends having at least k a,b,c\\n        // we find the substring which have atmost [character occurences - k] a,b,c\\n        // Now we have to slide this string window to get the max length of such a string\\n        // total length - length of this window will be our answer \\n\\n        //we calculate the length the total count of a,b,c in the string s\\n        // then we subtract this respective count with k i.e, our windowCountA = a-k, windowCountB = b-k, windowCountC = c-k\\n        // then we try to find a window which have atmost windowCountA a\\'s, windowCountB b\\'s and windowCountC c\\'s\\n        \\n        int n = s.length();\\n        a = a-k;\\n        b = b-k;\\n        c = c-k;\\n        int i=0,j=0;\\n        int mx = 0;\\n        int windowCountA=0,windowCountB=0,windowCountC=0;\\n        while(j<n){\\n            if(s[j] == \\'a\\'){\\n                windowCountA++;\\n            }\\n            else if(s[j] == \\'b\\'){\\n              windowCountB++;\\n            }\\n            else{\\n                windowCountC++;\\n            }\\n\\n            // if any character exceeds the maximum limit we reduce the window size until the count is under limit\\n            while(a < windowCountA || b < windowCountB || c < windowCountC){\\n                if(s[i] == \\'a\\'){\\n                    windowCountA--;\\n                }\\n                else if(s[i] == \\'b\\'){\\n                  windowCountB--;\\n                }\\n                else{\\n                    windowCountC--;\\n                }\\n                i++;\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        return n - mx;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nint takeCharacters(string s, int k) {\\n        int a = 0, b = 0, c = 0;\\n\\n        // make a check for base case i.e, if we don\\'t have enough characters to match k length\\n        for(auto it: s){\\n            if(it == \\'a\\'){\\n                a++;\\n            }\\n            else if(it == \\'b\\'){\\n              b++;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n        // return -1 if not enough count of at least one variable\\n        if(a < k || b < k || c < k){\\n            return -1;\\n        }\\n\\n        \\n        //Now comes the logic instead of finding the strings from both ends having at least k a,b,c\\n        // we find the substring which have atmost [character occurences - k] a,b,c\\n        // Now we have to slide this string window to get the max length of such a string\\n        // total length - length of this window will be our answer \\n\\n        //we calculate the length the total count of a,b,c in the string s\\n        // then we subtract this respective count with k i.e, our windowCountA = a-k, windowCountB = b-k, windowCountC = c-k\\n        // then we try to find a window which have atmost windowCountA a\\'s, windowCountB b\\'s and windowCountC c\\'s\\n        \\n        int n = s.length();\\n        a = a-k;\\n        b = b-k;\\n        c = c-k;\\n        int i=0,j=0;\\n        int mx = 0;\\n        int windowCountA=0,windowCountB=0,windowCountC=0;\\n        while(j<n){\\n            if(s[j] == \\'a\\'){\\n                windowCountA++;\\n            }\\n            else if(s[j] == \\'b\\'){\\n              windowCountB++;\\n            }\\n            else{\\n                windowCountC++;\\n            }\\n\\n            // if any character exceeds the maximum limit we reduce the window size until the count is under limit\\n            while(a < windowCountA || b < windowCountB || c < windowCountC){\\n                if(s[i] == \\'a\\'){\\n                    windowCountA--;\\n                }\\n                else if(s[i] == \\'b\\'){\\n                  windowCountB--;\\n                }\\n                else{\\n                    windowCountC--;\\n                }\\n                i++;\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        return n - mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948131,
                "title": "java-sliding-window-o-n",
                "content": "**Intuition :** \\n\\nwe have to take some length of substring from left side and some length of substring from right side, to fullfill the goal,\\n\\nassume string => [....left substring....][....middle substring....][....right substring....]\\n\\nanswer will contain some length of left substring and some length of right substring (left and right substring\\'s length can also be 0)\\nnow we also want length of both combined to be as small as possible.\\n\\nso we can slide window for the middle substring, \\nto make answer as small as possible, the middle substring should be as large as possible.\\n\\nso, we are finding the largest substring removing which the left and right remaining substrings will contain the required characters to fulfill the goal.\\n\\n```\\nclass Solution {\\n\\n    public int takeCharacters(String str, int k) {\\n        int ans = Integer.MAX_VALUE, c[] = { 0, 0, 0 };\\n        for (int i = 0; i < str.length(); i++) c[str.charAt(i) - \\'a\\']++;\\n        if (c[0] < k || c[1] < k || c[2] < k) return -1;\\n        for (int s = 0, e = 0; e < str.length(); e++) {\\n            c[str.charAt(e) - \\'a\\']--;\\n            while (s <= e && (c[0] < k || c[1] < k || c[2] < k)) c[str.charAt(s++) - \\'a\\']++;\\n            ans = Math.min(ans, str.length() - (e - s + 1));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int takeCharacters(String str, int k) {\\n        int ans = Integer.MAX_VALUE, c[] = { 0, 0, 0 };\\n        for (int i = 0; i < str.length(); i++) c[str.charAt(i) - \\'a\\']++;\\n        if (c[0] < k || c[1] < k || c[2] < k) return -1;\\n        for (int s = 0, e = 0; e < str.length(); e++) {\\n            c[str.charAt(e) - \\'a\\']--;\\n            while (s <= e && (c[0] < k || c[1] < k || c[2] < k)) c[str.charAt(s++) - \\'a\\']++;\\n            ans = Math.min(ans, str.length() - (e - s + 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948012,
                "title": "easy-to-understand-java-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] arr=new int[3];\\n        // count all the frq of string\\n        for(char ch:s.toCharArray()) arr[ch-\\'a\\']++;\\n        \\n        // if total frq of any char is less than k return -1;\\n        if(arr[0]<k||arr[1]<k||arr[2]<k) return -1;\\n        int ans=arr[0]+arr[1]+arr[2];\\n        int st=0;\\n        \\n        for(char ch:s.toCharArray()){\\n            arr[ch-\\'a\\']--;\\n            \\n            // if any char length is less than k then increase start position\\n            if(arr[0]<k||arr[1]<k||arr[2]<k){\\n                //get the min ans\\n                ans=Math.min(arr[0]+arr[1]+arr[2]+1,ans);\\n                while(s.charAt(st)!=ch){\\n                    arr[s.charAt(st)-\\'a\\']++;\\n                    st++;\\n                }\\n                arr[ch-\\'a\\']++;\\n                st++;\\n            }\\n        }\\n        ans=Math.min(arr[0]+arr[1]+arr[2],ans);\\n                \\n        return ans;\\n    }\\n}\\n```\\nupvote if u find it easy to understand",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] arr=new int[3];\\n        // count all the frq of string\\n        for(char ch:s.toCharArray()) arr[ch-\\'a\\']++;\\n        \\n        // if total frq of any char is less than k return -1;\\n        if(arr[0]<k||arr[1]<k||arr[2]<k) return -1;\\n        int ans=arr[0]+arr[1]+arr[2];\\n        int st=0;\\n        \\n        for(char ch:s.toCharArray()){\\n            arr[ch-\\'a\\']--;\\n            \\n            // if any char length is less than k then increase start position\\n            if(arr[0]<k||arr[1]<k||arr[2]<k){\\n                //get the min ans\\n                ans=Math.min(arr[0]+arr[1]+arr[2]+1,ans);\\n                while(s.charAt(st)!=ch){\\n                    arr[s.charAt(st)-\\'a\\']++;\\n                    st++;\\n                }\\n                arr[ch-\\'a\\']++;\\n                st++;\\n            }\\n        }\\n        ans=Math.min(arr[0]+arr[1]+arr[2],ans);\\n                \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948022,
                "title": "complete-explanation-sliding-window-binary-search-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/ad011bc4-5755-4917-9bf9-7b34dd95b374_1671942695.2378585.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void incDec(char ch, vector<int>&currCount, int inc) //to increment decrement count of \\'a\\', b\\', \\'c\\'\\n    {\\n        if (ch == \\'a\\') currCount[0] += inc;\\n        else if (ch == \\'b\\') currCount[1] += inc;\\n        else if (ch == \\'c\\') currCount[2] += inc;\\n    }\\n //==========================================================================================================================================\\n    //check whether the deleted window contains atleast k a\\'s, b\\'s and c\\'s\\n    bool deletedWindowValid(vector<int>&totalCount, vector<int>&currCount, int k) \\n    {\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int deletedCount = totalCount[i] - currCount[i];\\n            if (deletedCount >= k) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n//=====================================================================================================================================\\n    bool isValid(string& s, vector<int>&totalCount, int& k, int windowSize) \\n    {\\n        //Sliding window method to efficiently keep a track of count of a, b and c in the \"REMAINING WINDOW\"\\n        vector<int>currCount(3, 0);\\n        int i = 0;\\n        while(i < windowSize)\\n        {\\n            incDec(s[i], currCount, +1);\\n            i++;\\n        }\\n        if (deletedWindowValid(totalCount, currCount, k)) {  return true; } //check the validity of \"DELTED WINDOW\"\\n        //==============================================================\\n        while(i < s.size())\\n        {\\n            incDec(s[i], currCount, +1); //add curr char to the window\\n            incDec(s[i - windowSize], currCount, -1); //remove (curr - windowSize) char from the window\\n            if (deletedWindowValid(totalCount, currCount, k)) return true;\\n            i++;\\n        }\\n        //==============================================================\\n        return false; \\n    }\\n//===========================================================================================================================================\\n    int takeCharacters(string s, int k) \\n    {\\n        if (k == 0) return 0;\\n        \\n        int n = s.size();\\n        vector<int>totalCount(3, 0); //0 for A, 1 for B, 2 for C\\n        for (char ch : s)\\n        {\\n            if (ch == \\'a\\') totalCount[0]++;\\n            else if (ch == \\'b\\') totalCount[1]++;\\n            else if (ch == \\'c\\') totalCount[2]++;\\n        }\\n        if ((totalCount[0] < k) || (totalCount[1] < k) || (totalCount[2] < k)) return -1;\\n        //=================================================================\\n        //BINARY SEARCH for getting the maximum remaining window\\n        int low = 0, high = n;\\n        int ans = n;\\n        while(low <= high)\\n        {\\n            int windowSize = low + (high - low) / 2;\\n            if (isValid(s, totalCount, k, windowSize)) \\n            {\\n                ans = windowSize;\\n                low = windowSize + 1;\\n            }\\n            else high = windowSize - 1;\\n        }\\n        //=====================================================================\\n        //deltedWindowSize = n - remaining windowSize\\n        return (n - ans);\\n    }\\n//===========================================================================================================================================\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void incDec(char ch, vector<int>&currCount, int inc) //to increment decrement count of \\'a\\', b\\', \\'c\\'\\n    {\\n        if (ch == \\'a\\') currCount[0] += inc;\\n        else if (ch == \\'b\\') currCount[1] += inc;\\n        else if (ch == \\'c\\') currCount[2] += inc;\\n    }\\n //==========================================================================================================================================\\n    //check whether the deleted window contains atleast k a\\'s, b\\'s and c\\'s\\n    bool deletedWindowValid(vector<int>&totalCount, vector<int>&currCount, int k) \\n    {\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int deletedCount = totalCount[i] - currCount[i];\\n            if (deletedCount >= k) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n//=====================================================================================================================================\\n    bool isValid(string& s, vector<int>&totalCount, int& k, int windowSize) \\n    {\\n        //Sliding window method to efficiently keep a track of count of a, b and c in the \"REMAINING WINDOW\"\\n        vector<int>currCount(3, 0);\\n        int i = 0;\\n        while(i < windowSize)\\n        {\\n            incDec(s[i], currCount, +1);\\n            i++;\\n        }\\n        if (deletedWindowValid(totalCount, currCount, k)) {  return true; } //check the validity of \"DELTED WINDOW\"\\n        //==============================================================\\n        while(i < s.size())\\n        {\\n            incDec(s[i], currCount, +1); //add curr char to the window\\n            incDec(s[i - windowSize], currCount, -1); //remove (curr - windowSize) char from the window\\n            if (deletedWindowValid(totalCount, currCount, k)) return true;\\n            i++;\\n        }\\n        //==============================================================\\n        return false; \\n    }\\n//===========================================================================================================================================\\n    int takeCharacters(string s, int k) \\n    {\\n        if (k == 0) return 0;\\n        \\n        int n = s.size();\\n        vector<int>totalCount(3, 0); //0 for A, 1 for B, 2 for C\\n        for (char ch : s)\\n        {\\n            if (ch == \\'a\\') totalCount[0]++;\\n            else if (ch == \\'b\\') totalCount[1]++;\\n            else if (ch == \\'c\\') totalCount[2]++;\\n        }\\n        if ((totalCount[0] < k) || (totalCount[1] < k) || (totalCount[2] < k)) return -1;\\n        //=================================================================\\n        //BINARY SEARCH for getting the maximum remaining window\\n        int low = 0, high = n;\\n        int ans = n;\\n        while(low <= high)\\n        {\\n            int windowSize = low + (high - low) / 2;\\n            if (isValid(s, totalCount, k, windowSize)) \\n            {\\n                ans = windowSize;\\n                low = windowSize + 1;\\n            }\\n            else high = windowSize - 1;\\n        }\\n        //=====================================================================\\n        //deltedWindowSize = n - remaining windowSize\\n        return (n - ans);\\n    }\\n//===========================================================================================================================================\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947989,
                "title": "python-3-sliding-window",
                "content": "**INTUITION** :\\n\\nwe have to find length of **largest window/substring** where we have\\n*  occurences of \\'a\\' in window/substring **<=** (total occurences of \\'a\\' in s) - k\\n*  occurences of \\'b\\' in window/substring **<=** (total occurences of \\'b\\' in s) - k\\n*  occurences of \\'c\\' in window/substring **<=** (total occurences of \\'c\\' in s) - k\\n\\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        ra = s.count(\\'a\\') - k\\n        rb = s.count(\\'b\\') - k\\n        rc = s.count(\\'c\\') - k\\n        \\n\\t\\t# if any of them is less than 0, it means there are less than k occurences of a character.\\n        if any(i < 0 for i in [ra, rb, rc]):\\n            return -1\\n        \\n        hm = defaultdict(int)\\n        length = left = res = 0\\n        \\n        for right in s:\\n            hm[right] += 1\\n            length += 1\\n            \\n            while hm[\\'a\\'] > ra or hm[\\'b\\'] > rb or hm[\\'c\\'] > rc:\\n                hm[s[left]] -= 1\\n                length -= 1\\n                left += 1\\n            \\n            res = max(res, length)\\n        \\n        return len(s) - res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        ra = s.count(\\'a\\') - k\\n        rb = s.count(\\'b\\') - k\\n        rc = s.count(\\'c\\') - k\\n        \\n\\t\\t# if any of them is less than 0, it means there are less than k occurences of a character.\\n        if any(i < 0 for i in [ra, rb, rc]):\\n            return -1\\n        \\n        hm = defaultdict(int)\\n        length = left = res = 0\\n        \\n        for right in s:\\n            hm[right] += 1\\n            length += 1\\n            \\n            while hm[\\'a\\'] > ra or hm[\\'b\\'] > rb or hm[\\'c\\'] > rc:\\n                hm[s[left]] -= 1\\n                length -= 1\\n                left += 1\\n            \\n            res = max(res, length)\\n        \\n        return len(s) - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948185,
                "title": "c-different-perspective-sliding-window",
                "content": "\\n\\n # Kindly Upvote if it helped\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy directly looking into the problem we feel little bit confused \\n\\n ->**original problem**---**require minimum length that contain each character atleast k times from left and right.**\\n\\n-------------------------**Now change the problem** **statement**-------------------------------\\n\\n->**maximum length of substring that contains every character(a,b,c) at most (countofthatcharacter  -k) times**\\n**Now subtract this maximum length from total length to get the answer**\\n\\n->Now that becomes standard sliding window problem \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int a,int b,int c,string s)\\n    {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'a\\')\\n            {\\n                a--;\\n            }\\n            else if(s[j]==\\'b\\')\\n            {\\n                b--;\\n            }\\n            else if(s[j]==\\'c\\')\\n            {\\n                c--;\\n            }\\n// if(condition remain true)\\n            if(a>=0 &&b>=0 &&c>=0)\\n            {\\n                ans=max(ans,j-i+1);\\n            }\\n            while(a<0 ||b<0 ||c<0)\\n            {\\n                 if(s[i]==\\'a\\')\\n                {\\n                    a++;\\n                }\\n                 if(s[i]==\\'b\\')\\n                {\\n                    b++;\\n                }\\n                if(s[i]==\\'c\\')\\n                {\\n                    c++;\\n                }\\n                i++;\\n            }\\n          \\n            j++;\\n        }\\n        return ans;\\n    }\\n    int takeCharacters(string s, int k) {\\n        \\n        int a=0,b=0,c=0;\\n        for(auto x:s)\\n        {\\n            if(x==\\'a\\')\\n            {\\n                a++;\\n            }\\n            else if(x==\\'b\\')\\n            {\\n                b++;\\n            }\\n            else if(x==\\'c\\')\\n            {\\n                c++;\\n            }\\n        }\\n// if total is less than k than it is impossible to do it\\n     if(a<k ||b<k ||c<k)\\n     {\\n         return -1;\\n     }\\n//at most count-k\\n\\n        a=a-k,b=b-k,c=c-k;\\n\\n        return s.length()-solve(a,b,c,s);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int a,int b,int c,string s)\\n    {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'a\\')\\n            {\\n                a--;\\n            }\\n            else if(s[j]==\\'b\\')\\n            {\\n                b--;\\n            }\\n            else if(s[j]==\\'c\\')\\n            {\\n                c--;\\n            }\\n// if(condition remain true)\\n            if(a>=0 &&b>=0 &&c>=0)\\n            {\\n                ans=max(ans,j-i+1);\\n            }\\n            while(a<0 ||b<0 ||c<0)\\n            {\\n                 if(s[i]==\\'a\\')\\n                {\\n                    a++;\\n                }\\n                 if(s[i]==\\'b\\')\\n                {\\n                    b++;\\n                }\\n                if(s[i]==\\'c\\')\\n                {\\n                    c++;\\n                }\\n                i++;\\n            }\\n          \\n            j++;\\n        }\\n        return ans;\\n    }\\n    int takeCharacters(string s, int k) {\\n        \\n        int a=0,b=0,c=0;\\n        for(auto x:s)\\n        {\\n            if(x==\\'a\\')\\n            {\\n                a++;\\n            }\\n            else if(x==\\'b\\')\\n            {\\n                b++;\\n            }\\n            else if(x==\\'c\\')\\n            {\\n                c++;\\n            }\\n        }\\n// if total is less than k than it is impossible to do it\\n     if(a<k ||b<k ||c<k)\\n     {\\n         return -1;\\n     }\\n//at most count-k\\n\\n        a=a-k,b=b-k,c=c-k;\\n\\n        return s.length()-solve(a,b,c,s);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948347,
                "title": "c-commented-explanation-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int, vector<int>>mp1, mp2;// store occurance of each character at every indx\\n        vector<int>v(3,0);\\n        vector<int>v1(3,0);\\n        mp1[-1]=v;\\n        for(int i=0;i<s.size();i++){// prefix storing\\n            v[s[i]-\\'a\\']++;\\n            mp1[i]=v;\\n        }\\n    \\n        mp2[s.size()]=v1;\\n          for(int i=s.size()-1;i>=0;i--){// suffix storing\\n            v1[s[i]-\\'a\\']++;\\n            mp2[i]=v1;\\n        }\\n        if(v1[0]<k || v1[1]<k || v1[2]<k) // lets check for invalid condition\\n            return -1;\\n   \\n  \\n        int st=0, hg=s.size();\\n        int ans=-1;\\n    \\n        while(st<=hg){\\n            int md= st+ (hg-st)/2; // lt assum md is our  required answer\\n            bool flag= false;\\n            int n= s.size();\\n          \\n            int i=md;\\n            for( i=md-1;i>=-1;i--){ // checking that md is valid or not\\n                \\n                if((mp1[i][0]+mp2[n][0] >=k) && (mp1[i][1]+ mp2[n][1]>=k) && (mp1[i][2]+mp2[n][2]>=k) ){ // check that every occurance of character is greater than k or not by taking i character for starting index  and md-i charcter form backword side\\n                    flag= true;\\n                    break; // if condition true break;\\n                }\\n                n--;\\n              \\n            }\\n         \\n                if(flag){\\n                    ans=i+1 + s.size()-n; // if md is valid it means it is our answr and check that can we reduce our search space\\n                    hg=md-1;\\n                }\\n                else{\\n                    st=md+1; // if md is less than our required answer than that time we need to increase our search space\\n                }\\n          \\n            \\n        }\\n       \\n        return ans; // final answer\\n        \\n    }\\n};\\n\\n// plz upvote if it helps\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int, vector<int>>mp1, mp2;// store occurance of each character at every indx\\n        vector<int>v(3,0);\\n        vector<int>v1(3,0);\\n        mp1[-1]=v;\\n        for(int i=0;i<s.size();i++){// prefix storing\\n            v[s[i]-\\'a\\']++;\\n            mp1[i]=v;\\n        }\\n    \\n        mp2[s.size()]=v1;\\n          for(int i=s.size()-1;i>=0;i--){// suffix storing\\n            v1[s[i]-\\'a\\']++;\\n            mp2[i]=v1;\\n        }\\n        if(v1[0]<k || v1[1]<k || v1[2]<k) // lets check for invalid condition\\n            return -1;\\n   \\n  \\n        int st=0, hg=s.size();\\n        int ans=-1;\\n    \\n        while(st<=hg){\\n            int md= st+ (hg-st)/2; // lt assum md is our  required answer\\n            bool flag= false;\\n            int n= s.size();\\n          \\n            int i=md;\\n            for( i=md-1;i>=-1;i--){ // checking that md is valid or not\\n                \\n                if((mp1[i][0]+mp2[n][0] >=k) && (mp1[i][1]+ mp2[n][1]>=k) && (mp1[i][2]+mp2[n][2]>=k) ){ // check that every occurance of character is greater than k or not by taking i character for starting index  and md-i charcter form backword side\\n                    flag= true;\\n                    break; // if condition true break;\\n                }\\n                n--;\\n              \\n            }\\n         \\n                if(flag){\\n                    ans=i+1 + s.size()-n; // if md is valid it means it is our answr and check that can we reduce our search space\\n                    hg=md-1;\\n                }\\n                else{\\n                    st=md+1; // if md is less than our required answer than that time we need to increase our search space\\n                }\\n          \\n            \\n        }\\n       \\n        return ans; // final answer\\n        \\n    }\\n};\\n\\n// plz upvote if it helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988452,
                "title": "c-map-two-pointers-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) \\n    {\\n        int n=s.size();\\n        unordered_map<char, int> mp;\\n        for(auto it:s)  mp[it]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        int mini=n;\\n        int i=n-1, j=n-1;\\n\\n        while(i>=0)\\n        {\\n            mp[s[i]]--;\\n            while(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k)\\n            {\\n                mp[s[j]]++;\\n                j--;\\n            }\\n            mini = min(mini, i+n-1-j);\\n            i--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) \\n    {\\n        int n=s.size();\\n        unordered_map<char, int> mp;\\n        for(auto it:s)  mp[it]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        int mini=n;\\n        int i=n-1, j=n-1;\\n\\n        while(i>=0)\\n        {\\n            mp[s[i]]--;\\n            while(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k)\\n            {\\n                mp[s[j]]++;\\n                j--;\\n            }\\n            mini = min(mini, i+n-1-j);\\n            i--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950871,
                "title": "sliding-window-c-intuitive-explained-and-added-comments",
                "content": "This was inspired by [Introvert_1827\\'s solution](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/2947988/sliding-window-maximum-o-n-c-java/) with some comments added.\\n# Intuition\\n![\\u622A\\u5C4F2022-12-26 \\u4E0A\\u534810.56.47.png](https://assets.leetcode.com/users/images/90a64c19-ca1b-4d4f-932d-dc57c5ed9b95_1672070294.5144327.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char, int> cnt;\\n        for(auto c: s)\\n            cnt[c]++;\\n        \\n        if(cnt[\\'a\\'] < k || cnt[\\'b\\'] < k  || cnt[\\'c\\'] < k )\\n            return -1;\\n\\n        int windowSize = 0, startPos = 0;\\n        int curMin = s.length();\\n        // try to find the max window as possible\\n        // max window size = min leftover(what the problem asks for)\\n        for(int i = 0, N = s.length(); i < N; i++){\\n            \\n            windowSize++;\\n            cnt[s[i]]--;\\n\\n            while(cnt[s[i]] < k){ /* there is not enough s[i] outside the window */\\n                cnt[s[startPos]]++;      /* add back the j th char */\\n                startPos++;              /* move the window to the right by 1 */\\n\\n                windowSize--;     /* decrement windowSize here because it */\\n                                  /* will increment again next iteration */\\n            }\\n            // Why can we constantly move the window to the right (incrementing j)\\n            // if it dose not meet the criteria for the first time?\\n            // answer:\\n            //      If left startPos char out for the first time will cause the answer invalid, \\n            //      no matter how big the window is, it will never be a valid answer.\\n            //      If n-1 is valid, we know the window size n-1 is valid and there is no need for testing a smaller window size.\\n            curMin = min(curMin, N - windowSize);\\n        }\\n\\n        return curMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char, int> cnt;\\n        for(auto c: s)\\n            cnt[c]++;\\n        \\n        if(cnt[\\'a\\'] < k || cnt[\\'b\\'] < k  || cnt[\\'c\\'] < k )\\n            return -1;\\n\\n        int windowSize = 0, startPos = 0;\\n        int curMin = s.length();\\n        // try to find the max window as possible\\n        // max window size = min leftover(what the problem asks for)\\n        for(int i = 0, N = s.length(); i < N; i++){\\n            \\n            windowSize++;\\n            cnt[s[i]]--;\\n\\n            while(cnt[s[i]] < k){ /* there is not enough s[i] outside the window */\\n                cnt[s[startPos]]++;      /* add back the j th char */\\n                startPos++;              /* move the window to the right by 1 */\\n\\n                windowSize--;     /* decrement windowSize here because it */\\n                                  /* will increment again next iteration */\\n            }\\n            // Why can we constantly move the window to the right (incrementing j)\\n            // if it dose not meet the criteria for the first time?\\n            // answer:\\n            //      If left startPos char out for the first time will cause the answer invalid, \\n            //      no matter how big the window is, it will never be a valid answer.\\n            //      If n-1 is valid, we know the window size n-1 is valid and there is no need for testing a smaller window size.\\n            curMin = min(curMin, N - windowSize);\\n        }\\n\\n        return curMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951234,
                "title": "python-3-12-lines-sliding-window-t-m-291-ms-14-8-mb",
                "content": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n        d = Counter(s)\\n        if min(d.values()) < k: return -1\\n\\n        d[\\'a\\']-= k ; d[\\'b\\']-= k ; d[\\'c\\']-= k \\n\\n        ct = {\\'a\\':0, \\'b\\':0, \\'c\\':0}\\n\\n        n, left, ans = len(s)-1, 0, inf\\n\\n        for right, ch in enumerate(s):\\n            ct[ch]+= 1\\n\\n            while ct[ch] > d[ch]:\\n                ct[s[left]]-= 1\\n                left+= 1\\n\\n            ans = min(ans, n-right+left)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/submissions/865427114/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n        d = Counter(s)\\n        if min(d.values()) < k: return -1\\n\\n        d[\\'a\\']-= k ; d[\\'b\\']-= k ; d[\\'c\\']-= k \\n\\n        ct = {\\'a\\':0, \\'b\\':0, \\'c\\':0}\\n\\n        n, left, ans = len(s)-1, 0, inf\\n\\n        for right, ch in enumerate(s):\\n            ct[ch]+= 1\\n\\n            while ct[ch] > d[ch]:\\n                ct[s[left]]-= 1\\n                left+= 1\\n\\n            ans = min(ans, n-right+left)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948820,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3);\\n        for(char c:s)\\n        {\\n            v[c-\\'a\\']++;\\n        }\\n        for(int i:v)\\n            if(i<k)\\n                return -1;\\n        int n=s.size();\\n        int i=n-1;\\n        int a=0, b=0, c=0;\\n        while(i>=0 && (a<k || b<k || c<k))\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else if(s[i]==\\'b\\')\\n                b++;\\n            else\\n                c++;\\n            i--;\\n        }\\n        i++;\\n        int ans=n-i;\\n        int mn=ans;\\n        int l=0;\\n        for(int j=i;j<n;j++)\\n        {\\n            if(s[j]==\\'a\\')\\n                a--;\\n            else if(s[j]==\\'b\\')\\n                b--;\\n            else\\n                c--;\\n            while(a<k || b<k || c<k)\\n            {\\n                if(s[l]==\\'a\\')\\n                    a++;\\n                else if(s[l]==\\'b\\')\\n                    b++;\\n                else\\n                    c++;\\n                l++;\\n            }\\n            int mn=n-j-1+l;\\n            ans=min(ans, mn);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3);\\n        for(char c:s)\\n        {\\n            v[c-\\'a\\']++;\\n        }\\n        for(int i:v)\\n            if(i<k)\\n                return -1;\\n        int n=s.size();\\n        int i=n-1;\\n        int a=0, b=0, c=0;\\n        while(i>=0 && (a<k || b<k || c<k))\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else if(s[i]==\\'b\\')\\n                b++;\\n            else\\n                c++;\\n            i--;\\n        }\\n        i++;\\n        int ans=n-i;\\n        int mn=ans;\\n        int l=0;\\n        for(int j=i;j<n;j++)\\n        {\\n            if(s[j]==\\'a\\')\\n                a--;\\n            else if(s[j]==\\'b\\')\\n                b--;\\n            else\\n                c--;\\n            while(a<k || b<k || c<k)\\n            {\\n                if(s[l]==\\'a\\')\\n                    a++;\\n                else if(s[l]==\\'b\\')\\n                    b++;\\n                else\\n                    c++;\\n                l++;\\n            }\\n            int mn=n-j-1+l;\\n            ans=min(ans, mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654368,
                "title": "two-pointer-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check1(vector<int> &v,int &k){\\n        for(auto &i: v){\\n            if(i<k)return true;\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        if(check1(v,k)){\\n            return -1;\\n        }\\n        int i = 0, j =0,n=s.length(),ans=0;\\n        while(i<n){\\n            v[s[i]-\\'a\\']--;\\n            while(check1(v,k)){\\n                v[s[j]-\\'a\\']++;\\n                j++;\\n            }\\n            ans = max(i-j+1,ans);\\n            i++;\\n        }\\n        return s.length()-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check1(vector<int> &v,int &k){\\n        for(auto &i: v){\\n            if(i<k)return true;\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        if(check1(v,k)){\\n            return -1;\\n        }\\n        int i = 0, j =0,n=s.length(),ans=0;\\n        while(i<n){\\n            v[s[i]-\\'a\\']--;\\n            while(check1(v,k)){\\n                v[s[j]-\\'a\\']++;\\n                j++;\\n            }\\n            ans = max(i-j+1,ans);\\n            i++;\\n        }\\n        return s.length()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960142,
                "title": "intuition-explained-for-remaining-part-sliding-window-o-n-time-o-1-space-solution-with-comments",
                "content": "\\n### IDEA\\n- To minimize the current ans window on both left and right\\n- We need to maximize the REMAINING WINDOW. \\n- Eg:\\n- aabaaaacaabc k= 2\\n- aab|aaaa|caabc = 3|4|5\\n- Here 3+5 = 8 is ans\\n- So the middle part = REMAINING WIN needs to be as big as possible.\\n- So that LEFT OUT RIGHT AND LEFT PART HAS ATLEAST K \\'a\\'s \\'b\\'s \\'c\\'s\\n- we need 2 a,b,c. we have total 8-a 3-b 2-c. \\n- Then at max the opposite can have 6-a 1-b 0-c\\n- So we find such a substr.\\n- So that other than that substr in left and right ends we have our requirement\\n\\n### AT THE END WE CONVERTED \\n- ORG problem: require minimum length that contain each character atleast k times from left and right.\\n- I CONVERTED: maximum length of substring that contains every character(a,b,c) at most (countofthatcharacter -k) times\\n- STANDARD SLIDING WINDOW QUES\\n\\n# Code\\n```\\n//O(N) Time O(1) Space as we use mpp for abc only\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(s==\"\" || k == 0) return 0; //edge case\\n\\n        int N = s.length();\\n        \\n        unordered_map<char,int> mpp; // what we have in the given str\\n        for(char ch : s){\\n            mpp[ch]++;\\n        }\\n\\n        // what we can have atmax in the opposite substr\\n        mpp[\\'a\\']-=k;\\n        mpp[\\'b\\']-=k;\\n        mpp[\\'c\\']-=k;\\n        \\n        //so atmax how many we can have in the opposite substr is what we have \\n\\n        if(mpp[\\'a\\']<0 || mpp[\\'b\\']<0 || mpp[\\'c\\']<0) return -1;\\n        \\n        int ans = -1;\\n        int i=0;\\n        int j=0;\\n\\n        unordered_map<char,int>mpp2; // the substr freq \\n        \\n        while(j < N){\\n            mpp2[s[j]]++;\\n\\n            while(mpp2[\\'a\\'] > mpp[\\'a\\'] || mpp2[\\'b\\']>mpp[\\'b\\'] || mpp2[\\'c\\']>mpp[\\'c\\']){\\n                mpp2[s[i]]--;\\n                i++;\\n            }\\n            \\n            ans = max(ans, j-i+1);\\n\\n            j++; \\n        }\\n        \\n        \\n        if(ans == -1){\\n            return ans;\\n        }\\n\\n        return s.size()-ans;\\n        \\n    }\\n};\\n\\n/*\\nThe entire idea is that we simply traverse and find a sub str such that it is opposite of what we need, so that if thats found then the max len of it is what we need to subtract or delete out\\n\\nEg - we need 2 a,b,c. we have total 8-a 3-b 2-c. Then at max the opposite can have 6-a 1-b 0-c\\nSo we find such a substr.\\nSo that other than that substr in left and right ends we have our requirement\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//O(N) Time O(1) Space as we use mpp for abc only\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(s==\"\" || k == 0) return 0; //edge case\\n\\n        int N = s.length();\\n        \\n        unordered_map<char,int> mpp; // what we have in the given str\\n        for(char ch : s){\\n            mpp[ch]++;\\n        }\\n\\n        // what we can have atmax in the opposite substr\\n        mpp[\\'a\\']-=k;\\n        mpp[\\'b\\']-=k;\\n        mpp[\\'c\\']-=k;\\n        \\n        //so atmax how many we can have in the opposite substr is what we have \\n\\n        if(mpp[\\'a\\']<0 || mpp[\\'b\\']<0 || mpp[\\'c\\']<0) return -1;\\n        \\n        int ans = -1;\\n        int i=0;\\n        int j=0;\\n\\n        unordered_map<char,int>mpp2; // the substr freq \\n        \\n        while(j < N){\\n            mpp2[s[j]]++;\\n\\n            while(mpp2[\\'a\\'] > mpp[\\'a\\'] || mpp2[\\'b\\']>mpp[\\'b\\'] || mpp2[\\'c\\']>mpp[\\'c\\']){\\n                mpp2[s[i]]--;\\n                i++;\\n            }\\n            \\n            ans = max(ans, j-i+1);\\n\\n            j++; \\n        }\\n        \\n        \\n        if(ans == -1){\\n            return ans;\\n        }\\n\\n        return s.size()-ans;\\n        \\n    }\\n};\\n\\n/*\\nThe entire idea is that we simply traverse and find a sub str such that it is opposite of what we need, so that if thats found then the max len of it is what we need to subtract or delete out\\n\\nEg - we need 2 a,b,c. we have total 8-a 3-b 2-c. Then at max the opposite can have 6-a 1-b 0-c\\nSo we find such a substr.\\nSo that other than that substr in left and right ends we have our requirement\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953495,
                "title": "typescript-javascript-clean-solution-using-sliding-window",
                "content": "# Intuition\\nIt is same as finding longest substring which contains at most total_a_count-k and total_b_count-k and total_c_count-k frequencies. So from left or right of the string each a,b,c will appear at least k times. \\n\\n# Approach\\nConsidering subarray with a criteria of frequencies, sliding window is the perfect approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction takeCharacters(s: string, k: number): number {\\n    \\n    let countA = 0\\n    let countB = 0\\n    let countC = 0\\n\\n    for(let ch of s){\\n        if(ch==\\'a\\') countA++\\n        if(ch==\\'b\\') countB++\\n        if(ch==\\'c\\') countC++\\n    }\\n\\n    if(countA<k || countB<k || countC<k) return -1\\n\\n    let max = 0\\n\\n    let extraA = countA - k\\n    let extraB = countB - k\\n    let extraC = countC - k\\n\\n    let j = 0\\n\\n    for(let i=0;i<s.length;i++){\\n        if(s[i]==\\'a\\') extraA--\\n        if(s[i]==\\'b\\') extraB--\\n        if(s[i]==\\'c\\') extraC--\\n\\n        while(extraA<0 || extraB<0 || extraC<0){\\n            if(s[j]==\\'a\\') extraA++\\n            if(s[j]==\\'b\\') extraB++\\n            if(s[j]==\\'c\\') extraC++\\n\\n            j++\\n\\n        }\\n\\n        max = Math.max(max, i-j+1)\\n\\n\\n    }\\n\\n    return s.length - max\\n\\n    \\n\\n    \\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction takeCharacters(s: string, k: number): number {\\n    \\n    let countA = 0\\n    let countB = 0\\n    let countC = 0\\n\\n    for(let ch of s){\\n        if(ch==\\'a\\') countA++\\n        if(ch==\\'b\\') countB++\\n        if(ch==\\'c\\') countC++\\n    }\\n\\n    if(countA<k || countB<k || countC<k) return -1\\n\\n    let max = 0\\n\\n    let extraA = countA - k\\n    let extraB = countB - k\\n    let extraC = countC - k\\n\\n    let j = 0\\n\\n    for(let i=0;i<s.length;i++){\\n        if(s[i]==\\'a\\') extraA--\\n        if(s[i]==\\'b\\') extraB--\\n        if(s[i]==\\'c\\') extraC--\\n\\n        while(extraA<0 || extraB<0 || extraC<0){\\n            if(s[j]==\\'a\\') extraA++\\n            if(s[j]==\\'b\\') extraB++\\n            if(s[j]==\\'c\\') extraC++\\n\\n            j++\\n\\n        }\\n\\n        max = Math.max(max, i-j+1)\\n\\n\\n    }\\n\\n    return s.length - max\\n\\n    \\n\\n    \\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2952045,
                "title": "sliding-window-maximum-o-n-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean valid(int arr[],int k){\\n         if(arr[0]<k || arr[1]<k || arr[2] < k) return false;\\n         return true;\\n    }\\n    public int takeCharacters(String s, int k) {\\n        int arr[]=new int[3];\\n        for(int i=0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        if(arr[0]<k || arr[1]<k || arr[2]<k) return -1;\\n        int i = s.length()-1;\\n        int j = s.length()-1;\\n        int sum = arr[0] + arr[1] + arr[2];\\n        int mini = Integer.MAX_VALUE;\\n        while(i>=0 && j>=0){\\n            arr[s.charAt(i)-\\'a\\']--;\\n            i--;\\n            while(!valid(arr,k)&& j>=0){\\n                    arr[s.charAt(j)-\\'a\\']++;\\n                    j--;\\n                    \\n            }\\n            sum=arr[0]+arr[1]+arr[2];\\n            mini=Math.min(sum,mini);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean valid(int arr[],int k){\\n         if(arr[0]<k || arr[1]<k || arr[2] < k) return false;\\n         return true;\\n    }\\n    public int takeCharacters(String s, int k) {\\n        int arr[]=new int[3];\\n        for(int i=0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        if(arr[0]<k || arr[1]<k || arr[2]<k) return -1;\\n        int i = s.length()-1;\\n        int j = s.length()-1;\\n        int sum = arr[0] + arr[1] + arr[2];\\n        int mini = Integer.MAX_VALUE;\\n        while(i>=0 && j>=0){\\n            arr[s.charAt(i)-\\'a\\']--;\\n            i--;\\n            while(!valid(arr,k)&& j>=0){\\n                    arr[s.charAt(j)-\\'a\\']++;\\n                    j--;\\n                    \\n            }\\n            sum=arr[0]+arr[1]+arr[2];\\n            mini=Math.min(sum,mini);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950244,
                "title": "atmost-substring-sliding-window-standard-approach-striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are going to find the atmost a=count(a)-k,b=count(b)-k,c=count(c)-k maximum length of substring.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink opposite to the problem.\\nIn problem we want minimum length substring from left plus right.--> which means we need to delete middle substring.--> which deleted must be maximum length(ans) substring that have atmost a=count(a)-k,b=count(b)-k,c=count(c)-k. then the ans become equals to (len(s)-ans).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**1. Sliding window**\\n```\\nclass Solution {\\n\\n    public int takeCharacters(String s, int k) {  \\n        int[] arr = new int[3];\\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        arr[0]-=k;\\n        arr[1]-=k;\\n        arr[2]-=k;\\n\\n        if(arr[0]<0||arr[1]<0||arr[2]<0) return -1;\\n\\n        int n = s.length();\\n        int i=0;\\n        int ans=0;\\n        for(int j=0;j<n;j++){\\n            char ch = s.charAt(j);\\n            arr[ch-\\'a\\']--;\\n            if(arr[0]<0||arr[1]<0||arr[2]<0){\\n                while(arr[0]<0||arr[1]<0||arr[2]<0){\\n                    arr[s.charAt(i)-\\'a\\']++;\\n                    i++;\\n                }\\n            }\\n            ans = Math.max(ans,j-i+1);\\n        }\\n        return n-ans;\\n    }\\n}\\n```\\n**2. Recursion (Memoization)**\\n```\\npublic int takeCharacters(String s, int k) {  \\n        int n = s.length();\\n        int [][] dp = new int[n+1][n+1];\\n        for(int [] a: dp) Arrays.fill(a,-1);\\n        int ans = helper(s,k,0,0,0,0,0,s.length()-1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n\\n    }\\n    \\n    public int helper(String s, int k, int a, int b, int c, int count,int i,int j,int[][] dp){\\n        if(a>=k&&b>=k&&c>=k){\\n            return count;\\n        }\\n        if(i>j) return Integer.MAX_VALUE;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int out1=0;\\n        if(s.charAt(i)==\\'a\\'){\\n            out1 = helper(s,k,a+1,b,c,count+1,i+1,j,dp);\\n        }\\n        if(s.charAt(i)==\\'b\\'){\\n            out1 = helper(s,k,a,b+1,c,count+1,i+1,j,dp);\\n        }\\n        if(s.charAt(i)==\\'c\\'){\\n            out1 = helper(s,k,a,b,c+1,count+1,i+1,j,dp);\\n        }\\n        \\n        int out2=0;\\n        if(s.charAt(j)==\\'a\\'){\\n            out2 = helper(s,k,a+1,b,c,count+1,i,j-1,dp);\\n        }\\n        if(s.charAt(j)==\\'b\\'){\\n            out2 = helper(s,k,a,b+1,c,count+1,i,j-1,dp);\\n        }\\n        if(s.charAt(j)==\\'c\\'){\\n            out2 = helper(s,k,a,b,c+1,count+1,i,j-1,dp);\\n        }\\n        \\n        \\n        return dp[i][j] =  Math.min(out1,out2);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion",
                    "Memoization",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int takeCharacters(String s, int k) {  \\n        int[] arr = new int[3];\\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        arr[0]-=k;\\n        arr[1]-=k;\\n        arr[2]-=k;\\n\\n        if(arr[0]<0||arr[1]<0||arr[2]<0) return -1;\\n\\n        int n = s.length();\\n        int i=0;\\n        int ans=0;\\n        for(int j=0;j<n;j++){\\n            char ch = s.charAt(j);\\n            arr[ch-\\'a\\']--;\\n            if(arr[0]<0||arr[1]<0||arr[2]<0){\\n                while(arr[0]<0||arr[1]<0||arr[2]<0){\\n                    arr[s.charAt(i)-\\'a\\']++;\\n                    i++;\\n                }\\n            }\\n            ans = Math.max(ans,j-i+1);\\n        }\\n        return n-ans;\\n    }\\n}\\n```\n```\\npublic int takeCharacters(String s, int k) {  \\n        int n = s.length();\\n        int [][] dp = new int[n+1][n+1];\\n        for(int [] a: dp) Arrays.fill(a,-1);\\n        int ans = helper(s,k,0,0,0,0,0,s.length()-1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n\\n    }\\n    \\n    public int helper(String s, int k, int a, int b, int c, int count,int i,int j,int[][] dp){\\n        if(a>=k&&b>=k&&c>=k){\\n            return count;\\n        }\\n        if(i>j) return Integer.MAX_VALUE;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int out1=0;\\n        if(s.charAt(i)==\\'a\\'){\\n            out1 = helper(s,k,a+1,b,c,count+1,i+1,j,dp);\\n        }\\n        if(s.charAt(i)==\\'b\\'){\\n            out1 = helper(s,k,a,b+1,c,count+1,i+1,j,dp);\\n        }\\n        if(s.charAt(i)==\\'c\\'){\\n            out1 = helper(s,k,a,b,c+1,count+1,i+1,j,dp);\\n        }\\n        \\n        int out2=0;\\n        if(s.charAt(j)==\\'a\\'){\\n            out2 = helper(s,k,a+1,b,c,count+1,i,j-1,dp);\\n        }\\n        if(s.charAt(j)==\\'b\\'){\\n            out2 = helper(s,k,a,b+1,c,count+1,i,j-1,dp);\\n        }\\n        if(s.charAt(j)==\\'c\\'){\\n            out2 = helper(s,k,a,b,c+1,count+1,i,j-1,dp);\\n        }\\n        \\n        \\n        return dp[i][j] =  Math.min(out1,out2);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949533,
                "title": "c-sliding-window",
                "content": "# Approach\\nUse concept of variable length sliding window to find the length of maximum window that has elements which are not part of final answer.\\nWe need ```k``` number of ```\\'a\\', \\'b\\' & \\'c\\'``` taken from both end. Thus, if string has total of ``` A = count(\\'a\\')```, ```B = count(\\'b\\')``` and ```C = count(\\'c\\')``` then, remaining ``` a = A - k ```, ```b = B - k``` and ```c = C - k``` will be present in the middle of string. If we can find the maximum length of this substring which has these ``` a number of \\'a\\', b number of \\'b\\' and c number of \\'c\\'``` then, final answer will be ``` sizeof(s) - max length of such substring ```.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        vector<int> map(3, 0);\\n        for(auto it : s) \\n            map[it - \\'a\\']++;\\n        // If number of a or b or c is less than k\\n        if(map[0] < k || map[1] < k || map[2] < k)\\n            return -1;\\n        // Remaining a, b and c \\n        int a = map[0] - k, b = map[1] - k, c = map[2] - k;\\n        map[0] = map[1] = map[2] = 0;\\n        int i = 0, j = 0, maxLen = 0;\\n        while(j < n) {\\n            map[s[j++] -\\'a\\']++;\\n            while(map[0] > a || map[1] > b || map[2] > c) {\\n                map[s[i++] - \\'a\\']--;\\n            }\\n            maxLen = max(maxLen, j - i);\\n        }\\n        return n - maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```k```\n```\\'a\\', \\'b\\' & \\'c\\'```\n``` A = count(\\'a\\')```\n```B = count(\\'b\\')```\n```C = count(\\'c\\')```\n``` a = A - k ```\n```b = B - k```\n```c = C - k```\n``` a number of \\'a\\', b number of \\'b\\' and c number of \\'c\\'```\n``` sizeof(s) - max length of such substring ```\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        vector<int> map(3, 0);\\n        for(auto it : s) \\n            map[it - \\'a\\']++;\\n        // If number of a or b or c is less than k\\n        if(map[0] < k || map[1] < k || map[2] < k)\\n            return -1;\\n        // Remaining a, b and c \\n        int a = map[0] - k, b = map[1] - k, c = map[2] - k;\\n        map[0] = map[1] = map[2] = 0;\\n        int i = 0, j = 0, maxLen = 0;\\n        while(j < n) {\\n            map[s[j++] -\\'a\\']++;\\n            while(map[0] > a || map[1] > b || map[2] > c) {\\n                map[s[i++] - \\'a\\']--;\\n            }\\n            maxLen = max(maxLen, j - i);\\n        }\\n        return n - maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949049,
                "title": "c-prefix-sum-two-pointers-and-binary-search",
                "content": "# Intuition\\nIntuition is to keep a prefix sum of count of a, b and c. Then apply binary search on the prefix array from one end and keep on decreasing the count of a, b, c from other end.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPrefix Sum, Two Pointers and Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)   // Basically O(3*N) for three Prefix Sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int takeCharacters(string str, int k)\\n    {\\n        int n = str.size();\\n        // Edge Case\\n        if (k == 0)\\n            return 0;        \\n\\n        // Prefix Sum of count of a, b and c.\\n        vector<int> prefix_a(n, 0), prefix_b(n, 0), prefix_c(n, 0);\\n\\n        if (str[0] == \\'a\\')\\n            prefix_a[0] = 1;\\n        else if (str[0] == \\'b\\')\\n            prefix_b[0] = 1;\\n        else\\n            prefix_c[0] = 1;\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            prefix_a[i] = prefix_a[i - 1];\\n            prefix_b[i] = prefix_b[i - 1];\\n            prefix_c[i] = prefix_c[i - 1];\\n            if (str[i] == \\'a\\')\\n                prefix_a[i]++;\\n            else if (str[i] == \\'b\\')\\n                prefix_b[i]++;\\n            else\\n                prefix_c[i]++;\\n        }\\n\\n        int x = upper_bound(prefix_a.begin(), prefix_a.end(), k - 1) - prefix_a.begin();\\n        int y = upper_bound(prefix_b.begin(), prefix_b.end(), k - 1) - prefix_b.begin();\\n        int z = upper_bound(prefix_c.begin(), prefix_c.end(), k - 1) - prefix_c.begin();\\n\\n        // No answer is possible \\n        if (x == n || y == n || z == n)\\n            return -1;\\n\\n        int result = max({x + 1, y + 1, z + 1});\\n        int cnt_a = k, cnt_b = k, cnt_c = k;\\n\\n        // Applying binary search and two pointers to calculate the minimum no of operations required where we apply binary search from begining and move another pointer from end..\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            if (str[i] == \\'a\\')\\n                cnt_a--;\\n            else if (str[i] == \\'b\\')\\n                cnt_b--;\\n            else\\n                cnt_c--;\\n\\n            if (cnt_a <= 0 && cnt_b <= 0 && cnt_c <= 0)\\n            {\\n                result = min(result, n - i);\\n            }\\n\\n            int x = upper_bound(prefix_a.begin(), prefix_a.end(), cnt_a - 1) - prefix_a.begin();\\n            int y = upper_bound(prefix_b.begin(), prefix_b.end(), cnt_b - 1) - prefix_b.begin();\\n            int z = upper_bound(prefix_c.begin(), prefix_c.end(), cnt_c - 1) - prefix_c.begin();\\n\\n            int res = max({x + 1, y + 1, z + 1});\\n            result = min(result, res + n - i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\nPlease Upvote If Helpful...",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int takeCharacters(string str, int k)\\n    {\\n        int n = str.size();\\n        // Edge Case\\n        if (k == 0)\\n            return 0;        \\n\\n        // Prefix Sum of count of a, b and c.\\n        vector<int> prefix_a(n, 0), prefix_b(n, 0), prefix_c(n, 0);\\n\\n        if (str[0] == \\'a\\')\\n            prefix_a[0] = 1;\\n        else if (str[0] == \\'b\\')\\n            prefix_b[0] = 1;\\n        else\\n            prefix_c[0] = 1;\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            prefix_a[i] = prefix_a[i - 1];\\n            prefix_b[i] = prefix_b[i - 1];\\n            prefix_c[i] = prefix_c[i - 1];\\n            if (str[i] == \\'a\\')\\n                prefix_a[i]++;\\n            else if (str[i] == \\'b\\')\\n                prefix_b[i]++;\\n            else\\n                prefix_c[i]++;\\n        }\\n\\n        int x = upper_bound(prefix_a.begin(), prefix_a.end(), k - 1) - prefix_a.begin();\\n        int y = upper_bound(prefix_b.begin(), prefix_b.end(), k - 1) - prefix_b.begin();\\n        int z = upper_bound(prefix_c.begin(), prefix_c.end(), k - 1) - prefix_c.begin();\\n\\n        // No answer is possible \\n        if (x == n || y == n || z == n)\\n            return -1;\\n\\n        int result = max({x + 1, y + 1, z + 1});\\n        int cnt_a = k, cnt_b = k, cnt_c = k;\\n\\n        // Applying binary search and two pointers to calculate the minimum no of operations required where we apply binary search from begining and move another pointer from end..\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            if (str[i] == \\'a\\')\\n                cnt_a--;\\n            else if (str[i] == \\'b\\')\\n                cnt_b--;\\n            else\\n                cnt_c--;\\n\\n            if (cnt_a <= 0 && cnt_b <= 0 && cnt_c <= 0)\\n            {\\n                result = min(result, n - i);\\n            }\\n\\n            int x = upper_bound(prefix_a.begin(), prefix_a.end(), cnt_a - 1) - prefix_a.begin();\\n            int y = upper_bound(prefix_b.begin(), prefix_b.end(), cnt_b - 1) - prefix_b.begin();\\n            int z = upper_bound(prefix_c.begin(), prefix_c.end(), cnt_c - 1) - prefix_c.begin();\\n\\n            int res = max({x + 1, y + 1, z + 1});\\n            result = min(result, res + n - i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948647,
                "title": "python3-time-space-100-easy-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInstaed of thinking of how we can remove the substrings from both ends, think about what kind of substring in the middle we have to keep so the remaining substrings at both ends can have at least k count for all characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate `count`, a dictionary for chars counts in s.\\n\\nIf any of the char counts in `count` is less than k, `return -1` (means even if we remove the entire string we cannot accomplish the task).\\n\\n\\nElse, we apply sliding window.\\nInitialize `res = len(s)` for the worst case. We will keep minimizing `res` later on.\\nFor each `r`, find the smallest `l` so the current window can result in the remaining substirngs at both ends to have at least k for each chars. We use `while l <= r and (count[\\'a\\'] < k or count[\\'b\\'] < k or count[\\'c\\'] < k):` to guarantee this to happen. Otherwise, increase `l`.\\n\\nUpdate `res` equal to `min(res, count[\\'a\\'] + count[\\'b\\'] + count[\\'c\\'])` where `count[\\'a\\'] + count[\\'b\\'] + count[\\'c\\']` actually IS the length of the substrings at both ends.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        # create count dic\\n        count = collections.Counter(s)\\n        \\n        # any char is not enough\\n        if count[\\'a\\'] < k or count[\\'b\\'] < k or count[\\'c\\'] < k:\\n            return -1\\n        \\n        # sliding window\\n        res = len(s)\\n        l = 0\\n        for r in range(len(s)):\\n            # update count\\n            count[s[r]] -= 1\\n            # if freq not enough for the remaining string\\n            while l <= r and (count[\\'a\\'] < k or count[\\'b\\'] < k or count[\\'c\\'] < k):\\n                count[s[l]] += 1\\n                l += 1\\n            # update valid res\\n            res = min(res, count[\\'a\\'] + count[\\'b\\'] + count[\\'c\\'])\\n        return res\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        # create count dic\\n        count = collections.Counter(s)\\n        \\n        # any char is not enough\\n        if count[\\'a\\'] < k or count[\\'b\\'] < k or count[\\'c\\'] < k:\\n            return -1\\n        \\n        # sliding window\\n        res = len(s)\\n        l = 0\\n        for r in range(len(s)):\\n            # update count\\n            count[s[r]] -= 1\\n            # if freq not enough for the remaining string\\n            while l <= r and (count[\\'a\\'] < k or count[\\'b\\'] < k or count[\\'c\\'] < k):\\n                count[s[l]] += 1\\n                l += 1\\n            # update valid res\\n            res = min(res, count[\\'a\\'] + count[\\'b\\'] + count[\\'c\\'])\\n        return res\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948503,
                "title": "java-easy-solution-7ms-100",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/59867c01-4e89-4e37-857c-503ab34871c2_1671948999.1213312.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/42a9e236-fe57-45cd-a2f9-f320e8e20f3e_1671951485.066171.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] arr = new int[3];\\n        char[] c = s.toCharArray();\\n        int cur,len = c.length;\\n        for(cur = 0; cur < len; cur++){\\n            arr[c[cur] - \\'a\\']++;\\n            if(arr[0] >= k && arr[1] >= k && arr[2] >= k) break;\\n        }\\n        if(cur == len) return -1;\\n        int count = cur + 1,min = count,end = len - 1;\\n        while(cur >= 0){\\n            if(arr[c[cur] - \\'a\\'] == k){\\n                while(c[cur] != c[end]){\\n                    arr[c[end] - \\'a\\']++;\\n                    end--;\\n                    count++;\\n                }\\n                end--;\\n            }else{\\n                arr[c[cur] - \\'a\\']--;\\n                count--;\\n                min = Math.min(count, min);\\n            }\\n            cur--; \\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] arr = new int[3];\\n        char[] c = s.toCharArray();\\n        int cur,len = c.length;\\n        for(cur = 0; cur < len; cur++){\\n            arr[c[cur] - \\'a\\']++;\\n            if(arr[0] >= k && arr[1] >= k && arr[2] >= k) break;\\n        }\\n        if(cur == len) return -1;\\n        int count = cur + 1,min = count,end = len - 1;\\n        while(cur >= 0){\\n            if(arr[c[cur] - \\'a\\'] == k){\\n                while(c[cur] != c[end]){\\n                    arr[c[end] - \\'a\\']++;\\n                    end--;\\n                    count++;\\n                }\\n                end--;\\n            }else{\\n                arr[c[cur] - \\'a\\']--;\\n                count--;\\n                min = Math.min(count, min);\\n            }\\n            cur--; \\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948366,
                "title": "c-sliding-window-with-image-for-better-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/f9b0ba0a-e2f6-472c-9140-507da9e523be_1671947554.861765.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int left=0;\\n        int right=0;\\n        int ans=10000000;\\n        int n=s.size();\\n        if(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k){\\n            ans=min(ans,n-right+left);\\n        }\\n        while(right<s.size()){\\n            mp[s[right]]-=1;\\n            if(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k){\\n                ans=min(ans,n-right+left-1);\\n            }\\n            \\n            while(left<=right && !(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k)){\\n                mp[s[left]]+=1;\\n                left+=1;\\n                \\n            }    \\n            \\n            right+=1;\\n        }\\n        if(ans==10000000)return -1;\\n        return ans;\\n    }\\n};\\n//do upvote\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int left=0;\\n        int right=0;\\n        int ans=10000000;\\n        int n=s.size();\\n        if(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k){\\n            ans=min(ans,n-right+left);\\n        }\\n        while(right<s.size()){\\n            mp[s[right]]-=1;\\n            if(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k){\\n                ans=min(ans,n-right+left-1);\\n            }\\n            \\n            while(left<=right && !(mp[\\'a\\']>=k && mp[\\'b\\']>=k && mp[\\'c\\']>=k)){\\n                mp[s[left]]+=1;\\n                left+=1;\\n                \\n            }    \\n            \\n            right+=1;\\n        }\\n        if(ans==10000000)return -1;\\n        return ans;\\n    }\\n};\\n//do upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948094,
                "title": "c-sliding-window-circular-array",
                "content": "# Intuition\\nFor the sliding window, let i be the left bound and j be the right bound. We only need to consider 3 cases:\\nn is the length of string s.\\n\\n1. j<n-1: remove characters from left side only. the characters need to be removed is j+1.\\n2. j==n-1: remove characters from right side only. the characters need to be removed is j-i+1.\\n3. i<n && j>=n: remove characters from both left and right side. this is also when the circular array steps in. the characters need to be removed is j-i+1.\\n\\nAfter 2, we can check if there is no way to find the answer because 3 is an optimization to reduce the number of characters. But if after step 2, we cannot find an answer, there is no solution.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nint c[3]: to store the counts of a, b, c, respectively.\\nint i: the left bound of sliding window\\nint j: the right bound of sliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int takeCharacters(string s, int k) {\\n        if(k==0)\\n            return 0;\\n        int n = s.length();\\n        int c[3] = {0};\\n        int i=0, j = 0;\\n        int ret = INT_MAX;\\n        while(j<2*n) {\\n            c[s[j%n]-\\'a\\']++;\\n            while(i<n && c[0]>=k && c[1]>=k && c[2]>=k) {\\n                if(j<n-1)\\n                    ret = min(ret, j+1);\\n                else\\n                    ret = min(ret, j-i+1);\\n                \\n                c[s[i]-\\'a\\']--;\\n                i++;\\n            }\\n            if(j>=n-1 && ret==INT_MAX)\\n                return -1;\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int takeCharacters(string s, int k) {\\n        if(k==0)\\n            return 0;\\n        int n = s.length();\\n        int c[3] = {0};\\n        int i=0, j = 0;\\n        int ret = INT_MAX;\\n        while(j<2*n) {\\n            c[s[j%n]-\\'a\\']++;\\n            while(i<n && c[0]>=k && c[1]>=k && c[2]>=k) {\\n                if(j<n-1)\\n                    ret = min(ret, j+1);\\n                else\\n                    ret = min(ret, j-i+1);\\n                \\n                c[s[i]-\\'a\\']--;\\n                i++;\\n            }\\n            if(j>=n-1 && ret==INT_MAX)\\n                return -1;\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701170,
                "title": "easy-solution-using-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst set the left window to full length, right window to 0 length. \\nDecrease the left window by 1 until it becomes -1 (no elements in left window) when it doesn\\'t pass the test, increase the right window until it passes the test. if in the current traversal length is less than m, change m to current length. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v, int k){\\n        for(int i=0; i<v.size(); i++) if(v[i] < k) return false; \\n        return true; \\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3, 0), temp(3, 0); \\n        for(int i=0; i<s.length(); i++) v[s[i] - \\'a\\']++; \\n        temp = v; \\n        int l = s.length()-1, r =0 ;\\n        int ans = INT_MAX; \\n        if(!check(v, k)) return -1;\\n        ans = s.length();  \\n\\n       while (l >= 0){\\n           v[s[l] - \\'a\\']--; l--; \\n           if(!check(v, k)){ \\n              char kk = s[l+1]; \\n              while(v[kk - \\'a\\'] < k) {\\n                  v[s[s.length() -1 -r] - \\'a\\']++; r++; \\n              }\\n               \\n            }\\n           int t = 0; \\n           t += l+1; t += r; \\n        //    cout << v[0] << \" \" << v[1] << \" \" << v[2] << \" \" << l << \"  \" << r << \"  \" << t ; \\n           if( ans > t) ans = t; \\n       }\\n\\n       return ans; \\n\\n        \\n    return ans; \\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v, int k){\\n        for(int i=0; i<v.size(); i++) if(v[i] < k) return false; \\n        return true; \\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3, 0), temp(3, 0); \\n        for(int i=0; i<s.length(); i++) v[s[i] - \\'a\\']++; \\n        temp = v; \\n        int l = s.length()-1, r =0 ;\\n        int ans = INT_MAX; \\n        if(!check(v, k)) return -1;\\n        ans = s.length();  \\n\\n       while (l >= 0){\\n           v[s[l] - \\'a\\']--; l--; \\n           if(!check(v, k)){ \\n              char kk = s[l+1]; \\n              while(v[kk - \\'a\\'] < k) {\\n                  v[s[s.length() -1 -r] - \\'a\\']++; r++; \\n              }\\n               \\n            }\\n           int t = 0; \\n           t += l+1; t += r; \\n        //    cout << v[0] << \" \" << v[1] << \" \" << v[2] << \" \" << l << \"  \" << r << \"  \" << t ; \\n           if( ans > t) ans = t; \\n       }\\n\\n       return ans; \\n\\n        \\n    return ans; \\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3553178,
                "title": "beats-90-cpp-solution",
                "content": "# Intuition\\nNow comes the logic instead of finding the strings from both ends having at least k a,b,c\\nwe find the substring which have atmost [character occurences - k] a,b,c\\nNow we have to slide this string window to get the max length of such a string\\ntotal length - length of this window will be our answer\\nwe calculate the length the total count of a,b,c in the string s\\nthen we subtract this respective count with k i.e, our windowCountA = a-k, windowCountB = b-k, windowCountC = c-k\\nthen we try to find a window which have atmost windowCountA a\\'s, windowCountB b\\'s and windowCountC c\\'s\\n\\n# Complexity\\n- Time complexity: O(n+k)\\n\\n- Space complexity: O(1)\\n\\n# **Please Upvote if it help \\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n\\n        // checking the base case , whether we have enough characters to match with k \\n        for(auto &i : s){\\n            if(i == \\'a\\'){\\n                a++;\\n            }else if(i == \\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n        }\\n\\n        if(a < k || b < k || c < k){\\n            return -1;\\n        }\\n\\n        int n = s.length();\\n        a = a-k;\\n        b = b-k;\\n        c = c-k;\\n\\n        int maxi = 0;\\n        int i = 0, j = 0;\\n\\n        int windowA = 0;\\n        int windowB = 0;\\n        int windowC = 0;\\n\\n        while(j < n){\\n            if(s[j] == \\'a\\'){\\n                windowA++;\\n            }else if(s[j] == \\'b\\'){\\n                windowB++;\\n            }else{\\n                windowC++;\\n            }\\n\\n            while(windowA>a || windowB>b || windowC > c){\\n                if(s[i] == \\'a\\')\\n                    windowA--;\\n                else if(s[i] == \\'b\\')\\n                    windowB--;\\n                else{\\n                    windowC--;\\n                }\\n                i++;\\n            }\\n            maxi = max(maxi, j-i+1);\\n            j++;\\n        }\\n\\n        return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n\\n        // checking the base case , whether we have enough characters to match with k \\n        for(auto &i : s){\\n            if(i == \\'a\\'){\\n                a++;\\n            }else if(i == \\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n        }\\n\\n        if(a < k || b < k || c < k){\\n            return -1;\\n        }\\n\\n        int n = s.length();\\n        a = a-k;\\n        b = b-k;\\n        c = c-k;\\n\\n        int maxi = 0;\\n        int i = 0, j = 0;\\n\\n        int windowA = 0;\\n        int windowB = 0;\\n        int windowC = 0;\\n\\n        while(j < n){\\n            if(s[j] == \\'a\\'){\\n                windowA++;\\n            }else if(s[j] == \\'b\\'){\\n                windowB++;\\n            }else{\\n                windowC++;\\n            }\\n\\n            while(windowA>a || windowB>b || windowC > c){\\n                if(s[i] == \\'a\\')\\n                    windowA--;\\n                else if(s[i] == \\'b\\')\\n                    windowB--;\\n                else{\\n                    windowC--;\\n                }\\n                i++;\\n            }\\n            maxi = max(maxi, j-i+1);\\n            j++;\\n        }\\n\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161441,
                "title": "change-your-perspective",
                "content": "Rather than thinking about picking stuff from one end, you can think about making the longest subarray from the middle whose size can be calculated by finding the left over characters. This approach will take a time complexity of O(n).\\nFurther you can use the sliding window technique to find out the above longest subarray with the time complexity of O(n) & Space Complexity of O(1) roughly.\\nPS-> You can avoid the use of map & take counters instead to totally reduce the space complexity to O(1).\\n\\nTime Complexity -> O(N)\\nSpace Complexity -> O(1)\\n\\nSolution in C++\\n\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a=0,b=0,c=0;\\n        for(auto &it:s) \\n        {\\n            if(it==\\'a\\') a++;\\n            else if(it==\\'b\\') b++;\\n            else c++;\\n        }\\n        if(a<k||b<k||c<k) return -1;\\n        unordered_map<char,int> m={{\\'a\\',a-k},{\\'b\\',b-k},{\\'c\\',c-k}};\\n        int i=0,j=0,ans=0;\\n        while(j<s.size())\\n        {\\n            m[s[j]]--;\\n            while(m[s[j]]<0&&i<=j)\\n            {\\n                m[s[i]]++;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return s.size()-ans;\\n    }\\n};\\n```\\n\\nHonestly I wasn\\'t able to solve this in the contest but after spending some time I came up with this approach!",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a=0,b=0,c=0;\\n        for(auto &it:s) \\n        {\\n            if(it==\\'a\\') a++;\\n            else if(it==\\'b\\') b++;\\n            else c++;\\n        }\\n        if(a<k||b<k||c<k) return -1;\\n        unordered_map<char,int> m={{\\'a\\',a-k},{\\'b\\',b-k},{\\'c\\',c-k}};\\n        int i=0,j=0,ans=0;\\n        while(j<s.size())\\n        {\\n            m[s[j]]--;\\n            while(m[s[j]]<0&&i<=j)\\n            {\\n                m[s[i]]++;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return s.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963269,
                "title": "c-using-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int m=s.size(), counta=0, countb=0, countc=0, i=0;\\n\\n        if(k==0)\\n            return k;\\n            \\n        while(i<m){\\n            if(s[i]==\\'a\\')\\n                counta++;\\n            else if(s[i]==\\'b\\')\\n                countb++;\\n            else\\n                countc++;\\n            \\n            i++;\\n        }\\n\\n        if(counta < k || countb < k || countc < k)\\n            return -1;\\n\\n        i=m-1;\\n        int ans=INT_MAX, j=m;\\n        while(i>=0){\\n            if(s[i]==\\'a\\'){\\n                if(counta-1 >= k)\\n                    counta--;\\n                else\\n                    break;\\n            }\\n            else if(s[i]==\\'b\\'){\\n                if(countb-1 >= k)\\n                    countb--;\\n                else\\n                    break;\\n            }\\n            else if(s[i]==\\'c\\'){\\n                if(countc-1 >= k)\\n                    countc--;\\n                else \\n                    break;\\n            }\\n            i--;\\n            ans= min(ans, counta+countb+countc);\\n        }\\n\\n        while(j>0){\\n            j--;\\n            if(s[j]==\\'a\\')\\n                counta++;\\n            else if(s[j]==\\'b\\')\\n                countb++;\\n            else if(s[j]==\\'c\\')\\n                countc++;\\n\\n            while(i>=0){\\n                if(s[i]==\\'a\\'){\\n                    if(counta-1 >= k)\\n                        counta--;\\n                    else\\n                        break;\\n                }\\n                else if(s[i]==\\'b\\'){\\n                    if(countb-1 >= k)\\n                        countb--;\\n                    else\\n                        break;\\n                }\\n                else if(s[i]==\\'c\\'){\\n                    if(countc-1 >= k)\\n                        countc--;\\n                    else \\n                        break;\\n                }\\n                i--;\\n                ans= min(ans, counta+countb+countc);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int m=s.size(), counta=0, countb=0, countc=0, i=0;\\n\\n        if(k==0)\\n            return k;\\n            \\n        while(i<m){\\n            if(s[i]==\\'a\\')\\n                counta++;\\n            else if(s[i]==\\'b\\')\\n                countb++;\\n            else\\n                countc++;\\n            \\n            i++;\\n        }\\n\\n        if(counta < k || countb < k || countc < k)\\n            return -1;\\n\\n        i=m-1;\\n        int ans=INT_MAX, j=m;\\n        while(i>=0){\\n            if(s[i]==\\'a\\'){\\n                if(counta-1 >= k)\\n                    counta--;\\n                else\\n                    break;\\n            }\\n            else if(s[i]==\\'b\\'){\\n                if(countb-1 >= k)\\n                    countb--;\\n                else\\n                    break;\\n            }\\n            else if(s[i]==\\'c\\'){\\n                if(countc-1 >= k)\\n                    countc--;\\n                else \\n                    break;\\n            }\\n            i--;\\n            ans= min(ans, counta+countb+countc);\\n        }\\n\\n        while(j>0){\\n            j--;\\n            if(s[j]==\\'a\\')\\n                counta++;\\n            else if(s[j]==\\'b\\')\\n                countb++;\\n            else if(s[j]==\\'c\\')\\n                countc++;\\n\\n            while(i>=0){\\n                if(s[i]==\\'a\\'){\\n                    if(counta-1 >= k)\\n                        counta--;\\n                    else\\n                        break;\\n                }\\n                else if(s[i]==\\'b\\'){\\n                    if(countb-1 >= k)\\n                        countb--;\\n                    else\\n                        break;\\n                }\\n                else if(s[i]==\\'c\\'){\\n                    if(countc-1 >= k)\\n                        countc--;\\n                    else \\n                        break;\\n                }\\n                i--;\\n                ans= min(ans, counta+countb+countc);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952044,
                "title": "easy-to-understand-two-pointers-java-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires reduction of original description.\\n\\nBrute force approach:\\nIf solving this problem by dynamic programming and calculate number of counts of \\'a\\', \\'b\\', and \\'c\\' in prefix and suffix substrings, and iterate all possible substrings, the time complexity is O(n^2), and you would get TLE.\\n\\nThen we need to reduce the time complexity of this problem.\\n\\nNotice that after taking the leftmost and rightmost substrings, the rest is one continous substring, which we call it *middle_substring*. Similarly, the deleted substrings are *left_substring* and *right_substring*.\\n\\n```\\n[left_substring][middle_substring][right_substring]\\n```\\n\\nThus, the original description can be reduced to:\\n\\nLet original count of letter be original_count, then original description can be reduced to: \\n\\n**Return the maximum length of *middle_substring* that contains at most (original_count - k) for \\'a\\', \\'b\\', and \\'c\\'.**\\n\\nIf we store the ***counter array*** of \\'a\\', \\'b\\', and \\'c\\', then we can further reduce the description. Because when *middle_substring* contains at most (original_count - k) letters is equivalent to *left_substring* and *right_substring* has at least k letters, which is the count remained in the ***counter array***. Then this description can be further reduced to:\\n\\n**Return the maxium length of *middle_substring* that satisfies count of \\'a\\', \\'b\\', and \\'c\\' in *counter array* is at least k.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two-pointers method.\\n\\nThe approach is similar to [LeetCode 76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/).\\n\\nFirst count number of frequencies of \\'a\\', \\'b\\', and \\'c\\'.\\n\\nUse left and right pointer, *middle_substring* has inclusive range of [left, right].\\n\\nDecrease count of s.charAt(right).\\n\\nWhen count of s.charAt(right) is less than k, increase count of left letter (s.charAt(left)), move left pointer by one step. Repeat this step until count of s.charAt(right) is not less than k.\\n\\nCalculate minimum of removed letters by subtract (right - left + 1) from length of string s.\\n\\nLet length of string s be *n*.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n\\nWe need to store the counter array, which has length of three.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        // edge cases\\n        int n = s.length();\\n        int[] count = new int[3];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        if (count[0] < k || count[1] < k || count[2] < k) {\\n            return -1;\\n        }\\n        // normal cases\\n        int result = n;\\n        int left = 0;\\n        for (int right = 0; right < n; right++) {\\n            char ch = s.charAt(right);\\n            count[ch - \\'a\\']--;\\n            while (count[ch - \\'a\\'] < k) {\\n                count[s.charAt(left++) - \\'a\\']++;\\n            }\\n            result = Math.min(result, n - (right - left + 1));\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n[left_substring][middle_substring][right_substring]\\n```\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        // edge cases\\n        int n = s.length();\\n        int[] count = new int[3];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        if (count[0] < k || count[1] < k || count[2] < k) {\\n            return -1;\\n        }\\n        // normal cases\\n        int result = n;\\n        int left = 0;\\n        for (int right = 0; right < n; right++) {\\n            char ch = s.charAt(right);\\n            count[ch - \\'a\\']--;\\n            while (count[ch - \\'a\\'] < k) {\\n                count[s.charAt(left++) - \\'a\\']++;\\n            }\\n            result = Math.min(result, n - (right - left + 1));\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950044,
                "title": "rust-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Cacculate the answer with right moves only.\\n2) Loop with removing the right most move & adding needed left moves\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn take_characters(s: String, k: i32) -> i32 {\\n        if k == 0 { return 0 }\\n\\n        let (mut i, n) = (0, s.len());\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut count = vec![0; 3];\\n\\n        while i < n && (count[0] < k || count[1] < k || count[2] < k) {\\n            count[(s[i] as u8 - \\'a\\' as u8) as usize] += 1;\\n            i += 1;\\n        }\\n\\n        if *count.iter().min().unwrap() < k { return -1; }\\n        let mut ret = i;\\n\\n        let mut j = n;\\n        loop {\\n            count[(s[i - 1] as u8 - \\'a\\' as u8) as usize] -= 1;\\n\\n            while count[0] < k || count[1] < k || count[2] < k {\\n                j -= 1;\\n                count[(s[j] as u8 - \\'a\\' as u8) as usize] += 1;\\n            }\\n\\n            ret = ret.min(i - 1 + n - j);\\n            println![\"ret: {}\", ret];\\n            if i == 1 { break }\\n            i -= 1;\\n        }\\n\\n        ret as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn take_characters(s: String, k: i32) -> i32 {\\n        if k == 0 { return 0 }\\n\\n        let (mut i, n) = (0, s.len());\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut count = vec![0; 3];\\n\\n        while i < n && (count[0] < k || count[1] < k || count[2] < k) {\\n            count[(s[i] as u8 - \\'a\\' as u8) as usize] += 1;\\n            i += 1;\\n        }\\n\\n        if *count.iter().min().unwrap() < k { return -1; }\\n        let mut ret = i;\\n\\n        let mut j = n;\\n        loop {\\n            count[(s[i - 1] as u8 - \\'a\\' as u8) as usize] -= 1;\\n\\n            while count[0] < k || count[1] < k || count[2] < k {\\n                j -= 1;\\n                count[(s[j] as u8 - \\'a\\' as u8) as usize] += 1;\\n            }\\n\\n            ret = ret.min(i - 1 + n - j);\\n            println![\"ret: {}\", ret];\\n            if i == 1 { break }\\n            i -= 1;\\n        }\\n\\n        ret as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2949977,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int ans = Integer.MAX_VALUE,maxWindow = 0,j=0;\\n\\n        Map<Character,Integer> map = new HashMap<>();\\n\\n        for(char c : s.toCharArray()) map.put(c,map.getOrDefault(c,0)+1);\\n\\n        if(map.getOrDefault(\\'a\\',0) < k || map.getOrDefault(\\'b\\',0) < k || map.getOrDefault(\\'c\\',0) < k)   \\n        return -1;\\n\\n        for(char c : s.toCharArray()) {\\n            map.put(c,map.get(c)-1);\\n            maxWindow++;\\n            \\n            while(map.get(c) < k){\\n                map.put(s.charAt(j),map.get(s.charAt(j))+1);\\n                maxWindow--;\\n                j++;\\n            }\\n\\n            ans = Math.min(ans,s.length() - maxWindow);\\n\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int ans = Integer.MAX_VALUE,maxWindow = 0,j=0;\\n\\n        Map<Character,Integer> map = new HashMap<>();\\n\\n        for(char c : s.toCharArray()) map.put(c,map.getOrDefault(c,0)+1);\\n\\n        if(map.getOrDefault(\\'a\\',0) < k || map.getOrDefault(\\'b\\',0) < k || map.getOrDefault(\\'c\\',0) < k)   \\n        return -1;\\n\\n        for(char c : s.toCharArray()) {\\n            map.put(c,map.get(c)-1);\\n            maxWindow++;\\n            \\n            while(map.get(c) < k){\\n                map.put(s.charAt(j),map.get(s.charAt(j))+1);\\n                maxWindow--;\\n                j++;\\n            }\\n\\n            ans = Math.min(ans,s.length() - maxWindow);\\n\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949963,
                "title": "easy-to-understand-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(!k) return 0;\\n        unordered_map<char, int> m, t;\\n        for(char c : s) m[c]++;\\n        if(m.size() < 3) return -1;\\n\\n        int i = 0, n = s.size(), ans = 1e9;\\n        for(auto &i : m) {\\n            i.second -= k;\\n            if(i.second < 0) return -1;\\n        } \\n        \\n        for(int j=0; j<n; j++) {\\n            t[s[j]]++;\\n            while(i < j && (t[\\'a\\'] > m[\\'a\\'] || t[\\'b\\'] > m[\\'b\\'] || t[\\'c\\'] > m[\\'c\\'])) {\\n                t[s[i]]--;\\n                i++;\\n            }\\n            if(t[\\'a\\'] <= m[\\'a\\'] && t[\\'b\\'] <= m[\\'b\\'] && t[\\'c\\'] <= m[\\'c\\']) {\\n                ans = min(ans, n - (j - i + 1));\\n            }\\n        }\\n        return ans == 1e9 ? n : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(!k) return 0;\\n        unordered_map<char, int> m, t;\\n        for(char c : s) m[c]++;\\n        if(m.size() < 3) return -1;\\n\\n        int i = 0, n = s.size(), ans = 1e9;\\n        for(auto &i : m) {\\n            i.second -= k;\\n            if(i.second < 0) return -1;\\n        } \\n        \\n        for(int j=0; j<n; j++) {\\n            t[s[j]]++;\\n            while(i < j && (t[\\'a\\'] > m[\\'a\\'] || t[\\'b\\'] > m[\\'b\\'] || t[\\'c\\'] > m[\\'c\\'])) {\\n                t[s[i]]--;\\n                i++;\\n            }\\n            if(t[\\'a\\'] <= m[\\'a\\'] && t[\\'b\\'] <= m[\\'b\\'] && t[\\'c\\'] <= m[\\'c\\']) {\\n                ans = min(ans, n - (j - i + 1));\\n            }\\n        }\\n        return ans == 1e9 ? n : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949947,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int a = -k,b = -k,c = -k;\\n        int da = 0,db = 0,dc = 0;\\n        int ans = 0,j=0;\\n        for(int i = 0;i<s.length();i++) {\\n            if(s.charAt(i) == \\'a\\') a++;\\n            else if(s.charAt(i) == \\'b\\') b++;\\n            else c++;\\n        }\\n        if(a < 0 || b < 0 || c < 0 ) return -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\') da++;\\n            else if(s.charAt(i) == \\'b\\') db++;\\n            else dc++;\\n            while(da > a) {\\n                if(s.charAt(j)==\\'a\\') {\\n                    da--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'b\\'){\\n                        db--;\\n                    }\\n                    else {\\n                        dc--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            while(db > b) {\\n                if(s.charAt(j)==\\'b\\') {\\n                    db--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'a\\'){\\n                        da--;\\n                    }\\n                    else {\\n                        dc--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            while(dc > c) {\\n                if(s.charAt(j)==\\'c\\') {\\n                    dc--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'b\\'){\\n                        db--;\\n                    }\\n                    else {\\n                        da--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            ans = Math.max(ans,i-j+1);\\n        }\\n        return s.length()-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int a = -k,b = -k,c = -k;\\n        int da = 0,db = 0,dc = 0;\\n        int ans = 0,j=0;\\n        for(int i = 0;i<s.length();i++) {\\n            if(s.charAt(i) == \\'a\\') a++;\\n            else if(s.charAt(i) == \\'b\\') b++;\\n            else c++;\\n        }\\n        if(a < 0 || b < 0 || c < 0 ) return -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\') da++;\\n            else if(s.charAt(i) == \\'b\\') db++;\\n            else dc++;\\n            while(da > a) {\\n                if(s.charAt(j)==\\'a\\') {\\n                    da--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'b\\'){\\n                        db--;\\n                    }\\n                    else {\\n                        dc--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            while(db > b) {\\n                if(s.charAt(j)==\\'b\\') {\\n                    db--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'a\\'){\\n                        da--;\\n                    }\\n                    else {\\n                        dc--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            while(dc > c) {\\n                if(s.charAt(j)==\\'c\\') {\\n                    dc--;\\n                    j++;\\n                }\\n                else {\\n                    if(s.charAt(j)==\\'b\\'){\\n                        db--;\\n                    }\\n                    else {\\n                        da--;\\n                    }\\n                    j++;\\n                }\\n            }\\n            ans = Math.max(ans,i-j+1);\\n        }\\n        return s.length()-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949928,
                "title": "java-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) { \\n        HashMap<Integer,Integer>map_a=new HashMap<>();\\n        HashMap<Integer,Integer>map_b=new HashMap<>();\\n        HashMap<Integer,Integer>map_c=new HashMap<>();\\n        int n=s.length();\\n        int count=0;\\n        map_a.put(0,n);\\n        map_b.put(0,n);\\n        map_c.put(0,n);\\n        for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'a\\'){\\n                count++;\\n                map_a.put(count,i);\\n            }\\n        }\\n        int count2=0;\\n        int count3=0;\\n         for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'b\\'){\\n                count2++;\\n                map_b.put(count2,i);\\n            }\\n        }\\n         for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'c\\'){\\n                count3++;\\n                map_c.put(count3,i);\\n            }\\n        }\\n         if(k==0){\\n            return 0;\\n        }\\n        if(count<k||count2<k||count3<k){\\n            return -1;\\n        }\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int ans=-1;\\n        ans=n-Math.min(map_a.get(Math.max(0,k-ca)),Math.min(map_b.get(Math.max(0,k-cb)),map_c.get(Math.max(0,k-cc))));\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)==\\'a\\'){\\n                ca++;\\n            }else if(s.charAt(i)==\\'b\\'){\\n                cb++;\\n            }else{\\n                cc++;\\n            }\\n            ans=Math.min(ans,i+1+n-Math.min(map_a.get(Math.max(0,k-ca)),Math.min(map_b.get(Math.max(0,k-cb)),map_c.get(Math.max(0,k-cc)))));\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) { \\n        HashMap<Integer,Integer>map_a=new HashMap<>();\\n        HashMap<Integer,Integer>map_b=new HashMap<>();\\n        HashMap<Integer,Integer>map_c=new HashMap<>();\\n        int n=s.length();\\n        int count=0;\\n        map_a.put(0,n);\\n        map_b.put(0,n);\\n        map_c.put(0,n);\\n        for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'a\\'){\\n                count++;\\n                map_a.put(count,i);\\n            }\\n        }\\n        int count2=0;\\n        int count3=0;\\n         for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'b\\'){\\n                count2++;\\n                map_b.put(count2,i);\\n            }\\n        }\\n         for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'c\\'){\\n                count3++;\\n                map_c.put(count3,i);\\n            }\\n        }\\n         if(k==0){\\n            return 0;\\n        }\\n        if(count<k||count2<k||count3<k){\\n            return -1;\\n        }\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int ans=-1;\\n        ans=n-Math.min(map_a.get(Math.max(0,k-ca)),Math.min(map_b.get(Math.max(0,k-cb)),map_c.get(Math.max(0,k-cc))));\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)==\\'a\\'){\\n                ca++;\\n            }else if(s.charAt(i)==\\'b\\'){\\n                cb++;\\n            }else{\\n                cc++;\\n            }\\n            ans=Math.min(ans,i+1+n-Math.min(map_a.get(Math.max(0,k-ca)),Math.min(map_b.get(Math.max(0,k-cb)),map_c.get(Math.max(0,k-cc)))));\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949016,
                "title": "sliding-window-explained-tc-o-n-sc-o-1",
                "content": "# Intuition: \\nIf we can find a contiguous subarray of maximum length such that frequency of \\'a\\' may be at max total_count_Of_a - k, frequency of \\'b\\' may be at max total_count_of_b - k, frequency of \\'c\\' at max may be at max total_count_of_c - k.\\n\\nThen our result will be  = \\n                            length_of_string - max_lenght_of_subarray(with at max frequencies of a, b, and c);\\n\\n\\n# Approach\\n1. First of all we will calculate the frequencies of \\'a\\' , \\'b\\' and \\'c\\'.\\n2. if frequency of any of char is less than k then simply return -1 .\\n3. Now calculate the frequency A, B and C that may accommodate in our window.  \\n4. Now apply simple sliding window approach to find the maximum length of subrray that may contain at most A a\\'s, B b\\'s and C c\\'s.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1) \\n\\n# Code\\n```     \\nclass Solution {\\npublic:\\n    int maxTime = INT_MIN;\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int a = 0, b = 0, c = 0;\\n        //Count the freqn\\'s of a , b and c\\n        for(auto ch : s){\\n            if(ch == \\'a\\')a++;\\n            else if(ch == \\'b\\')b++;\\n            else c++;\\n        }\\n        if(a < k || b < k || c < k)return -1;\\n        \\n        int A = a - k, B = b - k, C = c - k;//max freqnc\\'s of a , b and c that may accommodate in our window\\n        \\n        int j = 0;\\n        int ct_A = 0, ct_B = 0, ct_C = 0;\\n        //Sliding window approach\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == \\'a\\')ct_A++;\\n            else if(s[i] == \\'b\\')ct_B++;\\n            else ct_C++;\\n            \\n            while(j <= i && (ct_A > A || ct_B > B || ct_C > C)){\\n                    if(s[j] == \\'a\\')ct_A--;\\n                    else if(s[j] == \\'b\\')ct_B--;\\n                    else ct_C--;\\n                    \\n                    j++;\\n            }\\n            maxTime = max(maxTime, (i - j + 1));\\n            \\n        }\\n        return n - maxTime; //result\\n    }\\n};\\n```\\nPleas upvote if you found it helpfull. \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```     \\nclass Solution {\\npublic:\\n    int maxTime = INT_MIN;\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int a = 0, b = 0, c = 0;\\n        //Count the freqn\\'s of a , b and c\\n        for(auto ch : s){\\n            if(ch == \\'a\\')a++;\\n            else if(ch == \\'b\\')b++;\\n            else c++;\\n        }\\n        if(a < k || b < k || c < k)return -1;\\n        \\n        int A = a - k, B = b - k, C = c - k;//max freqnc\\'s of a , b and c that may accommodate in our window\\n        \\n        int j = 0;\\n        int ct_A = 0, ct_B = 0, ct_C = 0;\\n        //Sliding window approach\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == \\'a\\')ct_A++;\\n            else if(s[i] == \\'b\\')ct_B++;\\n            else ct_C++;\\n            \\n            while(j <= i && (ct_A > A || ct_B > B || ct_C > C)){\\n                    if(s[j] == \\'a\\')ct_A--;\\n                    else if(s[j] == \\'b\\')ct_B--;\\n                    else ct_C--;\\n                    \\n                    j++;\\n            }\\n            maxTime = max(maxTime, (i - j + 1));\\n            \\n        }\\n        return n - maxTime; //result\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588370,
                "title": "sliding-window-c-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple , just change the problem statement to \"**Try to find out the longest substring that contain at most (freq-k) a,b and c\".**\\n\\nEx: s = \"aabaaaacbaac\" , k = 2\\n    freq[\\'a\\'] = 8\\n    freq[\\'b\\'] = 2\\n    freq[\\'c\\'] = 2\\n\\nNow try to find the longest substring that contains at most 6:a ,0:b and 0:c\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<int> freq(3,0);\\n        char c = \\'a\\';\\n\\n        for(int i = 0;i<n;i++)\\n        freq[s[i]-c]++;\\n\\n        if(freq[0]<k || freq[1]<k || freq[2]<k)\\n        return -1;\\n\\n        freq[0]-=k;\\n        freq[1]-=k;\\n        freq[2]-=k;\\n        int i = 0,j = 0,len = -1;\\n        vector<int> mp(3,0);\\n\\n        while(j<n)\\n        {\\n           mp[s[j]-c]++;\\n\\n           while(mp[s[j]-c] > freq[s[j]-c])\\n           {\\n               mp[s[i]-c]--;\\n               i++;\\n           }\\n\\n           len = max(len,j-i+1);\\n           j++;\\n        }\\n\\n        return n-len;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<int> freq(3,0);\\n        char c = \\'a\\';\\n\\n        for(int i = 0;i<n;i++)\\n        freq[s[i]-c]++;\\n\\n        if(freq[0]<k || freq[1]<k || freq[2]<k)\\n        return -1;\\n\\n        freq[0]-=k;\\n        freq[1]-=k;\\n        freq[2]-=k;\\n        int i = 0,j = 0,len = -1;\\n        vector<int> mp(3,0);\\n\\n        while(j<n)\\n        {\\n           mp[s[j]-c]++;\\n\\n           while(mp[s[j]-c] > freq[s[j]-c])\\n           {\\n               mp[s[i]-c]--;\\n               i++;\\n           }\\n\\n           len = max(len,j-i+1);\\n           j++;\\n        }\\n\\n        return n-len;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289442,
                "title": "take-k-chars-from-left-and-right-c-solution",
                "content": "**Do Upvote !**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem can be easily solved using prefix sum and binary search to locate best prefix and suffix to choose.\\n\\n# Complexity\\n- Time complexity: **O(NLogN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        ios_base::sync_with_stdio(0);\\n        int n = s.size();\\n        vector<vector<int>>pref(n+1,vector<int>(3,0)),suff(n+1,vector<int>(3,0));\\n        for(int i = 1; i <= n; i++){\\n            if(i == 1){\\n                pref[i][0] = s[i-1] == \\'a\\';\\n                pref[i][1] = s[i-1] == \\'b\\';\\n                pref[i][2] = s[i-1] == \\'c\\';\\n            }\\n            else{\\n                pref[i][0] = pref[i-1][0] + (s[i-1] == \\'a\\');\\n                pref[i][1] = pref[i-1][1] + (s[i-1] == \\'b\\');\\n                pref[i][2] = pref[i-1][2] + (s[i-1] == \\'c\\');\\n            }\\n        }\\n        for(int i = n-1; i >=0; i--){\\n            if(i == n-1){\\n                suff[i][0] = s[i] == \\'a\\';\\n                suff[i][1] = s[i] == \\'b\\';\\n                suff[i][2] = s[i] == \\'c\\';\\n            }\\n            else{\\n                suff[i][0] = suff[i+1][0] + (s[i] == \\'a\\');\\n                suff[i][1] = suff[i+1][1] + (s[i] == \\'b\\');\\n                suff[i][2] = suff[i+1][2] + (s[i] == \\'c\\');\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= n; i++){\\n            int start = n,end = i,mid,mov = INT_MAX;\\n            while(start >= end){\\n                mid = (start + end) / 2;\\n                int as = pref[i][0] + suff[mid][0],bs = pref[i][1] + suff[mid][1],cs = pref[i][2] + suff[mid][2];\\n                \\n                if(as >= k && bs >= k && cs >= k){\\n                    mov = n - mid;\\n                    end = mid + 1;\\n                }\\n                else{\\n                    start = mid - 1;\\n                }\\n            }\\n            if(mov != INT_MAX){\\n                ans = min(ans,i+mov);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        ios_base::sync_with_stdio(0);\\n        int n = s.size();\\n        vector<vector<int>>pref(n+1,vector<int>(3,0)),suff(n+1,vector<int>(3,0));\\n        for(int i = 1; i <= n; i++){\\n            if(i == 1){\\n                pref[i][0] = s[i-1] == \\'a\\';\\n                pref[i][1] = s[i-1] == \\'b\\';\\n                pref[i][2] = s[i-1] == \\'c\\';\\n            }\\n            else{\\n                pref[i][0] = pref[i-1][0] + (s[i-1] == \\'a\\');\\n                pref[i][1] = pref[i-1][1] + (s[i-1] == \\'b\\');\\n                pref[i][2] = pref[i-1][2] + (s[i-1] == \\'c\\');\\n            }\\n        }\\n        for(int i = n-1; i >=0; i--){\\n            if(i == n-1){\\n                suff[i][0] = s[i] == \\'a\\';\\n                suff[i][1] = s[i] == \\'b\\';\\n                suff[i][2] = s[i] == \\'c\\';\\n            }\\n            else{\\n                suff[i][0] = suff[i+1][0] + (s[i] == \\'a\\');\\n                suff[i][1] = suff[i+1][1] + (s[i] == \\'b\\');\\n                suff[i][2] = suff[i+1][2] + (s[i] == \\'c\\');\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= n; i++){\\n            int start = n,end = i,mid,mov = INT_MAX;\\n            while(start >= end){\\n                mid = (start + end) / 2;\\n                int as = pref[i][0] + suff[mid][0],bs = pref[i][1] + suff[mid][1],cs = pref[i][2] + suff[mid][2];\\n                \\n                if(as >= k && bs >= k && cs >= k){\\n                    mov = n - mid;\\n                    end = mid + 1;\\n                }\\n                else{\\n                    start = mid - 1;\\n                }\\n            }\\n            if(mov != INT_MAX){\\n                ans = min(ans,i+mov);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273084,
                "title": "sliding-window-hasing-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //to keep the suffix count of a b and c\\n    unordered_map<int,int>suffixa;\\n    unordered_map<int,int>suffixb;\\n    unordered_map<int,int>suffixc;\\n\\n    int takeCharacters(string s, int k) \\n    {\\n        //if we dont need to take k characters \\n        if(k == 0) \\n        return 0;  //zero minute will be taken \\n\\n        if(isPossible(s,k) == false)\\n        return -1;\\n\\n        fillsuffixmap(s);\\n\\n        int ans = INT_MAX;\\n\\n        //checking only suffix\\n        int len1 = suffixa[k];\\n        int len2 = suffixb[k];\\n        int len3 = suffixc[k];\\n     \\n        // cout<<\"len1 = \"<<len1<<endl;\\n        // cout<<\"len2 = \"<<len2<<endl;\\n        // cout<<\"len3 = \"<<len3<<endl;\\n\\n        int temp = max(len1,max(len2,len3));\\n        if(temp < ans)\\n        {\\n            ans = temp;\\n        }\\n \\n        //checking only prefix\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n        \\n        int prefixlen = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            prefixlen++;\\n            \\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] ==\\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n\\n            if(counta >=k and countb >=k and countc >=k)\\n            break;\\n        }\\n        if(prefixlen < ans)\\n        {\\n            ans = prefixlen;\\n        }\\n\\n        //checking some prefix and suffix        \\n        prefixlen = 0;\\n        int suffixlen = 0;\\n        counta = 0;\\n        countb = 0;\\n        countc = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            prefixlen++;\\n\\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] == \\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n\\n            int templen = max(suffixa[k-counta],max(suffixb[k-countb],suffixc[k-countc]));\\n\\n            //cout<<\"prefixlen = \"<<prefixlen<<\"  \"<<\"suffixlen = \"<<templen<<endl;\\n\\n            if((prefixlen + templen) < ans)\\n            {\\n                ans = (prefixlen + templen);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    void fillsuffixmap(string &s)\\n    {\\n        //checking the count of counta countb and countc \\n        //in every suiffix of the stirng\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n\\n        int suffixlen = 0;\\n        suffixa[counta] = suffixlen;\\n        suffixb[countb] = suffixlen;\\n        suffixc[countc] = suffixlen;\\n\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            suffixlen++;\\n\\n            if(s[i] == \\'a\\')\\n            {\\n                counta++;\\n                suffixa[counta] = suffixlen;\\n            }\\n            else if(s[i] == \\'b\\')\\n            {\\n                countb++;\\n                suffixb[countb] = suffixlen;\\n            }\\n            else\\n            {\\n                countc++;\\n                suffixc[countc] = suffixlen;\\n            }\\n        }      \\n    }\\n    bool isPossible(string &s,int &k)\\n    {\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] == \\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n        }\\n        if(counta < k or countb < k or countc < k) \\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //to keep the suffix count of a b and c\\n    unordered_map<int,int>suffixa;\\n    unordered_map<int,int>suffixb;\\n    unordered_map<int,int>suffixc;\\n\\n    int takeCharacters(string s, int k) \\n    {\\n        //if we dont need to take k characters \\n        if(k == 0) \\n        return 0;  //zero minute will be taken \\n\\n        if(isPossible(s,k) == false)\\n        return -1;\\n\\n        fillsuffixmap(s);\\n\\n        int ans = INT_MAX;\\n\\n        //checking only suffix\\n        int len1 = suffixa[k];\\n        int len2 = suffixb[k];\\n        int len3 = suffixc[k];\\n     \\n        // cout<<\"len1 = \"<<len1<<endl;\\n        // cout<<\"len2 = \"<<len2<<endl;\\n        // cout<<\"len3 = \"<<len3<<endl;\\n\\n        int temp = max(len1,max(len2,len3));\\n        if(temp < ans)\\n        {\\n            ans = temp;\\n        }\\n \\n        //checking only prefix\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n        \\n        int prefixlen = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            prefixlen++;\\n            \\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] ==\\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n\\n            if(counta >=k and countb >=k and countc >=k)\\n            break;\\n        }\\n        if(prefixlen < ans)\\n        {\\n            ans = prefixlen;\\n        }\\n\\n        //checking some prefix and suffix        \\n        prefixlen = 0;\\n        int suffixlen = 0;\\n        counta = 0;\\n        countb = 0;\\n        countc = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            prefixlen++;\\n\\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] == \\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n\\n            int templen = max(suffixa[k-counta],max(suffixb[k-countb],suffixc[k-countc]));\\n\\n            //cout<<\"prefixlen = \"<<prefixlen<<\"  \"<<\"suffixlen = \"<<templen<<endl;\\n\\n            if((prefixlen + templen) < ans)\\n            {\\n                ans = (prefixlen + templen);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    void fillsuffixmap(string &s)\\n    {\\n        //checking the count of counta countb and countc \\n        //in every suiffix of the stirng\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n\\n        int suffixlen = 0;\\n        suffixa[counta] = suffixlen;\\n        suffixb[countb] = suffixlen;\\n        suffixc[countc] = suffixlen;\\n\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            suffixlen++;\\n\\n            if(s[i] == \\'a\\')\\n            {\\n                counta++;\\n                suffixa[counta] = suffixlen;\\n            }\\n            else if(s[i] == \\'b\\')\\n            {\\n                countb++;\\n                suffixb[countb] = suffixlen;\\n            }\\n            else\\n            {\\n                countc++;\\n                suffixc[countc] = suffixlen;\\n            }\\n        }      \\n    }\\n    bool isPossible(string &s,int &k)\\n    {\\n        int counta = 0;\\n        int countb = 0;\\n        int countc = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            counta++;\\n            else if(s[i] == \\'b\\')\\n            countb++;\\n            else if(s[i] == \\'c\\')\\n            countc++;\\n        }\\n        if(counta < k or countb < k or countc < k) \\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227619,
                "title": "sliding-window-o-n-c",
                "content": "# Intuition\\nMost of the minimum operation by taking elements from left and right of the array can be solved using this approach.\\n\\n# Approach\\nWe will find the **longest subarray** which does not contain the required number of characters(i.e, example in the first example we find the longest subarray where there are **a = 8 - k = 6, b = 2 - 2 = 0 , c = 2 - 2 = 0** characters.)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3, 0);\\n        for(auto c: s){\\n            freq[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 3; i++){ freq[i] -= k; if(freq[i] < 0) return -1; }\\n        int l = 0, r = 0;\\n        vector<int> curr(3, 0);\\n        int len = 0;\\n        while(r < s.size()){\\n            curr[s[r] - \\'a\\']++;\\n            while(curr[s[r] - \\'a\\'] > freq[s[r] - \\'a\\']){\\n                curr[s[l] - \\'a\\']--;\\n                l++;\\n            }\\n            len = max(len, r - l + 1);\\n            r++;\\n        }\\n        return s.size() - len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3, 0);\\n        for(auto c: s){\\n            freq[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 3; i++){ freq[i] -= k; if(freq[i] < 0) return -1; }\\n        int l = 0, r = 0;\\n        vector<int> curr(3, 0);\\n        int len = 0;\\n        while(r < s.size()){\\n            curr[s[r] - \\'a\\']++;\\n            while(curr[s[r] - \\'a\\'] > freq[s[r] - \\'a\\']){\\n                curr[s[l] - \\'a\\']--;\\n                l++;\\n            }\\n            len = max(len, r - l + 1);\\n            r++;\\n        }\\n        return s.size() - len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061452,
                "title": "sliding-window-and-maps",
                "content": "Here our aim is to take out all the supporting elements from the left and right and find out the subarray in the middle which will be of no use. Then we substaract the subarray length from the total length of the string.\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mpp;\\n        mpp[\\'a\\']=0, mpp[\\'b\\']=0, mpp[\\'c\\']=0;\\n        for(auto it: s) mpp[it]++;\\n        \\n        unordered_map<char,int> m; // this is the map according to which we must take the \"atmost\" no of elements to form the subarray.\\n        for(auto it: mpp){\\n            m[it.first]=it.second-k;\\n            if(m[it.first]<0) return -1; // no combinations possible\\n        }\\n        // for(auto it: m){\\n        //     cout<<it.first<<\" \"<<it.second<<endl;\\n        // }\\n        unordered_map<char,int> temp;\\n        int i=0; int j=0;\\n        int res=0;\\n        while(i<n){\\n            temp[s[i]]++;\\n            while(temp[s[i]]>m[s[i]]){\\n                temp[s[j]]--;\\n                // cout<<temp[s[j]];\\n                j++;\\n            }\\n            //applying sliding window\\n            if(temp[\\'a\\']<=m[\\'a\\'] && temp[\\'b\\']<=m[\\'b\\'] && temp[\\'c\\']<=m[\\'c\\']){\\n                res=max(res,i-j+1);\\n                // cout<<i<<\" \"<<j<<\" \";\\n            }\\n            \\n            i++;\\n        }\\n        return s.size()-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mpp;\\n        mpp[\\'a\\']=0, mpp[\\'b\\']=0, mpp[\\'c\\']=0;\\n        for(auto it: s) mpp[it]++;\\n        \\n        unordered_map<char,int> m; // this is the map according to which we must take the \"atmost\" no of elements to form the subarray.\\n        for(auto it: mpp){\\n            m[it.first]=it.second-k;\\n            if(m[it.first]<0) return -1; // no combinations possible\\n        }\\n        // for(auto it: m){\\n        //     cout<<it.first<<\" \"<<it.second<<endl;\\n        // }\\n        unordered_map<char,int> temp;\\n        int i=0; int j=0;\\n        int res=0;\\n        while(i<n){\\n            temp[s[i]]++;\\n            while(temp[s[i]]>m[s[i]]){\\n                temp[s[j]]--;\\n                // cout<<temp[s[j]];\\n                j++;\\n            }\\n            //applying sliding window\\n            if(temp[\\'a\\']<=m[\\'a\\'] && temp[\\'b\\']<=m[\\'b\\'] && temp[\\'c\\']<=m[\\'c\\']){\\n                res=max(res,i-j+1);\\n                // cout<<i<<\" \"<<j<<\" \";\\n            }\\n            \\n            i++;\\n        }\\n        return s.size()-res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2991169,
                "title": "python3-o-nlogn-presum-and-bisect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom start to end, we need to find all rightmost position to take. Use presum and bisect to find the position.\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0: return 0\\n        n = len(s)\\n        presum = [[0] * (n + 1) for _ in range(3)]\\n        for i, c in enumerate(s):\\n            presum[0][i + 1], presum[1][i + 1], presum[2][i + 1] = presum[0][i], presum[1][i], presum[2][i]\\n            presum[ord(c) - ord(\\'a\\')][i + 1] += 1\\n        if any(presum[j][-1] < k for j in range(3)): return -1\\n        ans = n\\n        for i in range(n + 1):\\n            if all(presum[j][i] >= k for j in range(3)):\\n                ans = min(ans, i)\\n                break\\n            if i + 1 >= ans: break\\n            minidx = n + 1\\n            for j in range(3):\\n                if presum[j][i] < k:\\n                    minidx = min(minidx, bisect_left(presum[j], presum[j][i] + presum[j][-1] - k + 1))\\n            ans = min(ans, n + 1 - (minidx - i))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0: return 0\\n        n = len(s)\\n        presum = [[0] * (n + 1) for _ in range(3)]\\n        for i, c in enumerate(s):\\n            presum[0][i + 1], presum[1][i + 1], presum[2][i + 1] = presum[0][i], presum[1][i], presum[2][i]\\n            presum[ord(c) - ord(\\'a\\')][i + 1] += 1\\n        if any(presum[j][-1] < k for j in range(3)): return -1\\n        ans = n\\n        for i in range(n + 1):\\n            if all(presum[j][i] >= k for j in range(3)):\\n                ans = min(ans, i)\\n                break\\n            if i + 1 >= ans: break\\n            minidx = n + 1\\n            for j in range(3):\\n                if presum[j][i] < k:\\n                    minidx = min(minidx, bisect_left(presum[j], presum[j][i] + presum[j][-1] - k + 1))\\n            ans = min(ans, n + 1 - (minidx - i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989902,
                "title": "sliding-window-cyclic-string",
                "content": "\\tclass Solution:\\n\\t\\tdef takeCharacters(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = Counter(s)\\n\\t\\t\\ts = s+s \\n\\t\\t\\tn = len(s) \\n\\n\\t\\t\\ti,j = 0,n//2-1\\n\\n\\t\\t\\tdef found(d): \\n\\t\\t\\t\\tfor c in \\'abc\\': \\n\\t\\t\\t\\t\\tif dp[c]<k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not found(dp): return -1 \\n\\t\\t\\tres = n//2 \\n\\n\\t\\t\\twhile j<n and i<=n//2:\\n\\t\\t\\t\\tif found(dp): \\n\\t\\t\\t\\t\\tres = min(j-i+1,res)\\n\\t\\t\\t\\t\\tif dp[s[i]]: dp[s[i]]-=1  \\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tif (j-i+1) < n//2:\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\t\\tif j<n: dp[s[j]]+=1  \\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ti+=1 \\n\\t\\t\\t\\t\\t\\tif dp[s[i]]: dp[s[i]]-=1   \\n\\t\\t\\treturn res\\n\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef takeCharacters(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = Counter(s)\\n\\t\\t\\ts = s+s \\n\\t\\t\\tn = len(s) \\n\\n\\t\\t\\ti,j = 0,n//2-1\\n\\n\\t\\t\\tdef found(d): \\n\\t\\t\\t\\tfor c in \\'abc\\': \\n\\t\\t\\t\\t\\tif dp[c]<k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not found(dp): return -1 \\n\\t\\t\\tres = n//2 \\n\\n\\t\\t\\twhile j<n and i<=n//2:\\n\\t\\t\\t\\tif found(dp): \\n\\t\\t\\t\\t\\tres = min(j-i+1,res)\\n\\t\\t\\t\\t\\tif dp[s[i]]: dp[s[i]]-=1  \\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tif (j-i+1) < n//2:\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\t\\tif j<n: dp[s[j]]+=1  \\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ti+=1 \\n\\t\\t\\t\\t\\t\\tif dp[s[i]]: dp[s[i]]-=1   \\n\\t\\t\\treturn res\\n\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2970785,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        ct = collections.Counter(s)\\n        if ct[\\'a\\'] < k or ct[\\'b\\'] < k or ct[\\'c\\'] < k :\\n            return -1\\n        ct = collections.Counter()\\n        for i in range(len(s)) :\\n            ct[s[i]] += 1\\n            if ct[\\'a\\'] >= k and ct[\\'b\\'] >= k and ct[\\'c\\'] >= k :\\n                break\\n        used_i = i\\n        to_ret = sum(ct.values())\\n        pend = len(s)-1\\n        while used_i >= 0 :\\n            ct[s[used_i]] -= 1\\n            used_i -= 1\\n            while ct[\\'a\\'] < k or ct[\\'b\\'] < k or ct[\\'c\\'] < k :\\n                ct[s[pend]] += 1\\n                pend -= 1\\n            to_ret = min(to_ret, sum(ct.values()))\\n        return to_ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        ct = collections.Counter(s)\\n        if ct[\\'a\\'] < k or ct[\\'b\\'] < k or ct[\\'c\\'] < k :\\n            return -1\\n        ct = collections.Counter()\\n        for i in range(len(s)) :\\n            ct[s[i]] += 1\\n            if ct[\\'a\\'] >= k and ct[\\'b\\'] >= k and ct[\\'c\\'] >= k :\\n                break\\n        used_i = i\\n        to_ret = sum(ct.values())\\n        pend = len(s)-1\\n        while used_i >= 0 :\\n            ct[s[used_i]] -= 1\\n            used_i -= 1\\n            while ct[\\'a\\'] < k or ct[\\'b\\'] < k or ct[\\'c\\'] < k :\\n                ct[s[pend]] += 1\\n                pend -= 1\\n            to_ret = min(to_ret, sum(ct.values()))\\n        return to_ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964663,
                "title": "python-explained-with-comments-clever",
                "content": "# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        # make a duplicate and count\\n        ss = s*2\\n        freq = {\\'a\\': s.count(\\'a\\'), \\'b\\': s.count(\\'b\\'), \\'c\\': s.count(\\'c\\')}\\n\\n        if any([v < k for v in freq.values()]): # using any() to check if impossible\\n            return -1\\n\\n        # just some variables\\n        windows = []\\n        start = 0\\n        end = len(s)-1\\n\\n        # make sure start never crosses the boundary\\n        while start < len(s):\\n\\n            # as long as the window is still valid and start doesn\\'t cross the boundary\\n            while start < len(s) and all([v >= k for v in freq.values()]):\\n                # get rid of previous letter\\n                freq[s[start]] -= 1\\n                # next!\\n                start += 1\\n\\n            windows.append(end-start+2)\\n\\n            # as long as the window isn\\'t valid\\n            while end < len(ss)-1 and any([v < k for v in freq.values()]):\\n                end += 1\\n                freq[ss[end]] += 1\\n            windows.append(end-start+1)\\n\\n        # just return the smallest window size\\n        return min(windows)\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        # make a duplicate and count\\n        ss = s*2\\n        freq = {\\'a\\': s.count(\\'a\\'), \\'b\\': s.count(\\'b\\'), \\'c\\': s.count(\\'c\\')}\\n\\n        if any([v < k for v in freq.values()]): # using any() to check if impossible\\n            return -1\\n\\n        # just some variables\\n        windows = []\\n        start = 0\\n        end = len(s)-1\\n\\n        # make sure start never crosses the boundary\\n        while start < len(s):\\n\\n            # as long as the window is still valid and start doesn\\'t cross the boundary\\n            while start < len(s) and all([v >= k for v in freq.values()]):\\n                # get rid of previous letter\\n                freq[s[start]] -= 1\\n                # next!\\n                start += 1\\n\\n            windows.append(end-start+2)\\n\\n            # as long as the window isn\\'t valid\\n            while end < len(ss)-1 and any([v < k for v in freq.values()]):\\n                end += 1\\n                freq[ss[end]] += 1\\n            windows.append(end-start+1)\\n\\n        # just return the smallest window size\\n        return min(windows)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958092,
                "title": "best-solution-in-c-slidingwindow",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int size=s.size();\\n        if(k==0)\\n            return 0;\\n        unordered_map<char,int> mp;\\n        for(auto it:s)\\n            mp[it]++;\\n        int max_a=mp[\\'a\\']-k,max_b=mp[\\'b\\']-k,max_c=mp[\\'c\\']-k,i=0,j=0,maxi=0;\\n        if(max_a<0 || max_b<0 || max_c<0)\\n            return -1;\\n        mp.clear();\\n        while(j<size){\\n            mp[s[j]]++;\\n            if(s[j]==\\'a\\'){\\n                while(mp[s[j]]>max_a){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            else if(s[j]==\\'b\\'){\\n                while(mp[s[j]]>max_b){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            else if(s[j]==\\'c\\'){\\n                while(mp[s[j]]>max_c){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            maxi=max(maxi,j-i+1);\\n            j++;\\n        }\\n        return size-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int size=s.size();\\n        if(k==0)\\n            return 0;\\n        unordered_map<char,int> mp;\\n        for(auto it:s)\\n            mp[it]++;\\n        int max_a=mp[\\'a\\']-k,max_b=mp[\\'b\\']-k,max_c=mp[\\'c\\']-k,i=0,j=0,maxi=0;\\n        if(max_a<0 || max_b<0 || max_c<0)\\n            return -1;\\n        mp.clear();\\n        while(j<size){\\n            mp[s[j]]++;\\n            if(s[j]==\\'a\\'){\\n                while(mp[s[j]]>max_a){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            else if(s[j]==\\'b\\'){\\n                while(mp[s[j]]>max_b){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            else if(s[j]==\\'c\\'){\\n                while(mp[s[j]]>max_c){\\n                    mp[s[i]]--;\\n                    i++;\\n                }\\n            }\\n            maxi=max(maxi,j-i+1);\\n            j++;\\n        }\\n        return size-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954437,
                "title": "most-optimized-python-solution-with-explanation",
                "content": "# Intuition\\nInitially take right window as maximum as of length n and then keep decreasing it but increase the left window whenever required, and every time keep upadating the result (```min(res)```).\\n\\n# Approach\\nSliding Window. Notice here we are taking two windows simultaneously(for left and right), or can say it two pointer method also.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)     # we are just taking three variables for the count of \\'a\\', \\'b\\', \\'c\\', two pointer variables and one variable for keeping the result.\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        freq = Counter(s)\\n        if freq[\\'a\\'] < k or freq[\\'b\\'] < k or freq[\\'c\\'] < k:\\n            return -1\\n\\n        result = len(s)\\n        left = 0\\n\\n        for right in range(len(s)):\\n            freq[s[right]] -= 1        # Decreasing right window \\n\\n            while freq[s[right]] < k:\\n                freq[s[left]] += 1      # Increasing left window whenever needed.\\n                left += 1\\n            result = min(result, freq[\\'a\\'] + freq[\\'b\\'] + freq[\\'c\\'])\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```min(res)```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        freq = Counter(s)\\n        if freq[\\'a\\'] < k or freq[\\'b\\'] < k or freq[\\'c\\'] < k:\\n            return -1\\n\\n        result = len(s)\\n        left = 0\\n\\n        for right in range(len(s)):\\n            freq[s[right]] -= 1        # Decreasing right window \\n\\n            while freq[s[right]] < k:\\n                freq[s[left]] += 1      # Increasing left window whenever needed.\\n                left += 1\\n            result = min(result, freq[\\'a\\'] + freq[\\'b\\'] + freq[\\'c\\'])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952077,
                "title": "sliding-window-c-easy-explaination-o-n-t-c-o-n-s-c-beats-100",
                "content": "# *Upvote if you understood the approach and ask your doubts in comments.*\\n# Intuition\\nWhat we are asked in the question is the min. string from left and right such that selected string has char count > k. Then we\\'ll be remaining with the string in middle.\\n\\n# Approach\\nOur target is not left and right part, we\\'ll focus on the remaining string. If left and right part should have char count > k , then we\\'ll select maximum length middle string such that remaining string has char count > k , which can be easily done using sliding window.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.length() , start = 0 , ans = INT_MAX , cnt = 0;\\n        unordered_map<char,int> mp;\\n        for(auto &ch : s)\\n            mp[ch]++;\\n        \\n        if(mp[\\'a\\'] < k || mp[\\'b\\'] < k || mp[\\'c\\'] < k)\\n            return -1;\\n        for(int i=0 ; i<n ; i++){\\n            mp[s[i]]--;\\n            cnt++;\\n            \\n            while(mp[s[i]] < k){\\n                mp[s[start++]]++;\\n                cnt--;\\n            }\\n            ans = min(ans,n-cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.length() , start = 0 , ans = INT_MAX , cnt = 0;\\n        unordered_map<char,int> mp;\\n        for(auto &ch : s)\\n            mp[ch]++;\\n        \\n        if(mp[\\'a\\'] < k || mp[\\'b\\'] < k || mp[\\'c\\'] < k)\\n            return -1;\\n        for(int i=0 ; i<n ; i++){\\n            mp[s[i]]--;\\n            cnt++;\\n            \\n            while(mp[s[i]] < k){\\n                mp[s[start++]]++;\\n                cnt--;\\n            }\\n            ans = min(ans,n-cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950671,
                "title": "swift-solution-using-two-pointers",
                "content": "# Approach\\nWe use two pointers method: i and j represents the characters indices we take from left and right respectively.\\nFirst , we count number of \"a\",\"b\",\"c\" in the string to check whether solution is possible or not. Now, as we decrease i pointer and keep check of count of different alphabets and if any of these count becomes less than k, we start j pointer until the condition is satisfied.\\nOn each step we track the optimal answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    func takeCharacters(_ s: String, _ k: Int) -> Int {\\n        var s = Array(s)\\n        var dic: [Character: Int] = [\"a\" : 0, \"b\" : 0, \"c\" : 0]\\n        \\n        for character in s {\\n            dic[character, default: 0] += 1\\n        }\\n        \\n        guard !dic.values.contains(where: { $0 < k }) else {\\n            return -1\\n        }\\n        \\n        var ans = Int.max\\n        var i = s.count - 1, j = s.count - 1\\n        \\n        while i >= 0 {\\n            dic[s[i], default: 0] -= 1\\n            \\n            while dic[s[i], default: 0] < k {\\n                dic[s[j], default: 0] += 1\\n                j -= 1\\n            }\\n            i -= 1\\n            ans = min(ans, i + s.count - j)\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func takeCharacters(_ s: String, _ k: Int) -> Int {\\n        var s = Array(s)\\n        var dic: [Character: Int] = [\"a\" : 0, \"b\" : 0, \"c\" : 0]\\n        \\n        for character in s {\\n            dic[character, default: 0] += 1\\n        }\\n        \\n        guard !dic.values.contains(where: { $0 < k }) else {\\n            return -1\\n        }\\n        \\n        var ans = Int.max\\n        var i = s.count - 1, j = s.count - 1\\n        \\n        while i >= 0 {\\n            dic[s[i], default: 0] -= 1\\n            \\n            while dic[s[i], default: 0] < k {\\n                dic[s[j], default: 0] += 1\\n                j -= 1\\n            }\\n            i -= 1\\n            ans = min(ans, i + s.count - j)\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950449,
                "title": "easy-clean-c-approach-binary-search-sliding-window-o-nlogn",
                "content": "# Intuition\\nThis question is a combination of sliding window and binary search.\\nYou have to take out some character from both the ends. So, we can take a window on the left end and slide it backwards like it is a circular string.bi\\n\\n# Approach\\n//we have to take out characters from both the sides.\\n//now let\\'s say \"_ _ _ ->_<- _ _ _ _ _ _ _.\" this is the string and I take all characters uptil arrow-ptr\\n//from left side and no character i.e. (0) from right side.\\n\\n//now check from index (0 to arrow-ptr), about the freq of a, b, c and see if they satisfy the condition\\n//[freq[a]>=k && freq[b]>=k && freq[c]>=k].\\n//if yes then well and good see for a smaller soln(i.e. move arrow-ptr to arr-ptr-1).\\n//if no- NOW WE WILL DO A DIFFERENT KIND OF SLIDING WINDOW.\\n// here the window will move in reverse where we will delete the arrow\\'s character and \\n// add the last character of the string in the window.\\n// like so we will move the window like we are moving in a circular string anticlock-wise.\\n\\n//now we would have to check the min ans. by moving the arrow-cnt from n to 0. (overall).\\n//at every arrow position we will do sliding window.\\n\\n//Binary search introduced-now it will be of high complexity if we do by moving arrow from n to 0 in a linear manner.\\n// so we have optimized it with binary search.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //utility function to check the frequency condition.\\n    bool satisfy(vector<int>& freq, int k){\\n        if(freq[0]>=k && freq[1]>=k && freq[2]>=k) return true;\\n        else return false;\\n    }\\n\\n    //sliding window function.\\n    bool isValid(string s, int k, int ptr){\\n        vector<int> freq(3, 0);\\n\\n        //prepare the first window\\n        for(int i=0; i<ptr; i++){\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        if(satisfy(freq, k)) return true;\\n\\n        //slide the window.\\n        int size = s.length();\\n        int left = ptr-1;\\n        int right = size-1;\\n\\n        while(left>=0){\\n            freq[s[left]-\\'a\\']--;\\n            freq[s[right]-\\'a\\']++;\\n            if(satisfy(freq, k)) return true;\\n            left--;\\n            right--;\\n        }\\n\\n        // if after sliding the whole window also true is not returned, so return false.\\n        return false;\\n\\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        \\n        int start = 0;\\n        int end = s.length();\\n        int ans = INT_MAX;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n\\n            if(isValid(s, k, mid)){\\n                ans = min(ans, mid);\\n                //move to left for smaller ans\\n                end = mid-1;\\n            }else{\\n                //ans not found so move to bigger index\\n                start = mid+1;\\n            }\\n\\n        }\\n\\n        if(ans==INT_MAX) ans = -1; //that means no validity found uptill now.\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //utility function to check the frequency condition.\\n    bool satisfy(vector<int>& freq, int k){\\n        if(freq[0]>=k && freq[1]>=k && freq[2]>=k) return true;\\n        else return false;\\n    }\\n\\n    //sliding window function.\\n    bool isValid(string s, int k, int ptr){\\n        vector<int> freq(3, 0);\\n\\n        //prepare the first window\\n        for(int i=0; i<ptr; i++){\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        if(satisfy(freq, k)) return true;\\n\\n        //slide the window.\\n        int size = s.length();\\n        int left = ptr-1;\\n        int right = size-1;\\n\\n        while(left>=0){\\n            freq[s[left]-\\'a\\']--;\\n            freq[s[right]-\\'a\\']++;\\n            if(satisfy(freq, k)) return true;\\n            left--;\\n            right--;\\n        }\\n\\n        // if after sliding the whole window also true is not returned, so return false.\\n        return false;\\n\\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        \\n        int start = 0;\\n        int end = s.length();\\n        int ans = INT_MAX;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n\\n            if(isValid(s, k, mid)){\\n                ans = min(ans, mid);\\n                //move to left for smaller ans\\n                end = mid-1;\\n            }else{\\n                //ans not found so move to bigger index\\n                start = mid+1;\\n            }\\n\\n        }\\n\\n        if(ans==INT_MAX) ans = -1; //that means no validity found uptill now.\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950048,
                "title": "c-sliding-window-clean-code",
                "content": "# Intuition\\nfind a window with max size that makes count of chars outside the window meet the requirement.\\n\\n# Approach\\nincrease `r` by iteration. let char at `r` be `ch`. one step forward may cause count of ch<k. in this case, we keep increase `l` untill ch>=k.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size(), l = 0, r = 0;\\n        int count[3] = {0, 0, 0}; // count of a, b, c\\n        for(char ch: s) count[ch-\\'a\\']++;\\n        if(count[0] < k || count[1] < k || count[2] < k) return -1;\\n        int res = n;\\n        while(r < n) {\\n            char ch = s[r];\\n            count[ch-\\'a\\']--;\\n            r++;\\n            while(count[ch-\\'a\\'] < k && l < r) {\\n                count[s[l]-\\'a\\']++;\\n                l++;\\n            }\\n            if(count[0] >= k || count[1] >= k || count[2] >= k) res = min(res, n-r+l);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size(), l = 0, r = 0;\\n        int count[3] = {0, 0, 0}; // count of a, b, c\\n        for(char ch: s) count[ch-\\'a\\']++;\\n        if(count[0] < k || count[1] < k || count[2] < k) return -1;\\n        int res = n;\\n        while(r < n) {\\n            char ch = s[r];\\n            count[ch-\\'a\\']--;\\n            r++;\\n            while(count[ch-\\'a\\'] < k && l < r) {\\n                count[s[l]-\\'a\\']++;\\n                l++;\\n            }\\n            if(count[0] >= k || count[1] >= k || count[2] >= k) res = min(res, n-r+l);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949235,
                "title": "c-easy-solution-with-video-variable-sliding-window",
                "content": "**Intuition**\\nThe logic is to find the substring which have atmost character occurences - k instead of finding the strings from both ends having at least k a,b,c. We use the concept of variable sliding window and  will retuen total length - length of this window will be our answer. we calculate the length the total count of a,b,c in the string s, then we subtract this respective count with k i.e, our windowCountA = a-k, windowCountB = b-k, windowCountC = c-k, then we try to find a window which have atmost windowCountA a\\'s, windowCountB b\\'s and windowCountC c\\'s. \\n\\nReference Video : [Variable Slinding Window ](https://youtu.be/Lav6St0W_pQ)\\n\\n![image](https://assets.leetcode.com/users/images/4ab18a1e-e50c-4be5-8fa2-0849b4d26373_1671960564.730946.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int ca = 0, cb = 0, cc = 0;\\n        //Calculate frequencies of a, b and c\\n        for(auto it : s){\\n            if(it==\\'a\\') ca++;\\n            if(it==\\'b\\') cb++;\\n            if(it==\\'c\\') cc++;\\n        }\\n         //If any one of the freq is less than k return -1;\\n        if(ca<k || cb<k || cc<k)\\n            return -1;\\n        //To make the life easier we find the maximum length of totalfreq - k\\n        ca -= k; cb -= k; cc -= k;\\n        int windSizeOfa = 0, windSizeOfb = 0, windSizeOfc = 0;\\n        int maxLength = 0;\\n        int i = 0, j = 0;\\n        //Now apply two pointer approach to calculate maximum length\\n        while(j<s.size()){\\n            //Increase *windowSize of each  (*windowSize => currFreq of the char)\\n            if(s[j]==\\'a\\') windSizeOfa++;\\n            if(s[j]==\\'b\\') windSizeOfb++;\\n            if(s[j]==\\'c\\') windSizeOfc++;\\n            //Now if Window size is greater than required then decrease the size\\n            while(windSizeOfa > ca || windSizeOfb > cb || windSizeOfc > cc){\\n                if(s[i]==\\'a\\')\\n                   windSizeOfa--;\\n                if(s[i]==\\'b\\') \\n                   windSizeOfb--;\\n                if(s[i]==\\'c\\') \\n                    windSizeOfc--;\\n                i++;\\n            }\\n            int currLength = j - i + 1;\\n            maxLength = max(maxLength,currLength);\\n            j++;\\n        }\\n        return s.size()-maxLength;\\n    }\\n};\\n```\\n**Time Complexity : O(N)\\nSpace Complexity: O(1)**\\n\\n**If the solution helps to grow your concept then please upvote\\u2B06\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int ca = 0, cb = 0, cc = 0;\\n        //Calculate frequencies of a, b and c\\n        for(auto it : s){\\n            if(it==\\'a\\') ca++;\\n            if(it==\\'b\\') cb++;\\n            if(it==\\'c\\') cc++;\\n        }\\n         //If any one of the freq is less than k return -1;\\n        if(ca<k || cb<k || cc<k)\\n            return -1;\\n        //To make the life easier we find the maximum length of totalfreq - k\\n        ca -= k; cb -= k; cc -= k;\\n        int windSizeOfa = 0, windSizeOfb = 0, windSizeOfc = 0;\\n        int maxLength = 0;\\n        int i = 0, j = 0;\\n        //Now apply two pointer approach to calculate maximum length\\n        while(j<s.size()){\\n            //Increase *windowSize of each  (*windowSize => currFreq of the char)\\n            if(s[j]==\\'a\\') windSizeOfa++;\\n            if(s[j]==\\'b\\') windSizeOfb++;\\n            if(s[j]==\\'c\\') windSizeOfc++;\\n            //Now if Window size is greater than required then decrease the size\\n            while(windSizeOfa > ca || windSizeOfb > cb || windSizeOfc > cc){\\n                if(s[i]==\\'a\\')\\n                   windSizeOfa--;\\n                if(s[i]==\\'b\\') \\n                   windSizeOfb--;\\n                if(s[i]==\\'c\\') \\n                    windSizeOfc--;\\n                i++;\\n            }\\n            int currLength = j - i + 1;\\n            maxLength = max(maxLength,currLength);\\n            j++;\\n        }\\n        return s.size()-maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948485,
                "title": "easy-sliding-window-approach-o-n",
                "content": "Here we are finding the maximum remaining part after we remove characters from left and right.\\nWe will try to maximise the size of this remaining part as it will allow us to minimise the time.\\n\\n![image](https://assets.leetcode.com/users/images/ebc2fc27-b70a-416a-9c6d-f97da69aa7b0_1671949575.035688.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.length();\\n        vector<int> v(3);         // to store count of each letter\\n        for(int i=0;i<n;i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t// not sufficient characters present so return -1\\n        if(v[0]<k || v[1]<k || v[2]<k) return -1;                     \\n        \\n        int ans=0;\\n        int l=0,r=0;   // Left and right pointer of our window\\n\\t\\t\\n\\t\\t// Sliding window\\n        while(r<n){\\n\\t\\t\\t// Here we are storing character count of removed part in vector v , not the count in sliding window\\n\\t\\t\\t\\n\\t\\t\\t// If count of any character is less than k in removed part \\n\\t\\t\\t// then reduce size of window else increase the window size\\n            if(l<r && (v[0]<k || v[1]<k || v[2]<k)){\\n                v[s[l]-\\'a\\']++;\\n                l++;\\n            }\\n            else{\\n                v[s[r]-\\'a\\']--;\\n                r++;\\n            }\\n            \\n\\t\\t\\t// Update the answer only if it is a valid window\\n            if(v[0]>=k && v[1]>=k && v[2]>=k){\\n                ans=max(ans,r-l);\\n            }\\n        }\\n        \\n        if(v[0]>=k && v[1]>=k && v[2]>=k){\\n            ans=max(ans,r-l);\\n        }\\n\\t\\t\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.length();\\n        vector<int> v(3);         // to store count of each letter\\n        for(int i=0;i<n;i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t// not sufficient characters present so return -1\\n        if(v[0]<k || v[1]<k || v[2]<k) return -1;                     \\n        \\n        int ans=0;\\n        int l=0,r=0;   // Left and right pointer of our window\\n\\t\\t\\n\\t\\t// Sliding window\\n        while(r<n){\\n\\t\\t\\t// Here we are storing character count of removed part in vector v , not the count in sliding window\\n\\t\\t\\t\\n\\t\\t\\t// If count of any character is less than k in removed part \\n\\t\\t\\t// then reduce size of window else increase the window size\\n            if(l<r && (v[0]<k || v[1]<k || v[2]<k)){\\n                v[s[l]-\\'a\\']++;\\n                l++;\\n            }\\n            else{\\n                v[s[r]-\\'a\\']--;\\n                r++;\\n            }\\n            \\n\\t\\t\\t// Update the answer only if it is a valid window\\n            if(v[0]>=k && v[1]>=k && v[2]>=k){\\n                ans=max(ans,r-l);\\n            }\\n        }\\n        \\n        if(v[0]>=k && v[1]>=k && v[2]>=k){\\n            ans=max(ans,r-l);\\n        }\\n\\t\\t\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948333,
                "title": "c-sliding-window-solution",
                "content": "```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int a = 0, b = 0, c = 0, left = 0, right = s.Length-1;\\n        // increment \\'left\\' pointer until we have a,b,c >= k\\n        for(; left < s.Length; left++){\\n            if(s[left] == \\'a\\') a++;\\n            if(s[left] == \\'b\\') b++;\\n            if(s[left] == \\'c\\') c++;\\n            if(a >= k && b >= k && c >= k) break;\\n        }\\n        if(a < k || b < k || c < k) return -1;\\n        int res = left+1;\\n        while(left >= 0){\\n            // decrement \\'left\\' pointer one step back\\n            if(s[left] == \\'a\\') a--;\\n            if(s[left] == \\'b\\') b--;\\n            if(s[left] == \\'c\\') c--;\\n            left--;\\n            // and increment \\'right\\' pointer until we have a,b,c >= k\\n            while(right >= 0 && (a < k || b < k || c < k)){\\n                if(s[right] == \\'a\\') a++;\\n                if(s[right] == \\'b\\') b++;\\n                if(s[right] == \\'c\\') c++;\\n                right--;\\n            }\\n            // calculate minimun\\n            res = Math.Min(res, left+s.Length-right);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int a = 0, b = 0, c = 0, left = 0, right = s.Length-1;\\n        // increment \\'left\\' pointer until we have a,b,c >= k\\n        for(; left < s.Length; left++){\\n            if(s[left] == \\'a\\') a++;\\n            if(s[left] == \\'b\\') b++;\\n            if(s[left] == \\'c\\') c++;\\n            if(a >= k && b >= k && c >= k) break;\\n        }\\n        if(a < k || b < k || c < k) return -1;\\n        int res = left+1;\\n        while(left >= 0){\\n            // decrement \\'left\\' pointer one step back\\n            if(s[left] == \\'a\\') a--;\\n            if(s[left] == \\'b\\') b--;\\n            if(s[left] == \\'c\\') c--;\\n            left--;\\n            // and increment \\'right\\' pointer until we have a,b,c >= k\\n            while(right >= 0 && (a < k || b < k || c < k)){\\n                if(s[right] == \\'a\\') a++;\\n                if(s[right] == \\'b\\') b++;\\n                if(s[right] == \\'c\\') c++;\\n                right--;\\n            }\\n            // calculate minimun\\n            res = Math.Min(res, left+s.Length-right);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948284,
                "title": "sliding-window-by-adding-s-to-itself",
                "content": "# Intuition\\nSliding Window by adding `s` to itself. After appending `s` to itself there will be 3 exit points.\\n\\n1. at the beginning of the string\\n2. at the end of the string\\n3. at the middle of the string ( since we added `s` to itself )\\n\\nthese are represented by `exits` variable in code below\\n\\n\\n\\n# Approach\\nAdd string `s` to itself and use regular sliding window to find minimum window which contains `k` abc\\'s.\\n\\nWhen calculating minimum window add the nearest exit point distance.\\n\\nExample : \\n\\n![image.png](https://assets.leetcode.com/users/images/01606f16-6c28-4a99-890a-fbf572f84f75_1671946972.0000196.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n        # early terminations\\n        if k == 0:\\n            return 0\\n        c = Counter(s)\\n        if c[\\'a\\'] < k or c[\\'b\\'] < k or c[\\'c\\'] < k:\\n            return -1\\n\\n        # keep track of original `s` length\\n        slen = len(s)\\n\\n        # append `s` to itself\\n        s += s\\n        ans = float(\\'inf\\')\\n        limit = len(s)\\n\\n        # exits we can use after finding the sliding window which satisfies `k` abc\\'s\\n        exits = [0, slen - 1, limit - 1]\\n        seen = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        l = 0\\n\\n        # regular sliding window approach - find k number of `abc`s\\n        for r in range(limit):\\n            seen[s[r]] += 1\\n\\n            while l < r and seen[\\'a\\'] >= k and seen[\\'b\\'] >= k and seen[\\'c\\'] >= k:\\n                # after finding the sliding window\\n                # add nearest exit boundary either to left or right\\n                # if exit is present in the sliding window we just count the window boundary as the current best\\n                for e in exits:\\n                    ans = min(ans, max(r, e) - min(e, l) + 1)\\n                seen[s[l]] -= 1\\n                l += 1\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n        # early terminations\\n        if k == 0:\\n            return 0\\n        c = Counter(s)\\n        if c[\\'a\\'] < k or c[\\'b\\'] < k or c[\\'c\\'] < k:\\n            return -1\\n\\n        # keep track of original `s` length\\n        slen = len(s)\\n\\n        # append `s` to itself\\n        s += s\\n        ans = float(\\'inf\\')\\n        limit = len(s)\\n\\n        # exits we can use after finding the sliding window which satisfies `k` abc\\'s\\n        exits = [0, slen - 1, limit - 1]\\n        seen = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        l = 0\\n\\n        # regular sliding window approach - find k number of `abc`s\\n        for r in range(limit):\\n            seen[s[r]] += 1\\n\\n            while l < r and seen[\\'a\\'] >= k and seen[\\'b\\'] >= k and seen[\\'c\\'] >= k:\\n                # after finding the sliding window\\n                # add nearest exit boundary either to left or right\\n                # if exit is present in the sliding window we just count the window boundary as the current best\\n                for e in exits:\\n                    ans = min(ans, max(r, e) - min(e, l) + 1)\\n                seen[s[l]] -= 1\\n                l += 1\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948248,
                "title": "python3-sliding-window-sol-for-reference",
                "content": "The intuition for the solution is below. \\n\\nlets assume that there are ta,tb and tc chars of a,b and c in the string, then we are looking for the longest window where number of a\\'s is <= ta-a, b\\'s is <= tb - b and c\\'s is <= tc - c. \\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0: return 0\\n\\n        ans = len(s)\\n        start = 0 \\n        ctr = Counter(s)\\n        h = defaultdict(int)\\n                \\n        if ctr[\\'a\\'] < k or ctr[\\'b\\'] < k or ctr[\\'c\\'] < k:\\n            return -1\\n        \\n        ctr[\\'a\\'] -= k\\n        ctr[\\'b\\'] -= k\\n        ctr[\\'c\\'] -= k\\n                \\n        if not ctr[\\'a\\'] and not ctr[\\'b\\'] and not ctr[\\'c\\']:\\n            return len(s)\\n                \\n        for i,c in enumerate(s):\\n            h[c] += 1\\n            \\n            while (h[\\'a\\'] > ctr[\\'a\\'] or h[\\'b\\'] > ctr[\\'b\\'] or h[\\'c\\'] > ctr[\\'c\\']) and start <= i: \\n                h[s[start]] -= 1\\n                start += 1\\n            \\n            if h[\\'a\\'] <= ctr[\\'a\\'] and h[\\'b\\'] <= ctr[\\'b\\'] and h[\\'c\\'] <= ctr[\\'c\\']:\\n                ans = min(start+len(s)-i-1, ans)\\n            \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "The intuition for the solution is below. \\n\\nlets assume that there are ta,tb and tc chars of a,b and c in the string, then we are looking for the longest window where number of a\\'s is <= ta-a, b\\'s is <= tb - b and c\\'s is <= tc - c. \\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0: return 0\\n\\n        ans = len(s)\\n        start = 0 \\n        ctr = Counter(s)\\n        h = defaultdict(int)\\n                \\n        if ctr[\\'a\\'] < k or ctr[\\'b\\'] < k or ctr[\\'c\\'] < k:\\n            return -1\\n        \\n        ctr[\\'a\\'] -= k\\n        ctr[\\'b\\'] -= k\\n        ctr[\\'c\\'] -= k\\n                \\n        if not ctr[\\'a\\'] and not ctr[\\'b\\'] and not ctr[\\'c\\']:\\n            return len(s)\\n                \\n        for i,c in enumerate(s):\\n            h[c] += 1\\n            \\n            while (h[\\'a\\'] > ctr[\\'a\\'] or h[\\'b\\'] > ctr[\\'b\\'] or h[\\'c\\'] > ctr[\\'c\\']) and start <= i: \\n                h[s[start]] -= 1\\n                start += 1\\n            \\n            if h[\\'a\\'] <= ctr[\\'a\\'] and h[\\'b\\'] <= ctr[\\'b\\'] and h[\\'c\\'] <= ctr[\\'c\\']:\\n                ans = min(start+len(s)-i-1, ans)\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2948241,
                "title": "simple-sliding-window-o-n-time-o-1-space",
                "content": "```\\n/**\\n    first check k a,b,c are present in string or not\\n    we have to choose minimum from start and end means in middle a maximum size window must be present whose have count(a)-k, count(b)-k, count(c)-k characters of a,b,c repesctively\\n    \\n    just find a maximum window in string that must not has greater than count(character)-k character of a,b,c    \\n*/\\nclass Solution {\\npublic:\\n    bool check(int *arr, int *cur, int k) {\\n        \\n        if(cur[0] > arr[0]-k || cur[1] > arr[1]-k || cur[2] > arr[2]-k) return true;\\n        return false;\\n    }\\n    \\n    int takeCharacters(string s, int k) {\\n        \\n        int n = s.size();\\n        int arr[3] = {0};\\n        \\n        for(auto i : s) {\\n            arr[i-\\'a\\']++;\\n        }\\n        \\n        if(arr[0] < k || arr[1] < k || arr[2] < k) return -1;\\n        \\n        int ans = n;\\n        int window[3] = {0};\\n        \\n        int i = 0, j = 0;\\n        while(j < n) {\\n            \\n            window[s[j]-\\'a\\']++;\\n            j++;\\n            \\n            while(check(arr, window, k)) {\\n                window[s[i]-\\'a\\']--;\\n                i++;\\n            }\\n            \\n            ans = min(ans, n-(j-i));\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n    first check k a,b,c are present in string or not\\n    we have to choose minimum from start and end means in middle a maximum size window must be present whose have count(a)-k, count(b)-k, count(c)-k characters of a,b,c repesctively\\n    \\n    just find a maximum window in string that must not has greater than count(character)-k character of a,b,c    \\n*/\\nclass Solution {\\npublic:\\n    bool check(int *arr, int *cur, int k) {\\n        \\n        if(cur[0] > arr[0]-k || cur[1] > arr[1]-k || cur[2] > arr[2]-k) return true;\\n        return false;\\n    }\\n    \\n    int takeCharacters(string s, int k) {\\n        \\n        int n = s.size();\\n        int arr[3] = {0};\\n        \\n        for(auto i : s) {\\n            arr[i-\\'a\\']++;\\n        }\\n        \\n        if(arr[0] < k || arr[1] < k || arr[2] < k) return -1;\\n        \\n        int ans = n;\\n        int window[3] = {0};\\n        \\n        int i = 0, j = 0;\\n        while(j < n) {\\n            \\n            window[s[j]-\\'a\\']++;\\n            j++;\\n            \\n            while(check(arr, window, k)) {\\n                window[s[i]-\\'a\\']--;\\n                i++;\\n            }\\n            \\n            ans = min(ans, n-(j-i));\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948209,
                "title": "c-time-limit-exceeded-dfs-solution",
                "content": "DFS Recursion\\n \\n# Complexity\\n- Time complexity:\\nO(n) - Recursion w/ memoization \\n\\n- Space complexity:\\nO(n) - recursion stack + dictionary\\n\\n# Code\\n```\\npublic class Solution {\\n    private Dictionary<(int,int),int> memo = new();\\n    public int TakeCharacters(string s, int k) {\\n        int left = 0;\\n        int right = s.Length-1;\\n        for(int i=0; i<s.Length;i++){\\n            for(int j=0; j<s.Length;j++){\\n                memo[(i,j)]= -Int32.MaxValue;\\n            }\\n        }\\n        return Helper(0,left,right,0,0,0);\\n        \\n        int Helper(int count, int l, int r, int a, int b, int c){\\n            if(a>=k && b>=k && c>=k) return count;\\n            if(l>r) return -1;\\n            if(memo[(l,r)]!= -Int32.MaxValue)\\n                return memo[(l,r)];\\n               \\n            int leftCount = Helper(count+1,l+1,r,s[l]==\\'a\\' ? a+1 : a,s[l]==\\'b\\' ? b+1 : b,s[l]==\\'c\\' ? c+1 : c);\\n            int rightCount = Helper(count+1,l,r-1,s[r]==\\'a\\' ? a+1 : a,s[r]==\\'b\\' ? b+1 : b,s[r]==\\'c\\' ? c+1 : c);\\n            \\n            return memo[(l,r)] = Math.Min(leftCount,rightCount);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    private Dictionary<(int,int),int> memo = new();\\n    public int TakeCharacters(string s, int k) {\\n        int left = 0;\\n        int right = s.Length-1;\\n        for(int i=0; i<s.Length;i++){\\n            for(int j=0; j<s.Length;j++){\\n                memo[(i,j)]= -Int32.MaxValue;\\n            }\\n        }\\n        return Helper(0,left,right,0,0,0);\\n        \\n        int Helper(int count, int l, int r, int a, int b, int c){\\n            if(a>=k && b>=k && c>=k) return count;\\n            if(l>r) return -1;\\n            if(memo[(l,r)]!= -Int32.MaxValue)\\n                return memo[(l,r)];\\n               \\n            int leftCount = Helper(count+1,l+1,r,s[l]==\\'a\\' ? a+1 : a,s[l]==\\'b\\' ? b+1 : b,s[l]==\\'c\\' ? c+1 : c);\\n            int rightCount = Helper(count+1,l,r-1,s[r]==\\'a\\' ? a+1 : a,s[r]==\\'b\\' ? b+1 : b,s[r]==\\'c\\' ? c+1 : c);\\n            \\n            return memo[(l,r)] = Math.Min(leftCount,rightCount);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948161,
                "title": "detailed-explanation-using-binary-search-two-pointers-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Since we can see that for [1.......m..........n] if we are able to achieve our target \\'K\\' for \\'a\\' , \\'b\\' and \\'c\\' we would be able to do it for m+1 to n also.\\n\\nBut if we are not able to achieve the required complexity in time \\'m\\' we won\\'t be able to do it in 1 to m - 1 time also.\\n\\nThis is where I thought binary search can help us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Do binary search on answer for time required.\\n2. Check if it is possible to achieve frequency of \\'a\\' , \\'b\\' and \\'c\\' at time \\'mid\\'.\\n3. If possible try to decrease the time else increase the time\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(log(N) * N)\\n        logn(N) for binary search and everytime we check it is possible or not using two pointers which takes further O(N) complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1) since unordered map is always of size 3.\\n# Code\\n```\\nclass Solution {\\n    bool greaterThanEqualK(unordered_map<char , int>& freq,const int& k) //O(1)\\n    {\\n        for(auto& [ch , f] : freq)\\n        {\\n            if(f < k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool possible(int mid , const string& s ,const int& k)\\n    {\\n        int n = s.size();\\n        int i = 0 , j = n - 1;\\n        unordered_map<char , int>freq;\\n        freq[\\'a\\'] = 0 , freq[\\'b\\'] = 0 , freq[\\'c\\'] = 0;\\n        \\n        while(i < mid)\\n        {\\n            freq[s[i]]++;\\n            i++;\\n        }\\n        bool check = greaterThanEqualK(freq,k);\\n        if(check) return true;\\n        i--;\\n        while(i >= 0)\\n        {\\n            freq[s[i]]--;\\n            freq[s[j]]++;\\n            i-- , j--;\\n            bool check = greaterThanEqualK(freq,k);\\n            if(check) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k == 0)\\n            return 0;\\n        int sLen = s.size();\\n        int low = 1 , high = sLen;\\n        int ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            bool check = possible(mid , s , k );\\n            if(check)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool greaterThanEqualK(unordered_map<char , int>& freq,const int& k) //O(1)\\n    {\\n        for(auto& [ch , f] : freq)\\n        {\\n            if(f < k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool possible(int mid , const string& s ,const int& k)\\n    {\\n        int n = s.size();\\n        int i = 0 , j = n - 1;\\n        unordered_map<char , int>freq;\\n        freq[\\'a\\'] = 0 , freq[\\'b\\'] = 0 , freq[\\'c\\'] = 0;\\n        \\n        while(i < mid)\\n        {\\n            freq[s[i]]++;\\n            i++;\\n        }\\n        bool check = greaterThanEqualK(freq,k);\\n        if(check) return true;\\n        i--;\\n        while(i >= 0)\\n        {\\n            freq[s[i]]--;\\n            freq[s[j]]++;\\n            i-- , j--;\\n            bool check = greaterThanEqualK(freq,k);\\n            if(check) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k == 0)\\n            return 0;\\n        int sLen = s.size();\\n        int low = 1 , high = sLen;\\n        int ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            bool check = possible(mid , s , k );\\n            if(check)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948064,
                "title": "python-binary-search",
                "content": "**intuition**:\\n binary search on the longest substring that when deleted the remaining part will be a valid string \\n\\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        def isValid(count):\\n            return len([c for c, v in count.items() if v >= k]) == 3\\n\\n        if k == 0:\\n            return 0\\n        if  not isValid(Counter(s)):\\n            return -1\\n        def good(l):\\n            i = 0\\n            count = Counter(s)\\n            # delete the first chars that matches  the length\\n            while i < l:\\n                count[s[i]] -= 1\\n                i += 1\\n\\t\\t\\t# if it valid then return True , valid mean that after deleted that length the outer str have required chars\\n            if isValid(count):\\n                return True\\n\\t\\t\\t# maintain sliding window delete next char that will be added to the sliding window and add the prev char to the  outer part\\n            left = 0\\n            while i < len(s):\\n                count[s[left]] += 1\\n                count[s[i]] -= 1 \\n                if isValid(count):\\n                    return True\\n                i += 1\\n                left += 1\\n            return False\\n        l = 0\\n        r = len(s)\\n        while l < r:\\n            m = (l+r+1) >> 1\\n\\t\\t\\t# if it\\'s good , mean we can delete a large substring\\n            if good(m):\\n                l = m\\n            else :\\n                r = m - 1\\n        return len(s) - l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        def isValid(count):\\n            return len([c for c, v in count.items() if v >= k]) == 3\\n\\n        if k == 0:\\n            return 0\\n        if  not isValid(Counter(s)):\\n            return -1\\n        def good(l):\\n            i = 0\\n            count = Counter(s)\\n            # delete the first chars that matches  the length\\n            while i < l:\\n                count[s[i]] -= 1\\n                i += 1\\n\\t\\t\\t# if it valid then return True , valid mean that after deleted that length the outer str have required chars\\n            if isValid(count):\\n                return True\\n\\t\\t\\t# maintain sliding window delete next char that will be added to the sliding window and add the prev char to the  outer part\\n            left = 0\\n            while i < len(s):\\n                count[s[left]] += 1\\n                count[s[i]] -= 1 \\n                if isValid(count):\\n                    return True\\n                i += 1\\n                left += 1\\n            return False\\n        l = 0\\n        r = len(s)\\n        while l < r:\\n            m = (l+r+1) >> 1\\n\\t\\t\\t# if it\\'s good , mean we can delete a large substring\\n            if good(m):\\n                l = m\\n            else :\\n                r = m - 1\\n        return len(s) - l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948056,
                "title": "weak-in-binary-search-but-managed-to-solve-this",
                "content": "```\\nbool solve(int mid, string &s, int k)\\n    {\\n        int f[3] = {};\\n        if(s.length() < k)\\n            return false;\\n        for(int i=0; i<mid; i++)\\n            f[s[i]-\\'a\\']++;\\n        if(f[0] >= k && f[1] >= k && f[2] >= k)\\n            return true;\\n        for(int j=1; j<=mid; j++)\\n        {\\n            f[s[mid-j]-\\'a\\']--;\\n            f[s[s.length()-j]-\\'a\\']++;\\n            if(f[0] >= k && f[1] >= k && f[2] >= k)\\n            return true;\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        int ans = -1, n = s.length();\\n        int hi = n, lo = 3;\\n        if(k == 0)\\n            return 0;\\n        while(lo <= hi)\\n        {\\n            int mid = (lo + hi)/2;\\n            if(solve(mid, s, k))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool solve(int mid, string &s, int k)\\n    {\\n        int f[3] = {};\\n        if(s.length() < k)\\n            return false;\\n        for(int i=0; i<mid; i++)\\n            f[s[i]-\\'a\\']++;\\n        if(f[0] >= k && f[1] >= k && f[2] >= k)\\n            return true;\\n        for(int j=1; j<=mid; j++)\\n        {\\n            f[s[mid-j]-\\'a\\']--;\\n            f[s[s.length()-j]-\\'a\\']++;\\n            if(f[0] >= k && f[1] >= k && f[2] >= k)\\n            return true;\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        int ans = -1, n = s.length();\\n        int hi = n, lo = 3;\\n        if(k == 0)\\n            return 0;\\n        while(lo <= hi)\\n        {\\n            int mid = (lo + hi)/2;\\n            if(solve(mid, s, k))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947992,
                "title": "eassy-c",
                "content": "class Solution {\\npublic:\\n\\n    int solve(string s,vector<int>&vec,int k , int j){\\n         int ans = s.size() - j;\\n        for (int i = 0; i < s.size(); i += 1) {\\n            vec[s[i] - \\'a\\'] += 1;\\n            while (j < s.size()) {\\n                vec[s[j] - \\'a\\'] -= 1;\\n                if (*min_element(vec.begin(), vec.end()) >= k) {\\n                    j += 1;\\n                } else {\\n                    vec[s[j] - \\'a\\'] += 1;\\n                    break;\\n                }\\n            }\\n            int check = i + 1 + s.size() - j;\\n            ans = min(ans, check);\\n        }\\n        return ans;\\n    }\\n    int takeCharacters(string s, int k) {\\n        vector<int> vec(3);\\n        int j = s.size();\\n        while (j and *min_element(vec.begin(),vec.end()) < k) {\\n            j -= 1;\\n            vec[s[j] - \\'a\\'] += 1;\\n        }\\n        if (*min_element(vec.begin(), vec.end()) < k) return -1;\\n         return solve(s,vec,k,j);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int solve(string s,vector<int>&vec,int k , int j){\\n         int ans = s.size() - j;\\n        for (int i = 0; i < s.size(); i += 1) {\\n            vec[s[i] - \\'a\\'] += 1;\\n            while (j < s.size()) {\\n                vec[s[j] - \\'a\\'] -= 1;\\n                if (*min_element(vec.begin(), vec.end()) >= k) {\\n                    j += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4092619,
                "title": "c-python-sliding-window-solution-with-explanation",
                "content": "### sliding window\\nwe just find the longest window meet the requirement.\\n![image](https://assets.leetcode.com/users/images/996b478d-ff34-4ef2-b97a-0fe3601a064e_1695730454.699166.png)\\n\\n### python\\n```python\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        cnt = [0] * 3\\n        for ch in s:\\n            cnt[ord(ch) - ord(\\'a\\')] += 1\\n        if cnt[0] < k or cnt[1] < k or cnt[2] < k: return -1\\n        left = 0\\n        cur = [0] * 3\\n        ans = 0\\n        for i, ch in enumerate(s):\\n            cur[ord(ch) - ord(\\'a\\')] += 1\\n            while cnt[0] - cur[0] < k or cnt[1] - cur[1] < k or cnt[2] - cur[2] < k:\\n                cur[ord(s[left]) - ord(\\'a\\')] -= 1\\n                left += 1\\n            if i - left + 1 > ans: ans = i - left + 1\\n        return len(s) - ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int cnt[3] {0};\\n        for (int i = 0; i < s.size(); i+=1)\\n            cnt[s[i] - \\'a\\'] += 1;\\n        if (cnt[0] < k || cnt[1] < k || cnt[2] < k) return -1;\\n        int left = 0;\\n        int cur[3] {0};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i+=1) {\\n            cur[s[i] - \\'a\\'] += 1;\\n            while (cnt[0] - cur[0] < k || cnt[1] - cur[1] < k || cnt[2] - cur[2] < k) {\\n                cur[s[left] - \\'a\\'] -= 1;\\n                left += 1;\\n            }\\n            if (i - left + 1 > ans) ans = i - left + 1;\\n        }\\n        return s.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        cnt = [0] * 3\\n        for ch in s:\\n            cnt[ord(ch) - ord(\\'a\\')] += 1\\n        if cnt[0] < k or cnt[1] < k or cnt[2] < k: return -1\\n        left = 0\\n        cur = [0] * 3\\n        ans = 0\\n        for i, ch in enumerate(s):\\n            cur[ord(ch) - ord(\\'a\\')] += 1\\n            while cnt[0] - cur[0] < k or cnt[1] - cur[1] < k or cnt[2] - cur[2] < k:\\n                cur[ord(s[left]) - ord(\\'a\\')] -= 1\\n                left += 1\\n            if i - left + 1 > ans: ans = i - left + 1\\n        return len(s) - ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int cnt[3] {0};\\n        for (int i = 0; i < s.size(); i+=1)\\n            cnt[s[i] - \\'a\\'] += 1;\\n        if (cnt[0] < k || cnt[1] < k || cnt[2] < k) return -1;\\n        int left = 0;\\n        int cur[3] {0};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i+=1) {\\n            cur[s[i] - \\'a\\'] += 1;\\n            while (cnt[0] - cur[0] < k || cnt[1] - cur[1] < k || cnt[2] - cur[2] < k) {\\n                cur[s[left] - \\'a\\'] -= 1;\\n                left += 1;\\n            }\\n            if (i - left + 1 > ans) ans = i - left + 1;\\n        }\\n        return s.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074440,
                "title": "simple-sliding-window-solution-easy-approach",
                "content": "c.get(\\'a\\', 0), c.get(\\'b\\', 0), and c.get(\\'c\\', 0) retrieve the counts of characters \\'a\\', \\'b\\', and \\'c\\' respectively from the counter c. If a character is not present in the counter (like \\'a\\', \\'b\\', or \\'c\\'), it returns 0.\\nThe if condition checks if the count of \\'a\\', \\'b\\', or \\'c\\' (retrieved using c.get()) is less than a specified value k. If any of these counts are less than k, it returns -1.\\n\\n\\n\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\t\\n        c= Counter(s); d=defaultdict(int); i=0; ans=inf\\n        \\n        if c.get(\\'a\\', 0) < k or c.get(\\'b\\', 0) < k or c.get(\\'c\\', 0) < k:\\n            return -1\\n        \\n        for j in range(len(s)):\\n            d[s[j]]+=1\\n                \\n            while d[s[j]] > c[s[j]]-k:\\n                d[s[i]]-=1\\n                i+=1\\n            \\n            ans= min(ans, (len(s)) - (j-i+1))\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "c.get(\\'a\\', 0), c.get(\\'b\\', 0), and c.get(\\'c\\', 0) retrieve the counts of characters \\'a\\', \\'b\\', and \\'c\\' respectively from the counter c. If a character is not present in the counter (like \\'a\\', \\'b\\', or \\'c\\'), it returns 0.\\nThe if condition checks if the count of \\'a\\', \\'b\\', or \\'c\\' (retrieved using c.get()) is less than a specified value k. If any of these counts are less than k, it returns -1.\\n\\n\\n\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\t\\n        c= Counter(s); d=defaultdict(int); i=0; ans=inf\\n        \\n        if c.get(\\'a\\', 0) < k or c.get(\\'b\\', 0) < k or c.get(\\'c\\', 0) < k:\\n            return -1\\n        \\n        for j in range(len(s)):\\n            d[s[j]]+=1\\n                \\n            while d[s[j]] > c[s[j]]-k:\\n                d[s[i]]-=1\\n                i+=1\\n            \\n            ans= min(ans, (len(s)) - (j-i+1))\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3977762,
                "title": "c-sliding-window-hash-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(map<char,int>& m,int k)\\n    {\\n        if(m[\\'a\\']>=k && m[\\'b\\']>=k && m[\\'c\\']>=k)\\n        return true;\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        map<char,int> m;\\n        for(auto &i:s)\\n        m[i]++;\\n        if(!isValid(m,k))\\n        return -1;\\n        int i=0,j=0;\\n        int n = s.size();\\n        int ans = INT_MAX;\\n        while(j<n)\\n        {\\n            m[s[j]]--;\\n            if(isValid(m,k))\\n            {\\n                ans = min(ans,n-(j-i+1));\\n            }\\n            else\\n            {\\n                while(!isValid(m,k) && i<=j)\\n                {\\n                    m[s[i]]++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(map<char,int>& m,int k)\\n    {\\n        if(m[\\'a\\']>=k && m[\\'b\\']>=k && m[\\'c\\']>=k)\\n        return true;\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        map<char,int> m;\\n        for(auto &i:s)\\n        m[i]++;\\n        if(!isValid(m,k))\\n        return -1;\\n        int i=0,j=0;\\n        int n = s.size();\\n        int ans = INT_MAX;\\n        while(j<n)\\n        {\\n            m[s[j]]--;\\n            if(isValid(m,k))\\n            {\\n                ans = min(ans,n-(j-i+1));\\n            }\\n            else\\n            {\\n                while(!isValid(m,k) && i<=j)\\n                {\\n                    m[s[i]]++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969933,
                "title": "python-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0 :\\n            return 0\\n        allChar = Counter(s)\\n        currentChar = Counter()\\n        i = 0\\n        reqChar = {\"a\":k,\"b\":k,\"c\":k}\\n        if len(allChar) < 3 or min(allChar.values()) < k :\\n            return -1\\n\\n        l = len(s)\\n        count = l\\n        for j in range(l):\\n            currentChar[s[j]] += 1\\n            allChar[s[j]] -= 1\\n            # diffCounter = allChar - currentChar\\n            if allChar[\"a\"] >= k and allChar[\"b\"] >= k and allChar[\"c\"] >= k:\\n                count = min(count,  l-(j-i+1)) \\n\\n            else :\\n                #  diffCounter[\"a\"] < k or diffCounter[\"b\"] < k or diffCounter[\"c\"] < k:\\n                while(allChar[\"a\"] < k or allChar[\"b\"] < k or allChar[\"c\"] < k):\\n                    currentChar[s[i]] -= 1\\n                    allChar[s[i]] += 1\\n                    # diffCounter = allChar - currentChar\\n                    i += 1\\n\\n        return count \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k == 0 :\\n            return 0\\n        allChar = Counter(s)\\n        currentChar = Counter()\\n        i = 0\\n        reqChar = {\"a\":k,\"b\":k,\"c\":k}\\n        if len(allChar) < 3 or min(allChar.values()) < k :\\n            return -1\\n\\n        l = len(s)\\n        count = l\\n        for j in range(l):\\n            currentChar[s[j]] += 1\\n            allChar[s[j]] -= 1\\n            # diffCounter = allChar - currentChar\\n            if allChar[\"a\"] >= k and allChar[\"b\"] >= k and allChar[\"c\"] >= k:\\n                count = min(count,  l-(j-i+1)) \\n\\n            else :\\n                #  diffCounter[\"a\"] < k or diffCounter[\"b\"] < k or diffCounter[\"c\"] < k:\\n                while(allChar[\"a\"] < k or allChar[\"b\"] < k or allChar[\"c\"] < k):\\n                    currentChar[s[i]] -= 1\\n                    allChar[s[i]] += 1\\n                    # diffCounter = allChar - currentChar\\n                    i += 1\\n\\n        return count \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968710,
                "title": "golang-100-solution",
                "content": "# Code\\n```go\\nfunc takeCharacters(s string, k int) int {\\n\\tif k == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tcounterA, counterB, counterC := 0, 0, 0\\n\\tleftSize, rightSize := 0, 0\\n\\tfor i, v := range s {\\n\\t\\tswitch v {\\n\\t\\tcase \\'a\\':\\n\\t\\t\\tcounterA++\\n\\t\\tcase \\'b\\':\\n\\t\\t\\tcounterB++\\n\\t\\tcase \\'c\\':\\n\\t\\t\\tcounterC++\\n\\t\\t}\\n\\t\\tif counterA >= k && counterB >= k && counterC >= k {\\n\\t\\t\\tleftSize = i+1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tif leftSize == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tminSize := leftSize+rightSize\\n\\tfor leftSize > 0 {\\n\\t\\tleftSize--\\n\\t\\tswitch s[leftSize] {\\n\\t\\tcase \\'a\\':\\n\\t\\t\\tcounterA--\\n\\t\\tcase \\'b\\':\\n\\t\\t\\tcounterB--\\n\\t\\tcase \\'c\\':\\n\\t\\t\\tcounterC--\\n\\t\\t}\\n\\t\\tfor !(counterA >= k && counterB >= k && counterC >= k) {\\n\\t\\t\\trightSize++\\n\\t\\t\\tif rightSize >= minSize {\\n\\t\\t\\t\\treturn minSize\\n\\t\\t\\t}\\n\\t\\t\\tswitch s[len(s)-rightSize] {\\n\\t\\t\\tcase \\'a\\':\\n\\t\\t\\t\\tcounterA++\\n\\t\\t\\tcase \\'b\\':\\n\\t\\t\\t\\tcounterB++\\n\\t\\t\\tcase \\'c\\':\\n\\t\\t\\t\\tcounterC++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif curSize := leftSize+rightSize; curSize < minSize {\\n\\t\\t\\tminSize = curSize\\n\\t\\t}\\n\\t}\\n\\treturn minSize\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc takeCharacters(s string, k int) int {\\n\\tif k == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tcounterA, counterB, counterC := 0, 0, 0\\n\\tleftSize, rightSize := 0, 0\\n\\tfor i, v := range s {\\n\\t\\tswitch v {\\n\\t\\tcase \\'a\\':\\n\\t\\t\\tcounterA++\\n\\t\\tcase \\'b\\':\\n\\t\\t\\tcounterB++\\n\\t\\tcase \\'c\\':\\n\\t\\t\\tcounterC++\\n\\t\\t}\\n\\t\\tif counterA >= k && counterB >= k && counterC >= k {\\n\\t\\t\\tleftSize = i+1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tif leftSize == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tminSize := leftSize+rightSize\\n\\tfor leftSize > 0 {\\n\\t\\tleftSize--\\n\\t\\tswitch s[leftSize] {\\n\\t\\tcase \\'a\\':\\n\\t\\t\\tcounterA--\\n\\t\\tcase \\'b\\':\\n\\t\\t\\tcounterB--\\n\\t\\tcase \\'c\\':\\n\\t\\t\\tcounterC--\\n\\t\\t}\\n\\t\\tfor !(counterA >= k && counterB >= k && counterC >= k) {\\n\\t\\t\\trightSize++\\n\\t\\t\\tif rightSize >= minSize {\\n\\t\\t\\t\\treturn minSize\\n\\t\\t\\t}\\n\\t\\t\\tswitch s[len(s)-rightSize] {\\n\\t\\t\\tcase \\'a\\':\\n\\t\\t\\t\\tcounterA++\\n\\t\\t\\tcase \\'b\\':\\n\\t\\t\\t\\tcounterB++\\n\\t\\t\\tcase \\'c\\':\\n\\t\\t\\t\\tcounterC++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif curSize := leftSize+rightSize; curSize < minSize {\\n\\t\\t\\tminSize = curSize\\n\\t\\t}\\n\\t}\\n\\treturn minSize\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962345,
                "title": "sliding-window-two-pointer",
                "content": "```\\nCode block\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding window\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nConstant - O(3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\n  0 1 2 3 4 5 6 7 8 9 10 11\\n  a a b a a a a c a a b c\\n  a->8,b->2,c->2\\n\\n  search for the longest substring with character ans their frequencies as mp[a]-k,mp[b]-k and so on\\n\\n*/\\n   bool check(unordered_map<char,int>mp,int k){\\n     for(auto x:mp){\\n       if(x.second<k)return true;\\n     }\\n     return false;\\n   }\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n        if(mp[\\'a\\']<k||mp[\\'b\\']<k||mp[\\'c\\']<k)\\n        return -1;\\n        int len=0;\\n        int ans=s.size(),j=0;\\n        for(int i=0;i<s.size();i++){\\n                mp[s[i]]--;\\n                while(check(mp,k)){\\n                    mp[s[j]]++;\\n                    j++;\\n                }\\n              len=max(len,i-j+1);      \\n        }\\n        \\n        return ans-len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCode block\\n```\n```\\nclass Solution {\\npublic:\\n/*\\n  0 1 2 3 4 5 6 7 8 9 10 11\\n  a a b a a a a c a a b c\\n  a->8,b->2,c->2\\n\\n  search for the longest substring with character ans their frequencies as mp[a]-k,mp[b]-k and so on\\n\\n*/\\n   bool check(unordered_map<char,int>mp,int k){\\n     for(auto x:mp){\\n       if(x.second<k)return true;\\n     }\\n     return false;\\n   }\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n        if(mp[\\'a\\']<k||mp[\\'b\\']<k||mp[\\'c\\']<k)\\n        return -1;\\n        int len=0;\\n        int ans=s.size(),j=0;\\n        for(int i=0;i<s.size();i++){\\n                mp[s[i]]--;\\n                while(check(mp,k)){\\n                    mp[s[j]]++;\\n                    j++;\\n                }\\n              len=max(len,i-j+1);      \\n        }\\n        \\n        return ans-len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957061,
                "title": "python3-prefix-suffix",
                "content": "# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k==0: return 0\\n\\n        a, b, c = 0, 0, 0\\n        aSuffix = dict()\\n        bSuffix = dict()\\n        cSuffix = dict()\\n\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i]==\\'a\\':\\n                a+=1\\n            elif s[i]==\\'b\\':\\n                b+=1\\n            elif s[i]==\\'c\\':\\n                c+=1\\n            # print(i)\\n            if a not in aSuffix:\\n                aSuffix[a] = i\\n            if b not in bSuffix:\\n                bSuffix[b] = i\\n            if c not in cSuffix:\\n                cSuffix[c] = i\\n\\n        if a<k or b<k or c<k:\\n                return -1\\n        \\n        ans = 1000000\\n        a, b, c = 0, 0, 0\\n        for i in range(len(s)):\\n            if (k-a <= 0 or k-a in aSuffix) and (k-b<=0 or k-b in bSuffix) and (k-c<=0 or k-c in cSuffix):\\n                A = len(s) if k-a<=0 else aSuffix[k-a]\\n                B = len(s) if k-b<=0 else bSuffix[k-b]\\n                C = len(s) if k-c<=0 else cSuffix[k-c]\\n                ans = min(ans, i+len(s)-min(A, B, C))\\n            if s[i]==\\'a\\':\\n                a+=1\\n            elif s[i]==\\'b\\':\\n                b+=1\\n            elif s[i]==\\'c\\':\\n                c+=1\\n\\n        return ans\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k==0: return 0\\n\\n        a, b, c = 0, 0, 0\\n        aSuffix = dict()\\n        bSuffix = dict()\\n        cSuffix = dict()\\n\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i]==\\'a\\':\\n                a+=1\\n            elif s[i]==\\'b\\':\\n                b+=1\\n            elif s[i]==\\'c\\':\\n                c+=1\\n            # print(i)\\n            if a not in aSuffix:\\n                aSuffix[a] = i\\n            if b not in bSuffix:\\n                bSuffix[b] = i\\n            if c not in cSuffix:\\n                cSuffix[c] = i\\n\\n        if a<k or b<k or c<k:\\n                return -1\\n        \\n        ans = 1000000\\n        a, b, c = 0, 0, 0\\n        for i in range(len(s)):\\n            if (k-a <= 0 or k-a in aSuffix) and (k-b<=0 or k-b in bSuffix) and (k-c<=0 or k-c in cSuffix):\\n                A = len(s) if k-a<=0 else aSuffix[k-a]\\n                B = len(s) if k-b<=0 else bSuffix[k-b]\\n                C = len(s) if k-c<=0 else cSuffix[k-c]\\n                ans = min(ans, i+len(s)-min(A, B, C))\\n            if s[i]==\\'a\\':\\n                a+=1\\n            elif s[i]==\\'b\\':\\n                b+=1\\n            elif s[i]==\\'c\\':\\n                c+=1\\n\\n        return ans\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956820,
                "title": "2516-take-k-of-each-character-from-left-and-right",
                "content": "```\\nclass Solution {\\n public:\\n  int takeCharacters(string s, int k) {\\n    const int n = s.length();\\n    int ans = n;\\n    vector<int> count(3);\\n\\n    for (const char c : s)\\n      ++count[c - \\'a\\'];\\n\\n    if (count[0] < k || count[1] < k || count[2] < k)\\n      return -1;\\n\\n    for (int l = 0, r = 0; r < n; ++r) {\\n      --count[s[r] - \\'a\\'];\\n      while (count[s[r] - \\'a\\'] < k)\\n        ++count[s[l++] - \\'a\\'];\\n      ans = min(ans, n - (r - l + 1));\\n    }\\n\\n    return ans;\\n  }\\n};\\n",
                "solutionTags": [
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution {\\n public:\\n  int takeCharacters(string s, int k) {\\n    const int n = s.length();\\n    int ans = n;\\n    vector<int> count(3);\\n\\n    for (const char c : s)\\n      ++count[c - \\'a\\'];\\n\\n    if (count[0] < k || count[1] < k || count[2] < k)\\n      return -1;\\n\\n    for (int l = 0, r = 0; r < n; ++r) {\\n      --count[s[r] - \\'a\\'];\\n      while (count[s[r] - \\'a\\'] < k)\\n        ++count[s[l++] - \\'a\\'];\\n      ans = min(ans, n - (r - l + 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3951623,
                "title": "bin-search-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        n = len(s)\\n\\n        def build_array(ch, st):\\n            arr = [0] * (len(st) + 1)\\n            for i, x in enumerate(st):\\n                arr[i + 1] = arr[i] + int(x == ch)\\n            return arr\\n\\n        def bin_search(target, arr):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            return l\\n        \\n        # Create prefix and suffix arrays for each character using a loop\\n        prefix = {ch: build_array(ch, s) for ch in \"abc\"}\\n        suffix = {ch: build_array(ch, s[::-1]) for ch in \"abc\"}\\n\\n        min_minutes = float(\\'inf\\')\\n        for left in range(n + 1):\\n            total_right = 0\\n            for ch in \"abc\":\\n                total_right = max(total_right, bin_search(k - prefix[ch][left], suffix[ch]))\\n\\n            if left + total_right <= n:\\n                min_minutes = min(min_minutes, left + total_right)\\n\\n        return min_minutes if min_minutes != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        n = len(s)\\n\\n        def build_array(ch, st):\\n            arr = [0] * (len(st) + 1)\\n            for i, x in enumerate(st):\\n                arr[i + 1] = arr[i] + int(x == ch)\\n            return arr\\n\\n        def bin_search(target, arr):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            return l\\n        \\n        # Create prefix and suffix arrays for each character using a loop\\n        prefix = {ch: build_array(ch, s) for ch in \"abc\"}\\n        suffix = {ch: build_array(ch, s[::-1]) for ch in \"abc\"}\\n\\n        min_minutes = float(\\'inf\\')\\n        for left in range(n + 1):\\n            total_right = 0\\n            for ch in \"abc\":\\n                total_right = max(total_right, bin_search(k - prefix[ch][left], suffix[ch]))\\n\\n            if left + total_right <= n:\\n                min_minutes = min(min_minutes, left + total_right)\\n\\n        return min_minutes if min_minutes != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924597,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int m[3] = {};\\n        for (auto& c : s) ++m[c - \\'a\\'];\\n        if (m[0] < k || m[1] < k || m[2] < k) return -1;\\n        int ans = s.size();\\n        int l = 0, r = s.size() - 1, e = s.size() - 1;\\n        while (r >= 0){\\n            --m[s[(r--)] - \\'a\\'];\\n            while (m[0] < k || m[1] < k || m[2] < k) ++m[s[(e - l++)] - \\'a\\'];\\n            ans = min(ans, r + 1 + l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int m[3] = {};\\n        for (auto& c : s) ++m[c - \\'a\\'];\\n        if (m[0] < k || m[1] < k || m[2] < k) return -1;\\n        int ans = s.size();\\n        int l = 0, r = s.size() - 1, e = s.size() - 1;\\n        while (r >= 0){\\n            --m[s[(r--)] - \\'a\\'];\\n            while (m[0] < k || m[1] < k || m[2] < k) ++m[s[(e - l++)] - \\'a\\'];\\n            ans = min(ans, r + 1 + l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832300,
                "title": "solution-in-c-just-used-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Read it then see my solution](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/2947980/c-two-pointer-solution-o-n/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit\\'s just finding the largest middle string \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n    \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n\\n        \\n        if(mp[\\'a\\']<k or mp[\\'b\\']<k or mp[\\'c\\']<k)  return -1;\\n\\n        int ans=n;\\n        int j=0;\\n        int cnt=0;\\n        // just refer other solution\\'s intution.it\\'s just finding the largest middle string \\n        // just read the discussion and then come here and try again\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]--;\\n            while(mp[s[i]]<k){\\n                mp[s[j]]++; j++;}\\n            cnt=max(cnt,i-j+1);\\n        }\\n        return ans-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n    \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n\\n        \\n        if(mp[\\'a\\']<k or mp[\\'b\\']<k or mp[\\'c\\']<k)  return -1;\\n\\n        int ans=n;\\n        int j=0;\\n        int cnt=0;\\n        // just refer other solution\\'s intution.it\\'s just finding the largest middle string \\n        // just read the discussion and then come here and try again\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]--;\\n            while(mp[s[i]]<k){\\n                mp[s[j]]++; j++;}\\n            cnt=max(cnt,i-j+1);\\n        }\\n        return ans-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816623,
                "title": "java-sliding-window-simple-solution",
                "content": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] frq = new int[3];\\n        for (int p = 0; p < s.length(); p++) frq[s.charAt(p) - \\'a\\']++;\\n        if (frq[0] < k || frq[1] < k || frq[2] < k) return -1;\\n        int i = 0, j = 0, n = s.length(), a = frq[0] - k, b = frq[1] - k, c = frq[2] - k, len = 0;\\n        frq[0] = frq[1] = frq[2] = 0;\\n        while (j < n) {\\n            frq[s.charAt(j) - \\'a\\']++;\\n            while (i <= j && (frq[0] > a || frq[1] > b || frq[2] > c)) frq[s.charAt(i++) - \\'a\\']--;\\n            len = Math.max(len, j++ - i + 1);\\n        }\\n        return n - len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] frq = new int[3];\\n        for (int p = 0; p < s.length(); p++) frq[s.charAt(p) - \\'a\\']++;\\n        if (frq[0] < k || frq[1] < k || frq[2] < k) return -1;\\n        int i = 0, j = 0, n = s.length(), a = frq[0] - k, b = frq[1] - k, c = frq[2] - k, len = 0;\\n        frq[0] = frq[1] = frq[2] = 0;\\n        while (j < n) {\\n            frq[s.charAt(j) - \\'a\\']++;\\n            while (i <= j && (frq[0] > a || frq[1] > b || frq[2] > c)) frq[s.charAt(i++) - \\'a\\']--;\\n            len = Math.max(len, j++ - i + 1);\\n        }\\n        return n - len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799201,
                "title": "beats-100-two-pointer-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhat should be max time -- s.size();\\n\\n1. iterate i=0 -> n   count a ,b, c\\n2. take pointer i=n-1  &&   j=n-1\\n3. iterate i -> 0 decrement a,b,c\\n4. if(a<k || b<k || c<k) do  j--;\\n5. take ans=min(ans,i+n-j-1)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        int a=0,b=0,c=0;\\n\\n        for(auto i:s)\\n        {\\n            if(i==\\'a\\')a++;\\n            if(i==\\'b\\')b++;\\n            if(i==\\'c\\')c++;\\n        }\\n\\n        if(a<k || b<k || c<k)\\n        return -1;\\n\\n        int n=s.size(),i=n-1,j=n-1;\\n        int ans=n;\\n\\n        while(i>=0)\\n        {\\n            if(s[i]==\\'a\\')a--;\\n            if(s[i]==\\'b\\')b--;\\n            if(s[i]==\\'c\\')c--;\\n            while(a<k || b<k || c<k)\\n            {\\n                if(s[j]==\\'a\\')a++;\\n                if(s[j]==\\'b\\')b++;\\n                if(s[j]==\\'c\\')c++;\\n                j--;\\n            }\\n            ans=min(ans,i+n-j-1);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        int a=0,b=0,c=0;\\n\\n        for(auto i:s)\\n        {\\n            if(i==\\'a\\')a++;\\n            if(i==\\'b\\')b++;\\n            if(i==\\'c\\')c++;\\n        }\\n\\n        if(a<k || b<k || c<k)\\n        return -1;\\n\\n        int n=s.size(),i=n-1,j=n-1;\\n        int ans=n;\\n\\n        while(i>=0)\\n        {\\n            if(s[i]==\\'a\\')a--;\\n            if(s[i]==\\'b\\')b--;\\n            if(s[i]==\\'c\\')c--;\\n            while(a<k || b<k || c<k)\\n            {\\n                if(s[j]==\\'a\\')a++;\\n                if(s[j]==\\'b\\')b++;\\n                if(s[j]==\\'c\\')c++;\\n                j--;\\n            }\\n            ans=min(ans,i+n-j-1);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787636,
                "title": "easy-cpp-two-pointer-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n****First lets eliminate the -1 cases:\\nwe know that there is a way to collect the entire string (keep picking from left or right) so check if after collecting entire string we can satisfy the given conditions ie each letter has > k elements.****\\n\\n**Then we can kind of follow a two pointer approach with sliding window.**\\n\\n**Lets say im only allowed to pick from left whats the min time taken??**\\n**Thats easy to find with the below code**\\n\\n```\\nint n = s.size();\\nint ln1=0,ln2=0,ln3=0; //indicates no collected for each letter n1->a n2-> b n3->c\\nint left=0;\\nint ans=0;\\nwhile((ln1<k || ln2<k || ln3<k) && (left<n)){\\n    if(s[left]==\\'a\\') ln1++;\\n    else if(s[left]==\\'b\\')ln2++;\\n    else ln3++;\\n    left++;\\n}\\nif(ln1<k || ln2<k || ln3<k) return -1; //return -1 if not possible\\nans = left;\\n```\\n**Now we can start picking from the right and try to reduce the things which we have picked from left end by using the function this can be done by the following peice of code.**\\n\\n```\\nint rn1=0,rn2=0,rn3=0; //to keep track of right side pickings\\nint rdone=0; // to keep track of no of elements picked from right\\nwhile(right>=0){\\n    if(s[right]==\\'a\\')rn1++;\\n    else if(s[right]==\\'b\\') rn2++;\\n    else rn3++;\\n    rdone++;\\n    while(left>=0){ // try to reduce elements picked from left as much as possible\\n        if(s[left]==\\'a\\')ln1--;\\n        else if(s[left]==\\'b\\')ln2--;\\n        else ln3--;\\n        if(!candec(ln1,ln2,ln3,rn1,rn2,rn3,k)){\\n            if(s[left]==\\'a\\')ln1++;\\n            else if(s[left]==\\'b\\')ln2++;\\n            else ln3++;\\n            break;\\n        }\\n        else{\\n            left--;\\n        }\\n    }\\n    ans = min(ans,rdone+left+1); // take the minimum ans\\n    right--;\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool candec(int ln1,int ln2,int ln3,int rn1,int rn2,int rn3,int k){\\n        if((ln1+rn1) < k) return false;\\n        if((ln2+rn2) < k) return false;\\n        if((ln3+rn3) < k) return false;\\n        return true;\\n    }\\n\\n\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int ln1=0,ln2=0,ln3=0;\\n        int right=n-1;\\n        int left=0;\\n        int ans=0;\\n        while((ln1<k || ln2<k || ln3<k) && (left<n)){\\n            if(s[left]==\\'a\\') ln1++;\\n            else if(s[left]==\\'b\\')ln2++;\\n            else ln3++;\\n            left++;\\n        }\\n        if(ln1<k || ln2<k || ln3<k) return -1;\\n        ans = left;\\n        left--;\\n        int rn1=0,rn2=0,rn3=0;\\n        int rdone=0;\\n        while(right>=0){\\n            if(s[right]==\\'a\\')rn1++;\\n            else if(s[right]==\\'b\\') rn2++;\\n            else rn3++;\\n            rdone++;\\n            while(left>=0){\\n                if(s[left]==\\'a\\')ln1--;\\n                else if(s[left]==\\'b\\')ln2--;\\n                else ln3--;\\n                if(!candec(ln1,ln2,ln3,rn1,rn2,rn3,k)){\\n                    if(s[left]==\\'a\\')ln1++;\\n                    else if(s[left]==\\'b\\')ln2++;\\n                    else ln3++;\\n                    break;\\n                }\\n                else{\\n                    left--;\\n                }\\n            }\\n            ans = min(ans,rdone+left+1);\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint n = s.size();\\nint ln1=0,ln2=0,ln3=0; //indicates no collected for each letter n1->a n2-> b n3->c\\nint left=0;\\nint ans=0;\\nwhile((ln1<k || ln2<k || ln3<k) && (left<n)){\\n    if(s[left]==\\'a\\') ln1++;\\n    else if(s[left]==\\'b\\')ln2++;\\n    else ln3++;\\n    left++;\\n}\\nif(ln1<k || ln2<k || ln3<k) return -1; //return -1 if not possible\\nans = left;\\n```\n```\\nint rn1=0,rn2=0,rn3=0; //to keep track of right side pickings\\nint rdone=0; // to keep track of no of elements picked from right\\nwhile(right>=0){\\n    if(s[right]==\\'a\\')rn1++;\\n    else if(s[right]==\\'b\\') rn2++;\\n    else rn3++;\\n    rdone++;\\n    while(left>=0){ // try to reduce elements picked from left as much as possible\\n        if(s[left]==\\'a\\')ln1--;\\n        else if(s[left]==\\'b\\')ln2--;\\n        else ln3--;\\n        if(!candec(ln1,ln2,ln3,rn1,rn2,rn3,k)){\\n            if(s[left]==\\'a\\')ln1++;\\n            else if(s[left]==\\'b\\')ln2++;\\n            else ln3++;\\n            break;\\n        }\\n        else{\\n            left--;\\n        }\\n    }\\n    ans = min(ans,rdone+left+1); // take the minimum ans\\n    right--;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool candec(int ln1,int ln2,int ln3,int rn1,int rn2,int rn3,int k){\\n        if((ln1+rn1) < k) return false;\\n        if((ln2+rn2) < k) return false;\\n        if((ln3+rn3) < k) return false;\\n        return true;\\n    }\\n\\n\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int ln1=0,ln2=0,ln3=0;\\n        int right=n-1;\\n        int left=0;\\n        int ans=0;\\n        while((ln1<k || ln2<k || ln3<k) && (left<n)){\\n            if(s[left]==\\'a\\') ln1++;\\n            else if(s[left]==\\'b\\')ln2++;\\n            else ln3++;\\n            left++;\\n        }\\n        if(ln1<k || ln2<k || ln3<k) return -1;\\n        ans = left;\\n        left--;\\n        int rn1=0,rn2=0,rn3=0;\\n        int rdone=0;\\n        while(right>=0){\\n            if(s[right]==\\'a\\')rn1++;\\n            else if(s[right]==\\'b\\') rn2++;\\n            else rn3++;\\n            rdone++;\\n            while(left>=0){\\n                if(s[left]==\\'a\\')ln1--;\\n                else if(s[left]==\\'b\\')ln2--;\\n                else ln3--;\\n                if(!candec(ln1,ln2,ln3,rn1,rn2,rn3,k)){\\n                    if(s[left]==\\'a\\')ln1++;\\n                    else if(s[left]==\\'b\\')ln2++;\\n                    else ln3++;\\n                    break;\\n                }\\n                else{\\n                    left--;\\n                }\\n            }\\n            ans = min(ans,rdone+left+1);\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764013,
                "title": "easy-must-see-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mp;\\n        for(auto it:s)mp[it]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        int cnt_a=mp[\\'a\\']-k;\\n        int cnt_b=mp[\\'b\\']-k;\\n        int cnt_c=mp[\\'c\\']-k;\\n//The main concept here is to find the longest substring having atmost req_no of a,b,c\\n//then substract from total lenght to get req ans\\n        unordered_map<char,int> mpp;\\n        int j=0;\\n        int maxi=INT_MIN;\\n        int ans=-1;\\n        for(int i=0;i<n;++i){\\n            mpp[s[i]]++;\\n            // while(mpp[\\'a\\']>cnt_a || mpp[\\'b\\']>cnt_b || mpp[\\'c\\']>cnt_c && j<=i){ this will produce runtime error\\n             while((mpp[\\'a\\']>cnt_a || mpp[\\'b\\']>cnt_b || mpp[\\'c\\']>cnt_c) && j<=i){ //= will not hold in cnt\\n                mpp[s[j]]--;\\n                j++;\\n            }\\n            maxi=max(maxi,i-j+1);\\n            if(maxi!=INT_MIN)ans=n-maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mp;\\n        for(auto it:s)mp[it]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        int cnt_a=mp[\\'a\\']-k;\\n        int cnt_b=mp[\\'b\\']-k;\\n        int cnt_c=mp[\\'c\\']-k;\\n//The main concept here is to find the longest substring having atmost req_no of a,b,c\\n//then substract from total lenght to get req ans\\n        unordered_map<char,int> mpp;\\n        int j=0;\\n        int maxi=INT_MIN;\\n        int ans=-1;\\n        for(int i=0;i<n;++i){\\n            mpp[s[i]]++;\\n            // while(mpp[\\'a\\']>cnt_a || mpp[\\'b\\']>cnt_b || mpp[\\'c\\']>cnt_c && j<=i){ this will produce runtime error\\n             while((mpp[\\'a\\']>cnt_a || mpp[\\'b\\']>cnt_b || mpp[\\'c\\']>cnt_c) && j<=i){ //= will not hold in cnt\\n                mpp[s[j]]--;\\n                j++;\\n            }\\n            maxi=max(maxi,i-j+1);\\n            if(maxi!=INT_MIN)ans=n-maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761036,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n       int[] arr = new int[3];\\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        arr[0]-=k;\\n        arr[1]-=k;\\n        arr[2]-=k;\\n\\n        if(arr[0]<0||arr[1]<0||arr[2]<0) return -1;\\n\\n        int n = s.length();\\n        int i=0;\\n        int ans=0;\\n        for(int j=0;j<n;j++){\\n            char ch = s.charAt(j);\\n            arr[ch-\\'a\\']--;\\n            if(arr[0]<0||arr[1]<0||arr[2]<0){\\n                while(arr[0]<0||arr[1]<0||arr[2]<0){\\n                    arr[s.charAt(i)-\\'a\\']++;\\n                    i++;\\n                }\\n            }\\n            ans = Math.max(ans,j-i+1);\\n        }\\n        return n-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n       int[] arr = new int[3];\\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        arr[0]-=k;\\n        arr[1]-=k;\\n        arr[2]-=k;\\n\\n        if(arr[0]<0||arr[1]<0||arr[2]<0) return -1;\\n\\n        int n = s.length();\\n        int i=0;\\n        int ans=0;\\n        for(int j=0;j<n;j++){\\n            char ch = s.charAt(j);\\n            arr[ch-\\'a\\']--;\\n            if(arr[0]<0||arr[1]<0||arr[2]<0){\\n                while(arr[0]<0||arr[1]<0||arr[2]<0){\\n                    arr[s.charAt(i)-\\'a\\']++;\\n                    i++;\\n                }\\n            }\\n            ans = Math.max(ans,j-i+1);\\n        }\\n        return n-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749084,
                "title": "easy-to-understand-c-sliding-window",
                "content": "# Intuition\\nREAD THE CODE AND YOU WILL UNDERSTAND :)\\n\\nUPVOTE!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust try to find out maximum length of substring which can be eliminated so that freq of each character will be atleat k amd then substract the lenght of that substring from total length of string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int> & v, int k)\\n{\\n    for(int i = 0; i<v.size(); i++)\\n    {\\n        if(v[i] <k) return false;\\n        \\n    }\\n    return true;\\n}\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3,0);\\n        int n = s.size();\\n        for(int i = 0; i<n ; i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n        }\\n        if(check(v, k) == false) return -1;\\n        int i = 0, j = 0, ans = 0;\\n        while(j <n)\\n        {\\n            v[s[j]-\\'a\\']--;\\n            if(check(v,k) == true)\\n            {\\n                ans = max(ans, j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(v[s[j]-\\'a\\'] <k)\\n                {\\n                    v[s[i]-\\'a\\']++;\\n                    i++;\\n                }\\n                // i++;\\n                j++;\\n            }\\n        }\\n        int res = n-ans;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int> & v, int k)\\n{\\n    for(int i = 0; i<v.size(); i++)\\n    {\\n        if(v[i] <k) return false;\\n        \\n    }\\n    return true;\\n}\\n    int takeCharacters(string s, int k) {\\n        vector<int> v(3,0);\\n        int n = s.size();\\n        for(int i = 0; i<n ; i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n        }\\n        if(check(v, k) == false) return -1;\\n        int i = 0, j = 0, ans = 0;\\n        while(j <n)\\n        {\\n            v[s[j]-\\'a\\']--;\\n            if(check(v,k) == true)\\n            {\\n                ans = max(ans, j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(v[s[j]-\\'a\\'] <k)\\n                {\\n                    v[s[i]-\\'a\\']++;\\n                    i++;\\n                }\\n                // i++;\\n                j++;\\n            }\\n        }\\n        int res = n-ans;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742826,
                "title": "java-2-pivots",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if (k == 0) return k;\\n        if (s.length() < 3) return -1;\\n        int leftPivot = 0;\\n        int rightPivot = s.length() - 1;\\n        int[] letterCounter = new int[3];\\n        int minOperations;\\n        do {\\n            letterCounter[s.charAt(leftPivot) - \\'a\\']++;\\n        }\\n        while (!areAllCountersFull(letterCounter, k) && ++leftPivot < s.length());\\n\\n        if (areAllCountersFull(letterCounter, k)) {\\n            minOperations = sumArray(letterCounter);\\n        } else return -1;\\n\\n        do {\\n\\n            letterCounter[s.charAt(rightPivot--) - \\'a\\']++;\\n            letterCounter[s.charAt(leftPivot--) - \\'a\\']--;\\n\\n            if (areAllCountersFull(letterCounter, k)) minOperations = Math.min(sumArray(letterCounter), minOperations);\\n\\n            while (leftPivot >= 0 && areAllCountersFull(letterCounter, k)) {\\n                minOperations = Math.min(sumArray(letterCounter), minOperations);\\n                letterCounter[s.charAt(leftPivot--) - \\'a\\']--;\\n            }\\n\\n            if (areAllCountersFull(letterCounter, k)) minOperations = Math.min(sumArray(letterCounter), minOperations);\\n\\n        } while (leftPivot >= 0);\\n\\n        return minOperations;\\n    }\\n\\n    private boolean areAllCountersFull(int[] letterCounter, int k) {\\n        for (int i = 0; i < 3; i++) {\\n            if (letterCounter[i] < k) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int sumArray(int[] arr) {\\n        int sum = 0;\\n        for (int j : arr) {\\n            sum += j;\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if (k == 0) return k;\\n        if (s.length() < 3) return -1;\\n        int leftPivot = 0;\\n        int rightPivot = s.length() - 1;\\n        int[] letterCounter = new int[3];\\n        int minOperations;\\n        do {\\n            letterCounter[s.charAt(leftPivot) - \\'a\\']++;\\n        }\\n        while (!areAllCountersFull(letterCounter, k) && ++leftPivot < s.length());\\n\\n        if (areAllCountersFull(letterCounter, k)) {\\n            minOperations = sumArray(letterCounter);\\n        } else return -1;\\n\\n        do {\\n\\n            letterCounter[s.charAt(rightPivot--) - \\'a\\']++;\\n            letterCounter[s.charAt(leftPivot--) - \\'a\\']--;\\n\\n            if (areAllCountersFull(letterCounter, k)) minOperations = Math.min(sumArray(letterCounter), minOperations);\\n\\n            while (leftPivot >= 0 && areAllCountersFull(letterCounter, k)) {\\n                minOperations = Math.min(sumArray(letterCounter), minOperations);\\n                letterCounter[s.charAt(leftPivot--) - \\'a\\']--;\\n            }\\n\\n            if (areAllCountersFull(letterCounter, k)) minOperations = Math.min(sumArray(letterCounter), minOperations);\\n\\n        } while (leftPivot >= 0);\\n\\n        return minOperations;\\n    }\\n\\n    private boolean areAllCountersFull(int[] letterCounter, int k) {\\n        for (int i = 0; i < 3; i++) {\\n            if (letterCounter[i] < k) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int sumArray(int[] arr) {\\n        int sum = 0;\\n        for (int j : arr) {\\n            sum += j;\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723842,
                "title": "melody-khao-khud-jaan-jao-simple-c-solution-using-sliding-window",
                "content": "# Intuition\\nMelody Khao Khud Jaan jao\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool good(map<char,int>&mp ,int k){\\n        if(mp.size()<3) return false;\\n        for(auto it:mp){\\n            if(it.second<k) return false;\\n        }\\n        return true;\\n    }\\n    int takeCharacters(string s, int k) {\\n        map<char,int> mp;\\n        if(k==0) return 0;\\n        int n = s.size();\\n        for(int i=0 ; i<n ; i++) mp[s[i]]++;\\n\\n        if(mp.size()<3) return -1;\\n\\n        for(auto it:mp){\\n            if(it.second<k) return -1;\\n        }\\n\\n        \\n\\n        s = s + s;\\n        \\n        int i = 0 , j = 0;\\n\\n        mp.clear();\\n\\n        int minn = INT_MAX;\\n\\n        while(j<2*n){\\n            if(!good(mp , k)){\\n                mp[s[j]]++;\\n            }\\n            while(i<j and good(mp ,k)){\\n                if(i==0 or (i<n and j>=n-1))minn = min(minn , j-i+1);\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        mp.clear();\\n\\n        for(int i=0 ; i<n; i++){\\n            mp[s[i]]++;\\n            if(good(mp , k))minn = min(minn , i+1);\\n        }\\n\\n        mp.clear();\\n        \\n        for(int i=n-1 ; i>=0 ;  i--){\\n            mp[s[i]]++;\\n            if(good(mp , k))minn = min(minn , n-i);\\n        }\\n        return minn;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(map<char,int>&mp ,int k){\\n        if(mp.size()<3) return false;\\n        for(auto it:mp){\\n            if(it.second<k) return false;\\n        }\\n        return true;\\n    }\\n    int takeCharacters(string s, int k) {\\n        map<char,int> mp;\\n        if(k==0) return 0;\\n        int n = s.size();\\n        for(int i=0 ; i<n ; i++) mp[s[i]]++;\\n\\n        if(mp.size()<3) return -1;\\n\\n        for(auto it:mp){\\n            if(it.second<k) return -1;\\n        }\\n\\n        \\n\\n        s = s + s;\\n        \\n        int i = 0 , j = 0;\\n\\n        mp.clear();\\n\\n        int minn = INT_MAX;\\n\\n        while(j<2*n){\\n            if(!good(mp , k)){\\n                mp[s[j]]++;\\n            }\\n            while(i<j and good(mp ,k)){\\n                if(i==0 or (i<n and j>=n-1))minn = min(minn , j-i+1);\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        mp.clear();\\n\\n        for(int i=0 ; i<n; i++){\\n            mp[s[i]]++;\\n            if(good(mp , k))minn = min(minn , i+1);\\n        }\\n\\n        mp.clear();\\n        \\n        for(int i=n-1 ; i>=0 ;  i--){\\n            mp[s[i]]++;\\n            if(good(mp , k))minn = min(minn , n-i);\\n        }\\n        return minn;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693065,
                "title": "collapsing-sliding-window-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*First find the sub-string from index 0 which contains a,b,c at least K times. Then from left till right (initially end of string) form a sliding window.*\\n***Here sliding window contains the characters that we can ignore and have a,b,c at least K times combining the characters on left and right of sliding window.***\\n*Now move the sliding window one step to left, which may cause one of the a,b,c to become less than K. Then reduce the sliding window size from right-to-left, which exculdes the characters from the window. Check if there are at least K a,b,c outside the sliding window, and stop reducing the size. Check if the length of parts on left and right together is smaller than previous length found.\\nRepeat the process till right pointer becomes lesser than left pointer.*\\n\\n![Screenshot 2023-06-28 180916.png](https://assets.leetcode.com/users/images/6e4fb9b5-9279-4111-baa8-e0a3f73f4b64_1687955969.295218.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int n = s.Length;\\n        //string length should be at least 3*K, beacuse K-a\\'s, K-b\\'s and K-c\\'s\\n        if (n < 3*k)\\n            return -1;\\n\\n        //find first index from left, where you have K of a\\'s, b\\'s and c\\'s\\n        int left = 0;\\n        int right = n - 1;\\n        int ac = 0;\\n        int bc = 0;\\n        int cc = 0;\\n        for (left = 0; left <= right; left++)\\n        {\\n            switch (s[left])\\n            {\\n                case \\'a\\': ac++;\\n                    break;\\n                case \\'b\\': bc++;\\n                    break;\\n                case \\'c\\': cc++;\\n                    break;\\n            }\\n            \\n            if (ac >= k && bc >= k && cc >= k)\\n                break;\\n        }\\n\\n        //if there are no K a\\'s or b\\'s or c\\'s, return -1;\\n        if (ac < k || bc < k || cc < k)\\n            return -1;\\n\\n        int result = left + 1;  //length of current sub-string\\n        while (left >= 0)\\n        {\\n            switch (s[left])\\n            {\\n                case \\'a\\': ac--;\\n                    break;\\n                case \\'b\\': bc--;\\n                    break;\\n                case \\'c\\': cc--;\\n                    break;\\n            }\\n            left--;\\n\\n            //move sliding window to left, while reducing it\\'s size from right side.\\n            //now that we removed one char from left...\\n            //decrement right pointer till we have a >= k, b >= k and c >= k\\n            while (right >= left && (ac < k || bc < k || cc < k))\\n            {\\n                switch (s[right])\\n                {\\n                    case \\'a\\': ac++;\\n                        break;\\n                    case \\'b\\': bc++;\\n                        break;\\n                    case \\'c\\': cc++;\\n                        break;\\n                }\\n                right--;\\n            }\\n\\n            result = Math.Min(result, left + n - right);\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach\\n![Upvote please - Cat.jpg](https://assets.leetcode.com/users/images/a2f6a5e5-c1a2-4858-b5bb-2382cb50a454_1687956793.5936768.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int n = s.Length;\\n        //string length should be at least 3*K, beacuse K-a\\'s, K-b\\'s and K-c\\'s\\n        if (n < 3*k)\\n            return -1;\\n\\n        //find first index from left, where you have K of a\\'s, b\\'s and c\\'s\\n        int left = 0;\\n        int right = n - 1;\\n        int ac = 0;\\n        int bc = 0;\\n        int cc = 0;\\n        for (left = 0; left <= right; left++)\\n        {\\n            switch (s[left])\\n            {\\n                case \\'a\\': ac++;\\n                    break;\\n                case \\'b\\': bc++;\\n                    break;\\n                case \\'c\\': cc++;\\n                    break;\\n            }\\n            \\n            if (ac >= k && bc >= k && cc >= k)\\n                break;\\n        }\\n\\n        //if there are no K a\\'s or b\\'s or c\\'s, return -1;\\n        if (ac < k || bc < k || cc < k)\\n            return -1;\\n\\n        int result = left + 1;  //length of current sub-string\\n        while (left >= 0)\\n        {\\n            switch (s[left])\\n            {\\n                case \\'a\\': ac--;\\n                    break;\\n                case \\'b\\': bc--;\\n                    break;\\n                case \\'c\\': cc--;\\n                    break;\\n            }\\n            left--;\\n\\n            //move sliding window to left, while reducing it\\'s size from right side.\\n            //now that we removed one char from left...\\n            //decrement right pointer till we have a >= k, b >= k and c >= k\\n            while (right >= left && (ac < k || bc < k || cc < k))\\n            {\\n                switch (s[right])\\n                {\\n                    case \\'a\\': ac++;\\n                        break;\\n                    case \\'b\\': bc++;\\n                        break;\\n                    case \\'c\\': cc++;\\n                        break;\\n                }\\n                right--;\\n            }\\n\\n            result = Math.Min(result, left + n - right);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632978,
                "title": "two-pointers-unordered-map-to-count-doing-string-string-to-search-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.length();\\n        if(k==0) return 0;\\n        if(n<=2) return -1;\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<n;i++) mpp[s[i]]++;\\n        if(mpp[\\'a\\']<k || mpp[\\'b\\']<k || mpp[\\'c\\']<k) return -1;\\n        s+=s;\\n        int i=0,j=n-1; int cnt=INT_MAX;\\n        while(j>=i && j<s.length() && i<s.length()){\\n            if(mpp[\\'a\\']<k || mpp[\\'b\\']<k || mpp[\\'c\\']<k){\\n                j++;\\n                mpp[s[j]]++;\\n            }else{\\n                if(!(i>n && j<s.length()-1)) cnt=min(cnt,j-i+1);\\n                mpp[s[i]]--;\\n                i++;\\n            }\\n        }\\n        return cnt==INT_MAX? -1 : cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.length();\\n        if(k==0) return 0;\\n        if(n<=2) return -1;\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<n;i++) mpp[s[i]]++;\\n        if(mpp[\\'a\\']<k || mpp[\\'b\\']<k || mpp[\\'c\\']<k) return -1;\\n        s+=s;\\n        int i=0,j=n-1; int cnt=INT_MAX;\\n        while(j>=i && j<s.length() && i<s.length()){\\n            if(mpp[\\'a\\']<k || mpp[\\'b\\']<k || mpp[\\'c\\']<k){\\n                j++;\\n                mpp[s[j]]++;\\n            }else{\\n                if(!(i>n && j<s.length()-1)) cnt=min(cnt,j-i+1);\\n                mpp[s[i]]--;\\n                i++;\\n            }\\n        }\\n        return cnt==INT_MAX? -1 : cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591977,
                "title": "python3-solution-sliding-window",
                "content": "# Intuition\\n\\nCount of Elements inside the window affects the count of  Elements out side the window, so keep putting elements inside the window until any one of the outside element count reaches k, \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        hm = dict()\\n\\n        for ch in s:\\n            hm[ch] = hm.get(ch,0) + 1\\n\\n        if k == 0:\\n            return 0\\n            \\n        if len(hm.values()) < 3 or hm[\\'a\\'] < k or hm[\\'b\\'] < k or hm[\\'c\\'] < k:\\n            return -1\\n\\n        mx = 0\\n        l = 0\\n\\n        for r in range(len(s)):\\n            hm[s[r]] -= 1\\n            while l <= r and hm[s[r]] < k:\\n                hm[s[l]] += 1\\n                l += 1\\n\\n            mx = max(mx, r-l+1)\\n\\n        return len(s) - mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        hm = dict()\\n\\n        for ch in s:\\n            hm[ch] = hm.get(ch,0) + 1\\n\\n        if k == 0:\\n            return 0\\n            \\n        if len(hm.values()) < 3 or hm[\\'a\\'] < k or hm[\\'b\\'] < k or hm[\\'c\\'] < k:\\n            return -1\\n\\n        mx = 0\\n        l = 0\\n\\n        for r in range(len(s)):\\n            hm[s[r]] -= 1\\n            while l <= r and hm[s[r]] < k:\\n                hm[s[l]] += 1\\n                l += 1\\n\\n            mx = max(mx, r-l+1)\\n\\n        return len(s) - mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588495,
                "title": "python-sliding-window-with-no-more-than-a-b-c-chars",
                "content": "`DP` and etc won\\'t work because with at least `i` and `j` you will have `n^2` -> no-go. I am not talking about extra counters for `a`, `b`, and `c`, which is going to be another `* n^3`\\n\\nSliding window looks okayish until you realize that either you need to do some mumbo-jumbo with 3 loops where you look for an answer in left-to-right pass, right-to-left pass and somehow a wrapping pass/maybe 2 with bounded left or right side.\\n\\nThis one is really tricky.\\n\\nSo the idea is to find max `inverted` window of what we are asked.\\nFor example:\\n```\\naab aaaa caabc, k=2\\n8a 2b 2c\\n```\\nSo we need to find max window size that satisfies the following constraints:\\n- has no more than:\\n8a-2 = `6 a`\\n2b-2 = `0 b`\\n2c-2 = `0 c`\\n\\nIf the window violates the constraint, we shrink it from the left until it becomes `valid` again.\\nCalc new max_window_size.\\n\\nReturn `N - max_window_size`\\n\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        a = b = c = 0\\n        left = 0\\n        max_len = -1\\n        freq = Counter(s)\\n        freq[\\'a\\'] -= k\\n        freq[\\'b\\'] -= k\\n        freq[\\'c\\'] -= k\\n        if freq[\\'a\\'] < 0 or freq[\\'b\\'] < 0 or freq[\\'c\\'] < 0:\\n            return -1\\n        \\n        for right in range(N):\\n            a += s[right] == \\'a\\'\\n            b += s[right] == \\'b\\'\\n            c += s[right] == \\'c\\'\\n            \\n            while a > freq[\\'a\\'] or b > freq[\\'b\\'] or c > freq[\\'c\\']:\\n                a -= s[left] == \\'a\\'\\n                b -= s[left] == \\'b\\'\\n                c -= s[left] == \\'c\\'\\n                left += 1\\n\\n            max_len = max(max_len, right - left + 1)\\n\\n        return N - max_len\\n```\\nOR\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        chars_limit = defaultdict(lambda: -k)\\n        for c in s: chars_limit[c] += 1\\n        if chars_limit[\\'a\\'] < 0 or chars_limit[\\'b\\'] < 0 or chars_limit[\\'c\\'] < 0:\\n            return -1\\n\\n        abc = defaultdict(int)\\n        left = 0\\n        max_len = 0\\n        for right,ch in enumerate(s):\\n            abc[ch] += 1\\n            while abc[ch] > chars_limit[ch]:\\n                abc[s[left]] -= 1\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n        return N - max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\naab aaaa caabc, k=2\\n8a 2b 2c\\n```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        a = b = c = 0\\n        left = 0\\n        max_len = -1\\n        freq = Counter(s)\\n        freq[\\'a\\'] -= k\\n        freq[\\'b\\'] -= k\\n        freq[\\'c\\'] -= k\\n        if freq[\\'a\\'] < 0 or freq[\\'b\\'] < 0 or freq[\\'c\\'] < 0:\\n            return -1\\n        \\n        for right in range(N):\\n            a += s[right] == \\'a\\'\\n            b += s[right] == \\'b\\'\\n            c += s[right] == \\'c\\'\\n            \\n            while a > freq[\\'a\\'] or b > freq[\\'b\\'] or c > freq[\\'c\\']:\\n                a -= s[left] == \\'a\\'\\n                b -= s[left] == \\'b\\'\\n                c -= s[left] == \\'c\\'\\n                left += 1\\n\\n            max_len = max(max_len, right - left + 1)\\n\\n        return N - max_len\\n```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        N = len(s)\\n        chars_limit = defaultdict(lambda: -k)\\n        for c in s: chars_limit[c] += 1\\n        if chars_limit[\\'a\\'] < 0 or chars_limit[\\'b\\'] < 0 or chars_limit[\\'c\\'] < 0:\\n            return -1\\n\\n        abc = defaultdict(int)\\n        left = 0\\n        max_len = 0\\n        for right,ch in enumerate(s):\\n            abc[ch] += 1\\n            while abc[ch] > chars_limit[ch]:\\n                abc[s[left]] -= 1\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n        return N - max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565565,
                "title": "java-easy-sliding-window-runtime-28-ms-beats-31-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        if(k == 0) return 0;\\n\\n        int N = s.length();\\n        s = s.concat(s);\\n\\n        int[] arr = new int[]{0,0,0};\\n\\n        int i = 0, n = s.length(), min = 1000000, last = 0;\\n\\n        while(i < n){\\n\\n            char c = s.charAt(i);\\n\\n            arr[c - \\'a\\']++;\\n            int cnt = 0;\\n            while(arr[0] >= k && arr[1] >= k && arr[2] >= k){\\n                cnt++;\\n                if((i >= N - 1 && last <= N) || last == 0) {\\n                    if(i - last + 1 <= N)\\n                    min = Math.min(min,arr[0] + arr[1] + arr[2]);\\n                }                \\n                arr[s.charAt(last++) - \\'a\\']--;\\n            }\\n            if(cnt > 0){\\n                last--;\\n                arr[s.charAt(last) - \\'a\\']++;\\n            }\\n            i++;\\n        }\\n\\n        if(min == 1000000) return -1;\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        if(k == 0) return 0;\\n\\n        int N = s.length();\\n        s = s.concat(s);\\n\\n        int[] arr = new int[]{0,0,0};\\n\\n        int i = 0, n = s.length(), min = 1000000, last = 0;\\n\\n        while(i < n){\\n\\n            char c = s.charAt(i);\\n\\n            arr[c - \\'a\\']++;\\n            int cnt = 0;\\n            while(arr[0] >= k && arr[1] >= k && arr[2] >= k){\\n                cnt++;\\n                if((i >= N - 1 && last <= N) || last == 0) {\\n                    if(i - last + 1 <= N)\\n                    min = Math.min(min,arr[0] + arr[1] + arr[2]);\\n                }                \\n                arr[s.charAt(last++) - \\'a\\']--;\\n            }\\n            if(cnt > 0){\\n                last--;\\n                arr[s.charAt(last) - \\'a\\']++;\\n            }\\n            i++;\\n        }\\n\\n        if(min == 1000000) return -1;\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456318,
                "title": "take-k-of-each-character-from-left-and-right",
                "content": "---------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int a=0;\\n        int b=0;\\n        int c=0;\\n        int pa=0;\\n        int pb=0;\\n        int pc=0;\\n        int ans=0;\\n        int result=0;\\n        int j=0;\\n        int i=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\') a++;\\n            if(s[i]==\\'b\\') b++;\\n            if(s[i]==\\'c\\') c++;\\n        }\\n        pa=a-k;\\n        pb=b-k;\\n        pc=c-k;\\n        a=0;\\n        b=0;\\n        c=0;\\n        if(pa<0 ||pb<0 ||pc<0) return -1;\\n        while(j<n){\\n            if(s[j]==\\'a\\'){\\n                a++;\\n\\n            }else if(s[j]==\\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n            while(pa<a){\\n                if(s[i]!=\\'a\\'){\\n                  if(s[i]==\\'b\\'){\\n                    b--;\\n                  }else if(s[i]==\\'c\\'){\\n                    c--;\\n                  }\\n                  i++;\\n                }else{\\n                  a--;\\n                  i++;\\n                }\\n            }\\n            while(pb<b){\\n                if(s[i]!=\\'b\\'){\\n                  if(s[i]==\\'a\\'){\\n                    a--;\\n                  }else if(s[i]==\\'c\\'){\\n                    c--;\\n                  }\\n                  i++;\\n                }else{\\n                  b--;\\n                  i++;\\n                }\\n                \\n            }\\n             while(pc<c){\\n                if(s[i]!=\\'c\\'){\\n                  if(s[i]==\\'a\\'){\\n                    a--;\\n                  }else if(s[i]==\\'b\\'){\\n                    b--;\\n                  }\\n                  i++;\\n                }else{\\n                  c--;\\n                  i++;\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return s.size()-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int a=0;\\n        int b=0;\\n        int c=0;\\n        int pa=0;\\n        int pb=0;\\n        int pc=0;\\n        int ans=0;\\n        int result=0;\\n        int j=0;\\n        int i=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\') a++;\\n            if(s[i]==\\'b\\') b++;\\n            if(s[i]==\\'c\\') c++;\\n        }\\n        pa=a-k;\\n        pb=b-k;\\n        pc=c-k;\\n        a=0;\\n        b=0;\\n        c=0;\\n        if(pa<0 ||pb<0 ||pc<0) return -1;\\n        while(j<n){\\n            if(s[j]==\\'a\\'){\\n                a++;\\n\\n            }else if(s[j]==\\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n            while(pa<a){\\n                if(s[i]!=\\'a\\'){\\n                  if(s[i]==\\'b\\'){\\n                    b--;\\n                  }else if(s[i]==\\'c\\'){\\n                    c--;\\n                  }\\n                  i++;\\n                }else{\\n                  a--;\\n                  i++;\\n                }\\n            }\\n            while(pb<b){\\n                if(s[i]!=\\'b\\'){\\n                  if(s[i]==\\'a\\'){\\n                    a--;\\n                  }else if(s[i]==\\'c\\'){\\n                    c--;\\n                  }\\n                  i++;\\n                }else{\\n                  b--;\\n                  i++;\\n                }\\n                \\n            }\\n             while(pc<c){\\n                if(s[i]!=\\'c\\'){\\n                  if(s[i]==\\'a\\'){\\n                    a--;\\n                  }else if(s[i]==\\'b\\'){\\n                    b--;\\n                  }\\n                  i++;\\n                }else{\\n                  c--;\\n                  i++;\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return s.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428630,
                "title": "two-pointers",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/6d6d7021-1d68-4a0f-8136-61e3df743fca_1681855067.3842647.png)\\n\\n```\\nint takeCharacters(const string s, int k) \\n{\\n\\tint t[256]{};\\n\\tfor(const auto & c : s) ++t[c];\\t\\n\\tif(min({t[\\'a\\'],t[\\'b\\'],t[\\'c\\']})<k) return -1;\\n\\tint out(INT_MAX);\\n\\tfor(int i{}, j{}, sz(size(s)); i<=sz; )\\n\\t\\tmin({t[\\'a\\'],t[\\'b\\'],t[\\'c\\']})<k ? ++t[s[j++]] : out=min(out,j-i+sz), --t[s[i++]];\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint takeCharacters(const string s, int k) \\n{\\n\\tint t[256]{};\\n\\tfor(const auto & c : s) ++t[c];\\t\\n\\tif(min({t[\\'a\\'],t[\\'b\\'],t[\\'c\\']})<k) return -1;\\n\\tint out(INT_MAX);\\n\\tfor(int i{}, j{}, sz(size(s)); i<=sz; )\\n\\t\\tmin({t[\\'a\\'],t[\\'b\\'],t[\\'c\\']})<k ? ++t[s[j++]] : out=min(out,j-i+sz), --t[s[i++]];\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405810,
                "title": "javascript-sliding-window",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar takeCharacters = function(s, k) {\\n  const count = [0, 0, 0]; \\n  const a = \\'a\\'.charCodeAt();\\n  const n = s.length;\\n  let [l, r, window] = [0, 0, 0];\\n  \\n  for (let ch of s) count[ch.charCodeAt() - a]++;\\n\\n  if (count.some((num) => num < k)) return -1;\\n\\n  while (r < n) {\\n    const index = s.charCodeAt(r) - a;\\n    count[index]--;\\n    \\n\\twhile (count[index] < k) count[s.charCodeAt(l++) - a]++;\\n\\n    window = Math.max(window, r - l + 1);\\n    r++;\\n  }\\n\\n  return n - window;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar takeCharacters = function(s, k) {\\n  const count = [0, 0, 0]; \\n  const a = \\'a\\'.charCodeAt();\\n  const n = s.length;\\n  let [l, r, window] = [0, 0, 0];\\n  \\n  for (let ch of s) count[ch.charCodeAt() - a]++;\\n\\n  if (count.some((num) => num < k)) return -1;\\n\\n  while (r < n) {\\n    const index = s.charCodeAt(r) - a;\\n    count[index]--;\\n    \\n\\twhile (count[index] < k) count[s.charCodeAt(l++) - a]++;\\n\\n    window = Math.max(window, r - l + 1);\\n    r++;\\n  }\\n\\n  return n - window;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405106,
                "title": "sliding-window-solution",
                "content": "\\n\\n    int takeCharacters(string s, int k) {\\n        // I need to get maximum window which characters freq outside of the window is >= k\\n        unordered_map<char , int> m {{\\'a\\' , 0} , {\\'b\\' , 0} , {\\'c\\' , 0}};\\n        for(auto&c : s ) m[c]++;\\n        int r = 0 , l = 0 , sze = s.size() , mx = 0 ;  \\n        if(m[\\'a\\'] < k || m[\\'b\\'] < k  || m[\\'c\\'] < k) return -1 ;\\n        while(r < sze){\\n            m[s[r]]--;\\n            while(  m[s[r]] < k ) m[s[l++]]++;    \\n            mx = max(mx , r - l+1);\\n            r++;\\n        }\\n        return sze - mx ;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    int takeCharacters(string s, int k) {\\n        // I need to get maximum window which characters freq outside of the window is >= k\\n        unordered_map<char , int> m {{\\'a\\' , 0} , {\\'b\\' , 0} , {\\'c\\' , 0}};\\n        for(auto&c : s ) m[c]++;\\n        int r = 0 , l = 0 , sze = s.size() , mx = 0 ;  \\n        if(m[\\'a\\'] < k || m[\\'b\\'] < k  || m[\\'c\\'] < k) return -1 ;\\n        while(r < sze){\\n            m[s[r]]--;\\n            while(  m[s[r]] < k ) m[s[l++]]++;    \\n            mx = max(mx , r - l+1);\\n            r++;\\n        }\\n        return sze - mx ;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399442,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<int, int> mpa;\\n        unordered_map<int, int> mpb;\\n        unordered_map<int, int> mpc;\\n        if(k == 0) return 0;\\n        int acount = 0;\\n        int bcount = 0;\\n        int ccount = 0;\\n        mpa[acount] = 0;\\n        mpb[bcount] = 0;\\n        mpc[ccount] = 0;\\n        int best = s.size()+1;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'a\\') acount++;\\n            else if(s[i] == \\'b\\') bcount++;\\n            else if(s[i] == \\'c\\') ccount++;\\n\\n            if(mpa.count(acount) == 0) mpa[acount] = i+1;\\n            if(mpb.count(bcount) == 0) mpb[bcount] = i+1;\\n            if(mpc.count(ccount) == 0) mpc[ccount] = i+1;\\n\\n            if(acount >= k && bcount >= k && ccount >= k) best = min(best, i+1);\\n        }\\n        \\n        acount = 0;\\n        bcount = 0;\\n        ccount = 0;\\n        for(int i = 1; s.size()-i > 0; i++){\\n\\n            if(s[s.size()-i] == \\'a\\') acount++;\\n            else if(s[s.size()-i] == \\'b\\') bcount++;\\n            else if(s[s.size()-i] == \\'c\\') ccount++;\\n            if(acount >= k && bcount >= k && ccount >= k) return min(best, i);\\n            int diffa = max(0, k - acount);\\n            int diffb = max(0, k - bcount);\\n            int diffc = max(0, k - ccount);\\n            if(!mpa.count(diffa) || !mpb.count(diffb) || !mpc.count(diffc)) break;\\n            int req = max(mpa[diffa], mpb[diffb]);\\n            req = max(req, mpc[diffc]);\\n            best = min(best, i + req);\\n        }\\n\\n        if(best == s.size()+1) return -1;\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<int, int> mpa;\\n        unordered_map<int, int> mpb;\\n        unordered_map<int, int> mpc;\\n        if(k == 0) return 0;\\n        int acount = 0;\\n        int bcount = 0;\\n        int ccount = 0;\\n        mpa[acount] = 0;\\n        mpb[bcount] = 0;\\n        mpc[ccount] = 0;\\n        int best = s.size()+1;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'a\\') acount++;\\n            else if(s[i] == \\'b\\') bcount++;\\n            else if(s[i] == \\'c\\') ccount++;\\n\\n            if(mpa.count(acount) == 0) mpa[acount] = i+1;\\n            if(mpb.count(bcount) == 0) mpb[bcount] = i+1;\\n            if(mpc.count(ccount) == 0) mpc[ccount] = i+1;\\n\\n            if(acount >= k && bcount >= k && ccount >= k) best = min(best, i+1);\\n        }\\n        \\n        acount = 0;\\n        bcount = 0;\\n        ccount = 0;\\n        for(int i = 1; s.size()-i > 0; i++){\\n\\n            if(s[s.size()-i] == \\'a\\') acount++;\\n            else if(s[s.size()-i] == \\'b\\') bcount++;\\n            else if(s[s.size()-i] == \\'c\\') ccount++;\\n            if(acount >= k && bcount >= k && ccount >= k) return min(best, i);\\n            int diffa = max(0, k - acount);\\n            int diffb = max(0, k - bcount);\\n            int diffc = max(0, k - ccount);\\n            if(!mpa.count(diffa) || !mpb.count(diffb) || !mpc.count(diffc)) break;\\n            int req = max(mpa[diffa], mpb[diffb]);\\n            req = max(req, mpc[diffc]);\\n            best = min(best, i + req);\\n        }\\n\\n        if(best == s.size()+1) return -1;\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398236,
                "title": "java-sliding-window-time-o-n-space-o-1",
                "content": "# Approach\\nsliding window\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int left=0,len=s.length(),res=0,freqA=0,freqB=0,freqC=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==\\'a\\')freqA++;\\n            else if(s.charAt(i)==\\'b\\')freqB++;\\n            else if(s.charAt(i)==\\'c\\')freqC++;\\n        }\\n\\n        if(freqA<k || freqB<k || freqC<k)return -1;\\n\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==\\'a\\')freqA--;\\n            else if(s.charAt(i)==\\'b\\')freqB--;\\n            else if(s.charAt(i)==\\'c\\')freqC--;\\n            while(left<=i && (freqA<k || freqB<k || freqC<k)){\\n                if(s.charAt(left)==\\'a\\')freqA++;\\n                else if(s.charAt(left)==\\'b\\')freqB++;\\n                else if(s.charAt(left)==\\'c\\')freqC++; \\n                left++;               \\n            }\\n            res=Math.max(res,i-left+1);\\n        }\\n\\n        return len-res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int left=0,len=s.length(),res=0,freqA=0,freqB=0,freqC=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==\\'a\\')freqA++;\\n            else if(s.charAt(i)==\\'b\\')freqB++;\\n            else if(s.charAt(i)==\\'c\\')freqC++;\\n        }\\n\\n        if(freqA<k || freqB<k || freqC<k)return -1;\\n\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==\\'a\\')freqA--;\\n            else if(s.charAt(i)==\\'b\\')freqB--;\\n            else if(s.charAt(i)==\\'c\\')freqC--;\\n            while(left<=i && (freqA<k || freqB<k || freqC<k)){\\n                if(s.charAt(left)==\\'a\\')freqA++;\\n                else if(s.charAt(left)==\\'b\\')freqB++;\\n                else if(s.charAt(left)==\\'c\\')freqC++; \\n                left++;               \\n            }\\n            res=Math.max(res,i-left+1);\\n        }\\n\\n        return len-res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362874,
                "title": "clean-simple-solution-kotlin",
                "content": "# Code\\n```\\nclass Solution {\\n    private fun MutableMap<Char, Int>.incValue(key: Char) {\\n        this[key] = this[key]!! + 1\\n    }\\n\\n    private fun MutableMap<Char, Int>.decValue(key: Char) {\\n        this[key] = this[key]!! - 1\\n    }\\n    \\n    fun takeCharacters(s: String, k: Int): Int {\\n        val n = s.length\\n        val map = mutableMapOf(\\'a\\' to 0, \\'b\\' to 0, \\'c\\' to 0)\\n        s.forEach { map.incValue(it) }\\n        if (map.values.any { it < k }) return -1\\n\\n        var (answer, i, j) = listOf(Int.MAX_VALUE, n - 1, n - 1)\\n        while (i >= 0) {\\n            map.decValue(s[i])\\n            while (map[s[i]]!! < k) {\\n                map.incValue(s[j])\\n                j--\\n            }\\n            i--\\n            answer = answer.coerceAtMost(n + i - j)\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private fun MutableMap<Char, Int>.incValue(key: Char) {\\n        this[key] = this[key]!! + 1\\n    }\\n\\n    private fun MutableMap<Char, Int>.decValue(key: Char) {\\n        this[key] = this[key]!! - 1\\n    }\\n    \\n    fun takeCharacters(s: String, k: Int): Int {\\n        val n = s.length\\n        val map = mutableMapOf(\\'a\\' to 0, \\'b\\' to 0, \\'c\\' to 0)\\n        s.forEach { map.incValue(it) }\\n        if (map.values.any { it < k }) return -1\\n\\n        var (answer, i, j) = listOf(Int.MAX_VALUE, n - 1, n - 1)\\n        while (i >= 0) {\\n            map.decValue(s[i])\\n            while (map[s[i]]!! < k) {\\n                map.incValue(s[j])\\n                j--\\n            }\\n            i--\\n            answer = answer.coerceAtMost(n + i - j)\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356692,
                "title": "tricky-sliding-window-python-with-explanation",
                "content": "# Intuition\\n\\n    anytime you see taking somthing from the left or the right i think\\n    maximize sliding window that leaves some contition true for \\n    whatever is not in the window\\n\\n    idea is to maximize the window that leaves all the chars \\n    not in the window to be at a count of at lest K\\n\\n    for example :\\n\\n    at start when window size is 0\\n\\n    s = \"aabaaaacaabc\", k = 2\\n    \\n    counts_of_chars_not_in_window:\\n        a:8\\n        b:2\\n        c:2\\n\\n    -------\\n\\n\\n    \" a a b a a a a c a a b c\"  \\n    ^-^\\n    subtract 1 from count of a not in window and add to count of\\n    a in window\\n\\n    we check that count of a for counts_of_chars_not_in_window \\n    is still >= K after taking away 1 a\\n    a:7\\n    b:2\\n    c:2\\n\\n    ----------\\n    \\n    \" a a b a a a a c a a b c\"  \\n    ^---^\\n    a:6 still okay\\n\\n\\n    -----!!!!!!------    \\n\\n\\n\\n    \" a a b a a a a c a a b c\"  \\n    ^-----^\\n    a:6 still okay\\n    b:1 !!!!!\\n    taking away b makes its count of whats not in the window < k\\n    so we must shirnk window from left still the count of b is okay again\\n\\n\\n    \" a a b a a a a c a a b c\"  \\n        ^-^\\n        a:7 still okay\\n        b:1 !!!!!\\n\\n    ----\\n\\n    \" a a b a a a a c a a b c\"  \\n          ^^\\n        a:8 still okay\\n        b:1 !!!!!\\n    ---\\n\\n    \" a a b a a a a c a a b c\"  \\n            ^^\\n        a:8 still okay\\n        b:2 now okay !!!\\n\\n    ----------- repeat -----\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n\\n\\n\\n        # maximun window such that the total - winow \\n        # leaves k of all three\\n\\n        if k == 0:\\n            return 0\\n\\n        if len(set(s)) < 3:\\n            return -1\\n\\n        rest = {}\\n        for ch in s:\\n            rest[ch] = rest.get(ch,0)+1\\n\\n        if rest[\\'a\\'] < k or  rest[\\'b\\'] < k or  rest[\\'c\\'] < k:\\n            return -1\\n\\n\\n        \\n\\n\\n\\n\\n        window_count = {}\\n        l = 0\\n        best = 10**9\\n\\n        for r in range(len(s)):\\n\\n            ch = s[r]\\n            # while adding this char to the window makes it not possible to have k left over \\n            # inc l forward\\n\\n\\n            while rest.get(ch)-1 < k and l < r:\\n                # add to total substract from window\\n\\n                left_ch = s[l]\\n\\n                rest[left_ch]+=1\\n                window_count[left_ch]-=1\\n                l+=1\\n            # if we absoulty need this ch in the left or right becaue count(ch) == k\\n            # we move forward \\n            if rest.get(ch)-1 <k:\\n                l = r +1\\n                best = min(best, len(s) - (r-l+1))\\n                continue\\n\\n\\n\\n            #add to window substract from total\\n\\n            rest[s[r]] = rest.get(s[r],0)-1\\n            window_count[s[r]] = window_count.get(s[r],0)+1\\n\\n\\n            windowSize = (r-l+1)\\n            best = min(best, len(s) - windowSize)\\n\\n        return best\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n\\n\\n\\n\\n        # maximun window such that the total - winow \\n        # leaves k of all three\\n\\n        if k == 0:\\n            return 0\\n\\n        if len(set(s)) < 3:\\n            return -1\\n\\n        rest = {}\\n        for ch in s:\\n            rest[ch] = rest.get(ch,0)+1\\n\\n        if rest[\\'a\\'] < k or  rest[\\'b\\'] < k or  rest[\\'c\\'] < k:\\n            return -1\\n\\n\\n        \\n\\n\\n\\n\\n        window_count = {}\\n        l = 0\\n        best = 10**9\\n\\n        for r in range(len(s)):\\n\\n            ch = s[r]\\n            # while adding this char to the window makes it not possible to have k left over \\n            # inc l forward\\n\\n\\n            while rest.get(ch)-1 < k and l < r:\\n                # add to total substract from window\\n\\n                left_ch = s[l]\\n\\n                rest[left_ch]+=1\\n                window_count[left_ch]-=1\\n                l+=1\\n            # if we absoulty need this ch in the left or right becaue count(ch) == k\\n            # we move forward \\n            if rest.get(ch)-1 <k:\\n                l = r +1\\n                best = min(best, len(s) - (r-l+1))\\n                continue\\n\\n\\n\\n            #add to window substract from total\\n\\n            rest[s[r]] = rest.get(s[r],0)-1\\n            window_count[s[r]] = window_count.get(s[r],0)+1\\n\\n\\n            windowSize = (r-l+1)\\n            best = min(best, len(s) - windowSize)\\n\\n        return best\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351546,
                "title": "c-sliding-window-binary-search",
                "content": "**Binary Search**\\n```\\nint takeCharacters(string s, int k) {\\n\\t\\tint n = s.size(), ans = n;\\n\\t\\tvector<vector<int>> freq(n + 1, vector<int>(3));\\n\\t\\tfor(int i = 1; i <= n; i++) {\\n\\t\\t\\t\\tfreq[i] = freq[i-1];\\n\\t\\t\\t\\tfreq[i][s[i-1] - \\'a\\']++;\\n\\t\\t\\t\\tif(freq[i][0] >= k && freq[i][1] >= k && freq[i][2] >= k) ans = min(ans, i);\\n\\t\\t}\\n\\t\\t//check if ans is possible\\n\\t\\tif(freq.back()[0] < k || freq.back()[1] < k || freq.back()[2] < k) return -1;\\n\\n\\t\\tvector<int> req(3, k);\\n\\t\\tfor(int i = n - 1; i >= 0; i--){\\n\\t\\t\\t\\tif(req[0] == 0 && req[1] == 0 && req[2] == 0) ans = min(ans, n - i - 1);\\n\\t\\t\\t\\treq[s[i] - \\'a\\']--;\\n\\t\\t\\t\\tint hi = i, lo = 0;\\n\\t\\t\\t\\twhile(hi > lo){\\n\\t\\t\\t\\t\\t\\tint mid = (hi + lo)/2, check = true;\\n\\t\\t\\t\\t\\t\\tfor(int k = 0; k < 3; k++){\\n\\t\\t\\t\\t\\t\\t\\t\\tcheck = check && req[k] <= freq[mid][k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(check) hi = mid;\\n\\t\\t\\t\\t\\t\\telse lo = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = min(ans, n - i + lo);\\n\\t\\t}\\n\\t\\treturn ans;\\n}\\n```\\n\\n**Sliding Window O(n)**\\n```\\nint takeCharacters(string s, int k) {\\n\\tint n = s.size(), ans = n;\\n\\tvector<int> freq(3);\\n\\t//check if ans is possible\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfreq[s[i] - \\'a\\']++;\\n\\t}\\n\\tif(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n\\n\\t// initially every element is selected \\n\\t\\n\\tint i = 0;\\n\\tfor(int j = 0; j < n; j++){\\n\\t\\t// at each iteration we remove jth element from consideration\\n\\t\\tfreq[s[j] - \\'a\\']--;\\n\\t\\t\\n\\t\\t// shrink the window\\n\\t\\twhile(freq[0] < k || freq[1] < k || freq[2] < k) freq[s[i++] - \\'a\\']++;\\n\\t\\t\\n\\t\\t// in current state last  n - j - 1 elements and first i elements are inside window \\n\\t\\tans = min(ans, ( n - j - 1 ) + i);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nint takeCharacters(string s, int k) {\\n\\t\\tint n = s.size(), ans = n;\\n\\t\\tvector<vector<int>> freq(n + 1, vector<int>(3));\\n\\t\\tfor(int i = 1; i <= n; i++) {\\n\\t\\t\\t\\tfreq[i] = freq[i-1];\\n\\t\\t\\t\\tfreq[i][s[i-1] - \\'a\\']++;\\n\\t\\t\\t\\tif(freq[i][0] >= k && freq[i][1] >= k && freq[i][2] >= k) ans = min(ans, i);\\n\\t\\t}\\n\\t\\t//check if ans is possible\\n\\t\\tif(freq.back()[0] < k || freq.back()[1] < k || freq.back()[2] < k) return -1;\\n\\n\\t\\tvector<int> req(3, k);\\n\\t\\tfor(int i = n - 1; i >= 0; i--){\\n\\t\\t\\t\\tif(req[0] == 0 && req[1] == 0 && req[2] == 0) ans = min(ans, n - i - 1);\\n\\t\\t\\t\\treq[s[i] - \\'a\\']--;\\n\\t\\t\\t\\tint hi = i, lo = 0;\\n\\t\\t\\t\\twhile(hi > lo){\\n\\t\\t\\t\\t\\t\\tint mid = (hi + lo)/2, check = true;\\n\\t\\t\\t\\t\\t\\tfor(int k = 0; k < 3; k++){\\n\\t\\t\\t\\t\\t\\t\\t\\tcheck = check && req[k] <= freq[mid][k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(check) hi = mid;\\n\\t\\t\\t\\t\\t\\telse lo = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = min(ans, n - i + lo);\\n\\t\\t}\\n\\t\\treturn ans;\\n}\\n```\n```\\nint takeCharacters(string s, int k) {\\n\\tint n = s.size(), ans = n;\\n\\tvector<int> freq(3);\\n\\t//check if ans is possible\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfreq[s[i] - \\'a\\']++;\\n\\t}\\n\\tif(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n\\n\\t// initially every element is selected \\n\\t\\n\\tint i = 0;\\n\\tfor(int j = 0; j < n; j++){\\n\\t\\t// at each iteration we remove jth element from consideration\\n\\t\\tfreq[s[j] - \\'a\\']--;\\n\\t\\t\\n\\t\\t// shrink the window\\n\\t\\twhile(freq[0] < k || freq[1] < k || freq[2] < k) freq[s[i++] - \\'a\\']++;\\n\\t\\t\\n\\t\\t// in current state last  n - j - 1 elements and first i elements are inside window \\n\\t\\tans = min(ans, ( n - j - 1 ) + i);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347598,
                "title": "c-sliding-window-unordered-map-solution",
                "content": "\\n       int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n        mp[\\'a\\']=0;\\n        mp[\\'b\\']=0;\\n        mp[\\'c\\']=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t   mp[s[i]]++;\\n            \\n        }\\n        int head=0;\\n        int tail=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<k)\\n            {\\n                return -1;\\n                \\n            }\\n        }\\n        for(auto &it:mp)\\n        {\\n            it.second=it.second-k;\\n \\n        }\\n        int maxi=0;\\n        for(head=0;head<s.length();)\\n        {\\n                      mp[s[head]]--;\\n            // cout<<mp[s[head]]<<endl;\\n\\n            while(mp[s[head]]<0 && tail<=head)\\n            {\\n                mp[s[tail]]++;\\n                tail++;\\n                \\n            }\\n           maxi=max(maxi,head-tail+1);\\n            head++;\\n\\t\\t\\t  }\\n        return s.length()- maxi;\\n    }\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n       int takeCharacters(string s, int k) {\\n        unordered_map<char,int>mp;\\n        mp[\\'a\\']=0;\\n        mp[\\'b\\']=0;\\n        mp[\\'c\\']=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t   mp[s[i]]++;\\n            \\n        }\\n        int head=0;\\n        int tail=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<k)\\n            {\\n                return -1;\\n                \\n            }\\n        }\\n        for(auto &it:mp)\\n        {\\n            it.second=it.second-k;\\n \\n        }\\n        int maxi=0;\\n        for(head=0;head<s.length();)\\n        {\\n                      mp[s[head]]--;\\n            // cout<<mp[s[head]]<<endl;\\n\\n            while(mp[s[head]]<0 && tail<=head)\\n            {\\n                mp[s[tail]]++;\\n                tail++;\\n                \\n            }\\n           maxi=max(maxi,head-tail+1);\\n            head++;\\n\\t\\t\\t  }\\n        return s.length()- maxi;\\n    }\\n",
                "codeTag": "C++"
            },
            {
                "id": 3328130,
                "title": "python-100-faster",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def takeCharacters(self, s, k):\\n        if len(s)<3*k:\\n            return -1\\n        num=[0]*3\\n\\n        i=0\\n        j=len(s)-1\\n\\n        res=0\\n        mi=0\\n\\n        while num[0]<k or num[1]<k or num[2]<k:\\n            if i==len(s):\\n                return -1\\n            if s[i]==\\'a\\':\\n                num[0]+=1\\n            elif s[i]==\\'b\\':\\n                num[1]+=1\\n            else:\\n                num[2]+=1\\n            res+=1\\n            mi+=1\\n            i+=1\\n\\n        while i>0:\\n            i-=1\\n            num[ord(s[i])-ord(\\'a\\')]-=1\\n            mi-=1\\n            while num[ord(s[i])-ord(\\'a\\')]<k:\\n                num[ord(s[j])-ord(\\'a\\')]+=1\\n                j-=1\\n                mi+=1\\n            res=min(res,mi)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def takeCharacters(self, s, k):\\n        if len(s)<3*k:\\n            return -1\\n        num=[0]*3\\n\\n        i=0\\n        j=len(s)-1\\n\\n        res=0\\n        mi=0\\n\\n        while num[0]<k or num[1]<k or num[2]<k:\\n            if i==len(s):\\n                return -1\\n            if s[i]==\\'a\\':\\n                num[0]+=1\\n            elif s[i]==\\'b\\':\\n                num[1]+=1\\n            else:\\n                num[2]+=1\\n            res+=1\\n            mi+=1\\n            i+=1\\n\\n        while i>0:\\n            i-=1\\n            num[ord(s[i])-ord(\\'a\\')]-=1\\n            mi-=1\\n            while num[ord(s[i])-ord(\\'a\\')]<k:\\n                num[ord(s[j])-ord(\\'a\\')]+=1\\n                j-=1\\n                mi+=1\\n            res=min(res,mi)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314697,
                "title": "c-solution-using-sliding-window-faster-than-100",
                "content": "# Intuition\\nget the max length for remining substring after remove left characters and right characters instead of get the minimum number of minutes needed for you to take at least k. So I increase window size while the substring don\\'t include any required character.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int[] freq = new int[3];\\n        for(int i = 0; i < s.Length;i++) freq[s[i] - \\'a\\']++;\\n        if(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n        int left = 0, middleLen = 0; // \\n        for(int right = 0; right < s.Length;right++){\\n            freq[s[right] - \\'a\\']--;\\n            while(freq[0] < k || freq[1] < k || freq[2] < k) freq[s[left++] - \\'a\\']++;\\n            middleLen = Math.Max(middleLen,right - left + 1);\\n        }\\n        return s.Length - middleLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int TakeCharacters(string s, int k) {\\n        int[] freq = new int[3];\\n        for(int i = 0; i < s.Length;i++) freq[s[i] - \\'a\\']++;\\n        if(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n        int left = 0, middleLen = 0; // \\n        for(int right = 0; right < s.Length;right++){\\n            freq[s[right] - \\'a\\']--;\\n            while(freq[0] < k || freq[1] < k || freq[2] < k) freq[s[left++] - \\'a\\']++;\\n            middleLen = Math.Max(middleLen,right - left + 1);\\n        }\\n        return s.Length - middleLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311046,
                "title": "python-sliding-window-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        counts = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        for c in s:\\n            counts[c] += 1\\n        for key in counts:\\n            if counts[key] < k:\\n                return -1\\n        \\n        l = 0\\n        freq = [counts[\\'a\\'] - k, counts[\\'b\\'] - k, counts[\\'c\\'] - k]\\n        length = 0\\n        \\n        dic = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        for r in range(len(s)):\\n            dic[s[r]] += 1 \\n            \\n            while (dic[\\'a\\'] > freq[0] or dic[\\'b\\'] > freq[1] or dic[\\'c\\'] > freq[2]):\\n                dic[s[l]] -= 1\\n                l += 1\\n            \\n            length = max(length, r - l + 1)\\n                \\n        return len(s) - length\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        counts = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        for c in s:\\n            counts[c] += 1\\n        for key in counts:\\n            if counts[key] < k:\\n                return -1\\n        \\n        l = 0\\n        freq = [counts[\\'a\\'] - k, counts[\\'b\\'] - k, counts[\\'c\\'] - k]\\n        length = 0\\n        \\n        dic = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0}\\n        for r in range(len(s)):\\n            dic[s[r]] += 1 \\n            \\n            while (dic[\\'a\\'] > freq[0] or dic[\\'b\\'] > freq[1] or dic[\\'c\\'] > freq[2]):\\n                dic[s[l]] -= 1\\n                l += 1\\n            \\n            length = max(length, r - l + 1)\\n                \\n        return len(s) - length\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304418,
                "title": "c-9-line-o-n",
                "content": "```\\n    int takeCharacters(string s, int k) {\\n        vector<int> cnt(128, -k);\\n        for(auto c:s) cnt[c]++;\\n        for(char c : {\\'a\\', \\'b\\', \\'c\\'}) if(cnt[c] < 0) return -1;\\n        int longestMid = 0;\\n        for(int l=0,r=0,n=s.size(); r<n; cnt[s[l++]]++){\\n            while(r<n && cnt[s[r]] > 0) cnt[s[r++]]--;\\n            longestMid = max(longestMid, r-l);\\n        }   \\n        return s.size() - longestMid;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int takeCharacters(string s, int k) {\\n        vector<int> cnt(128, -k);\\n        for(auto c:s) cnt[c]++;\\n        for(char c : {\\'a\\', \\'b\\', \\'c\\'}) if(cnt[c] < 0) return -1;\\n        int longestMid = 0;\\n        for(int l=0,r=0,n=s.size(); r<n; cnt[s[l++]]++){\\n            while(r<n && cnt[s[r]] > 0) cnt[s[r++]]--;\\n            longestMid = max(longestMid, r-l);\\n        }   \\n        return s.size() - longestMid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269464,
                "title": "c-solution-using-sliding-window-easy-to-understand",
                "content": "```\\n int takeCharacters(string s, int k) {\\n      \\n    int n = s.size();\\n    unordered_map<char, int> mp;\\n    mp[\\'a\\'] = 0;\\n    mp[\\'b\\'] = 0;\\n    mp[\\'c\\'] = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        mp[s[i]]++;\\n    }\\n\\n    for (auto it : mp)\\n    {\\n        if (it.second < k)\\n        {\\n            return -1;\\n        }\\n    }\\n\\n    int i = 0;\\n    int j = -1;\\n\\n    int count_a = 0;\\n    int count_b = 0;\\n    int count_c = 0;\\n\\n    int ka = mp[\\'a\\'] - k;\\n    int kb = mp[\\'b\\'] - k;\\n    int kc = mp[\\'c\\'] - k;\\n\\n    int len = 0;\\n\\n    while (i < n)\\n    {\\n        // aquire karo\\n\\n        if (s[i] == \\'a\\')\\n        {\\n            count_a++;\\n            i++;\\n        }\\n        else if (s[i] == \\'b\\')\\n        {\\n            count_b++;\\n            i++;\\n        }\\n        else if (s[i] == \\'c\\')\\n        {\\n            count_c++;\\n            i++;\\n        }\\n\\n        if (count_a <= ka and count_b <= kb and count_c <= kc)\\n        {\\n            int sze = i - j;\\n            len = max(len, sze);\\n        }\\n\\n        while (count_a > ka or count_b > kb or count_c > kc)\\n        {\\n            j++;\\n\\n            if (s[j] == \\'a\\')\\n            {\\n                count_a--;\\n            }\\n            else if (s[j] == \\'b\\')\\n            {\\n                count_b--;\\n            }\\n            else if (s[j] == \\'c\\')\\n            {\\n                count_c--;\\n            }\\n        }\\n    }\\n        \\n    \\n    if (count_a <= ka and count_b <= kb and count_c <= kc)\\n    {\\n        int sze = i - j;\\n        len = max(len, sze);\\n    }\\n\\n    return n - len + 1;  \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int takeCharacters(string s, int k) {\\n      \\n    int n = s.size();\\n    unordered_map<char, int> mp;\\n    mp[\\'a\\'] = 0;\\n    mp[\\'b\\'] = 0;\\n    mp[\\'c\\'] = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        mp[s[i]]++;\\n    }\\n\\n    for (auto it : mp)\\n    {\\n        if (it.second < k)\\n        {\\n            return -1;\\n        }\\n    }\\n\\n    int i = 0;\\n    int j = -1;\\n\\n    int count_a = 0;\\n    int count_b = 0;\\n    int count_c = 0;\\n\\n    int ka = mp[\\'a\\'] - k;\\n    int kb = mp[\\'b\\'] - k;\\n    int kc = mp[\\'c\\'] - k;\\n\\n    int len = 0;\\n\\n    while (i < n)\\n    {\\n        // aquire karo\\n\\n        if (s[i] == \\'a\\')\\n        {\\n            count_a++;\\n            i++;\\n        }\\n        else if (s[i] == \\'b\\')\\n        {\\n            count_b++;\\n            i++;\\n        }\\n        else if (s[i] == \\'c\\')\\n        {\\n            count_c++;\\n            i++;\\n        }\\n\\n        if (count_a <= ka and count_b <= kb and count_c <= kc)\\n        {\\n            int sze = i - j;\\n            len = max(len, sze);\\n        }\\n\\n        while (count_a > ka or count_b > kb or count_c > kc)\\n        {\\n            j++;\\n\\n            if (s[j] == \\'a\\')\\n            {\\n                count_a--;\\n            }\\n            else if (s[j] == \\'b\\')\\n            {\\n                count_b--;\\n            }\\n            else if (s[j] == \\'c\\')\\n            {\\n                count_c--;\\n            }\\n        }\\n    }\\n        \\n    \\n    if (count_a <= ka and count_b <= kb and count_c <= kc)\\n    {\\n        int sze = i - j;\\n        len = max(len, sze);\\n    }\\n\\n    return n - len + 1;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3229283,
                "title": "c-golang-two-pointers",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int freq[3] = {0};\\n        int n = s.length();\\n        int ans = INT_MAX;\\n        for(char ch: s) freq[ch - \\'a\\']++;\\n        if(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n        for(int i = 0, j = 0; i < n; i++) {\\n            while(j <= n && freq[0] >= k && freq[1] >= k && freq[2] >= k) {\\n                ans = min(ans, i + n - j);\\n                if(j < n) freq[s[j] - \\'a\\']--;\\n                j++;\\n            }\\n            freq[s[i] - \\'a\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc takeCharacters(s string, k int) int {\\n    freq := make([]int, 3)\\n    var n int = len(s)\\n    var ans int = math.MaxInt\\n    for _, ch := range s {freq[ch - \\'a\\']++}\\n    if freq[0] < k || freq[1] < k || freq[2] < k {return -1}\\n    for i, j := 0, 0; i < n; i++ {\\n        for j <= n && freq[0] >= k && freq[1] >= k && freq[2] >= k {\\n            if i + n - j < ans {\\n                ans = i + n - j\\n            }\\n            if j < n {\\n                freq[s[j] - \\'a\\']--\\n            }\\n            j++\\n        }\\n        freq[s[i] - \\'a\\']++\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int freq[3] = {0};\\n        int n = s.length();\\n        int ans = INT_MAX;\\n        for(char ch: s) freq[ch - \\'a\\']++;\\n        if(freq[0] < k || freq[1] < k || freq[2] < k) return -1;\\n        for(int i = 0, j = 0; i < n; i++) {\\n            while(j <= n && freq[0] >= k && freq[1] >= k && freq[2] >= k) {\\n                ans = min(ans, i + n - j);\\n                if(j < n) freq[s[j] - \\'a\\']--;\\n                j++;\\n            }\\n            freq[s[i] - \\'a\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc takeCharacters(s string, k int) int {\\n    freq := make([]int, 3)\\n    var n int = len(s)\\n    var ans int = math.MaxInt\\n    for _, ch := range s {freq[ch - \\'a\\']++}\\n    if freq[0] < k || freq[1] < k || freq[2] < k {return -1}\\n    for i, j := 0, 0; i < n; i++ {\\n        for j <= n && freq[0] >= k && freq[1] >= k && freq[2] >= k {\\n            if i + n - j < ans {\\n                ans = i + n - j\\n            }\\n            if j < n {\\n                freq[s[j] - \\'a\\']--\\n            }\\n            j++\\n        }\\n        freq[s[i] - \\'a\\']++\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200211,
                "title": "java-time-o-n-space-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int takeCharacters(String s, int k) \\n    {\\n        int n = s.length();\\n        int freq[] = new int[26];\\n\\n        // Calculate the freq of each char.\\n        for(int i = 0; i < n; i++) \\n            freq[s.charAt(i) - \\'a\\']++;\\n\\n        // If freq of a,b,c is lesser than k return -1 from here only.\\n        if(freq[\\'a\\'-\\'a\\'] < k || freq[\\'b\\'-\\'a\\'] < k || freq[\\'c\\'-\\'a\\'] < k) return -1;  \\n\\n        // Find out what will be the size of maximum window we can exclude.\\n        int start = 0;\\n        int end = 0;\\n        int window = 0;\\n        int ans = -1;\\n        while(end < n)\\n        {\\n            // Expansion of Window\\n            char ch = s.charAt(end);\\n            freq[ch - \\'a\\']--;\\n            end++;\\n\\n            // If freq of curr char become < k then shrink the window\\n            while(freq[ch - \\'a\\'] < k)\\n            {\\n                freq[s.charAt(start) - \\'a\\']++;\\n                start++;\\n            }\\n            // Calculation\\n            ans = Math.max(ans, end - start); // Maximum Window we can exclude\\n        }\\n\\n        // Subtract size of max window which we can exclude.\\n        return n - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int takeCharacters(String s, int k) \\n    {\\n        int n = s.length();\\n        int freq[] = new int[26];\\n\\n        // Calculate the freq of each char.\\n        for(int i = 0; i < n; i++) \\n            freq[s.charAt(i) - \\'a\\']++;\\n\\n        // If freq of a,b,c is lesser than k return -1 from here only.\\n        if(freq[\\'a\\'-\\'a\\'] < k || freq[\\'b\\'-\\'a\\'] < k || freq[\\'c\\'-\\'a\\'] < k) return -1;  \\n\\n        // Find out what will be the size of maximum window we can exclude.\\n        int start = 0;\\n        int end = 0;\\n        int window = 0;\\n        int ans = -1;\\n        while(end < n)\\n        {\\n            // Expansion of Window\\n            char ch = s.charAt(end);\\n            freq[ch - \\'a\\']--;\\n            end++;\\n\\n            // If freq of curr char become < k then shrink the window\\n            while(freq[ch - \\'a\\'] < k)\\n            {\\n                freq[s.charAt(start) - \\'a\\']++;\\n                start++;\\n            }\\n            // Calculation\\n            ans = Math.max(ans, end - start); // Maximum Window we can exclude\\n        }\\n\\n        // Subtract size of max window which we can exclude.\\n        return n - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160905,
                "title": "binary-search-approch-with-constant-space-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // TC = O(N*LOG(N))\\n    // SC = O(1)\\n    bool condition(string &s , int mid , int k){\\n        int n = s.size() , i=0;\\n        vector<int> v(3);\\n\\n        for(; i<mid; i++){ v[s[i]-\\'a\\']++;}\\n        if(v[0]>=k && v[1]>=k && v[2]>=k) return true;\\n        int j = n-1; i--;\\n\\n        while(i>=0){\\n            v[s[i--]-\\'a\\']--;\\n            v[s[j--]-\\'a\\']++;\\n            if(v[0]>=k && v[1]>=k && v[2]>=k) return true;\\n        }\\n        return false;\\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int st = 1 , ed = n;\\n        if(k==0) return 0;\\n\\n        while(st<=ed){\\n            int m = st + (ed-st)/2;\\n            bool tell = condition(s , m , k);\\n            if(tell){\\n                ed = m-1;\\n            }else {\\n                st = m+1;\\n            }\\n        }\\n\\n        return (st == n+1)?-1:st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC = O(N*LOG(N))\\n    // SC = O(1)\\n    bool condition(string &s , int mid , int k){\\n        int n = s.size() , i=0;\\n        vector<int> v(3);\\n\\n        for(; i<mid; i++){ v[s[i]-\\'a\\']++;}\\n        if(v[0]>=k && v[1]>=k && v[2]>=k) return true;\\n        int j = n-1; i--;\\n\\n        while(i>=0){\\n            v[s[i--]-\\'a\\']--;\\n            v[s[j--]-\\'a\\']++;\\n            if(v[0]>=k && v[1]>=k && v[2]>=k) return true;\\n        }\\n        return false;\\n    }\\n\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        int st = 1 , ed = n;\\n        if(k==0) return 0;\\n\\n        while(st<=ed){\\n            int m = st + (ed-st)/2;\\n            bool tell = condition(s , m , k);\\n            if(tell){\\n                ed = m-1;\\n            }else {\\n                st = m+1;\\n            }\\n        }\\n\\n        return (st == n+1)?-1:st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159501,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int takeCharacters(string s, int k) \\n    {\\n       if(k==0)\\n           return 0;\\n       int n=s.length();\\n       unordered_map<char,int>m;\\n       for(int i=0;i<n;i++)\\n       {\\n           m[s[i]]++;\\n       }\\n        int p=0;\\n        int mf=INT_MAX;\\n        for(auto a:m)\\n        {\\n             p++;\\n            mf=max(mf,a.second);\\n            if(a.second<k)\\n            {\\n                return -1;\\n            }\\n          \\n        }\\n         if(p<3)\\n             return -1;\\n         if(mf==k)\\n             return n;\\n        int i=n-1;\\n        int j=i;\\n        int ml=n;\\n        int o=n;\\n        while(i>-1)\\n        {\\n             char c;\\n             while(i>-1)\\n             {\\n                 \\n                 m[s[i]]--;\\n                 if(m[s[i]]<k)\\n                 {\\n                     c=s[i];\\n                     i--;\\n                     o--;\\n                     break;\\n                 }\\n                 o--;\\n                 ml=min(ml,o);\\n                 i--;\\n             }\\n            while(j>-1 && j>=i)\\n            {\\n                o++;\\n                m[s[j]]++;\\n                if(s[j]==c)\\n                {\\n                    j--;\\n                    break;\\n                }\\n                else \\n                j--;\\n            }\\n                ml=min(ml,o);\\n        }\\n        return ml;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int takeCharacters(string s, int k) \\n    {\\n       if(k==0)\\n           return 0;\\n       int n=s.length();\\n       unordered_map<char,int>m;\\n       for(int i=0;i<n;i++)\\n       {\\n           m[s[i]]++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3156612,
                "title": "c-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int> mpp;\\n        for(int i=0;i<s.size();i++){\\n            mpp[s[i]]++;\\n        }\\n        int left=0;\\n        int right=0;\\n        int ans=INT_MAX;\\n        int n=s.size();\\n        if(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k){\\n            ans=min(ans,n-right+left);\\n        }\\n        while(right<s.size()){\\n            mpp[s[right]]--;\\n            if(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k){\\n                ans=min(ans,n-right+left-1);\\n            }\\n            \\n            while(left<=right && !(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k)){\\n                mpp[s[left]]++;\\n                left++;\\n                \\n            }    \\n            \\n            right++;\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        unordered_map<char,int> mpp;\\n        for(int i=0;i<s.size();i++){\\n            mpp[s[i]]++;\\n        }\\n        int left=0;\\n        int right=0;\\n        int ans=INT_MAX;\\n        int n=s.size();\\n        if(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k){\\n            ans=min(ans,n-right+left);\\n        }\\n        while(right<s.size()){\\n            mpp[s[right]]--;\\n            if(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k){\\n                ans=min(ans,n-right+left-1);\\n            }\\n            \\n            while(left<=right && !(mpp[\\'a\\']>=k && mpp[\\'b\\']>=k && mpp[\\'c\\']>=k)){\\n                mpp[s[left]]++;\\n                left++;\\n                \\n            }    \\n            \\n            right++;\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124530,
                "title": "beats-91-3-percent",
                "content": "# Intuition\\n<!-- sliding window solution -->\\nonly left and right can be deleted so all such possibilities can be exhausted using a sliding window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int c1 , int c2 , int c3 , int k){\\n        return c1>=k and c2 >=k and c3 >= k ; \\n    }\\n    int takeCharacters(string s, int k) {\\n        int n = s.size() ; \\n        int i = 0  , j = n-1 ; \\n        int c1 = 0 , c2 = 0 , c3 = 0 ; \\n        while(!f(c1 , c2 , c3 , k) and i < n){\\n            if(s[i] == \\'a\\') c1++ ;\\n            if(s[i] == \\'b\\') c2++ ;\\n            if(s[i] == \\'c\\') c3++ ;\\n            i++ ;\\n        }\\n        if(i >= n and !f(c1 , c2 , c3 , k) ) return -1 ;\\n        i-- ;\\n        int ans = i+1 ; \\n        while(i >= 0){\\n            // removal of ith character \\n            if(s[i] == \\'a\\') c1-- ;\\n            if(s[i] == \\'b\\') c2-- ;\\n            if(s[i] == \\'c\\') c3-- ;\\n            i-- ;\\n            while(j > i  and  !f(c1 , c2 , c3 , k)){\\n                if(s[j] == \\'a\\') c1++ ;\\n                if(s[j] == \\'b\\') c2++ ;\\n                if(s[j] == \\'c\\') c3++ ;\\n                j-- ;\\n            }\\n            ans = min(ans , i + n-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int c1 , int c2 , int c3 , int k){\\n        return c1>=k and c2 >=k and c3 >= k ; \\n    }\\n    int takeCharacters(string s, int k) {\\n        int n = s.size() ; \\n        int i = 0  , j = n-1 ; \\n        int c1 = 0 , c2 = 0 , c3 = 0 ; \\n        while(!f(c1 , c2 , c3 , k) and i < n){\\n            if(s[i] == \\'a\\') c1++ ;\\n            if(s[i] == \\'b\\') c2++ ;\\n            if(s[i] == \\'c\\') c3++ ;\\n            i++ ;\\n        }\\n        if(i >= n and !f(c1 , c2 , c3 , k) ) return -1 ;\\n        i-- ;\\n        int ans = i+1 ; \\n        while(i >= 0){\\n            // removal of ith character \\n            if(s[i] == \\'a\\') c1-- ;\\n            if(s[i] == \\'b\\') c2-- ;\\n            if(s[i] == \\'c\\') c3-- ;\\n            i-- ;\\n            while(j > i  and  !f(c1 , c2 , c3 , k)){\\n                if(s[j] == \\'a\\') c1++ ;\\n                if(s[j] == \\'b\\') c2++ ;\\n                if(s[j] == \\'c\\') c3++ ;\\n                j-- ;\\n            }\\n            ans = min(ans , i + n-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100203,
                "title": "python-short-and-clean-sliding-window-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        \\n        count=Counter(s)\\n        \\n        if count[\"a\"]<k or count[\"b\"]<k or count[\"c\"]<k:\\n            return -1\\n        \\n        c=Counter()\\n        left=0\\n        \\n        mx=0\\n\\n        for right,ch in enumerate(s):\\n            c[ch]+=1\\n            while count[ch]-c[ch]<k:\\n                \\n                c[s[left]]-=1\\n                left+=1\\n            \\n            mx=max(mx,right-left+1)\\n    \\n        return len(s)-mx \\n        \\n            \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        \\n        count=Counter(s)\\n        \\n        if count[\"a\"]<k or count[\"b\"]<k or count[\"c\"]<k:\\n            return -1\\n        \\n        c=Counter()\\n        left=0\\n        \\n        mx=0\\n\\n        for right,ch in enumerate(s):\\n            c[ch]+=1\\n            while count[ch]-c[ch]<k:\\n                \\n                c[s[left]]-=1\\n                left+=1\\n            \\n            mx=max(mx,right-left+1)\\n    \\n        return len(s)-mx \\n        \\n            \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096668,
                "title": "easy-c-solution-sliding-window-improvisation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        if(k==0){\\n            return 0;\\n        }\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k){\\n            return -1;\\n        }\\n        int i=n-1;\\n        int j=n-1;\\n        int ans=n;\\n        int ca=mp[\\'a\\'],cb=mp[\\'b\\'],cc=mp[\\'c\\'];\\n        while(i>=0){\\n            if(s[i]==\\'a\\') ca--;\\n            if(s[i]==\\'b\\') cb--;\\n            if(s[i]==\\'c\\') cc--;\\n            while(ca<k || cb<k || cc<k){\\n                if(s[j]==\\'a\\') ca++;\\n                if(s[j]==\\'b\\') cb++;\\n                if(s[j]==\\'c\\') cc++;\\n                j--;\\n            }\\n            ans=min(ans,n-(j-i+1));\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        if(k==0){\\n            return 0;\\n        }\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k){\\n            return -1;\\n        }\\n        int i=n-1;\\n        int j=n-1;\\n        int ans=n;\\n        int ca=mp[\\'a\\'],cb=mp[\\'b\\'],cc=mp[\\'c\\'];\\n        while(i>=0){\\n            if(s[i]==\\'a\\') ca--;\\n            if(s[i]==\\'b\\') cb--;\\n            if(s[i]==\\'c\\') cc--;\\n            while(ca<k || cb<k || cc<k){\\n                if(s[j]==\\'a\\') ca++;\\n                if(s[j]==\\'b\\') cb++;\\n                if(s[j]==\\'c\\') cc++;\\n                j--;\\n            }\\n            ans=min(ans,n-(j-i+1));\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092287,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from vishalsahu18\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N,window = 0;\\n       unordered_map<char,int>count;\\n\\n       for(auto c : s)\\n            count[c]++;\\n\\n       if(count[\\'a\\'] < k || count[\\'b\\'] <k || count[\\'c\\']<k)  \\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          count[s[i]]--;\\n          window++;\\n\\n            while(count[s[i]]<k){\\n                count[s[j++]]++;\\n                window--;\\n            }\\n            \\n          ans = min(ans,N- window);\\n       }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from vishalsahu18\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n       int N = s.length(),j = 0, ans = N,window = 0;\\n       unordered_map<char,int>count;\\n\\n       for(auto c : s)\\n            count[c]++;\\n\\n       if(count[\\'a\\'] < k || count[\\'b\\'] <k || count[\\'c\\']<k)  \\n            return -1;\\n\\n       for(int i=0;i<N;i++){\\n\\n          count[s[i]]--;\\n          window++;\\n\\n            while(count[s[i]]<k){\\n                count[s[j++]]++;\\n                window--;\\n            }\\n            \\n          ans = min(ans,N- window);\\n       }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080080,
                "title": "java-o-n-solution-using-two-pointer-and-sliding-window-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int n = s.length();\\n        int aCnt=-k;\\n        int bCnt=-k;\\n        int cCnt=-k;\\n\\n        // In these loop we are counting the number of extra character we have in string;        \\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'a\\'){\\n                aCnt++;\\n            }else if(c==\\'b\\'){\\n                bCnt++;\\n            }else{\\n                cCnt++;\\n            }\\n        }\\n\\n        // if count of any character is negative these means that character frequency is less than k therefore return -1;  \\n        \\n        if(aCnt<0 || bCnt<0 || cCnt<0) return -1;\\n\\n        int a = 0; int b=0; int c=0;\\n        \\n        // In these loop we are finding the maximum length of string which contains the extra charcters \\n        int maxLength = 0;  // maxLength represent maximum length of string that contains extra frequency may be equal to or less than\\n        int left=0;\\n        for(int right=0; right<n; right++){\\n            char cur = s.charAt(right);\\n            if(cur==\\'a\\'){\\n                a++;\\n            }else if(cur==\\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n\\n            // if at any time the string contains more frequency of any characters then extra frequency of that character then we reduce our string length            \\n            while(aCnt<a || bCnt<b || cCnt<c){\\n                char curChar = s.charAt(left);\\n                if(curChar==\\'a\\'){\\n                    a--;\\n                }else if(curChar==\\'b\\'){\\n                    b--;\\n                }else{\\n                    c--;\\n                }       \\n                left++;\\n            } \\n            maxLength = Math.max(maxLength,right-left+1);            \\n        }\\n\\n               \\n        return n-maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int n = s.length();\\n        int aCnt=-k;\\n        int bCnt=-k;\\n        int cCnt=-k;\\n\\n        // In these loop we are counting the number of extra character we have in string;        \\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'a\\'){\\n                aCnt++;\\n            }else if(c==\\'b\\'){\\n                bCnt++;\\n            }else{\\n                cCnt++;\\n            }\\n        }\\n\\n        // if count of any character is negative these means that character frequency is less than k therefore return -1;  \\n        \\n        if(aCnt<0 || bCnt<0 || cCnt<0) return -1;\\n\\n        int a = 0; int b=0; int c=0;\\n        \\n        // In these loop we are finding the maximum length of string which contains the extra charcters \\n        int maxLength = 0;  // maxLength represent maximum length of string that contains extra frequency may be equal to or less than\\n        int left=0;\\n        for(int right=0; right<n; right++){\\n            char cur = s.charAt(right);\\n            if(cur==\\'a\\'){\\n                a++;\\n            }else if(cur==\\'b\\'){\\n                b++;\\n            }else{\\n                c++;\\n            }\\n\\n            // if at any time the string contains more frequency of any characters then extra frequency of that character then we reduce our string length            \\n            while(aCnt<a || bCnt<b || cCnt<c){\\n                char curChar = s.charAt(left);\\n                if(curChar==\\'a\\'){\\n                    a--;\\n                }else if(curChar==\\'b\\'){\\n                    b--;\\n                }else{\\n                    c--;\\n                }       \\n                left++;\\n            } \\n            maxLength = Math.max(maxLength,right-left+1);            \\n        }\\n\\n               \\n        return n-maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077827,
                "title": "java-solution-two-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        int a = -k;\\n        int b = -k;\\n        int c = -k;\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\'){ a++; }\\n            else if(ch == \\'b\\'){ b++; }\\n            else{ c++; }\\n\\n        }\\n        \\n        if(a < 0 || b < 0 || c < 0){ return -1; }\\n\\n        int max = 0;\\n        int j = 0;\\n\\n        int a1 = 0;\\n        int b1 = 0;\\n        int c1 = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\'){ a1++; }\\n            else if(ch == \\'b\\'){ b1++; }\\n            else{ c1++; }\\n\\n            while(a1 > a || b1 > b || c1 > c){\\n                char chr = s.charAt(j);\\n\\n                if(chr == \\'a\\'){ a1--; }\\n                else if(chr == \\'b\\'){ b1--; }\\n                else{ c1--; }\\n                j++;\\n            }\\n\\n            max = Math.max(max,i-j+1);\\n\\n        }\\n\\n        return s.length()-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        int a = -k;\\n        int b = -k;\\n        int c = -k;\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\'){ a++; }\\n            else if(ch == \\'b\\'){ b++; }\\n            else{ c++; }\\n\\n        }\\n        \\n        if(a < 0 || b < 0 || c < 0){ return -1; }\\n\\n        int max = 0;\\n        int j = 0;\\n\\n        int a1 = 0;\\n        int b1 = 0;\\n        int c1 = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\'){ a1++; }\\n            else if(ch == \\'b\\'){ b1++; }\\n            else{ c1++; }\\n\\n            while(a1 > a || b1 > b || c1 > c){\\n                char chr = s.charAt(j);\\n\\n                if(chr == \\'a\\'){ a1--; }\\n                else if(chr == \\'b\\'){ b1--; }\\n                else{ c1--; }\\n                j++;\\n            }\\n\\n            max = Math.max(max,i-j+1);\\n\\n        }\\n\\n        return s.length()-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068217,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nMap \\'m\\' is used to count freuquency of letters.\\nTraverse and count the frequency.\\n(-1) if frequency does not meet \\'k\\'.\\nNow, set the map \\'m\\' for the frequency we dont want in string(sliding window)...\\nFor example:- \\'a\\' comes 5 times in string and \\'k\\'=2 so, we dont need the rest 3 \\'a\\' so we can ***at most exclude*** 3 \\'a\\' to get our excluded window, window may contain 3>=\\'a\\'.\\nThere are some crutial points such as (i==j) where n[\\'a\\']==m[\\'a\\'] so,we **skip that character only** at this condition.\\nFinally, we subtract the \\'ma\\' maximum window with string size.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0){\\n            return k;\\n        }\\n        int i=0;\\n        unordered_map<char,int>m;\\n        while(i<s.size()){\\n            m[s[i++]]++;\\n        }\\n        if(m[\\'a\\']<k||m[\\'b\\']<k||m[\\'c\\']<k){\\n            return -1;\\n        }\\n        int j=0,ma=0;i=0;\\n        m[\\'a\\']-=k,m[\\'b\\']-=k,m[\\'c\\']-=k;\\n        unordered_map<char,int>n;\\n        while(j<s.size()){\\n            while(j<s.size()&&n[s[j]]<m[s[j]]){\\n                n[s[j]]++;j++;\\n            }\\n            ma=max(ma,j-i);\\n            if(j>=s.size()){\\n                break;\\n            }\\n            while(i<j&&n[s[j]]==m[s[j]]){\\n                n[s[i]]--;i++;\\n            }\\n            if(i==j&&n[s[i]]==m[s[j]]){\\n                j++;i++;\\n            }\\n        }\\n        return s.size()-ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window",
                    "Counting",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0){\\n            return k;\\n        }\\n        int i=0;\\n        unordered_map<char,int>m;\\n        while(i<s.size()){\\n            m[s[i++]]++;\\n        }\\n        if(m[\\'a\\']<k||m[\\'b\\']<k||m[\\'c\\']<k){\\n            return -1;\\n        }\\n        int j=0,ma=0;i=0;\\n        m[\\'a\\']-=k,m[\\'b\\']-=k,m[\\'c\\']-=k;\\n        unordered_map<char,int>n;\\n        while(j<s.size()){\\n            while(j<s.size()&&n[s[j]]<m[s[j]]){\\n                n[s[j]]++;j++;\\n            }\\n            ma=max(ma,j-i);\\n            if(j>=s.size()){\\n                break;\\n            }\\n            while(i<j&&n[s[j]]==m[s[j]]){\\n                n[s[i]]--;i++;\\n            }\\n            if(i==j&&n[s[i]]==m[s[j]]){\\n                j++;i++;\\n            }\\n        }\\n        return s.size()-ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067986,
                "title": "easy-o-n-and-understandable-java-solution",
                "content": "# Intuition\\nMinimum deletions to get required no. of characters = Maximum length of substring that can be generated with the given string, with maximum (total-k) no. of each character.\\n\\n# Approach\\nFirst count the total no. of each character. Then, we have to find the maximum length of a substring in which every character occurs atmost (total-k) times the occurence of that character in the whole string. The answer will be total length of given string - maximum length of substring found.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        int arr[] = new int[3];\\n\\n        char chs[] = s.toCharArray();\\n\\n        for(char ch: chs)\\n        {\\n            int item = ch-\\'a\\';\\n            arr[item]++;\\n        }\\n\\n        int totalLength = arr[0]+arr[1]+arr[2];\\n        int ans = 0;\\n\\n        arr[0] = arr[0]-k;\\n        arr[1] = arr[1]-k;\\n        arr[2] = arr[2]-k;\\n\\n        if(arr[0] < 0 || arr[1] < 0 || arr[2] < 0) return -1;\\n\\n        int arr1[] = new int[3];\\n        int j = 0;\\n\\n        for(char ch: chs)\\n        {\\n            int item = ch-\\'a\\';\\n            arr1[item]++;\\n            if(arr1[item] > arr[item])\\n            {\\n                while(s.charAt(j)-\\'a\\' != item)\\n                {\\n                    arr1[s.charAt(j)-\\'a\\']--;\\n                    j++;\\n                }\\n                arr1[item]--;\\n                j++;\\n            }\\n\\n            ans = Math.max(arr1[0]+arr1[1]+arr1[2], ans);\\n            \\n        }\\n\\n        return (totalLength-ans);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        \\n        int arr[] = new int[3];\\n\\n        char chs[] = s.toCharArray();\\n\\n        for(char ch: chs)\\n        {\\n            int item = ch-\\'a\\';\\n            arr[item]++;\\n        }\\n\\n        int totalLength = arr[0]+arr[1]+arr[2];\\n        int ans = 0;\\n\\n        arr[0] = arr[0]-k;\\n        arr[1] = arr[1]-k;\\n        arr[2] = arr[2]-k;\\n\\n        if(arr[0] < 0 || arr[1] < 0 || arr[2] < 0) return -1;\\n\\n        int arr1[] = new int[3];\\n        int j = 0;\\n\\n        for(char ch: chs)\\n        {\\n            int item = ch-\\'a\\';\\n            arr1[item]++;\\n            if(arr1[item] > arr[item])\\n            {\\n                while(s.charAt(j)-\\'a\\' != item)\\n                {\\n                    arr1[s.charAt(j)-\\'a\\']--;\\n                    j++;\\n                }\\n                arr1[item]--;\\n                j++;\\n            }\\n\\n            ans = Math.max(arr1[0]+arr1[1]+arr1[2], ans);\\n            \\n        }\\n\\n        return (totalLength-ans);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066050,
                "title": "kotlin-two-pointers-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    fun takeCharacters(s: String, k: Int): Int {\\n        val counter = s.groupingBy { it }\\n            .eachCount()\\n            .toMutableMap()\\n            .withDefault { 0 }\\n        if (listOf(\\'a\\', \\'b\\', \\'c\\').map(counter::getValue).any { it < k }) {\\n            return -1\\n        }\\n        var (left, maxWindow) = 0 to 0\\n        for ((right, c) in s.withIndex()) {\\n            counter.merge(c, -1, Int::plus)\\n            while (counter.getValue(c) < k) {\\n                counter.merge(s[left++], 1, Int::plus)\\n            }\\n            maxWindow = maxOf(maxWindow, right - left + 1)\\n        }\\n        return s.length - maxWindow\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun takeCharacters(s: String, k: Int): Int {\\n        val counter = s.groupingBy { it }\\n            .eachCount()\\n            .toMutableMap()\\n            .withDefault { 0 }\\n        if (listOf(\\'a\\', \\'b\\', \\'c\\').map(counter::getValue).any { it < k }) {\\n            return -1\\n        }\\n        var (left, maxWindow) = 0 to 0\\n        for ((right, c) in s.withIndex()) {\\n            counter.merge(c, -1, Int::plus)\\n            while (counter.getValue(c) < k) {\\n                counter.merge(s[left++], 1, Int::plus)\\n            }\\n            maxWindow = maxOf(maxWindow, right - left + 1)\\n        }\\n        return s.length - maxWindow\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052851,
                "title": "beats-100-faster-tc-o-n-sc-o-1-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nn - max window size (which have the limit of count of sub-String [limit_A = totalA - k && limit_B = totalB - k && limit_C = totalC - k])..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) at first we need to calculate the hash value of every character..\\n2) if any of them is occuring < k  directly return -1.\\n3) else we calculate limitCount of A, limitCount of B, limitCount of C.\\n4) then we maintain a windwow of max size which have the count of characters with in the limit.\\n5) when we get the max window at the end we return n - maxWindow.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO:(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO:(1)\\n\\n\\nif you like my approch please upvote.\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int hash[] = new int[3];\\n        int n = s.length();\\n\\n        // we cal culculate the counts of a,b,c\\n        for(char c : s.toCharArray()){\\n            hash[c - \\'a\\']++;\\n        }\\n\\n        // if any of them is occurig < k  directly return -1.\\n        if(hash[0] < k || hash[1] < k || hash[2] < k){\\n            return -1;\\n        }\\n\\n        // calculate the max limit of occurrence a,b,c\\n        int limitCountA = hash[0] - k, limitCountB = hash[1] - k, limitCountC = hash[2]-k;\\n\\n        // reset the hash values\\n        Arrays.fill(hash, 0);\\n\\n        // here we maintain the max window which having the occurrence of a,b,c with in the limit of count. \\n        int max = 0, left = 0;\\n        for(int right = 0; right < n; right++){\\n            hash[s.charAt(right) - \\'a\\']++;\\n            while(hash[0] > limitCountA || hash[1] > limitCountB || hash[2] > limitCountC){\\n                hash[s.charAt(left) - \\'a\\']--;\\n                left++;\\n            }\\n            int window = right - left + 1;\\n            max = Math.max(window, max);\\n        }\\n\\n        return n - max;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        int hash[] = new int[3];\\n        int n = s.length();\\n\\n        // we cal culculate the counts of a,b,c\\n        for(char c : s.toCharArray()){\\n            hash[c - \\'a\\']++;\\n        }\\n\\n        // if any of them is occurig < k  directly return -1.\\n        if(hash[0] < k || hash[1] < k || hash[2] < k){\\n            return -1;\\n        }\\n\\n        // calculate the max limit of occurrence a,b,c\\n        int limitCountA = hash[0] - k, limitCountB = hash[1] - k, limitCountC = hash[2]-k;\\n\\n        // reset the hash values\\n        Arrays.fill(hash, 0);\\n\\n        // here we maintain the max window which having the occurrence of a,b,c with in the limit of count. \\n        int max = 0, left = 0;\\n        for(int right = 0; right < n; right++){\\n            hash[s.charAt(right) - \\'a\\']++;\\n            while(hash[0] > limitCountA || hash[1] > limitCountB || hash[2] > limitCountC){\\n                hash[s.charAt(left) - \\'a\\']--;\\n                left++;\\n            }\\n            int window = right - left + 1;\\n            max = Math.max(window, max);\\n        }\\n\\n        return n - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025039,
                "title": "c-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025038,
                "title": "c-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025037,
                "title": "c-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025034,
                "title": "c-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        vector<int> count(3, 0);\\n        for(auto p : s) count[int(p-\\'a\\')]++;\\n        for(auto p : count) if(p<k) return -1;\\n        int n = s.size(), ans = n;\\n        for(int i=n-1, j=n; i>=0; i--){\\n            count[s[i]-\\'a\\']--;\\n            while(count[s[i]-\\'a\\']<k){\\n                j--;\\n                count[s[j]-\\'a\\']++;\\n            }\\n            ans = min(ans, i+n-j);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010258,
                "title": "c-sol",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        if(s.size()<=2||s.size()<k*3)return -1;\\n        unordered_map<char,int>mp;\\n        int i=0,j=0,n=s.size(),fans=0;;\\n        for(auto i:s)mp[i]++;\\n        mp[\\'a\\']-=k; mp[\\'b\\']-=k; mp[\\'c\\']-=k;\\n        if(mp[\\'a\\']<0||mp[\\'b\\']<0||mp[\\'c\\']<0)return -1;\\n        while(j<n){\\n            mp[s[j]]--;\\n            if(mp[s[j]]<0){\\n                fans=max(fans,(j-i));\\n                while(j>=i&&mp[s[j]]<0){\\n                    mp[s[i]]++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        fans=max(fans,j-i);\\n        return n-fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return 0;\\n        if(s.size()<=2||s.size()<k*3)return -1;\\n        unordered_map<char,int>mp;\\n        int i=0,j=0,n=s.size(),fans=0;;\\n        for(auto i:s)mp[i]++;\\n        mp[\\'a\\']-=k; mp[\\'b\\']-=k; mp[\\'c\\']-=k;\\n        if(mp[\\'a\\']<0||mp[\\'b\\']<0||mp[\\'c\\']<0)return -1;\\n        while(j<n){\\n            mp[s[j]]--;\\n            if(mp[s[j]]<0){\\n                fans=max(fans,(j-i));\\n                while(j>=i&&mp[s[j]]<0){\\n                    mp[s[i]]++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        fans=max(fans,j-i);\\n        return n-fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002143,
                "title": "o-n-queue-based-approach",
                "content": "# Intuition\\nQueue based approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n     int n=s.size();\\n     int ac=0,bc=0,cc=0;\\n     if(k==0) return 0;\\n     queue<int>a,b,c;\\n     int arr[3]={0};\\n     int dur=INT_MAX;\\n     for(int i=0;i<n*2;i++){\\n         if(i<n) arr[s[i]-\\'a\\']++;\\n         if(s[i%n]==\\'a\\'){\\n             if(ac==k && !a.empty()) a.pop();   \\n             else ac++;\\n             a.push(i);\\n         }\\n         else if(s[i%n]==\\'b\\'){\\n             if(bc==k && !b.empty()) b.pop();   \\n             else bc++;\\n             b.push(i);\\n         }\\n         else if(s[i%n]==\\'c\\'){\\n             if(cc==k && !c.empty()) c.pop();   \\n             else cc++;\\n             c.push(i);\\n         }\\n         if(min(ac,min(bc,cc))>=k){\\n             int mi=min(a.front(),min(b.front(),c.front()));\\n             int ele=min(i+1,n-mi);\\n             if(i<n){\\n                 dur= min(dur,ele);\\n             }\\n             else if(i>=n && i-mi<n && mi<n){\\n                 dur=min(dur,i-mi+1);\\n             }\\n         }\\n     }\\n     for(auto i:arr) if(i<k) return -1;\\n     return dur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n     int n=s.size();\\n     int ac=0,bc=0,cc=0;\\n     if(k==0) return 0;\\n     queue<int>a,b,c;\\n     int arr[3]={0};\\n     int dur=INT_MAX;\\n     for(int i=0;i<n*2;i++){\\n         if(i<n) arr[s[i]-\\'a\\']++;\\n         if(s[i%n]==\\'a\\'){\\n             if(ac==k && !a.empty()) a.pop();   \\n             else ac++;\\n             a.push(i);\\n         }\\n         else if(s[i%n]==\\'b\\'){\\n             if(bc==k && !b.empty()) b.pop();   \\n             else bc++;\\n             b.push(i);\\n         }\\n         else if(s[i%n]==\\'c\\'){\\n             if(cc==k && !c.empty()) c.pop();   \\n             else cc++;\\n             c.push(i);\\n         }\\n         if(min(ac,min(bc,cc))>=k){\\n             int mi=min(a.front(),min(b.front(),c.front()));\\n             int ele=min(i+1,n-mi);\\n             if(i<n){\\n                 dur= min(dur,ele);\\n             }\\n             else if(i>=n && i-mi<n && mi<n){\\n                 dur=min(dur,i-mi+1);\\n             }\\n         }\\n     }\\n     for(auto i:arr) if(i<k) return -1;\\n     return dur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000513,
                "title": "c-binary-search",
                "content": "Intution we know upper bound and lower bound of result space, use binary search, here lower bound 3 times k or size of string,\\nidea is just write predicate function for binary search and we should be able to figure out optimal result.\\n\\n```\\nclass SolutionBinarySearch {\\npublic:\\n    bool isValid(vector<vector<int>> &prefix, string s, int k, int p) {\\n        int n = s.size();\\n        for (int l = 0; l <= p; l++) {\\n            int la = prefix[l][0];\\n            int lb = prefix[l][1];\\n            int lc = prefix[l][2];\\n            \\n            int r = p-l;\\n            int ra = prefix[n][0] - prefix[n-r][0];\\n            int rb = prefix[n][1] - prefix[n-r][1];\\n            int rc = prefix[n][2] - prefix[n-r][2];\\n            \\n            int na = la + ra; int nb = lb + rb; int nc = lc + rc;\\n            if ((na >= k) && (nb >= k ) && (nc >= k)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> prefix(n+1,vector<int>(3,0));\\n        for (int i = 1; i <= n; i++) {\\n            int idx = s[i-1]-\\'a\\';\\n            prefix[i][idx]++;\\n            for (int j = 0; j <3; j++) {\\n                prefix[i][j] += prefix[i-1][j];\\n            }\\n            \\n        }\\n        \\n        if (*min_element(begin(prefix[n]),end(prefix[n])) < k)\\n            return -1;\\n        int l = 3*k; int r = s.size();\\n        int m = 0;\\n        while (l < r) {\\n            m = l + (r-l)/2;\\n            if (isValid(prefix,s,k,m)) {\\n                r = m;\\n            } else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass SolutionBinarySearch {\\npublic:\\n    bool isValid(vector<vector<int>> &prefix, string s, int k, int p) {\\n        int n = s.size();\\n        for (int l = 0; l <= p; l++) {\\n            int la = prefix[l][0];\\n            int lb = prefix[l][1];\\n            int lc = prefix[l][2];\\n            \\n            int r = p-l;\\n            int ra = prefix[n][0] - prefix[n-r][0];\\n            int rb = prefix[n][1] - prefix[n-r][1];\\n            int rc = prefix[n][2] - prefix[n-r][2];\\n            \\n            int na = la + ra; int nb = lb + rb; int nc = lc + rc;\\n            if ((na >= k) && (nb >= k ) && (nc >= k)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> prefix(n+1,vector<int>(3,0));\\n        for (int i = 1; i <= n; i++) {\\n            int idx = s[i-1]-\\'a\\';\\n            prefix[i][idx]++;\\n            for (int j = 0; j <3; j++) {\\n                prefix[i][j] += prefix[i-1][j];\\n            }\\n            \\n        }\\n        \\n        if (*min_element(begin(prefix[n]),end(prefix[n])) < k)\\n            return -1;\\n        int l = 3*k; int r = s.size();\\n        int m = 0;\\n        while (l < r) {\\n            m = l + (r-l)/2;\\n            if (isValid(prefix,s,k,m)) {\\n                r = m;\\n            } else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988893,
                "title": "simple-easy-best-interpretation-of-sliding-window-c-easy-to-understand",
                "content": "```\\n// Solution is typical sliding window, just flip the question, to remove all successive characters from the string\\n// so that the string still consists all a/b/c greater than equal to k, find maximumm of such multiple windows.\\n// This is now a sliding window, sliding window means streams of successive character which satisify particular criteria\\n// Rules of sliding window\\n\\n// 1. Set l and r to 0 to start with as window size is 0\\n// 2. slide the right till time window is valid\\n// 3. At junction when window becomes invalid, capture the window size, as beyond this window is illegal\\n// 4. Now shrink the left side of window till it is valid again. Typically we shrink the left till we have\\n//    same character as right. \\n// 5. Once shrunk window is valid again, start extending the window again to find next window\\n\\n// Thus we are capturing the largest window which has redundant character, which means all other from left and right of the window\\n// will be taken out, hence total size of string - (size of window) is our rolling result, pick minimumm of all such combinations.\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3,0);\\n        for (auto &c: s)\\n            freq[c-\\'a\\']++;\\n        if (*min_element(begin(freq),end(freq)) < k)\\n            return -1;\\n        if (k == 0) return k;\\n        int slen = s.size();\\n        int j = 0;\\n        int result = slen;\\n        \\n        int l = 0; int r = 0;\\n        for (r = 0; r < slen; r++) {\\n            freq[s[r]-\\'a\\']--;\\n            // Remove current character frequency, check if we still have enough characters left\\n            // to satisfy the constraint of less than k\\n            // if removal of this character makes the remaining string invalid means which we\\n            // are border of case where window consists of all not needed characters,\\n            // character will remain and all other characters taken from left of the window [l] and \\n            // right of the window [r] will be picked are compulsory for cricteria k\\n            // if remvoing particular character now makes the window invalid\\n            // so first capture the size, evaluate result, reshrink the window from left to next valid window\\n            if (freq[s[r]-\\'a\\'] < k) {\\n                int window = (r-l);\\n                result = min(result,slen-window);\\n                // shrink the window from l to make the window valid again, i.e make all the\\n                // characters inside the window redundant\\n                while(freq[s[r]-\\'a\\'] < k) {\\n                    freq[s[l]-\\'a\\']++;\\n                    l++;\\n                }\\n            }\\n        }\\n        // if we end with valid window\\n        int window = (r-l);\\n        result = min(result,slen-window);\\n        \\n        return result;\\n    }\\n};\\n```\\nUpvote if you like !!!",
                "solutionTags": [],
                "code": "```\\n// Solution is typical sliding window, just flip the question, to remove all successive characters from the string\\n// so that the string still consists all a/b/c greater than equal to k, find maximumm of such multiple windows.\\n// This is now a sliding window, sliding window means streams of successive character which satisify particular criteria\\n// Rules of sliding window\\n\\n// 1. Set l and r to 0 to start with as window size is 0\\n// 2. slide the right till time window is valid\\n// 3. At junction when window becomes invalid, capture the window size, as beyond this window is illegal\\n// 4. Now shrink the left side of window till it is valid again. Typically we shrink the left till we have\\n//    same character as right. \\n// 5. Once shrunk window is valid again, start extending the window again to find next window\\n\\n// Thus we are capturing the largest window which has redundant character, which means all other from left and right of the window\\n// will be taken out, hence total size of string - (size of window) is our rolling result, pick minimumm of all such combinations.\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3,0);\\n        for (auto &c: s)\\n            freq[c-\\'a\\']++;\\n        if (*min_element(begin(freq),end(freq)) < k)\\n            return -1;\\n        if (k == 0) return k;\\n        int slen = s.size();\\n        int j = 0;\\n        int result = slen;\\n        \\n        int l = 0; int r = 0;\\n        for (r = 0; r < slen; r++) {\\n            freq[s[r]-\\'a\\']--;\\n            // Remove current character frequency, check if we still have enough characters left\\n            // to satisfy the constraint of less than k\\n            // if removal of this character makes the remaining string invalid means which we\\n            // are border of case where window consists of all not needed characters,\\n            // character will remain and all other characters taken from left of the window [l] and \\n            // right of the window [r] will be picked are compulsory for cricteria k\\n            // if remvoing particular character now makes the window invalid\\n            // so first capture the size, evaluate result, reshrink the window from left to next valid window\\n            if (freq[s[r]-\\'a\\'] < k) {\\n                int window = (r-l);\\n                result = min(result,slen-window);\\n                // shrink the window from l to make the window valid again, i.e make all the\\n                // characters inside the window redundant\\n                while(freq[s[r]-\\'a\\'] < k) {\\n                    freq[s[l]-\\'a\\']++;\\n                    l++;\\n                }\\n            }\\n        }\\n        // if we end with valid window\\n        int window = (r-l);\\n        result = min(result,slen-window);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985156,
                "title": "simple-easy-to-understand-a-different-explanation-for-sliding-window-c",
                "content": "```\\n// Idea is to find out the series of consecutive characters in the string whose removal doesn\\'t may diffrence on \\n// eventual criteria i.e frequency of characters still remains >= k\\n\\n\\n// Idea is to bin the frequency of each characters.\\n// iterate from left to right, keep incrementing the window size, i.e unwantedChars\\n// if reducing the frequency of particular character still keep the string intact then keep incrementing\\n// if frequency of remaining characters goes down below criteria then go back to find the fresh successive \\n// series \\n\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3,0);\\n        for (auto &c: s)\\n            freq[c-\\'a\\']++;\\n        if (*min_element(begin(freq),end(freq)) < k)\\n            return -1;\\n        int sz = s.size();\\n        int j = 0;\\n        int result = INT_MAX;\\n        // total number of character which remains after picking up valid characters from left and right\\n        int unwantedChars = 0; \\n        for (int i = 0; i < sz; i++) {\\n            freq[s[i]-\\'a\\']--;\\n            unwantedChars++; // series of characters which doesn\\'t make any diffrence \\n            if (freq[s[i]-\\'a\\'] < k) {\\n                // Reintroduce the lost character back from the left, which \\n                // gives the bound of window which is successive character which will stay back\\n                // after remvoal of all characters from left and right of this window\\n                while(freq[s[i]-\\'a\\'] < k) {\\n                    freq[s[j]-\\'a\\']++;\\n                    j++;\\n                    unwantedChars--;\\n                }\\n            }\\n            result = min(result,sz-unwantedChars);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Idea is to find out the series of consecutive characters in the string whose removal doesn\\'t may diffrence on \\n// eventual criteria i.e frequency of characters still remains >= k\\n\\n\\n// Idea is to bin the frequency of each characters.\\n// iterate from left to right, keep incrementing the window size, i.e unwantedChars\\n// if reducing the frequency of particular character still keep the string intact then keep incrementing\\n// if frequency of remaining characters goes down below criteria then go back to find the fresh successive \\n// series \\n\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        vector<int> freq(3,0);\\n        for (auto &c: s)\\n            freq[c-\\'a\\']++;\\n        if (*min_element(begin(freq),end(freq)) < k)\\n            return -1;\\n        int sz = s.size();\\n        int j = 0;\\n        int result = INT_MAX;\\n        // total number of character which remains after picking up valid characters from left and right\\n        int unwantedChars = 0; \\n        for (int i = 0; i < sz; i++) {\\n            freq[s[i]-\\'a\\']--;\\n            unwantedChars++; // series of characters which doesn\\'t make any diffrence \\n            if (freq[s[i]-\\'a\\'] < k) {\\n                // Reintroduce the lost character back from the left, which \\n                // gives the bound of window which is successive character which will stay back\\n                // after remvoal of all characters from left and right of this window\\n                while(freq[s[i]-\\'a\\'] < k) {\\n                    freq[s[j]-\\'a\\']++;\\n                    j++;\\n                    unwantedChars--;\\n                }\\n            }\\n            result = min(result,sz-unwantedChars);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982468,
                "title": "two-pointer-variable-length-sliding-window-explained-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninstead of finding the length of segment we have to take , we find out the length of the segment that will be missed in the middle . we subtract this length from the length of the string to get our answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nour middle segment will have at max a-k \\'a\\' characters ans so on.\\nwe use this condition as base case for our sliding window .\\nif we can\\'t take a segment because it currently violates one of our base cases then any addition to the segment will also violate our bas e case.\\n\\n\\neg->  if we can have at max 2 a\\'s in a segment and  our curr segment is ababa ,then any addition to the segment will also violate our base case eg-> ababac .\\n\\nso we reduce our segment from the left till our base cases are held true then we start increasing again from the right.\\n \\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) auxilary space.\\n\\n\\ncode is also commented ,ask for any doubt .\\nupvote if you found this helpful.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n     \\n        int a=0,b=0,c=0;\\n    \\n    for(auto it:s){\\n        if(it==\\'a\\')\\n            a++;\\n        else if(it ==\\'b\\')\\n            b++;\\n        else\\n            c++;\\n        }\\n        \\n        if( !(a>=k  && b>=k && c>=k))\\n        return -1;\\n        \\n        // we will find out the length of the part of the string that can be left out\\n        // basically if we take elements from each side , we may leave a segment of string untouched in the middle \\n\\n\\n        // according to the question we want to maximize the untouched middle part ..\\n\\n\\n        int len=s.size();\\n        // we need atleast k elements each of a b and c. so we can at max spare a-k for \\'a\\' , b-k for \\'b\\' and c-k \\n        // for \\'c\\' at the middle segment.\\n\\n       a-=k;\\n        b-=k;\\n        c-=k;\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        // these are the current character frequency \\n    int    wca=0;\\n    int    wcb=0;\\n    int    wcc=0;  // window size c\\n        \\n        int maxi=0;\\n        // we find the max length of the segment using 2 pointers.\\n        while(j<len){\\n            \\n            if(s[j]==\\'a\\')\\n                wca++;\\n            else if(s[j]==\\'b\\')\\n                wcb++;\\n            else\\n                wcc++;\\n            \\n        \\n            while(wca >a || wcb> b || wcc >c){\\n                if(s[i]==\\'a\\')\\n                    wca--;\\n                else if(s[i]==\\'b\\')\\n                    wcb--;\\n                else\\n                    wcc--;\\n                \\n                i++;\\n            }\\n            maxi=max(maxi,j-i+1);\\n        j++;\\n        }\\n        \\n        return len-maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n     \\n        int a=0,b=0,c=0;\\n    \\n    for(auto it:s){\\n        if(it==\\'a\\')\\n            a++;\\n        else if(it ==\\'b\\')\\n            b++;\\n        else\\n            c++;\\n        }\\n        \\n        if( !(a>=k  && b>=k && c>=k))\\n        return -1;\\n        \\n        // we will find out the length of the part of the string that can be left out\\n        // basically if we take elements from each side , we may leave a segment of string untouched in the middle \\n\\n\\n        // according to the question we want to maximize the untouched middle part ..\\n\\n\\n        int len=s.size();\\n        // we need atleast k elements each of a b and c. so we can at max spare a-k for \\'a\\' , b-k for \\'b\\' and c-k \\n        // for \\'c\\' at the middle segment.\\n\\n       a-=k;\\n        b-=k;\\n        c-=k;\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        // these are the current character frequency \\n    int    wca=0;\\n    int    wcb=0;\\n    int    wcc=0;  // window size c\\n        \\n        int maxi=0;\\n        // we find the max length of the segment using 2 pointers.\\n        while(j<len){\\n            \\n            if(s[j]==\\'a\\')\\n                wca++;\\n            else if(s[j]==\\'b\\')\\n                wcb++;\\n            else\\n                wcc++;\\n            \\n        \\n            while(wca >a || wcb> b || wcc >c){\\n                if(s[i]==\\'a\\')\\n                    wca--;\\n                else if(s[i]==\\'b\\')\\n                    wcb--;\\n                else\\n                    wcc--;\\n                \\n                i++;\\n            }\\n            maxi=max(maxi,j-i+1);\\n        j++;\\n        }\\n        \\n        return len-maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982203,
                "title": "copying-of-a-cyclic-string",
                "content": "Copy the string once to the right. Non-empty selections from both ends of the string correpond to new substrings with `left < n` and `right >= n`.\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length(), min = n + 1;\\n        int[] cnts = new int[3];\\n\\n        int left = 0;\\n        for (int right = 0; right < 2 * n; right++) {\\n            cnts[s.charAt(right % n) - \\'a\\']++;\\n            if (right < n) {\\n                continue;\\n            }\\n            while ((left < n || right == 2 * n - 1) && \\n                   (cnts[0] >= k && cnts[1] >= k && cnts[2] >= k) && \\n                   cnts[s.charAt(left % n) - \\'a\\'] > k) {\\n                cnts[s.charAt(left % n) - \\'a\\']--;\\n                left++;\\n            }\\n            min = Math.min(min, right - left + 1);\\n        }\\n        \\n        if (min == n + 1) {\\n            return -1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if (k == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length(), min = n + 1;\\n        int[] cnts = new int[3];\\n\\n        int left = 0;\\n        for (int right = 0; right < 2 * n; right++) {\\n            cnts[s.charAt(right % n) - \\'a\\']++;\\n            if (right < n) {\\n                continue;\\n            }\\n            while ((left < n || right == 2 * n - 1) && \\n                   (cnts[0] >= k && cnts[1] >= k && cnts[2] >= k) && \\n                   cnts[s.charAt(left % n) - \\'a\\'] > k) {\\n                cnts[s.charAt(left % n) - \\'a\\']--;\\n                left++;\\n            }\\n            min = Math.min(min, right - left + 1);\\n        }\\n        \\n        if (min == n + 1) {\\n            return -1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981998,
                "title": "a-few-solutions",
                "content": "We can perform a logarithmic amount of guesses to find the minimum threshold `T` sized sliding window.\\n\\n---\\n\\n*Kotlin*\\n```\\n// TODO: implement me\\n```\\n\\n*Javascript*\\n```\\nlet takeCharacters = (s, k) => {\\n    let cnt = new Map(Object.entries(_.countBy(s.split(\\'\\'))));\\n    if ((cnt.get(\\'a\\') || 0) < k || (cnt.get(\\'b\\') || 0) < k || (cnt.get(\\'c\\') || 0) < k)\\n        return -1;\\n    let N = s.length;\\n    let guess = T => {\\n        let m = new Map();\\n        let ok = () => k <= (m.get(\\'a\\') || 0) && k <= (m.get(\\'b\\') || 0) && k <= (m.get(\\'c\\') || 0);\\n        let i = 0,\\n            j = N;\\n        while (i < T)\\n            m.set(s[i], (m.get(s[i]) || 0) + 1), ++i;\\n        if (ok())\\n            return true;\\n        while (0 <= i - 1) {\\n            --i, m.set(s[i], (m.get(s[i]) || 0) - 1);\\n            --j, m.set(s[j], (m.get(s[j]) || 0) + 1);\\n            if (ok())\\n                return true;\\n        }\\n        return false;\\n    };\\n    let i = 0,\\n        j = N;\\n    while (i < j) {\\n        let T = Math.floor((i + j) / 2);\\n        if (guess(T))\\n            j = T;\\n        else\\n            i = T + 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        cnt = Counter(s)\\n        if cnt[\\'a\\'] < k or cnt[\\'b\\'] < k or cnt[\\'c\\'] < k:\\n            return -1\\n        N = len(s)\\n        def guess(T, i = 0):\\n            m, ok = Counter(), lambda: k <= m[\\'a\\'] and k <= m[\\'b\\'] and k <= m[\\'c\\']\\n            while i < T:\\n                m[s[i]] += 1; i += 1\\n            if ok():\\n                return True\\n            i, j = i - 1, N - 1\\n            while 0 <= i:\\n                m[s[i]] -= 1; i -= 1\\n                m[s[j]] += 1; j -= 1\\n                if ok():\\n                    return True\\n            return False\\n        i, j = 0, N\\n        while i < j:\\n            T = (i + j) // 2\\n            if guess(T):\\n                j = T\\n            else:\\n                i = T + 1\\n        return i\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int takeCharacters(string s, int k, Map cnt = {}) {\\n        for (auto c: s)\\n            ++cnt[c];\\n        if (cnt[\\'a\\'] < k || cnt[\\'b\\'] < k || cnt[\\'c\\'] < k)\\n            return -1;\\n        int N = s.size();\\n        auto guess = [&](auto T) {\\n            Map m;\\n            auto ok = [&]() { return k <= m[\\'a\\'] && k <= m[\\'b\\'] && k <= m[\\'c\\']; };\\n            auto i = 0,\\n                 j = N;\\n            while (i < T)\\n                ++m[s[i++]];\\n            if (ok())\\n                return true;\\n            while (0 <= i - 1) {\\n                --m[s[--i]];\\n                ++m[s[--j]];\\n                if (ok())\\n                    return true;\\n            }\\n            return false;\\n        };\\n        auto i = 0,\\n             j = N;\\n        while (i < j) {\\n            auto T = (i + j) / 2;\\n            if (guess(T))\\n                j = T;\\n            else\\n                i = T + 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// TODO: implement me\\n```\n```\\nlet takeCharacters = (s, k) => {\\n    let cnt = new Map(Object.entries(_.countBy(s.split(\\'\\'))));\\n    if ((cnt.get(\\'a\\') || 0) < k || (cnt.get(\\'b\\') || 0) < k || (cnt.get(\\'c\\') || 0) < k)\\n        return -1;\\n    let N = s.length;\\n    let guess = T => {\\n        let m = new Map();\\n        let ok = () => k <= (m.get(\\'a\\') || 0) && k <= (m.get(\\'b\\') || 0) && k <= (m.get(\\'c\\') || 0);\\n        let i = 0,\\n            j = N;\\n        while (i < T)\\n            m.set(s[i], (m.get(s[i]) || 0) + 1), ++i;\\n        if (ok())\\n            return true;\\n        while (0 <= i - 1) {\\n            --i, m.set(s[i], (m.get(s[i]) || 0) - 1);\\n            --j, m.set(s[j], (m.get(s[j]) || 0) + 1);\\n            if (ok())\\n                return true;\\n        }\\n        return false;\\n    };\\n    let i = 0,\\n        j = N;\\n    while (i < j) {\\n        let T = Math.floor((i + j) / 2);\\n        if (guess(T))\\n            j = T;\\n        else\\n            i = T + 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        cnt = Counter(s)\\n        if cnt[\\'a\\'] < k or cnt[\\'b\\'] < k or cnt[\\'c\\'] < k:\\n            return -1\\n        N = len(s)\\n        def guess(T, i = 0):\\n            m, ok = Counter(), lambda: k <= m[\\'a\\'] and k <= m[\\'b\\'] and k <= m[\\'c\\']\\n            while i < T:\\n                m[s[i]] += 1; i += 1\\n            if ok():\\n                return True\\n            i, j = i - 1, N - 1\\n            while 0 <= i:\\n                m[s[i]] -= 1; i -= 1\\n                m[s[j]] += 1; j -= 1\\n                if ok():\\n                    return True\\n            return False\\n        i, j = 0, N\\n        while i < j:\\n            T = (i + j) // 2\\n            if guess(T):\\n                j = T\\n            else:\\n                i = T + 1\\n        return i\\n```\n```\\n// TODO: implement me\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int takeCharacters(string s, int k, Map cnt = {}) {\\n        for (auto c: s)\\n            ++cnt[c];\\n        if (cnt[\\'a\\'] < k || cnt[\\'b\\'] < k || cnt[\\'c\\'] < k)\\n            return -1;\\n        int N = s.size();\\n        auto guess = [&](auto T) {\\n            Map m;\\n            auto ok = [&]() { return k <= m[\\'a\\'] && k <= m[\\'b\\'] && k <= m[\\'c\\']; };\\n            auto i = 0,\\n                 j = N;\\n            while (i < T)\\n                ++m[s[i++]];\\n            if (ok())\\n                return true;\\n            while (0 <= i - 1) {\\n                --m[s[--i]];\\n                ++m[s[--j]];\\n                if (ok())\\n                    return true;\\n            }\\n            return false;\\n        };\\n        auto i = 0,\\n             j = N;\\n        while (i < j) {\\n            auto T = (i + j) / 2;\\n            if (guess(T))\\n                j = T;\\n            else\\n                i = T + 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980157,
                "title": "swift-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe most difficult part is comes to the idea can convert this problem to sliding window question: \\nfind the longest substring consist of \"a\", \"b\", \"c\", each character count up to total count - k\\n\\nBecause we want to leave enough count of \"a\", \"b\", \"c\" to fulfill the requirement, take left or take right each time, left window and right window count of character summary >= k\\n\\n# Code\\n```\\n/*\\n    ------------------\\n    ----        ------\\n     ^-------------^\\n        anagram: [a: x, b: y, c: z], x >= k, y >= k, z >= k\\n\\n        --------\\n            ^: longest window [a: x, b: y, c: z] at most total - k\\n */\\nclass Solution {\\n    func takeCharacters(_ s: String, _ k: Int) -> Int {\\n        var anagram: [Character: Int] = [\\n            \"a\": 0,\\n            \"b\": 0,\\n            \"c\": 0\\n        ]\\n        s.forEach {\\n            anagram[$0, default: 0] += 1\\n        }\\n        guard anagram.allSatisfy ({\\n            $0.value >= k\\n        }) else { return -1 }\\n        \\n        return takeCharacters(Array(s), k, anagram)\\n    }\\n    \\n    func takeCharacters(_ s: [Character], _ k: Int, _ anagram: [Character: Int]) -> Int {\\n        var windowAnagarm: [Character: Int] = [\\n            \"a\": 0,\\n            \"b\": 0,\\n            \"c\": 0\\n        ]\\n        var i = 0\\n        var maxLength = 0\\n        for j in 0..<s.count {\\n            windowAnagarm[s[j], default: 0] += 1\\n            if windowAnagarm.allSatisfy({ $0.value <= anagram[$0.key, default: 0] - k }) {\\n                maxLength = max(maxLength, j - i + 1)\\n            } else {\\n                windowAnagarm[s[i], default: 0] -= 1\\n                i += 1\\n            }\\n        }\\n        return s.count - maxLength\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\n    ------------------\\n    ----        ------\\n     ^-------------^\\n        anagram: [a: x, b: y, c: z], x >= k, y >= k, z >= k\\n\\n        --------\\n            ^: longest window [a: x, b: y, c: z] at most total - k\\n */\\nclass Solution {\\n    func takeCharacters(_ s: String, _ k: Int) -> Int {\\n        var anagram: [Character: Int] = [\\n            \"a\": 0,\\n            \"b\": 0,\\n            \"c\": 0\\n        ]\\n        s.forEach {\\n            anagram[$0, default: 0] += 1\\n        }\\n        guard anagram.allSatisfy ({\\n            $0.value >= k\\n        }) else { return -1 }\\n        \\n        return takeCharacters(Array(s), k, anagram)\\n    }\\n    \\n    func takeCharacters(_ s: [Character], _ k: Int, _ anagram: [Character: Int]) -> Int {\\n        var windowAnagarm: [Character: Int] = [\\n            \"a\": 0,\\n            \"b\": 0,\\n            \"c\": 0\\n        ]\\n        var i = 0\\n        var maxLength = 0\\n        for j in 0..<s.count {\\n            windowAnagarm[s[j], default: 0] += 1\\n            if windowAnagarm.allSatisfy({ $0.value <= anagram[$0.key, default: 0] - k }) {\\n                maxLength = max(maxLength, j - i + 1)\\n            } else {\\n                windowAnagarm[s[i], default: 0] -= 1\\n                i += 1\\n            }\\n        }\\n        return s.count - maxLength\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976201,
                "title": "fairly-simple-o-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if(k==0)return 0;\\n        char [] arr = s.toCharArray();\\n        int l = s.length();\\n        ArrayList<Integer> list_a = new ArrayList<>();\\n        ArrayList<Integer> list_b = new ArrayList<>();\\n        ArrayList<Integer> list_c = new ArrayList<>();\\n        for(int i = 0;i<l;i++){\\n            char c = arr[i];\\n            if(c==\\'a\\')list_a.add(i);\\n            else if(c==\\'b\\')list_b.add(i);\\n            else list_c.add(i);\\n        }\\n        if(list_a.size()< k || list_b.size()<k || list_c.size()<k)return -1;\\n        int ans = Integer.MAX_VALUE,count_a = 0,count_b = 0,count_c = 0;\\n        int a2_right = count_a<k?l - list_a.get(list_a.size() - (k-count_a)):0;\\n        int b2_right = count_b<k?l - list_b.get(list_b.size() - (k-count_b)):0;\\n        int c2_right = count_c<k?l - list_c.get(list_c.size() - (k-count_c)):0;\\n        ans = Math.min(Math.max(a2_right,Math.max(b2_right,c2_right)),ans);\\n        for(int i = 0;i<l;i++){\\n            char c = arr[i];\\n            if(c==\\'a\\')count_a++;\\n            else if(c==\\'b\\')count_b++;\\n            else count_c++;\\n            int a_right = count_a<k?l - list_a.get(list_a.size() - (k-count_a)):0;\\n            int b_right = count_b<k?l - list_b.get(list_b.size() - (k-count_b)):0;\\n            int c_right = count_c<k?l - list_c.get(list_c.size() - (k-count_c)):0;\\n            ans = Math.min(i + 1 + Math.max(a_right,Math.max(b_right,c_right)),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int takeCharacters(String s, int k) {\\n        if(k==0)return 0;\\n        char [] arr = s.toCharArray();\\n        int l = s.length();\\n        ArrayList<Integer> list_a = new ArrayList<>();\\n        ArrayList<Integer> list_b = new ArrayList<>();\\n        ArrayList<Integer> list_c = new ArrayList<>();\\n        for(int i = 0;i<l;i++){\\n            char c = arr[i];\\n            if(c==\\'a\\')list_a.add(i);\\n            else if(c==\\'b\\')list_b.add(i);\\n            else list_c.add(i);\\n        }\\n        if(list_a.size()< k || list_b.size()<k || list_c.size()<k)return -1;\\n        int ans = Integer.MAX_VALUE,count_a = 0,count_b = 0,count_c = 0;\\n        int a2_right = count_a<k?l - list_a.get(list_a.size() - (k-count_a)):0;\\n        int b2_right = count_b<k?l - list_b.get(list_b.size() - (k-count_b)):0;\\n        int c2_right = count_c<k?l - list_c.get(list_c.size() - (k-count_c)):0;\\n        ans = Math.min(Math.max(a2_right,Math.max(b2_right,c2_right)),ans);\\n        for(int i = 0;i<l;i++){\\n            char c = arr[i];\\n            if(c==\\'a\\')count_a++;\\n            else if(c==\\'b\\')count_b++;\\n            else count_c++;\\n            int a_right = count_a<k?l - list_a.get(list_a.size() - (k-count_a)):0;\\n            int b_right = count_b<k?l - list_b.get(list_b.size() - (k-count_b)):0;\\n            int c_right = count_c<k?l - list_c.get(list_c.size() - (k-count_c)):0;\\n            ans = Math.min(i + 1 + Math.max(a_right,Math.max(b_right,c_right)),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976078,
                "title": "c-sliding-window-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n       int na=0;\\n       int nb=0;\\n       int nc=0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i]==\\'a\\') na++;\\n           if(s[i]==\\'b\\') nb++;\\n           if(s[i]==\\'c\\') nc++;\\n       } \\n\\n       if(na<k || nb<k || nc<k) return -1;\\n\\n       na-=k;\\n       nb-=k;\\n       nc-=k;\\n\\n       int ans=INT_MAX;\\n\\n       int i=0;\\n       int j=0;\\n\\n       int nna=0;\\n       int nnb=0;\\n       int nnc=0;\\n       int n=s.length();\\n\\n       while(j<s.length())\\n       {\\n           if(s[j]==\\'a\\') nna++;\\n           else if(s[j]==\\'b\\') nnb++;\\n           else nnc++;\\n\\n           if(nna<=na && nnb<=nb && nnc<=nc)\\n           {\\n               ans=min(ans,n-(j-i+1));\\n           }\\n           else \\n           {\\n               while(i<=j && (nna>na || nnb>nb || nnc>nc))\\n               {\\n                   if(s[i]==\\'a\\')nna--;\\n                   else if(s[i]==\\'b\\')nnb--;\\n                   else nnc--;\\n\\n                   i++;\\n               }\\n               ans=min(ans,n-(j-i+1));\\n           }\\n\\n           j++;\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n       int na=0;\\n       int nb=0;\\n       int nc=0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i]==\\'a\\') na++;\\n           if(s[i]==\\'b\\') nb++;\\n           if(s[i]==\\'c\\') nc++;\\n       } \\n\\n       if(na<k || nb<k || nc<k) return -1;\\n\\n       na-=k;\\n       nb-=k;\\n       nc-=k;\\n\\n       int ans=INT_MAX;\\n\\n       int i=0;\\n       int j=0;\\n\\n       int nna=0;\\n       int nnb=0;\\n       int nnc=0;\\n       int n=s.length();\\n\\n       while(j<s.length())\\n       {\\n           if(s[j]==\\'a\\') nna++;\\n           else if(s[j]==\\'b\\') nnb++;\\n           else nnc++;\\n\\n           if(nna<=na && nnb<=nb && nnc<=nc)\\n           {\\n               ans=min(ans,n-(j-i+1));\\n           }\\n           else \\n           {\\n               while(i<=j && (nna>na || nnb>nb || nnc>nc))\\n               {\\n                   if(s[i]==\\'a\\')nna--;\\n                   else if(s[i]==\\'b\\')nnb--;\\n                   else nnc--;\\n\\n                   i++;\\n               }\\n               ans=min(ans,n-(j-i+1));\\n           }\\n\\n           j++;\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975425,
                "title": "binary-serach-solution-c-simple",
                "content": "# Prerequisite:   Binary search   \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwe want minimum minutes to collect each char at least k times . So for minimum minutes we go gor binary search and for each mid (as our ans we check whether we can collect each char at least k or not ,  acc to our ans we shifted our low and high )    \\n <!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    //this function tells us whether we can choose atleast each char k times within mid minutes  \\n    bool CAN(string &s,int k,int mid)\\n    {\\n        int n = s.length() , a = 0 , b = 0 , c = 0 ;\\n        \\n        // get the count of each character within mid min   \\n        for( int i = 0;i<mid;i++)\\n        {\\n            if(s[i] == \\'a\\') a++;\\n            if(s[i] == \\'b\\') b++;\\n            if(s[i] == \\'c\\') c++;\\n        }\\n        \\n        if(a>=k && b>=k && c>=k ) return true;\\n        \\n        //    < - - - - mid - - - - - - > \\n        //    < - - - mid   - - - - - - > \\n        //    < - - mid  - - - - - - -  > \\n        //    < - mid  - - - - - - - -  > \\n        //    < mid   - - - - - - - - - > \\n        \\n\\n        int j = n-1 , i = mid-1 ;  \\n        \\n        while(i>=0 )\\n        {\\n            if(s[i] == \\'a\\') a--;\\n            if(s[i] == \\'b\\') b--;\\n            if(s[i] == \\'c\\') c--;\\n            \\n            if(s[j] == \\'a\\') a++;\\n            if(s[j] == \\'b\\') b++;\\n            if(s[j] == \\'c\\') c++;\\n            \\n            if(a>=k && b>=k && c>=k ) return true;\\n\\n            i--;\\n            j--;\\n               \\n        }\\n        \\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        \\n        \\n        if(k ==  0 ) return 0;\\n        int a = 0, b= 0, c= 0   , n = s.length();\\n        for(char i:s)\\n        {\\n            if(i == \\'a\\')a++;\\n            if(i == \\'b\\')b++;\\n            if(i == \\'c\\')c++;\\n        }\\n        // one pass for ans exist or not i.e we can choose atleast k char each in given string   \\n        if(a<k || b<k || c<k) return -1;\\n        \\n        // value of var low must be greater than 3*k (why? : k for a + k for b + k for c == 3*k  )\\n        int low = 3*k ,  high =  n ,ans = 0 ;\\n        \\n        // Binary search \\n        while(low <= high)\\n        {\\n            int mid = low+(high-low)/2 ; \\n            \\n            if(CAN(s,k,mid))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n            low = mid+1 ;\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //this function tells us whether we can choose atleast each char k times within mid minutes  \\n    bool CAN(string &s,int k,int mid)\\n    {\\n        int n = s.length() , a = 0 , b = 0 , c = 0 ;\\n        \\n        // get the count of each character within mid min   \\n        for( int i = 0;i<mid;i++)\\n        {\\n            if(s[i] == \\'a\\') a++;\\n            if(s[i] == \\'b\\') b++;\\n            if(s[i] == \\'c\\') c++;\\n        }\\n        \\n        if(a>=k && b>=k && c>=k ) return true;\\n        \\n        //    < - - - - mid - - - - - - > \\n        //    < - - - mid   - - - - - - > \\n        //    < - - mid  - - - - - - -  > \\n        //    < - mid  - - - - - - - -  > \\n        //    < mid   - - - - - - - - - > \\n        \\n\\n        int j = n-1 , i = mid-1 ;  \\n        \\n        while(i>=0 )\\n        {\\n            if(s[i] == \\'a\\') a--;\\n            if(s[i] == \\'b\\') b--;\\n            if(s[i] == \\'c\\') c--;\\n            \\n            if(s[j] == \\'a\\') a++;\\n            if(s[j] == \\'b\\') b++;\\n            if(s[j] == \\'c\\') c++;\\n            \\n            if(a>=k && b>=k && c>=k ) return true;\\n\\n            i--;\\n            j--;\\n               \\n        }\\n        \\n        return false;\\n    }\\n    int takeCharacters(string s, int k) {\\n        \\n        \\n        if(k ==  0 ) return 0;\\n        int a = 0, b= 0, c= 0   , n = s.length();\\n        for(char i:s)\\n        {\\n            if(i == \\'a\\')a++;\\n            if(i == \\'b\\')b++;\\n            if(i == \\'c\\')c++;\\n        }\\n        // one pass for ans exist or not i.e we can choose atleast k char each in given string   \\n        if(a<k || b<k || c<k) return -1;\\n        \\n        // value of var low must be greater than 3*k (why? : k for a + k for b + k for c == 3*k  )\\n        int low = 3*k ,  high =  n ,ans = 0 ;\\n        \\n        // Binary search \\n        while(low <= high)\\n        {\\n            int mid = low+(high-low)/2 ; \\n            \\n            if(CAN(s,k,mid))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n            low = mid+1 ;\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975401,
                "title": "binarysearch-easy-elegant-time-complexity-o-nlogn-space-complexity-o-1",
                "content": "```\\nbool isPossible(int &currLen,string &s,int &k){\\n    int freq[3]; memset(freq,0,sizeof(freq));\\n    for(int i=0;i<currLen;i++){\\n        freq[s[i]-\\'a\\']++;\\n        if(freq[0]>=k and freq[1]>=k and freq[2]>=k)\\n            return true;\\n    }\\n    \\n    int j = s.size()-1;\\n    int i = currLen-1;\\n    while(i>=0){\\n        freq[s[i]-\\'a\\']--;\\n        i--;\\n        freq[s[j]-\\'a\\']++;\\n        j--;\\n        if(freq[0]>=k and freq[1]>=k and freq[2]>=k)\\n            return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        if(k==0) return 0;\\n        int low=1,high=n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(isPossible(mid,s,k))\\n                high=mid;\\n            else\\n                low=mid;\\n            if(high-low==1) break;\\n        }\\n        \\n        if(isPossible(low,s,k))\\n            return low;\\n        else if(isPossible(high,s,k))\\n        return high;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(int &currLen,string &s,int &k){\\n    int freq[3]; memset(freq,0,sizeof(freq));\\n    for(int i=0;i<currLen;i++){\\n        freq[s[i]-\\'a\\']++;\\n        if(freq[0]>=k and freq[1]>=k and freq[2]>=k)\\n            return true;\\n    }\\n    \\n    int j = s.size()-1;\\n    int i = currLen-1;\\n    while(i>=0){\\n        freq[s[i]-\\'a\\']--;\\n        i--;\\n        freq[s[j]-\\'a\\']++;\\n        j--;\\n        if(freq[0]>=k and freq[1]>=k and freq[2]>=k)\\n            return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n = s.size();\\n        if(k==0) return 0;\\n        int low=1,high=n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(isPossible(mid,s,k))\\n                high=mid;\\n            else\\n                low=mid;\\n            if(high-low==1) break;\\n        }\\n        \\n        if(isPossible(low,s,k))\\n            return low;\\n        else if(isPossible(high,s,k))\\n        return high;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975113,
                "title": "python-sliding-window-explained",
                "content": "# Intuition\\n We can search for the longest substring that if we remove from s \\n        we would still have at least k occurences of each letters in \\'a\\', \\'b\\', \\'c\\'\\n\\n    similar problem = 1658. Minimum Operations to Reduce X to Zero\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Length of S) = O(N) Time complexity\\n\\n- Space complexity:\\nO(1) Space complexity as we are keeping a dictionary of 3 letters only\\n\\n\\n# Code\\n```\\n#Baraa\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        c = collections.Counter(s)\\n        if c[\\'a\\'] < k or c[\\'b\\'] < k or c[\\'c\\'] < k:\\n            return -1\\n        target_c = target_a = target_b = k\\n        window_start = 0\\n        longest_window = 0\\n        for window_end, letter in enumerate(s):\\n            c[letter] -= 1\\n            while c[\\'a\\'] < target_a or c[\\'b\\'] < target_b or c[\\'c\\'] < target_c:\\n                l = s[window_start]\\n                c[l] += 1\\n                window_start += 1\\n            longest_window = max(longest_window, window_end - window_start + 1)\\n        return len(s) - longest_window\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        c = collections.Counter(s)\\n        if c[\\'a\\'] < k or c[\\'b\\'] < k or c[\\'c\\'] < k:\\n            return -1\\n        target_c = target_a = target_b = k\\n        window_start = 0\\n        longest_window = 0\\n        for window_end, letter in enumerate(s):\\n            c[letter] -= 1\\n            while c[\\'a\\'] < target_a or c[\\'b\\'] < target_b or c[\\'c\\'] < target_c:\\n                l = s[window_start]\\n                c[l] += 1\\n                window_start += 1\\n            longest_window = max(longest_window, window_end - window_start + 1)\\n        return len(s) - longest_window\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971614,
                "title": "sliding-window-two-pointers-c-step-by-step-explanation",
                "content": "```\\n //TAG:Sliding Excluding Window\\n //IDEA:\\n        //Count all characters. & Exclude those characters that don\\'t have an impact\\n        //on the condition given in problem statement by taking them inside a window.\\n\\t\\t//Here a sliding window represents the characters that must be excluded.\\n        //Try to maximize the width of window so that we willl have to minimize the operations.\\n\\t\\t\\n\\t\\t//Step by Step Explaination Below:\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n\\t\\n        int i=0,j=0,n=s.length();\\n\\t\\t//here i is the end point of the window. \\n\\t\\t// j is the starting point of the window.\\n\\t\\t//i will include the characters in the window.\\n\\t\\t//j will exclude the character in the window.\\n        int res=0;\\n        \\n        //count array represents the number of a,b,& c\\'s included in our\\n        //ans for the current value of i & j;\\n        vector<int> cnt(3,0);\\n        for(auto i:s){\\n            cnt[i-\\'a\\']++;\\n        }\\n        \\n        //edge case to check if all character have at least k occurences or not.\\n        if(*min_element(cnt.begin(),cnt.end())<k)return -1;\\n        \\n        for(i=0;i<n;i++){\\n            \\n            //since i is the end of window.\\n            //it will include the current character to exclusion window.\\n            cnt[s[i]-\\'a\\']--;\\n            \\n            //if count of current character becomes less than k then \\n            //we will shrink the window.\\n            \\n            if(cnt[s[i]-\\'a\\']<k){\\n                //Shrink means j(the start point of window) will move towards i & keep excluding the elements in between (that have been included in window earlier by i ) until count of all characters becomes at least k\\n            //the length of this type of each window(i-j+1) will represent one of the many possible excluded windows.\\n            //out of all those we will choose the window with max size that meets the given criteria.\\n            //so that excluding max characters will lead to min opertaions.\\n                while(cnt[s[i]-\\'a\\']<k){\\n                    cnt[s[j]-\\'a\\']++;\\n                    j++;\\n                }\\n            }\\n            res=max(res,i-j+1);\\n        }\\n        return n-res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n //TAG:Sliding Excluding Window\\n //IDEA:\\n        //Count all characters. & Exclude those characters that don\\'t have an impact\\n        //on the condition given in problem statement by taking them inside a window.\\n\\t\\t//Here a sliding window represents the characters that must be excluded.\\n        //Try to maximize the width of window so that we willl have to minimize the operations.\\n\\t\\t\\n\\t\\t//Step by Step Explaination Below:\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n\\t\\n        int i=0,j=0,n=s.length();\\n\\t\\t//here i is the end point of the window. \\n\\t\\t// j is the starting point of the window.\\n\\t\\t//i will include the characters in the window.\\n\\t\\t//j will exclude the character in the window.\\n        int res=0;\\n        \\n        //count array represents the number of a,b,& c\\'s included in our\\n        //ans for the current value of i & j;\\n        vector<int> cnt(3,0);\\n        for(auto i:s){\\n            cnt[i-\\'a\\']++;\\n        }\\n        \\n        //edge case to check if all character have at least k occurences or not.\\n        if(*min_element(cnt.begin(),cnt.end())<k)return -1;\\n        \\n        for(i=0;i<n;i++){\\n            \\n            //since i is the end of window.\\n            //it will include the current character to exclusion window.\\n            cnt[s[i]-\\'a\\']--;\\n            \\n            //if count of current character becomes less than k then \\n            //we will shrink the window.\\n            \\n            if(cnt[s[i]-\\'a\\']<k){\\n                //Shrink means j(the start point of window) will move towards i & keep excluding the elements in between (that have been included in window earlier by i ) until count of all characters becomes at least k\\n            //the length of this type of each window(i-j+1) will represent one of the many possible excluded windows.\\n            //out of all those we will choose the window with max size that meets the given criteria.\\n            //so that excluding max characters will lead to min opertaions.\\n                while(cnt[s[i]-\\'a\\']<k){\\n                    cnt[s[j]-\\'a\\']++;\\n                    j++;\\n                }\\n            }\\n            res=max(res,i-j+1);\\n        }\\n        return n-res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970819,
                "title": "shrinking-window-reverse-strategy-c",
                "content": "Instead of choosing characters from front and end, we try to maximize the length of the window in the middle such that it contains atmost frequency - k occurence of a b and c.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        int arr[3]{0};\\n        for(auto i:s) arr[i-\\'a\\']++;\\n        for(int i=0;i<3;i++) if(arr[i]<k) return -1;\\n\\n        int maxi=INT_MIN;\\n        int l=0, r=0;\\n        while(r<n){\\n            while(arr[s[r]-\\'a\\']<=k) arr[s[l++]-\\'a\\']++;\\n            if(arr[s[r]-\\'a\\']<=k) break;\\n            arr[s[r]-\\'a\\']--;\\n            maxi=max(maxi,r-l+1);\\n            r++;\\n        }\\n\\n        return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int n=s.size();\\n        int arr[3]{0};\\n        for(auto i:s) arr[i-\\'a\\']++;\\n        for(int i=0;i<3;i++) if(arr[i]<k) return -1;\\n\\n        int maxi=INT_MIN;\\n        int l=0, r=0;\\n        while(r<n){\\n            while(arr[s[r]-\\'a\\']<=k) arr[s[l++]-\\'a\\']++;\\n            if(arr[s[r]-\\'a\\']<=k) break;\\n            arr[s[r]-\\'a\\']--;\\n            maxi=max(maxi,r-l+1);\\n            r++;\\n        }\\n\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970365,
                "title": "tow-pointer-or-sliding-window-c",
                "content": "# Intuition\\nSimply we find the substring which contains the maximum extra a\\'s, b\\'s and c\\'s using sliding window approch\\n\\n# Approach\\nSliding Window.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a=count(s.begin(),s.end(),\\'a\\'),b=count(s.begin(),s.end(),\\'b\\');\\n        int c=count(s.begin(),s.end(),\\'c\\');\\n        if(a<k||b<k||c<k){return -1;}\\n        int aa=0,bb=0,cc=0;\\n        //extra character\\n        int wa=a-k,wb=b-k,wc=c-k;\\n        int i=0,j=0;int ans=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'a\\'){aa++;}\\n            if(s[j]==\\'b\\'){bb++;}\\n            if(s[j]==\\'c\\'){cc++;}\\n            while(wa<aa||wb<bb||wc<cc){\\n                if(s[i]==\\'a\\'){aa--;}\\n                if(s[i]==\\'b\\'){bb--;}\\n                if(s[i]==\\'c\\'){cc--;}\\n                i++;\\n            }\\n            //ans store the length of max substring\\n            ans=max(ans,j-i+1);j++;\\n        }\\n        //return length of left string\\n        return s.length()-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        int a=count(s.begin(),s.end(),\\'a\\'),b=count(s.begin(),s.end(),\\'b\\');\\n        int c=count(s.begin(),s.end(),\\'c\\');\\n        if(a<k||b<k||c<k){return -1;}\\n        int aa=0,bb=0,cc=0;\\n        //extra character\\n        int wa=a-k,wb=b-k,wc=c-k;\\n        int i=0,j=0;int ans=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'a\\'){aa++;}\\n            if(s[j]==\\'b\\'){bb++;}\\n            if(s[j]==\\'c\\'){cc++;}\\n            while(wa<aa||wb<bb||wc<cc){\\n                if(s[i]==\\'a\\'){aa--;}\\n                if(s[i]==\\'b\\'){bb--;}\\n                if(s[i]==\\'c\\'){cc--;}\\n                i++;\\n            }\\n            //ans store the length of max substring\\n            ans=max(ans,j-i+1);j++;\\n        }\\n        //return length of left string\\n        return s.length()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969226,
                "title": "97-mem-efficient-90-faster-cpp-solution-two-pointer-first-from-left-and-simultaneously-from-right",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return k;\\n        int l=0,r=s.size();\\n        int a=0,b=0,c=0,t=0,res=INT_MAX;\\n        while(l<s.size()){\\n            switch(s[l]){\\n                case \\'a\\':\\n                    a++;\\n                    if(a==k)t++;\\n                break;\\n                case \\'b\\':\\n                    b++;\\n                    if(b==k)t++;\\n                break;\\n                case \\'c\\':\\n                    c++;\\n                    if(c==k)t++;\\n                break;\\n            }\\n            if(t==3)break;\\n            l++;\\n        }\\n        if(l==s.size()&&t!=3)return -1;//cout << l << \" \" << c << \"\\\\n\";\\n        res = (res < l+1+s.size()-r ? res : l+1+s.size()-r);\\n        r--;\\n        while(r>0&&l>0){\\n            //cout << \"l : \" << l << \", r : \" << r << \", a : \" << a << \", b : \" << b << \", c : \" << c << \"\\\\n\";\\n            if(s[l]==\\'a\\'&&a==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else if(s[l]==\\'b\\'&&b==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else if(s[l]==\\'c\\'&&c==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else{\\n                if(s[l]==\\'a\\'){\\n                    a--;\\n                }else if(s[l]==\\'b\\'){\\n                    b--;\\n                }else{\\n                    c--;\\n                }\\n                l--;\\n            }\\n            res = (res < l+1+s.size()-r ? res : l+1+s.size()-r-1);\\n        }\\n        r = s.size()-1;\\n        a=0;b=0;c=0;t=0;\\n        while(r>=0){\\n            switch(s[r]){\\n                case \\'a\\':\\n                    a++;\\n                    if(a==k)t++;\\n                break;\\n                case \\'b\\':\\n                    b++;\\n                    if(b==k)t++;\\n                break;\\n                case \\'c\\':\\n                    c++;\\n                    if(c==k)t++;\\n                break;\\n            }\\n            if(t==3)break;\\n            r--;\\n        }\\n        res = (res < s.size()-r ? res : s.size()-r);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k==0)return k;\\n        int l=0,r=s.size();\\n        int a=0,b=0,c=0,t=0,res=INT_MAX;\\n        while(l<s.size()){\\n            switch(s[l]){\\n                case \\'a\\':\\n                    a++;\\n                    if(a==k)t++;\\n                break;\\n                case \\'b\\':\\n                    b++;\\n                    if(b==k)t++;\\n                break;\\n                case \\'c\\':\\n                    c++;\\n                    if(c==k)t++;\\n                break;\\n            }\\n            if(t==3)break;\\n            l++;\\n        }\\n        if(l==s.size()&&t!=3)return -1;//cout << l << \" \" << c << \"\\\\n\";\\n        res = (res < l+1+s.size()-r ? res : l+1+s.size()-r);\\n        r--;\\n        while(r>0&&l>0){\\n            //cout << \"l : \" << l << \", r : \" << r << \", a : \" << a << \", b : \" << b << \", c : \" << c << \"\\\\n\";\\n            if(s[l]==\\'a\\'&&a==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else if(s[l]==\\'b\\'&&b==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else if(s[l]==\\'c\\'&&c==k){\\n                while(r>=l&&s[l]!=s[r]){\\n                    if(s[r]==\\'a\\')a++;\\n                    else if(s[r]==\\'b\\')b++;\\n                    else\\n                        c++;\\n                    r--;\\n                }\\n                r--;\\n                l--;\\n            }else{\\n                if(s[l]==\\'a\\'){\\n                    a--;\\n                }else if(s[l]==\\'b\\'){\\n                    b--;\\n                }else{\\n                    c--;\\n                }\\n                l--;\\n            }\\n            res = (res < l+1+s.size()-r ? res : l+1+s.size()-r-1);\\n        }\\n        r = s.size()-1;\\n        a=0;b=0;c=0;t=0;\\n        while(r>=0){\\n            switch(s[r]){\\n                case \\'a\\':\\n                    a++;\\n                    if(a==k)t++;\\n                break;\\n                case \\'b\\':\\n                    b++;\\n                    if(b==k)t++;\\n                break;\\n                case \\'c\\':\\n                    c++;\\n                    if(c==k)t++;\\n                break;\\n            }\\n            if(t==3)break;\\n            r--;\\n        }\\n        res = (res < s.size()-r ? res : s.size()-r);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2968152,
                "title": "golang-4-ms-5-4-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nconst CharsCount = 3\\n\\nfunc takeCharacters(s string, k int) int {\\n\\tif k == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif len(s) < CharsCount*k {\\n\\t\\treturn -1\\n\\t}\\n\\tcounts := [CharsCount]int{}\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tcounts[s[i]-\\'a\\']++\\n\\t}\\n\\tvar fullChars int\\n\\tfor _, count := range counts {\\n\\t\\tif count >= k {\\n\\t\\t\\tfullChars++\\n\\t\\t}\\n\\t}\\n\\tif fullChars != CharsCount {\\n\\t\\treturn -1\\n\\t}\\n\\tresult := len(s)\\n\\tfor l, r := 0, 0; r < len(s); {\\n\\t\\tfor ; r < len(s) && fullChars == CharsCount; r++ {\\n\\t\\t\\tif counts[s[r]-\\'a\\'] == k {\\n\\t\\t\\t\\tfullChars--\\n\\t\\t\\t}\\n\\t\\t\\tcounts[s[r]-\\'a\\']--\\n\\t\\t}\\n\\t\\tw := len(s) - (r - l - 1)\\n\\t\\tif fullChars == CharsCount {\\n\\t\\t\\tw--\\n\\t\\t}\\n\\t\\tif w < result {\\n\\t\\t\\tresult = w\\n\\t\\t}\\n\\t\\tfor ; l < r && fullChars != CharsCount; l++ {\\n\\t\\t\\tcounts[s[l]-\\'a\\']++\\n\\t\\t\\tif counts[s[l]-\\'a\\'] == k {\\n\\t\\t\\t\\tfullChars++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst CharsCount = 3\\n\\nfunc takeCharacters(s string, k int) int {\\n\\tif k == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif len(s) < CharsCount*k {\\n\\t\\treturn -1\\n\\t}\\n\\tcounts := [CharsCount]int{}\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tcounts[s[i]-\\'a\\']++\\n\\t}\\n\\tvar fullChars int\\n\\tfor _, count := range counts {\\n\\t\\tif count >= k {\\n\\t\\t\\tfullChars++\\n\\t\\t}\\n\\t}\\n\\tif fullChars != CharsCount {\\n\\t\\treturn -1\\n\\t}\\n\\tresult := len(s)\\n\\tfor l, r := 0, 0; r < len(s); {\\n\\t\\tfor ; r < len(s) && fullChars == CharsCount; r++ {\\n\\t\\t\\tif counts[s[r]-\\'a\\'] == k {\\n\\t\\t\\t\\tfullChars--\\n\\t\\t\\t}\\n\\t\\t\\tcounts[s[r]-\\'a\\']--\\n\\t\\t}\\n\\t\\tw := len(s) - (r - l - 1)\\n\\t\\tif fullChars == CharsCount {\\n\\t\\t\\tw--\\n\\t\\t}\\n\\t\\tif w < result {\\n\\t\\t\\tresult = w\\n\\t\\t}\\n\\t\\tfor ; l < r && fullChars != CharsCount; l++ {\\n\\t\\t\\tcounts[s[l]-\\'a\\']++\\n\\t\\t\\tif counts[s[l]-\\'a\\'] == k {\\n\\t\\t\\t\\tfullChars++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967503,
                "title": "c-step-by-step-explained-with-comments",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint takeCharacters(string s, int k) {\\n\\t\\t\\tint a = 0, b = 0, c = 0;\\n\\t\\t\\tfor( int i = 0; i < s.size(); i++ ){   // count total no of a\\'s, b\\'s, c\\'s\\n\\t\\t\\t\\tif( s[i] == \\'a\\' ) a++;\\n\\t\\t\\t\\telse if( s[i] == \\'b\\' ) b++;\\n\\t\\t\\t\\telse if( s[i] == \\'c\\' ) c++;\\n\\t\\t\\t}\\n\\t\\t\\ta = a-k;   // remove total a\\'s - required\\n\\t\\t\\tb = b-k;   // remove total b\\'s - required\\n\\t\\t\\tc = c-k;   // remove total c\\'s - required\\n\\t\\t\\t\\n\\t\\t\\t// so after removing required we have a -> represents max no of a\\'s  possible ( upper limit )\\n\\t\\t\\t//  similarly for b and c we have upper limits i.e max no acceptable\\n\\t\\t\\t\\n\\t\\t\\tif( a<0 || b<0 || c<0 ) return -1;   // if we dont have even minimum  return -1;\\n\\t\\t\\t\\n\\t\\t\\tint ans = 0, len = 0;                     \\n\\t\\t\\tint pa = 0, pb = 0, pc = 0;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\t\\n\\t\\t\\tfor( int i = 0; i < s.size(); i++ ){\\n\\t\\t\\t\\tif( s[i] == \\'a\\' ) pa++;\\n\\t\\t\\t\\telse if( s[i] == \\'b\\' ) pb++;\\n\\t\\t\\t\\telse if( s[i] == \\'c\\' ) pc++;\\n            \\n\\t\\t\\t\\twhile( pa > a ){   // if count of \\'a\\' greater than upper limit start j pointer until count is acceptable \\n\\t\\t\\t\\t\\tif( s[j] == \\'a\\' ){\\n\\t\\t\\t\\t\\t\\tpa--; j++;      // if s[j] is \\'a\\' decrease count of \\'a\\'\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif( s[j] == \\'b\\' ) pb--;    // if s[j] is \\'b\\' decrease count of \\'b\\'\\n\\t\\t\\t\\t\\t\\telse pc--;                 // if s[j] is \\'c\\' decrease count of \\'c\\'\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n            \\n\\t\\t\\t\\twhile( pb > b ){     // similarly chech the condition for b\\n\\t\\t\\t\\t\\tif( s[j] == \\'b\\' ){\\n\\t\\t\\t\\t\\t\\tpb--; j++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif( s[j] == \\'a\\' ) pa--;\\n\\t\\t\\t\\t\\t\\telse pc--;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n            \\n\\t\\t\\t\\twhile( pc > c ){    // similarly check the condition for c\\n\\t\\t\\t\\t\\tif( s[j] == \\'c\\' ){\\n\\t\\t\\t\\t\\t\\tpc--; j++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif( s[j] == \\'a\\' ) pa--;\\n\\t\\t\\t\\t\\t\\telse pb--;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n            \\n\\t\\t\\t\\tans = max( ans, i-j+1 );     // store the max length of string \\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// we need to store the max length of string i.e is acceptable and meets the conditions because \\n\\t\\t\\t// if we remove minimum elements we get the resultant string of max length\\n\\t\\t\\t\\n\\t\\t\\t return s.size()-ans;  // remove ans (max length of string after removing required) from string length for result\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint takeCharacters(string s, int k) {\\n\\t\\t\\tint a = 0, b = 0, c = 0;\\n\\t\\t\\tfor( int i = 0; i < s.size(); i++ ){   // count total no of a\\'s, b\\'s, c\\'s\\n\\t\\t\\t\\tif( s[i] == \\'a\\' ) a++;\\n\\t\\t\\t\\telse if( s[i] == \\'b\\' ) b++;\\n\\t\\t\\t\\telse if( s[i] == \\'c\\' ) c++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2966927,
                "title": "implemented-using-binary-search-on-answers",
                "content": "# Intuition\\nIntution behind the idea is since we already know that in worst case what could be the possible answer which is the length of the string now our task is only to reduce the answer set in which binary search on answers fits the best.\\n# Approach\\nJust run the first loop to calculate the mid and just check if it is possible to have this answer? To calculate the if this answer is possible or not we only need to check in which of the window our answer may lie. \\n```\\nfor(int i = 0;i<=ans;i++) {\\n    int left = i;\\n    int right = (ans -i);\\n}\\n```\\nThe above loop is capable enough to generate the solution from left and right and use prefix sum to optimize the calculation.\\n\\nBenefit of using this if in further one asks that what are indices which are giving our answer from left and right we can answer.\\n\\n# Complexity\\n- Time complexity: **O(nlogn)** **logn** for the binary search and **n** for the loop on window\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** for prefix sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int& ans, string &s, int& k, vector<vector<int>>& prefix){\\n        for(int i = 0;i<=ans;i++){\\n            int left = i;\\n            int right = (ans -i);\\n            int a=0,b=0,c=0;\\n            if(left!=0){\\n                a=prefix[left-1][0];\\n                b=prefix[left-1][1];\\n                c=prefix[left-1][2];\\n            }\\n            if(right!=s.length()){\\n                a+=(prefix[s.length()-1][0]-prefix[s.length()-right-1][0]);\\n                b+=(prefix[s.length()-1][1]-prefix[s.length()-right-1][1]);\\n                c+=(prefix[s.length()-1][2]-prefix[s.length()-right-1][2]);\\n            }\\n            if(a>=k && b>=k && c>=k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int takeCharacters(string s, int k) {\\n        int i = 0;\\n        int j = s.length();\\n        int finalAns = INT_MAX;\\n        vector<vector<int>>prefix;\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n        for(char chr : s){\\n            if(chr==\\'a\\')\\n                a++;\\n            if(chr==\\'b\\')\\n                b++;\\n            if(chr==\\'c\\')\\n                c++;\\n            vector<int>v;\\n            v.push_back(a);\\n            v.push_back(b);\\n            v.push_back(c);\\n            prefix.push_back(v);\\n        }\\n        if(k==0)\\n            return 0;\\n        while(i<=j){\\n            int ans = i + (j-i)/2;\\n            if(isPossible(ans, s, k, prefix)){\\n                finalAns = min(finalAns, ans);\\n                j = ans - 1;\\n            }else{\\n                i = ans + 1;\\n            }\\n        }\\n        return finalAns==INT_MAX?-1:finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor(int i = 0;i<=ans;i++) {\\n    int left = i;\\n    int right = (ans -i);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int& ans, string &s, int& k, vector<vector<int>>& prefix){\\n        for(int i = 0;i<=ans;i++){\\n            int left = i;\\n            int right = (ans -i);\\n            int a=0,b=0,c=0;\\n            if(left!=0){\\n                a=prefix[left-1][0];\\n                b=prefix[left-1][1];\\n                c=prefix[left-1][2];\\n            }\\n            if(right!=s.length()){\\n                a+=(prefix[s.length()-1][0]-prefix[s.length()-right-1][0]);\\n                b+=(prefix[s.length()-1][1]-prefix[s.length()-right-1][1]);\\n                c+=(prefix[s.length()-1][2]-prefix[s.length()-right-1][2]);\\n            }\\n            if(a>=k && b>=k && c>=k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int takeCharacters(string s, int k) {\\n        int i = 0;\\n        int j = s.length();\\n        int finalAns = INT_MAX;\\n        vector<vector<int>>prefix;\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n        for(char chr : s){\\n            if(chr==\\'a\\')\\n                a++;\\n            if(chr==\\'b\\')\\n                b++;\\n            if(chr==\\'c\\')\\n                c++;\\n            vector<int>v;\\n            v.push_back(a);\\n            v.push_back(b);\\n            v.push_back(c);\\n            prefix.push_back(v);\\n        }\\n        if(k==0)\\n            return 0;\\n        while(i<=j){\\n            int ans = i + (j-i)/2;\\n            if(isPossible(ans, s, k, prefix)){\\n                finalAns = min(finalAns, ans);\\n                j = ans - 1;\\n            }else{\\n                i = ans + 1;\\n            }\\n        }\\n        return finalAns==INT_MAX?-1:finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966827,
                "title": "simple-cpp-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // Solution with explanation \\n    int takeCharacters(string s, int k) {\\n       // take out the maximum count of a, b and c\\n        map<char,int> mp,count;\\n        for(auto ch : s) mp[ch]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        // take maximum of a, b and c we can have in a substring if we remove k terms of each\\n        int max_a = mp[\\'a\\']-k, max_b = mp[\\'b\\']-k, max_c = mp[\\'c\\']-k;\\n        // traverse the string and take maximum till the max of a, b and c condition satisfied\\n        int left=0,right=0,max_l=0;\\n        for(auto x : s){\\n            count[x]++;\\n            right++;\\n            while(count[\\'a\\']>max_a || count[\\'b\\']>max_b || count[\\'c\\']>max_c){\\n                count[s[left]]--;\\n                left++;\\n            }\\n            max_l=max(max_l,right-left);\\n        }\\n        return s.length()-max_l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solution with explanation \\n    int takeCharacters(string s, int k) {\\n       // take out the maximum count of a, b and c\\n        map<char,int> mp,count;\\n        for(auto ch : s) mp[ch]++;\\n        if(mp[\\'a\\']<k || mp[\\'b\\']<k || mp[\\'c\\']<k) return -1;\\n        // take maximum of a, b and c we can have in a substring if we remove k terms of each\\n        int max_a = mp[\\'a\\']-k, max_b = mp[\\'b\\']-k, max_c = mp[\\'c\\']-k;\\n        // traverse the string and take maximum till the max of a, b and c condition satisfied\\n        int left=0,right=0,max_l=0;\\n        for(auto x : s){\\n            count[x]++;\\n            right++;\\n            while(count[\\'a\\']>max_a || count[\\'b\\']>max_b || count[\\'c\\']>max_c){\\n                count[s[left]]--;\\n                left++;\\n            }\\n            max_l=max(max_l,right-left);\\n        }\\n        return s.length()-max_l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966446,
                "title": "python-storing-suffix-maps",
                "content": "approach : we need some part from left and some from right so,\\nwe will store the counts as keys and index as values \\nthat means from end till  i there are ```ca,cb,cc``` count  ```a,b,c``` respectively\\nwe will find the condition where left + right has all 3 characters atleast k times and we\\'ll be returning min of suchs\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k ==0 :return 0\\n        n = len(s)\\n        da = {0:n},db = {0:n}, dc = {0:n}\\n        ca,cb,cc=0,0,0\\n        for i in range(n-1,-1,-1):\\n            if s[i] == \"a\":\\n                ca+=1\\n                da[ca]=i\\n            elif s[i] == \"b\":\\n                cb+=1\\n                db[cb]=i\\n            else:\\n                cc+=1\\n                dc[cc]=i\\n        if ca<k or cb<k or cc<k :return -1\\n        ca,cb,cc=0,0,0\\n        ans=n-min(da[max(0,k-ca)], db[max(0, k-cb)], dc[max(0,k-cc)])\\n        for i in range(n):\\n            if s[i] == \"a\":ca+=1\\n            elif s[i] == \"b\":cb+=1\\n            else:cc+=1\\n            ans =min(ans,i+1+n-min(da[max(0,k-ca)], db[max(0, k-cb)], dc[max(0,k-cc)]))\\n        return ans\\n```",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```ca,cb,cc```\n```a,b,c```\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        if k ==0 :return 0\\n        n = len(s)\\n        da = {0:n},db = {0:n}, dc = {0:n}\\n        ca,cb,cc=0,0,0\\n        for i in range(n-1,-1,-1):\\n            if s[i] == \"a\":\\n                ca+=1\\n                da[ca]=i\\n            elif s[i] == \"b\":\\n                cb+=1\\n                db[cb]=i\\n            else:\\n                cc+=1\\n                dc[cc]=i\\n        if ca<k or cb<k or cc<k :return -1\\n        ca,cb,cc=0,0,0\\n        ans=n-min(da[max(0,k-ca)], db[max(0, k-cb)], dc[max(0,k-cc)])\\n        for i in range(n):\\n            if s[i] == \"a\":ca+=1\\n            elif s[i] == \"b\":cb+=1\\n            else:cc+=1\\n            ans =min(ans,i+1+n-min(da[max(0,k-ca)], db[max(0, k-cb)], dc[max(0,k-cc)]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965941,
                "title": "python-easy-to-read-run",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, nums, k):\\n        count = Counter(nums)\\n        \\n        if any(count[a] < k for a in \\'abc\\'): \\n            return -1\\n        \\n        x = len(nums)\\n        result = len(nums)\\n        y = x - 1\\n        \\n        for i in range(x - 1, -1, -1):\\n            count[nums[i]] -= 1\\n            \\n            while count[nums[i]] < k:\\n                count[nums[y]] += 1\\n                y -= 1\\n                \\n            result = min(result, x - (y - i + 1))\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, nums, k):\\n        count = Counter(nums)\\n        \\n        if any(count[a] < k for a in \\'abc\\'): \\n            return -1\\n        \\n        x = len(nums)\\n        result = len(nums)\\n        y = x - 1\\n        \\n        for i in range(x - 1, -1, -1):\\n            count[nums[i]] -= 1\\n            \\n            while count[nums[i]] < k:\\n                count[nums[y]] += 1\\n                y -= 1\\n                \\n            result = min(result, x - (y - i + 1))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965083,
                "title": "simple-two-pointers-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom left to right, we can use one pointer to find the first possible substring that satisfies the condition. Then from right to left, we can use another pointer to find if there is a shorter substring that can replace the right part of the first substring.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Variable\\n  1. `i`, `j` - int: two pointers, `i` is from left to right, `j` is from right to left.\\n  2. `memo` - hashtable: save the count of \\'a\\' \\'b\\' and \\'c\\' characters showing from left to the pointer `i` and from right to the pointer `j`.\\n  3. `res` - int: save the minimum length of the required string.\\n- Steps\\n  1. Get the length `n` of the string `s`, check if it big enough to have `3k` characters.\\n  2. Move pointer `i` from left to right, if the k-condition is satisfied, break. Use a flag `finish` to mark if the required sub-string is found.\\n  3. Move pointer `j` from right to left, shrink the left window OR move the pointer `i` from right to left on the condition of **not breaking the requirement**. In other words, during this process, we keep the count of `abc` characters at least `k`.\\n  4. After each movement of `j`, update `res` if a shorter substring is found.\\n  5. Stop until `j` arrives index 0.\\n\\n# Complexity\\n- Time complexity: $O(N)$ where $N$ is the length of the input string `s`. We at most visit each character in `s` twice.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        n = len(s)\\n        # check special cases\\n        if n < k*3:\\n            return -1\\n        if k == 0:\\n            return 0\\n        # move pointer i from left to right to find the first possible substring\\n        memo = {\\'a\\':0, \\'b\\':0, \\'c\\':0}\\n        finish = False\\n        for i in range(n):\\n            memo[s[i]] += 1\\n            if memo[\\'a\\'] >= k and memo[\\'b\\'] >= k and memo[\\'c\\'] >= k:\\n                finish = True\\n                break\\n        # check if such required substring exists\\n        if finish:\\n            res = i+1\\n        else:\\n            return -1\\n        # move the pointer j from right to left\\n        # at the same time, shrink left window by move the pointer i from right to left\\n        j = n-1\\n        while j >= 0:\\n            memo[s[j]] += 1\\n            while i >= 0 and memo[s[i]] > k:\\n                memo[s[i]] -= 1\\n                i -= 1\\n            # update res if possible\\n            res = min(res, n-j+i+1)   \\n            j -= 1\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def takeCharacters(self, s: str, k: int) -> int:\\n        n = len(s)\\n        # check special cases\\n        if n < k*3:\\n            return -1\\n        if k == 0:\\n            return 0\\n        # move pointer i from left to right to find the first possible substring\\n        memo = {\\'a\\':0, \\'b\\':0, \\'c\\':0}\\n        finish = False\\n        for i in range(n):\\n            memo[s[i]] += 1\\n            if memo[\\'a\\'] >= k and memo[\\'b\\'] >= k and memo[\\'c\\'] >= k:\\n                finish = True\\n                break\\n        # check if such required substring exists\\n        if finish:\\n            res = i+1\\n        else:\\n            return -1\\n        # move the pointer j from right to left\\n        # at the same time, shrink left window by move the pointer i from right to left\\n        j = n-1\\n        while j >= 0:\\n            memo[s[j]] += 1\\n            while i >= 0 and memo[s[i]] > k:\\n                memo[s[i]] -= 1\\n                i -= 1\\n            # update res if possible\\n            res = min(res, n-j+i+1)   \\n            j -= 1\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964982,
                "title": "share-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k == 0){\\n            return 0;\\n        }\\n        vector<int> dp_a(k+1, -1);\\n        vector<int> dp_b(k+1, -1);\\n        vector<int> dp_c(k+1, -1);\\n        dp_a[0] = s.size();\\n        dp_b[0] = s.size();\\n        dp_c[0] = s.size();\\n\\n        unordered_map<int, int> map; \\n        for(int i=s.size()-1;i>=0;i--){\\n            int key = s[i] - \\'a\\';\\n            map[key]++;\\n            if(map[key]>k){\\n                continue;\\n            }\\n            if(key == 0){\\n                dp_a[map[key]] = i;\\n            }else if(key == 1){\\n                dp_b[map[key]] = i;\\n            }else if(key == 2){\\n                dp_c[map[key]] = i;\\n            }\\n        }\\n\\n        if(dp_a[k] == -1 || dp_b[k] == -1 || dp_c[k] == -1){\\n            return -1;\\n        }\\n\\n\\n        unordered_map<int, int> counter;\\n        counter[0] = 0;\\n        counter[1] = 0;\\n        counter[2] = 0;\\n\\n        int min_index = min(dp_a[k], min(dp_c[k], dp_b[k]));\\n        int res = s.size() - min_index;\\n\\n        for(int i=0;i<s.size();i++){\\n            char key = s[i] - \\'a\\';\\n            counter[key]++;\\n            \\n            int rest_a = counter[0]>k?0:k - counter[0];\\n            int rest_b = counter[1]>k?0:k - counter[1];\\n            int rest_c = counter[2]>k?0:k - counter[2];\\n\\n            int min_index = min(dp_a[rest_a], min(dp_b[rest_b], dp_c[rest_c]));\\n\\n            if(min_index<=i){\\n                continue;\\n            }\\n            \\n            int needed_len = s.size() - min_index + i + 1;\\n\\n            \\n            res = min(res, needed_len);\\n        }\\n\\n        return res;\\n    \\n    \\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        if(k == 0){\\n            return 0;\\n        }\\n        vector<int> dp_a(k+1, -1);\\n        vector<int> dp_b(k+1, -1);\\n        vector<int> dp_c(k+1, -1);\\n        dp_a[0] = s.size();\\n        dp_b[0] = s.size();\\n        dp_c[0] = s.size();\\n\\n        unordered_map<int, int> map; \\n        for(int i=s.size()-1;i>=0;i--){\\n            int key = s[i] - \\'a\\';\\n            map[key]++;\\n            if(map[key]>k){\\n                continue;\\n            }\\n            if(key == 0){\\n                dp_a[map[key]] = i;\\n            }else if(key == 1){\\n                dp_b[map[key]] = i;\\n            }else if(key == 2){\\n                dp_c[map[key]] = i;\\n            }\\n        }\\n\\n        if(dp_a[k] == -1 || dp_b[k] == -1 || dp_c[k] == -1){\\n            return -1;\\n        }\\n\\n\\n        unordered_map<int, int> counter;\\n        counter[0] = 0;\\n        counter[1] = 0;\\n        counter[2] = 0;\\n\\n        int min_index = min(dp_a[k], min(dp_c[k], dp_b[k]));\\n        int res = s.size() - min_index;\\n\\n        for(int i=0;i<s.size();i++){\\n            char key = s[i] - \\'a\\';\\n            counter[key]++;\\n            \\n            int rest_a = counter[0]>k?0:k - counter[0];\\n            int rest_b = counter[1]>k?0:k - counter[1];\\n            int rest_c = counter[2]>k?0:k - counter[2];\\n\\n            int min_index = min(dp_a[rest_a], min(dp_b[rest_b], dp_c[rest_c]));\\n\\n            if(min_index<=i){\\n                continue;\\n            }\\n            \\n            int needed_len = s.size() - min_index + i + 1;\\n\\n            \\n            res = min(res, needed_len);\\n        }\\n\\n        return res;\\n    \\n    \\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964951,
                "title": "c-sliding-window",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int TakeCharacters(string s, int k)\\n    {\\n        int n = s.Length;\\n        //freq of a, b, c\\n        int[] freq = new int[3];\\n        foreach (char c in s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        if (freq[0] < k || freq[1] < k || freq[2] < k)\\n            return -1;\\n\\n        int result = n;\\n\\n        int left = 0;\\n        for (int right = 0; right < n;)\\n        {\\n            freq[s[right] - \\'a\\']--;\\n            right++;\\n            while ((freq[0] < k || freq[1] < k || freq[2] < k) && left < right)\\n            {\\n                freq[s[left] - \\'a\\']++;\\n                left++;\\n            }\\n            result = Math.Min(result, n - (right - left));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int TakeCharacters(string s, int k)\\n    {\\n        int n = s.Length;\\n        //freq of a, b, c\\n        int[] freq = new int[3];\\n        foreach (char c in s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        if (freq[0] < k || freq[1] < k || freq[2] < k)\\n            return -1;\\n\\n        int result = n;\\n\\n        int left = 0;\\n        for (int right = 0; right < n;)\\n        {\\n            freq[s[right] - \\'a\\']--;\\n            right++;\\n            while ((freq[0] < k || freq[1] < k || freq[2] < k) && left < right)\\n            {\\n                freq[s[left] - \\'a\\']++;\\n                left++;\\n            }\\n            result = Math.Min(result, n - (right - left));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964924,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int counta=0;\\n        int countb=0;\\n        int countc=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'){\\n                counta++;\\n            }\\n            else if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            else{\\n                countc++;\\n            }\\n        }\\n        if(counta<k || countb<k || countc<k){\\n            return -1;\\n        }\\n        counta=counta-k;\\n        countb=countb-k;\\n        countc=countc-k;\\n        int maxi=-1e9;\\n        int i=0;\\n        int j=0;\\n        while(j<s.size()){\\n            \\n            if(s[j]==\\'a\\'){\\n                counta--;\\n            }\\n            else if(s[j]==\\'b\\'){\\n                countb--;\\n            }\\n            else{\\n                countc--;\\n            }\\n            if(counta<0 || countb<0 || countc<0){\\n                \\n                while(counta<0 || countb<0 || countc<0){\\n                    \\n                    if(s[i]==\\'a\\'){\\n                        counta++;\\n                    }\\n                    else if(s[i]==\\'b\\'){\\n                        countb++;\\n                    }\\n                    else{\\n                        countc++;\\n                    }\\n                    i++;\\n                }\\n            }\\n            int len=j-i+1;\\n            maxi=max(maxi,len);\\n            j++;\\n        }\\n        int ans=s.size()-maxi;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int takeCharacters(string s, int k) {\\n        \\n        int counta=0;\\n        int countb=0;\\n        int countc=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'){\\n                counta++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727749,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1727670,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1727435,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1728754,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1727380,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1742969,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1955034,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1732467,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            },
            {
                "id": 1730976,
                "content": [
                    {
                        "username": "manunangliya",
                        "content": "variation of sliding window... \nthink in different way that in our final answer some leftmost elements and some rightmost elements will be there , means we have to remove a portion of middle elements which are irrelevent , after removing some middle elements still we are able to make answer which contains atleast k elements of a,b,c .. (as i explainded before some leftmost elements and some rightmost elements will be there ) and removing of middle can be done by sliding window technique."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "man what is this problem"
                    },
                    {
                        "username": "CyborgGuy",
                        "content": "exactly me.."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I feel you samurai, glad to not be alone"
                    },
                    {
                        "username": "sgsumitgupta17",
                        "content": "Intuition\\nWe have to remove one char from start or last but we don\\'t know which one to remove to get the required ans. One approach to use recursion and try all the possibilities one by one but it will give TLE.\\nWe can use sliding window approach, we just need to find the max length substring which we can remove from string s so that all other chars length is greater than or equal to k.\\n\\nApproach\\nStart from the 0th index and keep start of substring on 0th index. Decrease the frq of char as we go. Go till u find any one of the char(a,b or c) is less than k.\\n\\n**For Ex. aabaaaacaabc\\nst=0\\n**\\n\\nwhen we will go to i =2 we can see b=1, less than k(2) now we will increase st till we get b and increase the frq of chars. So,\\nst=2;\\n\\nthen we will increase end till we get any value less than k. We will update our answer whenever we find any char frq less than k."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "On what basis you will decide whether to traverse from left or from right?"
                    },
                    {
                        "username": "meringueee",
                        "content": "The simplest way is to solve it as 2-point problem..."
                    },
                    {
                        "username": "vajja999",
                        "content": "<ol>\\n<li>How did they select <b>5</b> on the right <b>3</b> on the <b>left</b> makes sense 3 elements?</li>\\n<li>Few more <b>Examples</b> to easily understand as a human being?</li>\\n<li>Solution would be great</li>\\n</ol>"
                    },
                    {
                        "username": "d3g3n",
                        "content": "I have a binary search solution in python that\\'s timing out sometimes. seems like nlogn should always pass? doubt the code would fail if translated to c++ or java."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Holy cow. How do you even come up with a binary search idea?\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "take left window as full keep on decreasing elements, whenever it doesn\\'t fulfill conditions increase right window to left window\\'s complimentary. Record lowest total length through this iteration. \\n\\nSee this solution for detailed explanation: \\n\\n[https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/3701170/easy-solution-using-intution/)"
                    },
                    {
                        "username": "Mashijams",
                        "content": "I solved it with prefix sums and binary search.\\nThough 2 - pointer approach is very quick to implement in contest."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem smells like a SLIDING WINDOW problem.\\nThe trick here is to find the `Largest Window` (eg, abc[aaaaab]abc ; k=2) which can be `removed/deleted`, and the string should still contain \\'a\\',\\'b\\' and \\'c\\' atleast k times. "
                    },
                    {
                        "username": "adityarev",
                        "content": "This is already came up to my mind. But still don't know how to determine the window size. Any idea?"
                    }
                ]
            }
        ]
    }
]