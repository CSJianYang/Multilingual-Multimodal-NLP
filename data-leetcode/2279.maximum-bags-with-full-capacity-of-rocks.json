[
    {
        "title": "Maximum Bags With Full Capacity of Rocks",
        "question_content": "You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.\nReturn the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\n&nbsp;\nExample 1:\n\nInput: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2\nOutput: 3\nExplanation:\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now [2,3,4,4].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\nExample 2:\n\nInput: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100\nOutput: 3\nExplanation:\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now [10,2,2].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n&nbsp;\nConstraints:\n\n\tn == capacity.length == rocks.length\n\t1 <= n <= 5 * 104\n\t1 <= capacity[i] <= 109\n\t0 <= rocks[i] <= capacity[i]\n\t1 <= additionalRocks <= 109",
        "solutions": [
            {
                "id": 2061949,
                "title": "greedy-intuition-o-1-space-c-java",
                "content": "**Intuition**:\\n> Trick is to fill the bags with less remaining capacity, as these require less water and more number of bags will be be filled first.\\n\\nIf we sort in increasing order on the basis of difference between `current` and `orginal`, then our work will be to reduce difference to 0 with the help of `additionalRocks`.\\n\\n# C++    \\n\\tint maximumBags(vector<int>& C, vector<int>& R, int add) {\\n        int n = size(R), cnt=0;\\n        for(int i = 0;i < n; i++) R[i] = C[i] - R[i];\\n        sort(begin(R), end(R));\\n        for(int i = 0;i < n && R[i] - add <= 0; i++) cnt++, add -= R[i];\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int maximumBags(int[] C, int[] R, int add) {\\n       int n = R.length, cnt=0;\\n       for(int i = 0;i < n; i++) R[i] = C[i] - R[i];\\n       Arrays.sort(R);\\n       for(int i = 0;i < n && (R[i] - add) <= 0;i++) { \\n\\t        cnt++;\\n\\t\\t    add -= R[i];\\n\\t   }\\n       return cnt;\\n\\t}\\n**Time** - O(NlogN)\\n**Space** - O(1)\\n\\n\\n**Please Upvote if you like it! (\\u25CF\\'\\u25E1\\'\\u25CF)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Intuition**:\\n> Trick is to fill the bags with less remaining capacity, as these require less water and more number of bags will be be filled first.\\n\\nIf we sort in increasing order on the basis of difference between `current` and `orginal`, then our work will be to reduce difference to 0 with the help of `additionalRocks`.\\n\\n# C++    \\n\\tint maximumBags(vector<int>& C, vector<int>& R, int add) {\\n        int n = size(R), cnt=0;\\n        for(int i = 0;i < n; i++) R[i] = C[i] - R[i];\\n        sort(begin(R), end(R));\\n        for(int i = 0;i < n && R[i] - add <= 0; i++) cnt++, add -= R[i];\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int maximumBags(int[] C, int[] R, int add) {\\n       int n = R.length, cnt=0;\\n       for(int i = 0;i < n; i++) R[i] = C[i] - R[i];\\n       Arrays.sort(R);\\n       for(int i = 0;i < n && (R[i] - add) <= 0;i++) { \\n\\t        cnt++;\\n\\t\\t    add -= R[i];\\n\\t   }\\n       return cnt;\\n\\t}\\n**Time** - O(NlogN)\\n**Space** - O(1)\\n\\n\\n**Please Upvote if you like it! (\\u25CF\\'\\u25E1\\'\\u25CF)**",
                "codeTag": "Unknown"
            },
            {
                "id": 2062185,
                "title": "c-python-greedy-solution",
                "content": "# **Explanation**\\nCalculate all empty space for each bag.\\nSort them from small to big, including 0 empty space.\\n\\nGreedily Fill the bags, from small empty space to bigger one.\\nreturn the number of full bags.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n\\n**C++**\\n```cpp\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        vector<int> count;\\n        int n = rocks.size(), i;\\n        for (int i = 0; i < n; ++i) \\n            count.push_back(capacity[i] - rocks[i]);\\n        sort(count.begin(), count.end());\\n        for (i = 0; i < n && k >= count[i]; ++i)\\n            k -= count[i];\\n        return i;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumBags(self, capacity, rocks, x):\\n        count = sorted(c - r for c,r in zip(capacity, rocks))[::-1]\\n        while count and x and count[-1] <= x:\\n            x -= count.pop()\\n        return len(rocks) - len(count)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        vector<int> count;\\n        int n = rocks.size(), i;\\n        for (int i = 0; i < n; ++i) \\n            count.push_back(capacity[i] - rocks[i]);\\n        sort(count.begin(), count.end());\\n        for (i = 0; i < n && k >= count[i]; ++i)\\n            k -= count[i];\\n        return i;\\n    }\\n```\n```py\\n    def maximumBags(self, capacity, rocks, x):\\n        count = sorted(c - r for c,r in zip(capacity, rocks))[::-1]\\n        while count and x and count[-1] <= x:\\n            x -= count.pop()\\n        return len(rocks) - len(count)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2061813,
                "title": "greedy",
                "content": "```\\npublic int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0; i<rocks.length; i++){\\n            list.add(capacity[i]-rocks[i]);\\n        }\\n        Collections.sort(list);\\n        int ans=0,count=0;\\n        for(int a:list){\\n            count += a;\\n            if(count > additionalRocks) break;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0; i<rocks.length; i++){\\n            list.add(capacity[i]-rocks[i]);\\n        }\\n        Collections.sort(list);\\n        int ans=0,count=0;\\n        for(int a:list){\\n            count += a;\\n            if(count > additionalRocks) break;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061907,
                "title": "easy-to-understand-c-subtract-then-sort-greedy-o-nlog-n",
                "content": "```\\nTime : O(nlog(n))\\nSpace : O(n) \\n\\nif we modify the given vector then space will be O(1)\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n         vector<int> vv ; \\n         for(int i = 0 ; i < capacity.size(); i ++ ) {\\n              vv.push_back(capacity[i] - rocks[i]); \\n         }\\n         sort(vv.begin(), vv.end()); \\n         int  cnt = 0 ; \\n         for(auto a : vv ) {\\n              if(a == 0) {\\n                   cnt ++ ; \\n              }else if(additionalRocks - a >= 0){\\n                  cnt ++; \\n                  additionalRocks -= a ; \\n              }\\n         }\\n        return cnt ; \\n}\\n```\\nplease upvote if like : >",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nTime : O(nlog(n))\\nSpace : O(n) \\n\\nif we modify the given vector then space will be O(1)\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n         vector<int> vv ; \\n         for(int i = 0 ; i < capacity.size(); i ++ ) {\\n              vv.push_back(capacity[i] - rocks[i]); \\n         }\\n         sort(vv.begin(), vv.end()); \\n         int  cnt = 0 ; \\n         for(auto a : vv ) {\\n              if(a == 0) {\\n                   cnt ++ ; \\n              }else if(additionalRocks - a >= 0){\\n                  cnt ++; \\n                  additionalRocks -= a ; \\n              }\\n         }\\n        return cnt ; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2956353,
                "title": "python3-874ms-100-faster-code-and-1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSummary of this problem is to maximize the number of full bags.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Zip cap and rocks, then subtract each element of zip.\\nYou can use **itertool.starmap** and **operator.sub**.\\n```\\nstarmap(sub, zip(cap, rocks))\\n```\\n2. Sort the ones from 1.\\n```\\nsorted(\\n    starmap(sub,zip(cap, rocks))\\n)\\n```\\n\\n3. Make prefixSum of sorted list from 2. \\nYou can use **itertools.accumulate** function in python3.\\n```\\naccumulate(\\n    sorted(\\n        starmap(sub, zip(cap, rocks))\\n    )\\n)\\n```\\n4. Find where addRocks will be located.\\nYou can use **bisect.bisect_right**.\\n```\\nbisect_right(\\n    list(accumulate(\\n        sorted(\\n            starmap(sub, zip(cap, rocks))\\n        )\\n    )),\\n    addRocks\\n)\\n```\\nSubmission Code Link\\n-> https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/submissions/866129457/\\n\\nThanks for reading my post!\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, cap, rocks, addRocks):\\n        return bisect_right(list(accumulate(sorted(starmap(sub,zip(cap,rocks))))),addRocks)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nstarmap(sub, zip(cap, rocks))\\n```\n```\\nsorted(\\n    starmap(sub,zip(cap, rocks))\\n)\\n```\n```\\naccumulate(\\n    sorted(\\n        starmap(sub, zip(cap, rocks))\\n    )\\n)\\n```\n```\\nbisect_right(\\n    list(accumulate(\\n        sorted(\\n            starmap(sub, zip(cap, rocks))\\n        )\\n    )),\\n    addRocks\\n)\\n```\n```\\nclass Solution:\\n    def maximumBags(self, cap, rocks, addRocks):\\n        return bisect_right(list(accumulate(sorted(starmap(sub,zip(cap,rocks))))),addRocks)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062618,
                "title": "two-solutions",
                "content": "**Fill the bag with least space left first to get maximum full bags.**\\n\\n\\n**Priority Queue | Space O(n)** \\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int res(0), n(size(rocks));\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i=0; i<n; i++) pq.push(capacity[i] - rocks[i]);\\n        \\n        while (!pq.empty() and pq.top() <= additionalRocks) {\\n            \\n\\t\\t\\t// pq.top() returns bag with least space.\\n            additionalRocks -= pq.top();\\n            pq.pop();\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Sorting | Space O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int n(size(rocks)), res(0);\\n        for (int i=0; i<n; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        \\n        sort(begin(capacity), end(capacity));\\n        for (int i=0; i<n and additionalRocks; i++) {\\n            if (capacity[i] <= additionalRocks) {\\n                additionalRocks -= capacity[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int res(0), n(size(rocks));\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i=0; i<n; i++) pq.push(capacity[i] - rocks[i]);\\n        \\n        while (!pq.empty() and pq.top() <= additionalRocks) {\\n            \\n\\t\\t\\t// pq.top() returns bag with least space.\\n            additionalRocks -= pq.top();\\n            pq.pop();\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int n(size(rocks)), res(0);\\n        for (int i=0; i<n; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        \\n        sort(begin(capacity), end(capacity));\\n        for (int i=0; i<n and additionalRocks; i++) {\\n            if (capacity[i] <= additionalRocks) {\\n                additionalRocks -= capacity[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061863,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=capacity.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            capacity[i]=capacity[i]-rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        for(int i=0;i<n;i++){\\n            if(additionalRocks<capacity[i]) break;\\n                cnt++;\\n            additionalRocks=additionalRocks-capacity[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=capacity.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            capacity[i]=capacity[i]-rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        for(int i=0;i<n;i++){\\n            if(additionalRocks<capacity[i]) break;\\n                cnt++;\\n            additionalRocks=additionalRocks-capacity[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061886,
                "title": "subtract-then-sort",
                "content": "**C++**\\n```cpp\\nint maximumBags(vector<int>& c, vector<int>& r, int additionalRocks) {\\n    transform(begin(c), end(c), begin(r), begin(c), [](int c, int r){ return c - r; });\\n    sort(begin(c), end(c));\\n    int i = 0;\\n    for (; i < c.size() && c[i] <= additionalRocks; ++i)\\n        additionalRocks -= c[i];            \\n    return i;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumBags(vector<int>& c, vector<int>& r, int additionalRocks) {\\n    transform(begin(c), end(c), begin(r), begin(c), [](int c, int r){ return c - r; });\\n    sort(begin(c), end(c));\\n    int i = 0;\\n    for (; i < c.size() && c[i] <= additionalRocks; ++i)\\n        additionalRocks -= c[i];            \\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2956564,
                "title": "c-diff-cap-rocks-approach-sorting-easy-for-beginner",
                "content": "```\\nTime Complexity : O(n long n)                          // took max (Sorting)\\nSpace Complexity : O(n)                                // vector memory\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) \\n    {\\n        int n = rocks.size();\\n        vector<int> v;\\n        \\n        // storing the diff of cap-roc (max rocks that i cam put in bag now)\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(capacity[i]-rocks[i]);\\n        }\\n        \\n        // 1,1,0,1\\n        // 0,1,1,1\\n        sort(v.begin(),v.end());\\n        \\n        // now i am having additionalRocks and I\\'ll try to put those into the bags and check how many bangs can be full\\n        for(int i=0;i<n;i++)\\n        {\\n            // if curr bag is not full and I can put bricks into it from additionalRocks\\n            if(v[i]!=0 && v[i]<=additionalRocks)\\n            {\\n                additionalRocks = additionalRocks-v[i];                         // reduce the taken bricks\\n                v[i] = 0;                                                       // after taking the bricks current bag will be full\\n                if(additionalRocks<=0) break;                                   // any time if my additionalRocks goes <=0 if means just stop\\n            }\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            // couting the bags that are full\\n            if(v[i]==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nTime Complexity : O(n long n)                          // took max (Sorting)\\nSpace Complexity : O(n)                                // vector memory\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) \\n    {\\n        int n = rocks.size();\\n        vector<int> v;\\n        \\n        // storing the diff of cap-roc (max rocks that i cam put in bag now)\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(capacity[i]-rocks[i]);\\n        }\\n        \\n        // 1,1,0,1\\n        // 0,1,1,1\\n        sort(v.begin(),v.end());\\n        \\n        // now i am having additionalRocks and I\\'ll try to put those into the bags and check how many bangs can be full\\n        for(int i=0;i<n;i++)\\n        {\\n            // if curr bag is not full and I can put bricks into it from additionalRocks\\n            if(v[i]!=0 && v[i]<=additionalRocks)\\n            {\\n                additionalRocks = additionalRocks-v[i];                         // reduce the taken bricks\\n                v[i] = 0;                                                       // after taking the bricks current bag will be full\\n                if(additionalRocks<=0) break;                                   // any time if my additionalRocks goes <=0 if means just stop\\n            }\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            // couting the bags that are full\\n            if(v[i]==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2061955,
                "title": "java-o-n-log-n",
                "content": "```\\nclass Solution {\\n\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        // build heap on basis of additionalRocks required for each stack of rocks.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - a[0]) - (b[1] - b[0]));\\n        for (int i = 0; i < capacity.length; i++) pq.add(new int[] { rocks[i], capacity[i] });\\n        int c = 0;\\n        while (!pq.isEmpty() && additionalRocks > 0) {\\n            int curr[] = pq.remove();\\n            int req = curr[1] - curr[0];\\n            if (additionalRocks < req) break;\\n            additionalRocks -= req;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        // build heap on basis of additionalRocks required for each stack of rocks.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - a[0]) - (b[1] - b[0]));\\n        for (int i = 0; i < capacity.length; i++) pq.add(new int[] { rocks[i], capacity[i] });\\n        int c = 0;\\n        while (!pq.isEmpty() && additionalRocks > 0) {\\n            int curr[] = pq.remove();\\n            int req = curr[1] - curr[0];\\n            if (additionalRocks < req) break;\\n            additionalRocks -= req;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956024,
                "title": "c-vector-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=capacity.size();\\n        vector<int>temp(n,0);\\n        for(int i=0;i<n;i++){\\n            temp[i]=capacity[i]-rocks[i];\\n        }\\n        sort(temp.begin(),temp.end());\\n        int i=0;\\n        int sum=0;\\n        int count=0;\\n        while(sum<=additionalRocks && i<n){\\n            sum+=temp[i];\\n            if(sum<=additionalRocks){count++;}\\n            i++;\\n        }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=capacity.size();\\n        vector<int>temp(n,0);\\n        for(int i=0;i<n;i++){\\n            temp[i]=capacity[i]-rocks[i];\\n        }\\n        sort(temp.begin(),temp.end());\\n        int i=0;\\n        int sum=0;\\n        int count=0;\\n        while(sum<=additionalRocks && i<n){\\n            sum+=temp[i];\\n            if(sum<=additionalRocks){count++;}\\n            i++;\\n        }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279847,
                "title": "easy-to-understand-c-code-o-1-space-o-nlog-n-time",
                "content": "#### Explanation\\n\\nIterate over both the given arrays and calculate all empty space for each bag.\\n\\nNow sort them from small to big, including 0 empty space.\\n\\nGreedily fill the bags, from small empty space to bigger one.\\n\\nFinally, return the number of full bags.\\n\\n\\n#### Complexity\\n\\n> Time O(nlogn) \\n// due to sorting\\n\\n> Space O(1) \\n// no extra array used for storing the empty spaces, insead capacity array is utilized for it\\n\\n---\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size();\\n\\t\\t\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n\\t\\t\\n        sort(capacity.begin(),capacity.end());\\n\\t\\t\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=capacity[i];\\n            if(ans>additionalRocks){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size();\\n\\t\\t\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n\\t\\t\\n        sort(capacity.begin(),capacity.end());\\n\\t\\t\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=capacity[i];\\n            if(ans>additionalRocks){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061788,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& rocks, int b) {\\n        vector<int>v;\\n        for(int i=0; i < rocks.size(); i++)     v.push_back(c[i] - rocks[i]);\\n        sort(v.begin(), v.end());\\n        int i = 0;\\n        while(b > 0 and i < c.size()){\\n            b -= v[i];\\n            i++;\\n        }\\n        return b<0 ? i-1 : i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& rocks, int b) {\\n        vector<int>v;\\n        for(int i=0; i < rocks.size(); i++)     v.push_back(c[i] - rocks[i]);\\n        sort(v.begin(), v.end());\\n        int i = 0;\\n        while(b > 0 and i < c.size()){\\n            b -= v[i];\\n            i++;\\n        }\\n        return b<0 ? i-1 : i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955979,
                "title": "maximum-bags-with-capacity-python-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPython Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        for i in range(len(rocks)):\\n            capacity[i]=capacity[i]-rocks[i]\\n        capacity.sort()\\n        c=0\\n        for i in capacity:\\n            if(i<=additionalRocks):\\n                c+=1\\n                additionalRocks-=i \\n        return c\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        for i in range(len(rocks)):\\n            capacity[i]=capacity[i]-rocks[i]\\n        capacity.sort()\\n        c=0\\n        for i in capacity:\\n            if(i<=additionalRocks):\\n                c+=1\\n                additionalRocks-=i \\n        return c\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955466,
                "title": "daily-leetcoding-challenge-december-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2061947,
                "title": "subtract-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        int count=0;\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            c[i]-=r[i];\\n        }\\n        sort(c.begin(),c.end());\\n        for(int i=0;i<c.size();i++)\\n        {\\n            if(c[i]==0)\\n            {\\n                count++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(a>=c[i])\\n                {  a-=c[i];\\n                    count++;\\n                }\\n                else\\n                {break;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```\\n**Like it? Please Upvote;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        int count=0;\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            c[i]-=r[i];\\n        }\\n        sort(c.begin(),c.end());\\n        for(int i=0;i<c.size();i++)\\n        {\\n            if(c[i]==0)\\n            {\\n                count++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(a>=c[i])\\n                {  a-=c[i];\\n                    count++;\\n                }\\n                else\\n                {break;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061826,
                "title": "python-sorting",
                "content": "```\\nclass Solution:\\n    def maximumBags(self, cap: List[int], rocks: List[int], more: int) -> int:\\n        for i in range(len(cap)):\\n            cap[i] -= rocks[i]\\n        i = 0\\n        cap.sort()\\n        while i < len(cap) and more - cap[i] >= 0:\\n            more -= cap[i]\\n            i += 1\\n        return i\\n```\\n*Please UPVOTE!*",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, cap: List[int], rocks: List[int], more: int) -> int:\\n        for i in range(len(cap)):\\n            cap[i] -= rocks[i]\\n        i = 0\\n        cap.sort()\\n        while i < len(cap) and more - cap[i] >= 0:\\n            more -= cap[i]\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061805,
                "title": "java-greedy-fill-the-smallest-left-bags",
                "content": "Always fill the smallest left bag first.\\n\\nTime: O(NlogN)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n    final int n = capacity.length;\\n    for (int i = 0; i < n; i++) {\\n      capacity[i] -= rocks[i];\\n    }\\n\\n    // always pick the smallest left bag\\n    Arrays.sort(capacity);\\n    int count = 0;\\n    for (int i = 0; i < n && additionalRocks > 0; i++) {\\n      if (additionalRocks >= capacity[i]) {\\n        count++;\\n      }\\n      additionalRocks -= capacity[i];\\n    }\\n\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n    final int n = capacity.length;\\n    for (int i = 0; i < n; i++) {\\n      capacity[i] -= rocks[i];\\n    }\\n\\n    // always pick the smallest left bag\\n    Arrays.sort(capacity);\\n    int count = 0;\\n    for (int i = 0; i < n && additionalRocks > 0; i++) {\\n      if (additionalRocks >= capacity[i]) {\\n        count++;\\n      }\\n      additionalRocks -= capacity[i];\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061801,
                "title": "easy-solution-without-using-extra-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int cnt = 0;\\n        \\n        for(int i=0;i<capacity.size();i++) capacity[i] = capacity[i] - rocks[i];\\n        \\n        sort(begin(capacity),end(capacity));\\n        \\n        for(auto it : capacity){\\n            if(it == 0){ \\n                cnt++;\\n                continue;\\n            }\\n            additionalRocks -= it;\\n            if(additionalRocks >=0) cnt++;\\n            else break;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int cnt = 0;\\n        \\n        for(int i=0;i<capacity.size();i++) capacity[i] = capacity[i] - rocks[i];\\n        \\n        sort(begin(capacity),end(capacity));\\n        \\n        for(auto it : capacity){\\n            if(it == 0){ \\n                cnt++;\\n                continue;\\n            }\\n            additionalRocks -= it;\\n            if(additionalRocks >=0) cnt++;\\n            else break;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061793,
                "title": "java-basic-approach-o-n-log-n-time-o-n-space",
                "content": "class Solution {\\n    \\n    \\n                // If you like it #UP_VOTE for me..\\n    \\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n    int []diff=new int[capacity.length];  // it holdes the Diff between max and actual capacity..\\n        \\n        for(int i=0;i<diff.length;i++){\\n            diff[i]=capacity[i]-rocks[i];   // inserting Diff our Diff array according to index.\\n        }\\n        \\n        Arrays.sort(diff);     // sorting the Diff array..\\n        \\n         int count=0;\\n        \\n        for(int i=0;i<diff.length;i++){\\n            \\n            if(diff[i]==0){                 // if our bag is alrady full  no need to insert addtionalROck\\n                count++;\\n            }else {\\n                if(additionalRocks>=diff[i]){ // if space if less then Additional rock then we can put rocks in bag.\\n                    \\n                    additionalRocks=additionalRocks-diff[i]; // reaming Additionals Rock.\\n                    count++;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n       \\n        \\n        \\n        \\n        return count;\\n        \\n    \\n        /// Update..we can Also Do it in O(1) space..\\n\\t\\t/*\\n\\t\\tby inserting the Diff in any array either in capacity or rocks..array...\\n\\t\\tand else part remains same;;;\\n\\t\\t*/\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    \\n                // If you like it #UP_VOTE for me..\\n    \\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n    int []diff=new int[capacity.length];  // it holdes the Diff between max and actual capacity..\\n        \\n        for(int i=0;i<diff.length;i++){\\n            diff[i]=capacity[i]-rocks[i];   // inserting Diff our Diff array according to index.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3373650,
                "title": "c-easy-solution-sorting",
                "content": "# Intuition\\nWe need to fill the bags full as many as possible so we need to target the bags having less space so we use sorting.\\n\\n# Approach\\nWe need to make an array with remaining space and sort the array. Now let us traverse the array and fill those. If it is filled update the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(NogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = rocks.size();\\n        vector<int>rem(n);\\n        for(int i = 0;i<n;i++){\\n            rem[i] = capacity[i]-rocks[i];\\n        }\\n        int ans = 0;\\n        sort(rem.begin(),rem.end());\\n        int i = 0;\\n        while(i<n && additionalRocks){\\n            int temp = min(rem[i],additionalRocks);\\n            rem[i]-=temp;\\n            additionalRocks-=temp;\\n            if(!rem[i]){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = rocks.size();\\n        vector<int>rem(n);\\n        for(int i = 0;i<n;i++){\\n            rem[i] = capacity[i]-rocks[i];\\n        }\\n        int ans = 0;\\n        sort(rem.begin(),rem.end());\\n        int i = 0;\\n        while(i<n && additionalRocks){\\n            int temp = min(rem[i],additionalRocks);\\n            rem[i]-=temp;\\n            additionalRocks-=temp;\\n            if(!rem[i]){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955825,
                "title": "c-priority-queue-easy-solution-explained-o-n-tc-o-n-sc",
                "content": "# Intuition\\nIn this question, we must provide the maximum number of full bags as output after filling some (or all) of the bags with rocks from additional rocks. So, to fill the maximum number of bags, we would fill the bag that requires the least amount of rocks first, then the second, and so on....\\n# Approach\\n- As a result, we must store the difference between `capacity[i]` and `difference[i]` in ascending order.\\n- as a result, we can use `priority queue` here.\\n- we iterate through the array ones, increasing the counter if `capacity[i] == difference[i]`, otherwise we push their difference into the `priority queue`.\\n- and then we iterate the priority queue while the number of additional rocks is greater than zero and the size of the priority queue is greater than zero and in iteration, if the top of the priority queue is less than or equal to the number of additional rocks, we simply decrease the number of additional rocks and increase the counter.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        int count = 0;\\n        for(int i =0;i<capacity.size();i++){\\n            if(capacity[i]==rocks[i])count++;\\n            else q.push(capacity[i]-rocks[i]);\\n        }\\n        while(additionalRocks>0 && q.size()){\\n            int f = q.top();\\n            q.pop();\\n            if(additionalRocks>=f){\\n                additionalRocks -= f;\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n\\n    }\\n};\\n```\\n\\n-  upvote this solution if you like it\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        int count = 0;\\n        for(int i =0;i<capacity.size();i++){\\n            if(capacity[i]==rocks[i])count++;\\n            else q.push(capacity[i]-rocks[i]);\\n        }\\n        while(additionalRocks>0 && q.size()){\\n            int f = q.top();\\n            q.pop();\\n            if(additionalRocks>=f){\\n                additionalRocks -= f;\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958902,
                "title": "java-simple-video-explanation",
                "content": "Look at the video to understand the approach[https://youtu.be/6byJdbkSxEo]()\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = rocks.length;\\n        int answer;\\n        for(int i=0; i<n; i++){\\n            capacity[i] -= rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for(answer=0; answer<n && additionalRocks>=capacity[answer]; answer++){\\n            additionalRocks -= capacity[answer];\\n        }\\n        return answer;\\n    }\\n}\\n```\\nUPVOTE if it adds value or helps you it keeps me motivated!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = rocks.length;\\n        int answer;\\n        for(int i=0; i<n; i++){\\n            capacity[i] -= rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for(answer=0; answer<n && additionalRocks>=capacity[answer]; answer++){\\n            additionalRocks -= capacity[answer];\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958523,
                "title": "easy-solution-o-nlogn-tc-o-1-sc",
                "content": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        for i in range(len(capacity)):\\n            capacity[i] -= rocks[i]\\n            \\n        capacity.sort()\\n        for i in range(len(capacity)):\\n            if capacity[i] > additionalRocks:\\n                return i\\n            additionalRocks -= capacity[i]\\n            \\n        return len(capacity)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        for i in range(len(capacity)):\\n            capacity[i] -= rocks[i]\\n            \\n        capacity.sort()\\n        for i in range(len(capacity)):\\n            if capacity[i] > additionalRocks:\\n                return i\\n            additionalRocks -= capacity[i]\\n            \\n        return len(capacity)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957711,
                "title": "c-greedy-approach-sorting",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    //for sorting pairs which has less difference b/w capacity and rocks\\n    static bool compare(vector<int> &a, vector<int> &b) \\n    {\\n        return (a[1]-a[0] < b[1]-b[0]);\\n    }\\n\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrocks) \\n    {\\n        int n=cap.size();\\n        vector<vector<int>> bags; \\n\\n        //storing rocks and capacity in 2d vector\\n        for(int i=0; i<n; i++)\\n            bags.push_back({rocks[i], cap[i]});\\n\\n        //sort bags based on less difference between capacity and rocks\\n        sort(bags.begin(), bags.end(), compare);\\n\\n        //count maximum number of bags having full capacity\\n        int cnt=0;\\n        for(auto &it:bags) \\n        {\\n            if((it[1]-it[0]) <= addrocks) addrocks -= (it[1]-it[0]);       \\n            else break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    //for sorting pairs which has less difference b/w capacity and rocks\\n    static bool compare(vector<int> &a, vector<int> &b) \\n    {\\n        return (a[1]-a[0] < b[1]-b[0]);\\n    }\\n\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrocks) \\n    {\\n        int n=cap.size();\\n        vector<vector<int>> bags; \\n\\n        //storing rocks and capacity in 2d vector\\n        for(int i=0; i<n; i++)\\n            bags.push_back({rocks[i], cap[i]});\\n\\n        //sort bags based on less difference between capacity and rocks\\n        sort(bags.begin(), bags.end(), compare);\\n\\n        //count maximum number of bags having full capacity\\n        int cnt=0;\\n        for(auto &it:bags) \\n        {\\n            if((it[1]-it[0]) <= addrocks) addrocks -= (it[1]-it[0]);       \\n            else break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957447,
                "title": "0ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int c = 0;\\n        for(int i=0;i<capacity.length;i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for(int i=0;i<capacity.length;i++){\\n            additionalRocks-=capacity[i];\\n            if(additionalRocks>=0){\\n                c++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int c = 0;\\n        for(int i=0;i<capacity.length;i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for(int i=0;i<capacity.length;i++){\\n            additionalRocks-=capacity[i];\\n            if(additionalRocks>=0){\\n                c++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957116,
                "title": "c-fast-and-intuitive-o-nlogn",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int aR) {\\n        int n = c.size();\\n\\n        // Find out all the remaining capacities \\n        vector<int> rc(n);\\n        for( int i=0 ; i<n ; i++ ){\\n            rc[i] = c[i]-r[i];\\n        }\\n\\n        // Sort the remaining Capacities \\n        // So that we end up filling max bags \\n        sort( rc.begin(), rc.end() );\\n\\n        for( int i=0 ; i<n ; i++ ){\\n        \\n            if( rc[i]>0 ){\\n                // if additional rocks are greater than capacity \\n                // Update the additional rocks and remaining capacity becomes 0\\n                if( aR>rc[i] ){\\n                    aR = aR - rc[i];\\n                    rc[i] = 0 ;\\n                } \\n                // if additional rocks are lesser than the capacity\\n                // Update the remaining capacity and additional rocks becomes 0\\n                else{\\n                    rc[i] -= aR ;\\n                    aR = 0;\\n                }\\n            }\\n\\n            // if at any point additional rocks becomes 0 : Break\\n            if( aR == 0 ) break;\\n        }\\n        \\n        // Calculate the bags filled full \\n        int ans=0;\\n        for( int i=0 ; i<n ; i++ ){\\n            if( rc[i] == 0 ) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int aR) {\\n        int n = c.size();\\n\\n        // Find out all the remaining capacities \\n        vector<int> rc(n);\\n        for( int i=0 ; i<n ; i++ ){\\n            rc[i] = c[i]-r[i];\\n        }\\n\\n        // Sort the remaining Capacities \\n        // So that we end up filling max bags \\n        sort( rc.begin(), rc.end() );\\n\\n        for( int i=0 ; i<n ; i++ ){\\n        \\n            if( rc[i]>0 ){\\n                // if additional rocks are greater than capacity \\n                // Update the additional rocks and remaining capacity becomes 0\\n                if( aR>rc[i] ){\\n                    aR = aR - rc[i];\\n                    rc[i] = 0 ;\\n                } \\n                // if additional rocks are lesser than the capacity\\n                // Update the remaining capacity and additional rocks becomes 0\\n                else{\\n                    rc[i] -= aR ;\\n                    aR = 0;\\n                }\\n            }\\n\\n            // if at any point additional rocks becomes 0 : Break\\n            if( aR == 0 ) break;\\n        }\\n        \\n        // Calculate the bags filled full \\n        int ans=0;\\n        for( int i=0 ; i<n ; i++ ){\\n            if( rc[i] == 0 ) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956777,
                "title": "heap-o-nlogn-time-complexity",
                "content": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        n = len(rocks)\\n        track, count = [], 0\\n\\t\\t# First keep track of the diffrences of the Capacity and Rocks for each index\\n        for i in range(n):\\n            diff = capacity[i] - rocks[i]\\n            heappush(track, diff)\\n\\t  # Using min heap fill in each space left in the capacity\\n        for i in range(n):\\n            additionalRocks -= heappop(track)\\n            if additionalRocks >= 0:\\n                count += 1  \\n        return count        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        n = len(rocks)\\n        track, count = [], 0\\n\\t\\t# First keep track of the diffrences of the Capacity and Rocks for each index\\n        for i in range(n):\\n            diff = capacity[i] - rocks[i]\\n            heappush(track, diff)\\n\\t  # Using min heap fill in each space left in the capacity\\n        for i in range(n):\\n            additionalRocks -= heappop(track)\\n            if additionalRocks >= 0:\\n                count += 1  \\n        return count        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956188,
                "title": "super-simple-easy-c-sorting-solution",
                "content": "# Intuition\\nFinding the remaining capacity to accomodate more rocks and then greedily filling those bags first which require least rocks.\\n# Approach\\n1. Create an additional array which stores remaining capacity the \\nbags\\n2. Sort the diff array\\n3. Allot rocks to these bags greedily which requires least rocks first\\n4. keep a variable ans, which keeps count of fully filled bags, once additionalRocks goes below 0 or less than min required, break;\\n\\n# Complexity\\n- Time complexity:\\nNlog(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        int ans = 0;\\n        vector<int>diff;\\n\\n        for(int i = 0; i < rocks.size(); i++) diff.push_back(capacity[i] - rocks[i]);\\n\\n        sort(diff.begin(), diff.end());\\n\\n        for(auto it : diff){\\n\\n            if(it > 0 and additionalRocks >= it){\\n                ans++;\\n                additionalRocks -= it;\\n            }else if(it == 0) ans++;\\n            else \\n                break;           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        int ans = 0;\\n        vector<int>diff;\\n\\n        for(int i = 0; i < rocks.size(); i++) diff.push_back(capacity[i] - rocks[i]);\\n\\n        sort(diff.begin(), diff.end());\\n\\n        for(auto it : diff){\\n\\n            if(it > 0 and additionalRocks >= it){\\n                ans++;\\n                additionalRocks -= it;\\n            }else if(it == 0) ans++;\\n            else \\n                break;           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956136,
                "title": "simple-solution-using-1-loop-cpp-solution",
                "content": "# Intuition:\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1st of all I founded the required rocks for each index to full their capacity, so created a diff named vector. Then sorted the diff vector so that least required bags will full 1st so that we will have the more full bags. and then traverse through all the bags and add the required rocks in the bag, if required rocks are greater than available extra then I break the loop.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximumBags(vector<int> &capacity, vector<int> &rocks, int additionalRocks)\\n    {\\n        vector<long long> diff;\\n        long long size = capacity.size();\\n        for (int i = 0; i < size; i++)\\n            diff.push_back(capacity[i] - rocks[i]);\\n        sort(diff.begin(), diff.end());\\n        int ans = 0;\\n        long long req = 0, extra = additionalRocks;\\n        for (int i = 0; i < size; i++)\\n        {\\n            if (diff[i] > extra)\\n                break;\\n            extra -= diff[i];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumBags(vector<int> &capacity, vector<int> &rocks, int additionalRocks)\\n    {\\n        vector<long long> diff;\\n        long long size = capacity.size();\\n        for (int i = 0; i < size; i++)\\n            diff.push_back(capacity[i] - rocks[i]);\\n        sort(diff.begin(), diff.end());\\n        int ans = 0;\\n        long long req = 0, extra = additionalRocks;\\n        for (int i = 0; i < size; i++)\\n        {\\n            if (diff[i] > extra)\\n                break;\\n            extra -= diff[i];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955724,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n       long long n =rocks.size(),sumc=0;\\n       for(int i=0;i<n;i++)\\n           rocks[i]=capacity[i]-rocks[i];\\n\\n       long long sum=0,ans=0;\\n       sort(rocks.begin(),rocks.end());\\n       for(int i=0;i<n;i++)\\n       {\\n           sum+=rocks[i];\\n           if(sum > additionalRocks) break;\\n           else ans++;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n       long long n =rocks.size(),sumc=0;\\n       for(int i=0;i<n;i++)\\n           rocks[i]=capacity[i]-rocks[i];\\n\\n       long long sum=0,ans=0;\\n       sort(rocks.begin(),rocks.end());\\n       for(int i=0;i<n;i++)\\n       {\\n           sum+=rocks[i];\\n           if(sum > additionalRocks) break;\\n           else ans++;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599995,
                "title": "java-array-sorting-simple-logic",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count=0;\\n        for(int i=0;i<capacity.length;i++)\\n            capacity[i]=capacity[i]-rocks[i];\\n        Arrays.sort(capacity);\\n        for(int j=0;j<capacity.length;j++){\\n            if(capacity[j]==0)\\n                count++;\\n            else if(additionalRocks!=0 && additionalRocks>=capacity[j]){\\n                additionalRocks=additionalRocks-capacity[j];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count=0;\\n        for(int i=0;i<capacity.length;i++)\\n            capacity[i]=capacity[i]-rocks[i];\\n        Arrays.sort(capacity);\\n        for(int j=0;j<capacity.length;j++){\\n            if(capacity[j]==0)\\n                count++;\\n            else if(additionalRocks!=0 && additionalRocks>=capacity[j]){\\n                additionalRocks=additionalRocks-capacity[j];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223868,
                "title": "c-step-by-step-explanation-beats-90",
                "content": "1. First of all we calculate and store the required number of rocks to fill each index completely. \\nLet\\'s say the array which stores the required rocks is `requiredRocks[]`.\\n\\n2. Now we sort the `requiredRocks[]` array in non decreasing order. Note that we don\\'t need to specify which index has to be filled in what order.\\n\\n3.  Now we iterate through the `requiredRocks[]` array till we don\\'t have any `additionalRocks` left, initially we will find  `0s` therefore we increment the `full` variable(which holds our final answer) meaning that position is already filled *completely*.\\n\\n4. When a non zero value appears, we check if the *additional rocks* available can fill the current index completely,if so, then we increment the `full` variable and we decrement the `additionalRocks` by the amount it would take to fill current position.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        vector<int> requiredRocks(n);\\n        for(int i=0;i<n;i++) {\\n            requiredRocks[i] = capacity[i] - rocks[i];\\n        }\\n        sort(requiredRocks.begin(),requiredRocks.end());\\n        int full = 0;\\n        for(int i=0;i<n and additionalRocks>0;i++) {\\n            if(requiredRocks[i] != 0) {\\n                if(additionalRocks >= requiredRocks[i])\\n                    full++;\\n                \\n                additionalRocks = additionalRocks-requiredRocks[i];\\n            } else full++;\\n        }\\n        return full;\\n    }\\n};\\n```\\nAny critique or suggestion would be appreciated :)",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        vector<int> requiredRocks(n);\\n        for(int i=0;i<n;i++) {\\n            requiredRocks[i] = capacity[i] - rocks[i];\\n        }\\n        sort(requiredRocks.begin(),requiredRocks.end());\\n        int full = 0;\\n        for(int i=0;i<n and additionalRocks>0;i++) {\\n            if(requiredRocks[i] != 0) {\\n                if(additionalRocks >= requiredRocks[i])\\n                    full++;\\n                \\n                additionalRocks = additionalRocks-requiredRocks[i];\\n            } else full++;\\n        }\\n        return full;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081458,
                "title": "o-1-space-java-solution",
                "content": "The problem is straight forward. Just have an array of subtracted values and sort that array and calculate the ans.\\nInitially, I did this using an extra array. But we can also do this in O(1) space if we modify the input values itself. \\n\\nPlease upvote if you liked and feel free to ask any doubts!!\\n```java\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for (int i = 0; i<rocks.length; i++) {\\n            rocks[i] = capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(rocks);\\n        int count = 0;\\n        for (int val: rocks) {\\n            if (val == 0) {\\n                count++;\\n                continue;\\n            };\\n            if (val>additionalRocks) break;\\n            if (val<=additionalRocks){\\n                additionalRocks -= val;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for (int i = 0; i<rocks.length; i++) {\\n            rocks[i] = capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(rocks);\\n        int count = 0;\\n        for (int val: rocks) {\\n            if (val == 0) {\\n                count++;\\n                continue;\\n            };\\n            if (val>additionalRocks) break;\\n            if (val<=additionalRocks){\\n                additionalRocks -= val;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063360,
                "title": "simple-java-priority-queue-solution-sorting",
                "content": "\\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n     \\n        int n = capacity.length;\\n        int count = 0;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff == 0) count++;\\n            else pq.add(diff);\\n        }\\n        \\n        while(pq.size() != 0 && additionalRocks != 0){\\n            int val = pq.remove();\\n            if(additionalRocks >= val){\\n                count++;\\n                additionalRocks -= val;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n     \\n        int n = capacity.length;\\n        int count = 0;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff == 0) count++;\\n            else pq.add(diff);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061946,
                "title": "maximum-bag-with-full-capacity-of-rocks",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> vec;\\n        for(int i=0;i<capacity.size();i++){\\n            vec[i]=capacity[i]-rocks[i];\\n        }\\n        int a=additionalRocks;\\n        sort(vec.begin(), vec.end());\\n        int j=0;\\n        while(a>0){\\n            a=a-vec[j];\\n            j++;\\n        }       \\n        return j+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> vec;\\n        for(int i=0;i<capacity.size();i++){\\n            vec[i]=capacity[i]-rocks[i];\\n        }\\n        int a=additionalRocks;\\n        sort(vec.begin(), vec.end());\\n        int j=0;\\n        while(a>0){\\n            a=a-vec[j];\\n            j++;\\n        }       \\n        return j+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061818,
                "title": "c-easy-to-understand-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n    int ans=0;\\n        priority_queue <int, vector<int>, greater<int>> q;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(r[i]<=c[i])\\n            {\\n                int val=c[i]-r[i];\\n               q.push(val);\\n            }\\n        }\\n        while(!q.empty())\\n        {   int z=q.top();\\n            if(z<=a)\\n            {\\n                a-=z;\\n                ans++;\\n            }\\n         q.pop();\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```\\nKindly upvote, if you like the solution :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n    int ans=0;\\n        priority_queue <int, vector<int>, greater<int>> q;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(r[i]<=c[i])\\n            {\\n                int val=c[i]-r[i];\\n               q.push(val);\\n            }\\n        }\\n        while(!q.empty())\\n        {   int z=q.top();\\n            if(z<=a)\\n            {\\n                a-=z;\\n                ans++;\\n            }\\n         q.pop();\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061803,
                "title": "cpp-easy-solution-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& v, int k,int ans=0) {\\n        int n=v.size();\\n        vector<int> idx(n);\\n        for(int i=0;i<n;i++)idx[i]=i;\\n        sort(idx.begin(),idx.end(),[&](int i,int j){\\n            return cap[i]-v[i]<cap[j]-v[j];\\n        });\\n        for(int i:idx){\\n            if(k>=cap[i]-v[i])ans+=1,k-=(cap[i]-v[i]);\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& v, int k,int ans=0) {\\n        int n=v.size();\\n        vector<int> idx(n);\\n        for(int i=0;i<n;i++)idx[i]=i;\\n        sort(idx.begin(),idx.end(),[&](int i,int j){\\n            return cap[i]-v[i]<cap[j]-v[j];\\n        });\\n        for(int i:idx){\\n            if(k>=cap[i]-v[i])ans+=1,k-=(cap[i]-v[i]);\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424113,
                "title": "beginner-s-friendly-solution-o-nlogn",
                "content": "# Intuition\\nIt\\'s just a simple sorting game!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>ans = {};\\n        for(int i = 0; i < rocks.size(); i++) {\\n            int k = capacity[i] - rocks[i];\\n            ans.push_back(k);\\n        }\\n\\n        int count = 0;\\n        sort(ans.begin(), ans.end());\\n\\n        for(int i = 0; i < ans.size(); i++) {\\n            if(additionalRocks != 0) {\\n                count++;\\n                if(ans[i] <= additionalRocks) {\\n                    additionalRocks = additionalRocks - ans[i];\\n                    ans[i] = 0;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        int anss = 0;\\n        for(int i: ans) {\\n            if(i == 0) {\\n                anss++;\\n            }\\n        }\\n        return anss;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>ans = {};\\n        for(int i = 0; i < rocks.size(); i++) {\\n            int k = capacity[i] - rocks[i];\\n            ans.push_back(k);\\n        }\\n\\n        int count = 0;\\n        sort(ans.begin(), ans.end());\\n\\n        for(int i = 0; i < ans.size(); i++) {\\n            if(additionalRocks != 0) {\\n                count++;\\n                if(ans[i] <= additionalRocks) {\\n                    additionalRocks = additionalRocks - ans[i];\\n                    ans[i] = 0;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        int anss = 0;\\n        for(int i: ans) {\\n            if(i == 0) {\\n                anss++;\\n            }\\n        }\\n        return anss;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959811,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "# Intuition\\nAccording to the question, we are supposed to use the additional rocks and fill the half full rock bags. Given the capacity and number of rocks already filled.\\n\\n# Approach\\nThis solution is a greedy approach, where another vector with the remaining space is stored. Sorting it and then subtracting the values from the additional rocks will ensure that maximum bags are filled.\\n\\n# Time complexity\\n This approach has $$O(n)$$ time complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n This approach has $$O(n)$$ space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector <int> add;\\n        int l = capacity.size();\\n        for(int i = 0; i < l; i++){\\n            add.push_back(capacity[i] - rocks[i]);\\n        }\\n        sort(add.begin(), add.end());\\n        int ct = 0;\\n        for(int i = 0; i < l; i++){\\n            if(additionalRocks >= add[i]){\\n                additionalRocks -= add[i];\\n                ct += 1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector <int> add;\\n        int l = capacity.size();\\n        for(int i = 0; i < l; i++){\\n            add.push_back(capacity[i] - rocks[i]);\\n        }\\n        sort(add.begin(), add.end());\\n        int ct = 0;\\n        for(int i = 0; i < l; i++){\\n            if(additionalRocks >= add[i]){\\n                additionalRocks -= add[i];\\n                ct += 1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958417,
                "title": "100-faster-easy-java-soln",
                "content": "First of all the difficulty level of this problem should be changed to easy.\\n# Approach\\nFirst we define an array of integers(d) where we store the number of available capacity in each bags(capacity-rocks).\\nWe sort this array so that we find out the bags which can be full with minimum number of rocks.\\nNow we traverse through this array and decrease the available stones by the number of rocks we keep in each bag,and in each step we increase the counter variable.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: 0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int[] d = new int[capacity.length];\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n            d[i]=capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(d);\\n        int c=0;\\n        for(int i=0;i<d.length;i++)\\n        {\\n//            if(additionalRocks==0)\\n//                break;\\n            if(d[i]==0)\\n                c++;\\n            else if(additionalRocks>=d[i]){\\n                additionalRocks-=d[i];\\n                c++;}\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int[] d = new int[capacity.length];\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n            d[i]=capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(d);\\n        int c=0;\\n        for(int i=0;i<d.length;i++)\\n        {\\n//            if(additionalRocks==0)\\n//                break;\\n            if(d[i]==0)\\n                c++;\\n            else if(additionalRocks>=d[i]){\\n                additionalRocks-=d[i];\\n                c++;}\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958096,
                "title": "easy-greedy-c-solution-using-sorting",
                "content": "# Intuition\\nHere they are asking to find filling maximun to it\\'s capacity so i get idea to think greedily\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Here i take a vector df which store element if there is difference of more than 0 in between rocks and capacity.\\n2. Here i sort the df vector to fill greedily.\\n3. Then here we traverse through vector and if element of vector is  smaller or equal to addiionalRocks then it will increasew ans by 1 and substract element from additonalRocks.\\n4. At the end i add already full capacity elements by N-df.size() where n is size of rock array.\\n5. Return the ans \\n# Complexity\\n- Time complexity:\\nO(N * Log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> df;\\n        int n=rocks.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity[i]>rocks[i])\\n            {\\n                df.push_back(capacity[i]-rocks[i]);\\n            }\\n        }\\n        sort(df.begin(),df.end());\\n        for(auto x:df)\\n        {\\n            if(additionalRocks>=x)\\n            {\\n                additionalRocks-=x;\\n                ans++;\\n            }\\n        }\\n        ans+=(n-df.size());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> df;\\n        int n=rocks.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity[i]>rocks[i])\\n            {\\n                df.push_back(capacity[i]-rocks[i]);\\n            }\\n        }\\n        sort(df.begin(),df.end());\\n        for(auto x:df)\\n        {\\n            if(additionalRocks>=x)\\n            {\\n                additionalRocks-=x;\\n                ans++;\\n            }\\n        }\\n        ans+=(n-df.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957103,
                "title": "java-sorting-greedy-commented",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        // get the vacancy\\n        for (int i = 0; i < rocks.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n\\n        // sort the capacity array, we want to fill as many bags as possible\\n        // we can achieve it only if we get the bags with lesser vacanies first\\n        Arrays.sort(capacity);\\n\\n        int fullBags = 0;\\n        for (int i = 0; i < rocks.length; i++) {\\n            // fill the bags\\n            // if bag is not full, fill it and increase count.\\n            // if already full, can\\'t fill it but the count still increases\\n            if (additionalRocks >= capacity[i]) {\\n                additionalRocks -= capacity[i];\\n                fullBags++;\\n            }\\n        }\\n\\n        return fullBags;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        // get the vacancy\\n        for (int i = 0; i < rocks.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n\\n        // sort the capacity array, we want to fill as many bags as possible\\n        // we can achieve it only if we get the bags with lesser vacanies first\\n        Arrays.sort(capacity);\\n\\n        int fullBags = 0;\\n        for (int i = 0; i < rocks.length; i++) {\\n            // fill the bags\\n            // if bag is not full, fill it and increase count.\\n            // if already full, can\\'t fill it but the count still increases\\n            if (additionalRocks >= capacity[i]) {\\n                additionalRocks -= capacity[i];\\n                fullBags++;\\n            }\\n        }\\n\\n        return fullBags;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956807,
                "title": "simple-easy-to-understand-c-greedy",
                "content": "# Intuition\\nfirst of all declare a vector v and push diff of capacity and rocks\\ni.e--->v[i]=cpacity[i]-rock[i];\\n \\nafter that sort vector v\\nand now look for number of bags that you can completely fill with given additional rock\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int addrock) {\\n        vector<int> v;\\n        for(int i=0;i<rocks.size();i++)\\n            v.push_back(capacity[i]-rocks[i]);\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            addrock-=v[i];\\n            if(addrock<0) return ans;\\n            else ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int addrock) {\\n        vector<int> v;\\n        for(int i=0;i<rocks.size();i++)\\n            v.push_back(capacity[i]-rocks[i]);\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            addrock-=v[i];\\n            if(addrock<0) return ans;\\n            else ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956583,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        for(int i=0; i<c.size(); i++){\\n            c[i]-=r[i];\\n        }\\n        sort(c.begin(), c.end());\\n        int sum =0, ans =0;\\n        for(int i=0; i<c.size(); i++){\\n            sum+=c[i];\\n            if(sum<=a) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        for(int i=0; i<c.size(); i++){\\n            c[i]-=r[i];\\n        }\\n        sort(c.begin(), c.end());\\n        int sum =0, ans =0;\\n        for(int i=0; i<c.size(); i++){\\n            sum+=c[i];\\n            if(sum<=a) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956537,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        int[] x = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            x[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(x);\\n        int ans = 0;\\n        for (int y : x) {\\n            if (y <= additionalRocks) {\\n                ++ans;\\n                additionalRocks -= y;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        int[] x = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            x[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(x);\\n        int ans = 0;\\n        for (int y : x) {\\n            if (y <= additionalRocks) {\\n                ++ans;\\n                additionalRocks -= y;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956422,
                "title": "banker-s-algo-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    //This problem is easily solved by Banker\\'s algo.\\n* Determine the number of rocks needed to fill the bags.\\n* Set a counter to zero and repeat the given process until the addRocks do not equal zero.\\n* If the required value is 0, count++.\\n* If required value of the rocks[i] <=addRocks count++ and addRocks -=rocks[i].\\n* Return the counter value.\\n* Also, if counter == number of bags, either return the number of bags or break the process and return the counter value.\\xA0\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int aR) {\\n        \\n        for(int i=0;i<rocks.size();i++){\\n            rocks[i]=capacity[i]-rocks[i];\\n        }\\n        sort(rocks.begin(),rocks.end());\\n        int c=0,i=0;\\n        while(aR && i<rocks.size()){\\n            if(c==rocks.size())break;\\n            if(rocks[i]==0)c++;\\n            else if(rocks[i]<=aR){\\n                aR-=rocks[i];\\n\\n                c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int aR) {\\n        \\n        for(int i=0;i<rocks.size();i++){\\n            rocks[i]=capacity[i]-rocks[i];\\n        }\\n        sort(rocks.begin(),rocks.end());\\n        int c=0,i=0;\\n        while(aR && i<rocks.size()){\\n            if(c==rocks.size())break;\\n            if(rocks[i]==0)c++;\\n            else if(rocks[i]<=aR){\\n                aR-=rocks[i];\\n\\n                c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955509,
                "title": "c-greedy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we wanted to fill maximum bags we care about the remaining capacity we required to add with additional capacity\\n\\nSuppose we have\\n* Bag 1 whose capacity is 10 and currently contains 3 rocks difference is 7 rocks.\\n* Bag 2 whose capacity is 20 and currently contians 18 rocks.\\n* Bag 3 whose capacity is 10 and currently contains 8 rocks.\\n\\nWe approach `greedily` here, and select bag 2 first (because bag2 and bag3 have same priority we can select any of them) and after that we can select bag 2, bag 1 respectively if we have enough `additionalRocks`.\\n\\nTherefore, we need to calculate the remaining capacity of each bag i, by letting its capacity capacity[i] substract the number of rocks it currently has rocks[i]. That is: remaining capacity of `bag i = capacity[i] - rocks[i]`.\\n\\nAs we would like to full as many bags as possible, we will fill the bag with the smallest remaining capacity first.\\n\\nTherefore, we should sort all the bags by the order of remaining capacity, then start to fill them using additionalRocks from the bag with the smallest remaining capacity. This process stops when we don\\'t have enough rocks to fill the current bag. Since we sort by remaining capacity, all subsequent bags will have no less remaining capacity than the current one, so if we can\\'t fill this bag, it means we can\\'t fill any of the bags after it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Calculate the remaining capacity of each bag and store the values in an array remaining_capacity, set full_bags = 0.\\n* Sort remaining_capacity.\\n* Iterate over the sorted remaining_capacity, for each value cap, check we have enough additionalRocks to fill cap.\\n* If so, increment full_bags by 1, decrement additionalRocks by cap, and move on to the next bag.\\n* Otherwise, stop iterating as we don\\'t have enough rocks to continue.\\nAfter we run out of rocks or finish the iteration, return full_bags.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n logn)$$ where n is the size of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the extra space required to store differences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = int(capacity.size()), maxBagsRequire = 0;\\n        vector<int> curr_capacity(n);\\n\\n        for (int i = 0; i < n; ++i)\\n            curr_capacity[i] = capacity[i] - rocks[i];\\n        sort(curr_capacity.begin(), curr_capacity.end());\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (additionalRocks >= curr_capacity[i]) {\\n                additionalRocks -= curr_capacity[i];\\n                maxBagsRequire++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return maxBagsRequire;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = int(capacity.size()), maxBagsRequire = 0;\\n        vector<int> curr_capacity(n);\\n\\n        for (int i = 0; i < n; ++i)\\n            curr_capacity[i] = capacity[i] - rocks[i];\\n        sort(curr_capacity.begin(), curr_capacity.end());\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (additionalRocks >= curr_capacity[i]) {\\n                additionalRocks -= curr_capacity[i];\\n                maxBagsRequire++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return maxBagsRequire;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154237,
                "title": "easy-and-nice-o-nlogn-c-and-python-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> v;\\n        int c=0, l = rocks.size();\\n        for(int i=0; i<l; ++i){\\n            int p = capacity[i]-rocks[i];\\n            if(p>0)\\n                v.push_back(p);\\n            else ++c;\\n        }\\n        sort(v.begin(),v.end());\\n        int k=0;\\n        while(additionalRocks>0 && k<v.size()){\\n            if(v[k]<=additionalRocks){\\n                ++c;\\n                additionalRocks -= v[k];\\n            }\\n            ++k;\\n        }\\n        return c;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n       v, c, l = [], 0, len(rocks)\\n        for i in range(l):\\n            p = capacity[i]-rocks[i]\\n            if(p>0):\\n                v.append(p)\\n            else: c += 1\\n        v.sort()\\n        k=0\\n        while(additionalRocks>0 and k<len(v)):\\n            if(v[k]<=additionalRocks):\\n                c += 1\\n                additionalRocks -= v[k]\\n            k += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> v;\\n        int c=0, l = rocks.size();\\n        for(int i=0; i<l; ++i){\\n            int p = capacity[i]-rocks[i];\\n            if(p>0)\\n                v.push_back(p);\\n            else ++c;\\n        }\\n        sort(v.begin(),v.end());\\n        int k=0;\\n        while(additionalRocks>0 && k<v.size()){\\n            if(v[k]<=additionalRocks){\\n                ++c;\\n                additionalRocks -= v[k];\\n            }\\n            ++k;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n       v, c, l = [], 0, len(rocks)\\n        for i in range(l):\\n            p = capacity[i]-rocks[i]\\n            if(p>0):\\n                v.append(p)\\n            else: c += 1\\n        v.sort()\\n        k=0\\n        while(additionalRocks>0 and k<len(v)):\\n            if(v[k]<=additionalRocks):\\n                c += 1\\n                additionalRocks -= v[k]\\n            k += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065080,
                "title": "easy-javascript-solution",
                "content": "```\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    var differences = []\\n    var count = 0\\n    for (let i in rocks) {\\n        if ((capacity[i] - rocks[i]) > 0) { // check if rocks[i] is less than capacity[i]\\n            differences.push(capacity[i] - rocks[i]) // add the difference\\n        } else {\\n            count++ // rocks[i] is at full capacity, so the result goes up by 1\\n        }\\n    }\\n    differences.sort((a, b) => a-b) // sort the differences\\n    var r = additionalRocks\\n    while (r != 0 && differences.length > 0) { // loop through differences until there is no more rocks or all of the bags of rocks are at full capacity\\n        if (differences[0] <= r) { \\n            r -= differences[0] // minus the difference of the rocks\\n            count++ // add to result because another bag of rocks is at full capacity\\n        } else {\\n            break // rocks can not make any other bags at full capacity, so stop right here\\n        }\\n        differences.shift() // remove the first difference\\n    } return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    var differences = []\\n    var count = 0\\n    for (let i in rocks) {\\n        if ((capacity[i] - rocks[i]) > 0) { // check if rocks[i] is less than capacity[i]\\n            differences.push(capacity[i] - rocks[i]) // add the difference\\n        } else {\\n            count++ // rocks[i] is at full capacity, so the result goes up by 1\\n        }\\n    }\\n    differences.sort((a, b) => a-b) // sort the differences\\n    var r = additionalRocks\\n    while (r != 0 && differences.length > 0) { // loop through differences until there is no more rocks or all of the bags of rocks are at full capacity\\n        if (differences[0] <= r) { \\n            r -= differences[0] // minus the difference of the rocks\\n            count++ // add to result because another bag of rocks is at full capacity\\n        } else {\\n            break // rocks can not make any other bags at full capacity, so stop right here\\n        }\\n        differences.shift() // remove the first difference\\n    } return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063439,
                "title": "greedy-intuitive-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        if(c.size()!=r.size())\\n            return 0;\\n        int size = r.size();\\n        multimap<int,int> mp;\\n        for(int i = 0;i<size;i++){\\n            if(c[i]>r[i])\\n            mp.insert({c[i]-r[i],i});\\n        }\\n        int ans = 0;\\n        for(auto &i : mp){\\n            if(a>=i.first){\\n                a-=i.first;\\n                r[i.second] += c[i.second] - r[i.second];\\n            }\\n        }\\n        for(int i = 0;i<size;i++)\\n        {\\n            if(r[i] == c[i])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int a) {\\n        if(c.size()!=r.size())\\n            return 0;\\n        int size = r.size();\\n        multimap<int,int> mp;\\n        for(int i = 0;i<size;i++){\\n            if(c[i]>r[i])\\n            mp.insert({c[i]-r[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2062021,
                "title": "java-easy-explained-o-n-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        //to find curr capacity, subtract rocks[i] from capacity[i];\\n        for(int i = 0; i < capacity.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        \\n        //start distributing the additional rocks from smallest to largest to get max no of full bags\\n        Arrays.sort(capacity);\\n        int count = 0;\\n        for(int i = 0; i < capacity.length; i++) {\\n            if(capacity[i] <= additionalRocks) {\\n                additionalRocks -= capacity[i];\\n                count++;\\n            }\\n            if(additionalRocks == 0) {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        //to find curr capacity, subtract rocks[i] from capacity[i];\\n        for(int i = 0; i < capacity.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        \\n        //start distributing the additional rocks from smallest to largest to get max no of full bags\\n        Arrays.sort(capacity);\\n        int count = 0;\\n        for(int i = 0; i < capacity.length; i++) {\\n            if(capacity[i] <= additionalRocks) {\\n                additionalRocks -= capacity[i];\\n                count++;\\n            }\\n            if(additionalRocks == 0) {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061980,
                "title": "solution-using-difference-array",
                "content": "I have created a new difference array, which stores the difference between the max capacity and current capacity.\\nAnd then sorted it, now we just have to fill the bag which is most easy to fill, i.e, that has the least capacity.\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int adr) {\\n        int n = capacity.size();\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++){\\n            v[i] = (capacity[i] - rocks[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(v[i] == 0)\\n                count++;\\n            else if(v[i] <= adr){\\n                count++;\\n                adr = adr - v[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int adr) {\\n        int n = capacity.size();\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++){\\n            v[i] = (capacity[i] - rocks[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(v[i] == 0)\\n                count++;\\n            else if(v[i] <= adr){\\n                count++;\\n                adr = adr - v[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061968,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] c, int[] r, int a) {\\n        int k=c.length;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            b[i]=c[i]-r[i];\\n        }\\n        Arrays.sort(b);\\n        int m=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(a-b[i]<0)\\n                break;\\n            a-=b[i];\\n            m++;\\n        }\\n        return m;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maximumBags(int[] c, int[] r, int a) {\\n        int k=c.length;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            b[i]=c[i]-r[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3620099,
                "title": "clean-code-c-soln-min-heap-explained",
                "content": "# Intuition\\nThe intuition behind this approach is that we want to fill the bags with the least remaining capacity first, as adding rocks to those bags will result in the maximum increase in the number of bags with full capacity.\\n\\n# Approach\\n\\nHere is the step-by-step approach:\\n\\n- Initialize a priority queue called helper with the greater<int> comparator.\\n- Iterate over the bags and calculate the difference between the capacity and the current number of rocks in each bag. Push these differences into the helper priority queue.\\n- Initialize a counter variable to keep track of the number of bags at full capacity.\\n    - While the helper priority queue is not empty and we have additional rocks to place (trocks >= 0), do the following:\\n    - Increment the counter variable to count a bag with full capacity.\\n    - Get the top element from the helper priority queue, which represents the bag with the smallest remaining capacity.\\n    - Remove the top element from the helper priority queue.\\n    - Subtract the remaining capacity from trocks.\\n- If trocks is still greater than or equal to 0, it means we have additional rocks left but no bags to fill. In this case, return the total number of bags (rocks.size()).\\n- Otherwise, return counter - 1, which represents the maximum number of bags with full capacity.\\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n\\n- Space complexity:\\n O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int trocks) {\\n        priority_queue<int,vector<int>,greater<int>>helper;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            helper.push(capacity[i]-rocks[i]);\\n        }\\n        int counter=0;\\n        while(!helper.empty() && trocks>=0)\\n        {\\n            counter++;\\n            int t=helper.top();\\n            helper.pop();\\n            trocks-=t;\\n\\n        }\\n        if(trocks>=0)\\n        return rocks.size();\\n        return counter-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int trocks) {\\n        priority_queue<int,vector<int>,greater<int>>helper;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            helper.push(capacity[i]-rocks[i]);\\n        }\\n        int counter=0;\\n        while(!helper.empty() && trocks>=0)\\n        {\\n            counter++;\\n            int t=helper.top();\\n            helper.pop();\\n            trocks-=t;\\n\\n        }\\n        if(trocks>=0)\\n        return rocks.size();\\n        return counter-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960652,
                "title": "simple-java-code-with-o-n-log-n-time-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) \\n    {\\n         int cnt=0;\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n            capacity[i]-=rocks[i];\\n            if(capacity[i]==0) \\n                cnt++;\\n        }\\n        Arrays.sort(capacity);\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n\\n            if(additionalRocks>=capacity[i] && capacity[i]>0)\\n            {\\n                additionalRocks-=capacity[i]; \\n                cnt++;\\n            }\\n            if(additionalRocks<=0 || additionalRocks<capacity[i])\\n                break;\\n\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) \\n    {\\n         int cnt=0;\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n            capacity[i]-=rocks[i];\\n            if(capacity[i]==0) \\n                cnt++;\\n        }\\n        Arrays.sort(capacity);\\n        for(int i=0;i<capacity.length;i++)\\n        {\\n\\n            if(additionalRocks>=capacity[i] && capacity[i]>0)\\n            {\\n                additionalRocks-=capacity[i]; \\n                cnt++;\\n            }\\n            if(additionalRocks<=0 || additionalRocks<capacity[i])\\n                break;\\n\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959362,
                "title": "100-runtime-js-solution",
                "content": "# Intuition\\nGreedy approach. Similar to Knapsack problem\\n\\n# Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity: 0(nlogn) for sort the array in 0(nlogn) time. Assume that we use a O(nlogn) algorithm. \\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    let result = 0;\\n    for(let i = 0; i < rocks.length; i++){\\n        rocks[i] = capacity[i] - rocks[i];\\n        result += rocks[i];\\n    }\\n    if(additionalRocks >= result) return rocks.length;\\n    rocks.sort(function(a, b){return a - b});\\n    result = 0;\\n    for(let i in rocks){\\n        result += rocks[i];\\n        if(result > additionalRocks) return i;\\n    } \\n};\\n```\\n# Code\\n```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    // number of bags that could have full capacity.\\n    let result = 0;\\n    // the number of capacities left in bag ith. For example, \\n    // cap = [2,3,4,5], rocks = [1,2,4,4], then we have [2 - 1 = 1,\\n    // 1, 0, 1].\\n    for(let i = 0; i < rocks.length; i++){\\n        rocks[i] = capacity[i] - rocks[i];\\n        result += rocks[i];\\n    }\\n    // check if additional rocks can place in all of the bags. For example, you have \\n    // 100 rocks and 10 capacities left, then maximum number of bags always equal to\\n    // number of bags. \\n    if(additionalRocks >= result) return rocks.length;\\n    // sort rocks array to find least stone first. Greedy approach. For example,\\n    // [8, 0, 2] => [0, 2, 8].\\n    rocks.sort(function(a, b){return a - b});\\n    // Set result to 0 to compute maximum number of bags.\\n    result = 0;\\n    // keep adding rocks until there isn\\'t enough rocks to add anymore. \\n    // Because additional rocks cant place in all \\n    // of the bags (additionalRocks >= result)\\n    // So don\\'t need to return result because additionalRocks < result. For example, \\n    // 8 rocks and 10 space left so just add it.\\n    for(let i in rocks){\\n        result += rocks[i];\\n        if(result > additionalRocks) return i;\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    let result = 0;\\n    for(let i = 0; i < rocks.length; i++){\\n        rocks[i] = capacity[i] - rocks[i];\\n        result += rocks[i];\\n    }\\n    if(additionalRocks >= result) return rocks.length;\\n    rocks.sort(function(a, b){return a - b});\\n    result = 0;\\n    for(let i in rocks){\\n        result += rocks[i];\\n        if(result > additionalRocks) return i;\\n    } \\n};\\n```\n```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    // number of bags that could have full capacity.\\n    let result = 0;\\n    // the number of capacities left in bag ith. For example, \\n    // cap = [2,3,4,5], rocks = [1,2,4,4], then we have [2 - 1 = 1,\\n    // 1, 0, 1].\\n    for(let i = 0; i < rocks.length; i++){\\n        rocks[i] = capacity[i] - rocks[i];\\n        result += rocks[i];\\n    }\\n    // check if additional rocks can place in all of the bags. For example, you have \\n    // 100 rocks and 10 capacities left, then maximum number of bags always equal to\\n    // number of bags. \\n    if(additionalRocks >= result) return rocks.length;\\n    // sort rocks array to find least stone first. Greedy approach. For example,\\n    // [8, 0, 2] => [0, 2, 8].\\n    rocks.sort(function(a, b){return a - b});\\n    // Set result to 0 to compute maximum number of bags.\\n    result = 0;\\n    // keep adding rocks until there isn\\'t enough rocks to add anymore. \\n    // Because additional rocks cant place in all \\n    // of the bags (additionalRocks >= result)\\n    // So don\\'t need to return result because additionalRocks < result. For example, \\n    // 8 rocks and 10 space left so just add it.\\n    for(let i in rocks){\\n        result += rocks[i];\\n        if(result > additionalRocks) return i;\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2959152,
                "title": "python-functional-style-and-readability",
                "content": "# Intuition\\n\\nIt\\'s easiest to fill up bags that are closest to being full.\\n\\n# Approach\\n\\n1. First of all, find the `free` space in each bag as `capacity[i] - rocks[i]`. It is rather obvious that one can use `zip` to avoid iteration by index. You may further recall that `operator.sub` can perform subtraction. The tricky part is that `operator.sub` takes two args, whereas `zip` produces tuples with two elements, so instead of a usual `map` you need `itertools.starmap` to unpack the tuples produced by `zip`:\\n\\n```python\\nfree = itertools.starmap(operator.sub, zip(capacity, rocks))\\n```\\n\\n2. As explained in the intuition, the cheapest (in terms of additional rocks placed) way of filling `i` bags is to take `i` smallest values from `free`. Therefore, after sorting `free` the `cost` to fill `i` bags is the `i`-th prefix sum which can be computed with `itertools.accumulate`:\\n\\n```python\\ncosts = itertools.accumulate(sorted(free))\\n```\\n\\n3. Each prefix sum that is less than or equal to `additional_rocks` represents a bag that we can fill fully. It therefore remains to count the number of such prefix sums. `sum(map(can_fill, costs))` comes to mind. \\n\\n```python\\nreturn sum(map(can_fill, costs))\\n```\\n\\n4. `can_fill` should somehow express `additional_rocks >= cost` in a functional way. This is an example of a context-dependent expression. A general way to incorporate context in a function is `functools.partial` that captures some of the function\\'s arguments from the environment. In our case the function is `>=` a.k.a. `operator.ge` and the argument to capture is `additional_rocks`:\\n\\n```python\\ncan_fill = functools.partial(operator.ge, additional_rocks)\\n```\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\log n)$$ for sorting. $$O(n)$$ for prefix sums.\\n\\n- Space complexity: $$O(n)$$ for sorting. $$O(1)$$ for prefix sums thanks to generators.\\n\\n# Code\\n\\n```python\\nimport functools\\nimport itertools\\nimport operator\\n\\n\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int],\\n                    additional_rocks: int) -> int:\\n        free = itertools.starmap(operator.sub, zip(capacity, rocks))\\n        costs = itertools.accumulate(sorted(free))\\n        can_fill = functools.partial(operator.ge, additional_rocks)\\n        return sum(map(can_fill, costs))\\n```\\n\\nI think that the above code has the optimal percentage of functional style. Note that defining additional variables doesn\\'t hurt the performance thanks to generators. Some people will prefer the following \"inlined\" version:\\n\\n```python\\nimport functools\\nimport itertools\\nimport operator\\n\\n\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int],\\n                    additional_rocks: int) -> int:\\n        return sum(map(\\n            functools.partial(\\n                operator.ge, \\n                additional_rocks\\n            ),\\n            itertools.accumulate(sorted(itertools.starmap(\\n                operator.sub,\\n                zip(capacity, rocks)\\n            )))\\n        ))\\n```\\n\\nI still find the above code to be readable, but only barely. You can go further and convert it into a one-liner:\\n\\n```python\\nclass Solution:\\n    def maximumBags(self, c: list[int], r: list[int], a: int) -> int:\\n        return sum(map(partial(ge, a), accumulate(sorted(starmap(sub, zip(c, r))))))\\n```\\n\\nNow this definitely isn\\'t readable, but it\\'s fun so why not? Let me know which of the above versions you find the most readable in the comments down below!\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```python\\nfree = itertools.starmap(operator.sub, zip(capacity, rocks))\\n```\n```python\\ncosts = itertools.accumulate(sorted(free))\\n```\n```python\\nreturn sum(map(can_fill, costs))\\n```\n```python\\ncan_fill = functools.partial(operator.ge, additional_rocks)\\n```\n```python\\nimport functools\\nimport itertools\\nimport operator\\n\\n\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int],\\n                    additional_rocks: int) -> int:\\n        free = itertools.starmap(operator.sub, zip(capacity, rocks))\\n        costs = itertools.accumulate(sorted(free))\\n        can_fill = functools.partial(operator.ge, additional_rocks)\\n        return sum(map(can_fill, costs))\\n```\n```python\\nimport functools\\nimport itertools\\nimport operator\\n\\n\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int],\\n                    additional_rocks: int) -> int:\\n        return sum(map(\\n            functools.partial(\\n                operator.ge, \\n                additional_rocks\\n            ),\\n            itertools.accumulate(sorted(itertools.starmap(\\n                operator.sub,\\n                zip(capacity, rocks)\\n            )))\\n        ))\\n```\n```python\\nclass Solution:\\n    def maximumBags(self, c: list[int], r: list[int], a: int) -> int:\\n        return sum(map(partial(ge, a), accumulate(sorted(starmap(sub, zip(c, r))))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959065,
                "title": "100-0ms-faster-simple-3-lines",
                "content": "# upvote pls\\n\\n# Complexity\\n- Time complexity: o(sort)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] C, int[] R, int A) {\\n        int in=0,l=C.length;\\n        for(int i=0;i<l;i++) C[i]-=R[i];\\n        Arrays.sort(C);\\n        for(in=0;in<l&&A>=C[in];in++) A-=C[in];\\n        return in;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] C, int[] R, int A) {\\n        int in=0,l=C.length;\\n        for(int i=0;i<l;i++) C[i]-=R[i];\\n        Arrays.sort(C);\\n        for(in=0;in<l&&A>=C[in];in++) A-=C[in];\\n        return in;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959014,
                "title": "java-100-solution-maximum-bags-with-full-capacity-of-rocks",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for(int i=0;i<rocks.length;i++)\\n            capacity[i]-=rocks[i];\\n        Arrays.sort(capacity);\\n        int ans=0;\\n        for(int i=0;i<capacity.length;i++)\\n            if(capacity[i]==0)\\n                ans++;\\n            else if(additionalRocks>=capacity[i])\\n            {\\n                additionalRocks-=capacity[i];\\n                ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for(int i=0;i<rocks.length;i++)\\n            capacity[i]-=rocks[i];\\n        Arrays.sort(capacity);\\n        int ans=0;\\n        for(int i=0;i<capacity.length;i++)\\n            if(capacity[i]==0)\\n                ans++;\\n            else if(additionalRocks>=capacity[i])\\n            {\\n                additionalRocks-=capacity[i];\\n                ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958946,
                "title": "java-beats-99-o-nlogn-time-and-o-1-space-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        for(int i=0; i<n; i++){\\n            capacity[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            if(capacity[i] <= additionalRocks){\\n                additionalRocks -= capacity[i];\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        for(int i=0; i<n; i++){\\n            capacity[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            if(capacity[i] <= additionalRocks){\\n                additionalRocks -= capacity[i];\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957929,
                "title": "maximum-bags-with-full-capacity-of-rocks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n- Space complexity:O(1)\\n- wihout using extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int arr) {\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++){\\n            cap[i]=cap[i]-rocks[i];\\n        }\\n        sort(cap.begin(),cap.end());\\n        int ct=0;\\n        for(auto it:cap){\\n           if(arr>=it){\\n               arr-=it;\\n               ct++;\\n           }\\n           else break;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int arr) {\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++){\\n            cap[i]=cap[i]-rocks[i];\\n        }\\n        sort(cap.begin(),cap.end());\\n        int ct=0;\\n        for(auto it:cap){\\n           if(arr>=it){\\n               arr-=it;\\n               ct++;\\n           }\\n           else break;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957773,
                "title": "beats-100-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        # Calculate the vacant space in each bag\\n        vacant = []\\n        for a, b in zip(capacity, rocks):\\n            vacant.append(a - b)\\n\\n        # Sort the list of vacant spaces in ascending order\\n        vacant.sort()\\n\\n        # Initialize a counter for the number of filled bags\\n        ans = 0\\n\\n        # Iterate over the list of vacant spaces\\n        for i in range(len(vacant)):\\n            # If the current bag has no rocks, increment the counter\\n            if vacant[i] == 0:\\n                ans += 1\\n            # If the current bag has some rocks, check if there are enough additional rocks to fill it\\n            else:\\n                # If there are enough additional rocks, fill the bag and decrement the additional rocks counter\\n                if additionalRocks >= vacant[i]:\\n                    additionalRocks -= vacant[i]\\n                    ans += 1\\n                # If there are not enough additional rocks, break the loop and return the current count\\n                else:\\n                    break\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        # Calculate the vacant space in each bag\\n        vacant = []\\n        for a, b in zip(capacity, rocks):\\n            vacant.append(a - b)\\n\\n        # Sort the list of vacant spaces in ascending order\\n        vacant.sort()\\n\\n        # Initialize a counter for the number of filled bags\\n        ans = 0\\n\\n        # Iterate over the list of vacant spaces\\n        for i in range(len(vacant)):\\n            # If the current bag has no rocks, increment the counter\\n            if vacant[i] == 0:\\n                ans += 1\\n            # If the current bag has some rocks, check if there are enough additional rocks to fill it\\n            else:\\n                # If there are enough additional rocks, fill the bag and decrement the additional rocks counter\\n                if additionalRocks >= vacant[i]:\\n                    additionalRocks -= vacant[i]\\n                    ans += 1\\n                # If there are not enough additional rocks, break the loop and return the current count\\n                else:\\n                    break\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957715,
                "title": "simple-java-solution-maximum-bags-with-full-capacity-of-rocks",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int len=rocks.length;\\n        int[] arr=new int[len];\\n        for(int i=0;i<len;i++){\\n            if(rocks[i]<=capacity[i]){\\n                arr[i]=capacity[i]-rocks[i];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int count=0;\\n        for(int i=0;i<len;i++){\\n            if(arr[i]<=additionalRocks){\\n                count++;\\n                additionalRocks=additionalRocks-arr[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int len=rocks.length;\\n        int[] arr=new int[len];\\n        for(int i=0;i<len;i++){\\n            if(rocks[i]<=capacity[i]){\\n                arr[i]=capacity[i]-rocks[i];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int count=0;\\n        for(int i=0;i<len;i++){\\n            if(arr[i]<=additionalRocks){\\n                count++;\\n                additionalRocks=additionalRocks-arr[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957665,
                "title": "python-greedy",
                "content": "```python\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        total = 0\\n        diff = sorted(a - b for a, b in zip(capacity, rocks))\\n        \\n        for d in diff:\\n            if d == 0:\\n                total += 1\\n            elif additionalRocks >= d:\\n                additionalRocks -= d\\n                total += 1\\n            else:\\n                break\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        total = 0\\n        diff = sorted(a - b for a, b in zip(capacity, rocks))\\n        \\n        for d in diff:\\n            if d == 0:\\n                total += 1\\n            elif additionalRocks >= d:\\n                additionalRocks -= d\\n                total += 1\\n            else:\\n                break\\n            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957511,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            v.push_back(capacity[i] - rocks[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; i++) {\\n            if(v[i] == 0) ans++;\\n            else if(v[i] <= additionalRocks) {\\n                additionalRocks -= v[i];\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            v.push_back(capacity[i] - rocks[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; i++) {\\n            if(v[i] == 0) ans++;\\n            else if(v[i] <= additionalRocks) {\\n                additionalRocks -= v[i];\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957502,
                "title": "simple-easy-to-understand-begineer-friendly",
                "content": "\\n\\n     int maximumBags(vector<int>& cap, vector<int>& rocks, int x) \\n    {\\n         vector<int> res;\\n         int n = cap.size();\\n         for(int i=0; i<n; i++){\\n             int temp = cap[i]-rocks[i];\\n             res.push_back(temp);\\n         }\\n         sort(res.begin(),res.end());\\n        int i = 0;\\n        while(x!=0 && i<n)\\n        {\\n            if(x>=res[i])\\n            {\\n                x-=res[i];\\n                res[i] = 0;\\n            }\\n            i++;\\n        }\\n        int ans = count(res.begin(),res.end(),0);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n     int maximumBags(vector<int>& cap, vector<int>& rocks, int x) \\n    {\\n         vector<int> res;\\n         int n = cap.size();\\n         for(int i=0; i<n; i++){\\n             int temp = cap[i]-rocks[i];\\n             res.push_back(temp);\\n         }\\n         sort(res.begin(),res.end());\\n        int i = 0;\\n        while(x!=0 && i<n)\\n        {\\n            if(x>=res[i])\\n            {\\n                x-=res[i];\\n                res[i] = 0;\\n            }\\n            i++;\\n        }\\n        int ans = count(res.begin(),res.end(),0);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2957322,
                "title": "beats-100-simple-c-o-nlogn-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to fill the maximum number of bags, we need to start with minimum number of rock capacitites left so that we can fill maximum bags.   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the capacities left for each index by : \\n    \\n    capacity[i] - rocks[i]\\n\\nand store it in some array. \\n\\nOptimization : You don\\'t have to use an extra array for this. You can use any of the given arrays for the same purpose. Here I have used the rocks array.\\n\\nSort the values so as to greedily choose minimum capacitiy left. Filling until there are no additional rocks left.\\n\\n\\n# Complexity\\n- Time complexity: **O(NlogN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        // Calculate the capacities left to fill \\n        for(int i=0; i<rocks.size(); i++)\\n        {\\n            rocks[i] = capacity[i] - rocks[i];\\n        }\\n        \\n        // Sort to operate Greedily\\n        sort(rocks.begin(), rocks.end());\\n\\n        int ans = 0;\\n        for(int i=0; i<rocks.size(); i++)\\n        {\\n            // Fill until no addtional rocks left\\n            if(rocks[i] <= additionalRocks)\\n            {\\n                additionalRocks -= rocks[i];\\n                ans++;\\n            }\\n            else \\n                break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        // Calculate the capacities left to fill \\n        for(int i=0; i<rocks.size(); i++)\\n        {\\n            rocks[i] = capacity[i] - rocks[i];\\n        }\\n        \\n        // Sort to operate Greedily\\n        sort(rocks.begin(), rocks.end());\\n\\n        int ans = 0;\\n        for(int i=0; i<rocks.size(); i++)\\n        {\\n            // Fill until no addtional rocks left\\n            if(rocks[i] <= additionalRocks)\\n            {\\n                additionalRocks -= rocks[i];\\n                ans++;\\n            }\\n            else \\n                break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957179,
                "title": "simple-c-greedy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0;i<capacity.size();i++){\\n            int diff=capacity[i]-rocks[i];\\n            if(diff > 0) //because if diff ==0 then already sorted\\n                ans.push_back(diff);\\n            //count stores no. of already max weight capacity bags\\n            else count++;\\n        }\\n        //sorting difference of arrays (greedy)\\n        sort(ans.begin(),ans.end());\\n        \\n        for(int i=0;i<ans.size();i++){\\n            if(additionalRocks-ans[i] >=0 ){\\n                additionalRocks-=ans[i];\\n                count++;\\n                if(additionalRocks==0) break;     \\n            }\\n            \\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0;i<capacity.size();i++){\\n            int diff=capacity[i]-rocks[i];\\n            if(diff > 0) //because if diff ==0 then already sorted\\n                ans.push_back(diff);\\n            //count stores no. of already max weight capacity bags\\n            else count++;\\n        }\\n        //sorting difference of arrays (greedy)\\n        sort(ans.begin(),ans.end());\\n        \\n        for(int i=0;i<ans.size();i++){\\n            if(additionalRocks-ans[i] >=0 ){\\n                additionalRocks-=ans[i];\\n                count++;\\n                if(additionalRocks==0) break;     \\n            }\\n            \\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956979,
                "title": "c-easy-explained-o-n",
                "content": "# Intuition\\n###### First we need to calculate how much `Space` for the `Additional stones`left in each bag.\\n###### Then we arrange the bags accordingly( `increasing left capcity`)  \\n###### check the bags are `already full or not` if not full then `keep filling them one by one with additional stones untill no more additional stone left` \\n\\n# Approach\\n1. make a left vector where `left[i]=capacity[i]-rocks[i]`\\n2. sort the left vector in ascending order\\n3. traverse the vector \\n4. if the element is already 0(bag is already full) append the answer count\\n5. else append the answer count and subtract the element from additional rock (filling the bag)\\n6. if additional rock becomes 0 (no additional rock are left) then stop\\n7. return the answer count  \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: )(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int x) {\\n        vector<int>left;\\n        for(int i=0;i<c.size();i++)\\n            left.push_back(c[i]-r[i]);\\n        sort(left.begin(),left.end());\\n        int ans=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            if(left[i]==0)\\n                ans++;\\n            else if(left[i]<=x)\\n            {\\n                ans++;\\n                x-=left[i];\\n            }\\n            if(x==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n ### Thank You (Do Upvote if You Like \\uD83D\\uDE0A)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int x) {\\n        vector<int>left;\\n        for(int i=0;i<c.size();i++)\\n            left.push_back(c[i]-r[i]);\\n        sort(left.begin(),left.end());\\n        int ans=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            if(left[i]==0)\\n                ans++;\\n            else if(left[i]<=x)\\n            {\\n                ans++;\\n                x-=left[i];\\n            }\\n            if(x==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956332,
                "title": "simple-code-explaination-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to check how many bags can be completely filled\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will take a vector that will store the the remaining amount that can be filled in sorted manner and we\\'ll take a counter that will count the no. of full bags and reduce the additionalRocks amount and will return the count \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<capacity.size();i++){\\n            ans.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(auto it:ans){\\n            if(it==0) cnt++;\\n            else if(it<=additionalRocks){\\n                cnt++;\\n                additionalRocks-=it;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<capacity.size();i++){\\n            ans.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(auto it:ans){\\n            if(it==0) cnt++;\\n            else if(it<=additionalRocks){\\n                cnt++;\\n                additionalRocks-=it;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956320,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int a[]=new int[capacity.length];  \\n      for(int i=0;i<capacity.length;i++){\\n          a[i]=capacity[i]-rocks[i];\\n      }\\n      Arrays.sort(a);\\n      int count=0;\\n      for(int i=0;i<capacity.length;i++){\\n          if(a[i]==0){\\n              count++;\\n          }else{\\n              if(additionalRocks>=a[i]){\\n                  additionalRocks-=a[i];\\n                  count++;\\n              }else{\\n                  break;\\n\\n              }\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int a[]=new int[capacity.length];  \\n      for(int i=0;i<capacity.length;i++){\\n          a[i]=capacity[i]-rocks[i];\\n      }\\n      Arrays.sort(a);\\n      int count=0;\\n      for(int i=0;i<capacity.length;i++){\\n          if(a[i]==0){\\n              count++;\\n          }else{\\n              if(additionalRocks>=a[i]){\\n                  additionalRocks-=a[i];\\n                  count++;\\n              }else{\\n                  break;\\n\\n              }\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956239,
                "title": "easiest-explanation-clean-code-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have total capacity for each one and also the no of rocks it has now, so what we can do is, for each index we can do this capacity[i]-=rocks[i], this will help us to understand, after that how much rocks for each index we need to fill that one.\\nAfter doing this, we can just sort the cpacity array, and then run a for loop, where we will be using the additionalRocks, if and only addtionalRocks is more than our capacity[i], i.e.  \\n    if additionalRocks >= capacity[i]:\\n            additionalRocks -= capacity[i]\\n            count++\\n\\nand at last we can just return the count\\n\\n# Complexity\\n- Time complexity:\\nO(n)+O(nlogn) ~ O(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for(int i = 0 ; i < capacity.size() ; i++)\\n        {\\n            capacity[i] -= rocks[i];\\n        }\\n        int cnt = 0;\\n        sort(capacity.begin(), capacity.end());\\n        for(int i = 0 ; i < capacity.size() && additionalRocks ; i++)\\n        {\\n            if(additionalRocks >= capacity[i])\\n            {\\n                additionalRocks -= capacity[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for(int i = 0 ; i < capacity.size() ; i++)\\n        {\\n            capacity[i] -= rocks[i];\\n        }\\n        int cnt = 0;\\n        sort(capacity.begin(), capacity.end());\\n        for(int i = 0 ; i < capacity.size() && additionalRocks ; i++)\\n        {\\n            if(additionalRocks >= capacity[i])\\n            {\\n                additionalRocks -= capacity[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956217,
                "title": "c-begineer-friendly-easy-understanding-o-1-video-solution",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=55uUGD5Pkek/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans =0;\\n        for(int i=0;i<capacity.size();i++){\\n            capacity[i]=capacity[i]-rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n\\n        for(auto x:capacity){\\n            if(additionalRocks >= x){\\n                additionalRocks -= x;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans =0;\\n        for(int i=0;i<capacity.size();i++){\\n            capacity[i]=capacity[i]-rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n\\n        for(auto x:capacity){\\n            if(additionalRocks >= x){\\n                additionalRocks -= x;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956204,
                "title": "python-priority-queue-explained",
                "content": "We just need to calculate the number of missing rocks for each of the bag;\\nPlace the additional rocks into the bag that need the least number of rocks.\\n\\nWe can use a min heap/priority queue to sort the bags based on the missing rocks.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        missing_rocks = []\\n        num_full_bags = 0\\n        \\n        for idx, bag in enumerate(capacity):\\n            heapq.heappush(missing_rocks, bag - rocks[idx])\\n        \\n        while missing_rocks:\\n            additionalRocks -= heapq.heappop(missing_rocks)\\n            if additionalRocks >= 0:\\n                num_full_bags += 1\\n        \\n        return num_full_bags\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        missing_rocks = []\\n        num_full_bags = 0\\n        \\n        for idx, bag in enumerate(capacity):\\n            heapq.heappush(missing_rocks, bag - rocks[idx])\\n        \\n        while missing_rocks:\\n            additionalRocks -= heapq.heappop(missing_rocks)\\n            if additionalRocks >= 0:\\n                num_full_bags += 1\\n        \\n        return num_full_bags\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956203,
                "title": "simple-logical-greedy-solution-explained-with-extra-2d-space",
                "content": "# Approach\\n```\\nFirst We will create a 2D array where difference between \\nthe capacity and currently filled capacity of rocks, \\ncurrent strength of rocks, total capacity of rocks \\nare stored respectively.\\nThen we will sort based on the differences. \\nhere we will think **greedily** because we are sure that \\nif we want maximum then we should start filling the bags \\nwhich need minimum additional rocks.\\nAfter Sorting we will just iterate through the array\\nand will try decreasing the additional rocks until it becomes\\nzero or is less than some difference which we cannot fulfill by \\nadding the extra rocks to that bag.\\nThen simply we will iterate through array and see the postions \\nwhere we have the bags filled with full capacity.\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<capacity.size(); i++){\\n            v.push_back({capacity[i]-rocks[i], rocks[i], capacity[i]});\\n\\n        }\\n        sort(v.begin(), v.end());\\n        int i=0;\\n        while(additionalRocks && i<v.size()){\\n            if(additionalRocks>=v[i][0]){\\n                additionalRocks-=v[i][0];\\n                v[i][1]=v[i][2];\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        int ans=0;\\n        for(auto vec: v){\\n            if(vec[1]==vec[2])ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Upvote if Helpful.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nFirst We will create a 2D array where difference between \\nthe capacity and currently filled capacity of rocks, \\ncurrent strength of rocks, total capacity of rocks \\nare stored respectively.\\nThen we will sort based on the differences. \\nhere we will think **greedily** because we are sure that \\nif we want maximum then we should start filling the bags \\nwhich need minimum additional rocks.\\nAfter Sorting we will just iterate through the array\\nand will try decreasing the additional rocks until it becomes\\nzero or is less than some difference which we cannot fulfill by \\nadding the extra rocks to that bag.\\nThen simply we will iterate through array and see the postions \\nwhere we have the bags filled with full capacity.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<capacity.size(); i++){\\n            v.push_back({capacity[i]-rocks[i], rocks[i], capacity[i]});\\n\\n        }\\n        sort(v.begin(), v.end());\\n        int i=0;\\n        while(additionalRocks && i<v.size()){\\n            if(additionalRocks>=v[i][0]){\\n                additionalRocks-=v[i][0];\\n                v[i][1]=v[i][2];\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        int ans=0;\\n        for(auto vec: v){\\n            if(vec[1]==vec[2])ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956175,
                "title": "fastest-python-solution",
                "content": "# Intuition\\nMy thought behind this logic is that I want to fill up the bags first that needs less additional rocks to full the bags\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIt\\'s the greedy approach, sort the bags with their difference between full capacity and current filled amount \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        dif=[capacity[i]-rocks[i] for i in range(len(rocks))]\\n        dif.sort()\\n        ct=0\\n        for i in range(len(dif)):\\n            if additionalRocks==0:\\n                break\\n            if additionalRocks>=dif[i]:\\n                ct+=1\\n                additionalRocks-=dif[i]\\n            else:\\n                break\\n        return ct\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        dif=[capacity[i]-rocks[i] for i in range(len(rocks))]\\n        dif.sort()\\n        ct=0\\n        for i in range(len(dif)):\\n            if additionalRocks==0:\\n                break\\n            if additionalRocks>=dif[i]:\\n                ct+=1\\n                additionalRocks-=dif[i]\\n            else:\\n                break\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955711,
                "title": "js-faster-than-95-sort-clean-code-easy-to-follow",
                "content": "# Intuition\\nGreedy. Sort, ignore and count full bags, then fill the most close-to-full bag first.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar maximumBags = function (cap, roc, ad) {\\n  let arr = [],full = 0;\\n  for (let i = 0; i < cap.length; i++) {\\n    cap[i] > roc[i] ? arr.push(cap[i] - roc[i]) : full++;\\n  }\\n  arr.sort((a, b) => a - b);\\n  for (let num of arr) {\\n    if (ad >= num) {ad -= num;\\n      full++;\\n    } else {break;}\\n  }\\n  return full;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumBags = function (cap, roc, ad) {\\n  let arr = [],full = 0;\\n  for (let i = 0; i < cap.length; i++) {\\n    cap[i] > roc[i] ? arr.push(cap[i] - roc[i]) : full++;\\n  }\\n  arr.sort((a, b) => a - b);\\n  for (let num of arr) {\\n    if (ad >= num) {ad -= num;\\n      full++;\\n    } else {break;}\\n  }\\n  return full;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955572,
                "title": "c-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we can use *greedy approach*: put additional stones to the bag with the smallest rest (`capacity - rocks`) capacity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOrder bags by their `delta` (original - used) capacity, then a simple for loop. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    \\n    public int MaximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        var deltas = capacity\\n            .Zip(rocks, (c, r) => c - r)\\n            .OrderBy(item => item);\\n\\n        int result = 0;    \\n            \\n        foreach (int delta in deltas) {\\n            if (additionalRocks < delta)\\n                break;\\n            \\n            additionalRocks -= delta;\\n            \\n            result += 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public int MaximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        var deltas = capacity\\n            .Zip(rocks, (c, r) => c - r)\\n            .OrderBy(item => item);\\n\\n        int result = 0;    \\n            \\n        foreach (int delta in deltas) {\\n            if (additionalRocks < delta)\\n                break;\\n            \\n            additionalRocks -= delta;\\n            \\n            result += 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955559,
                "title": "rust-elixir-sort-the-spaces",
                "content": "# Rust\\n```rust\\nimpl Solution {\\n    pub fn maximum_bags(capacity: Vec<i32>, rocks: Vec<i32>, mut additional_rocks: i32) -> i32 {\\n        let mut need: Vec<i32> = (0..rocks.len())\\n            .map(|i| capacity[i] - rocks[i])\\n            .collect();\\n        need.sort_unstable();\\n        for i in 0..need.len() {\\n            if additional_rocks < need[i] {\\n                return i as i32;\\n            }\\n            additional_rocks -= need[i];\\n        }\\n        need.len() as i32\\n    }\\n}\\n```\\n# Elixir\\n```elixir\\ndefmodule Solution do\\n  @spec maximum_bags(capacity :: [integer], rocks :: [integer], additional_rocks :: integer) :: integer\\n  def maximum_bags(capacity, rocks, additional_rocks) do\\n    Enum.zip_with([capacity, rocks], fn [c, r] -> c - r end)\\n    |> Enum.sort()\\n    |> Enum.scan(&(&1 + &2))\\n    |> Enum.find_index(&(&1 > additional_rocks))\\n    |> Kernel.||(length(rocks)) # replace :nil with n\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Sorting"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_bags(capacity: Vec<i32>, rocks: Vec<i32>, mut additional_rocks: i32) -> i32 {\\n        let mut need: Vec<i32> = (0..rocks.len())\\n            .map(|i| capacity[i] - rocks[i])\\n            .collect();\\n        need.sort_unstable();\\n        for i in 0..need.len() {\\n            if additional_rocks < need[i] {\\n                return i as i32;\\n            }\\n            additional_rocks -= need[i];\\n        }\\n        need.len() as i32\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec maximum_bags(capacity :: [integer], rocks :: [integer], additional_rocks :: integer) :: integer\\n  def maximum_bags(capacity, rocks, additional_rocks) do\\n    Enum.zip_with([capacity, rocks], fn [c, r] -> c - r end)\\n    |> Enum.sort()\\n    |> Enum.scan(&(&1 + &2))\\n    |> Enum.find_index(&(&1 > additional_rocks))\\n    |> Kernel.||(length(rocks)) # replace :nil with n\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2955504,
                "title": "python-1-liner",
                "content": "We always want to fill the bags closest to being full, so sort bags by the number of spaces left. Then compute prefix sum to find cumulative number of spaces left. Finally, perform a binary search to find the index where our cumulative sum is <= the number of additional rocks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\ndef maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n    return bisect(list(accumulate(sorted([capacity[i] - rocks[i] for i in range(len(capacity))]))), additionalRocks)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n    return bisect(list(accumulate(sorted([capacity[i] - rocks[i] for i in range(len(capacity))]))), additionalRocks)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2592726,
                "title": "javascript-solution",
                "content": "```\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    for (let i = 0; i < capacity.length; i++) {\\n        rocks[i] = capacity[i] - rocks[i]\\n    }\\n    \\n    rocks.sort((a, b) => a - b)\\n    \\n    let total_bags = 0\\n    let len = 0\\n    while(additionalRocks > 0 && len < rocks.length){\\n        additionalRocks -= rocks[len]\\n        if (additionalRocks >= 0) {\\n            total_bags++\\n        }\\n        len++\\n    }\\n    return total_bags\\n};\\n\\n// Solution 2 - Binary search\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    let len = capacity.length;\\n    let diff = []\\n    for (let i = 0; i < capacity.length; i++) {\\n        diff.push(capacity[i] - rocks[i])\\n    }\\n    diff.sort((a, b) => a - b)\\n    \\n    let start = 0;\\n    let end = len;\\n    let ans = 0;\\n    while(start <= end){\\n       let mid = start + Math.floor((end-start)/2);\\n       if(isValid(diff,mid,additionalRocks,len)){\\n           ans = mid;\\n           start = mid + 1;\\n       } else {\\n           end = mid - 1;\\n       }\\n    }\\n    return ans;\\n}\\n\\nvar isValid = function(diff,mid,additionalRocks,len) {    \\n       for(let i=0;i<len;i++){\\n        additionalRocks -= diff[i];\\n        if(additionalRocks < 0)return false;\\n        if(additionalRocks >= 0 && i == (mid - 1))break;\\n    }\\n     return true;\\n   }",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    for (let i = 0; i < capacity.length; i++) {\\n        rocks[i] = capacity[i] - rocks[i]\\n    }\\n    \\n    rocks.sort((a, b) => a - b)\\n    \\n    let total_bags = 0\\n    let len = 0\\n    while(additionalRocks > 0 && len < rocks.length){\\n        additionalRocks -= rocks[len]\\n        if (additionalRocks >= 0) {\\n            total_bags++\\n        }\\n        len++\\n    }\\n    return total_bags\\n};\\n\\n// Solution 2 - Binary search\\nvar maximumBags = function(capacity, rocks, additionalRocks) {\\n    let len = capacity.length;\\n    let diff = []\\n    for (let i = 0; i < capacity.length; i++) {\\n        diff.push(capacity[i] - rocks[i])\\n    }\\n    diff.sort((a, b) => a - b)\\n    \\n    let start = 0;\\n    let end = len;\\n    let ans = 0;\\n    while(start <= end){\\n       let mid = start + Math.floor((end-start)/2);\\n       if(isValid(diff,mid,additionalRocks,len)){\\n           ans = mid;\\n           start = mid + 1;\\n       } else {\\n           end = mid - 1;\\n       }\\n    }\\n    return ans;\\n}\\n\\nvar isValid = function(diff,mid,additionalRocks,len) {    \\n       for(let i=0;i<len;i++){\\n        additionalRocks -= diff[i];\\n        if(additionalRocks < 0)return false;\\n        if(additionalRocks >= 0 && i == (mid - 1))break;\\n    }\\n     return true;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 2221439,
                "title": "rust-common-approach",
                "content": "The first version\\'s best time was 14ms. The second one 23ms. And the 3rd one gets around 14ms.\\n\\nOf the three, I think the 3rd is the best as it requires only one pass over the data.\\n\\n## Approach\\nThe `capacity` vector is updated to reflect the remaining space of each bag after subtracting the number of rocks in each bag. The vector is sorted ascending. `capacity` is then iterated over (skipping all bags with 0 capacity), subtracting each item\\'s remaining space from `additional` (the remaining rocks). When `additional` dips below 0, counting stops.\\n\\n## Complexity\\n- Time: $$O(n*log(n))$$\\n- Space: $$O(1)$$ *auxiliary* space.\\n\\n```rust\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let mut additional = additional_rocks;\\n        let mut capacity   = capacity;\\n        \\n        capacity.iter_mut().zip(rocks).for_each(|(c, r)| *c -= r);\\n        capacity.sort_unstable();\\n\\n        let start = capacity.partition_point(|&n| n < 1);\\n\\n        capacity[start..].into_iter()\\n                         .take_while(|&n| { additional -= n; additional >= 0 })\\n                         .count() as i32\\n        + start as i32\\n    }\\n}\\n```\\n\\n## Using BinaryHeap\\n\\n`BinaryHeap::from(capacity)` in the code below doesn\\'t allocate more space; it takes the vector and assigns it to the `BinaryHeap`\\'s internal data field. The capacity values have inverted sign due to `BinaryHeap` being a max heap.\\n\\n## Complexity\\n- Time: $$O(n*log(n))$$\\n- Space: $$O(1)$$ *auxiliary* space.\\n\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let     n          = rocks.len();\\n        let mut capacity   = capacity;\\n        let mut additional = additional_rocks;\\n        \\n        capacity.iter_mut().zip(rocks).for_each(|(c, r)| *c = r - *c);\\n\\n        let mut capacity = BinaryHeap::from(capacity);\\n\\n        (0..n).filter_map(|_| capacity.pop())\\n              .take_while(|&n| { additional += n; additional >= 0 })\\n              .count() as i32\\n    }\\n}\\n```\\n\\n## Single Pass Over Data\\n\\nThis version only takes one single pass over the data set to find the answer. Both of the examples above take multiple passes over it either explicitly, or implicitly.\\n\\nAs the input data is cycled over, the unfilled capacity of the current bag is used as the heap key. Bags are added until we have enough on the heap to eat up all the `additional_rocks`. Then we continue.\\n\\nBags that have more left over capacity are going to eat up `additional_rocks` faster. So those are at the top of the heap, ready to be tossed out for better options. When a bag comes along that has less free capacity than the heap\\'s top item, it bumps the largest bag off the heap before bing pushed. This strategy ensures the heap will be populated by the bags with the least additional capacity when the cycle completes.\\n\\n## Complexity\\n- Time: $$O(n*log(n))$$ The performance may be better than this since pop operations aren\\'t performed for every item. The heap\\'s pop operation is $$O(log(n))$$. Other operations are $$O(1)$$.\\n- Space: $$O(n)$$ This is probably actually `O(min(additional_rocks, n))`\\n\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let     n    = rocks.len();\\n        let mut sum  = 0;\\n        let mut heap = BinaryHeap::new();\\n\\n        for i in 0..n {\\n            let diff = capacity[i] - rocks[i];\\n\\n            if diff + sum <= additional_rocks {\\n                heap.push(diff);\\n                sum += diff;\\n            } else if Some(&diff) < heap.peek() {\\n                sum -= heap.pop().unwrap();\\n                sum += diff;\\n                heap.push(diff);\\n            }\\n        }\\n        heap.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let mut additional = additional_rocks;\\n        let mut capacity   = capacity;\\n        \\n        capacity.iter_mut().zip(rocks).for_each(|(c, r)| *c -= r);\\n        capacity.sort_unstable();\\n\\n        let start = capacity.partition_point(|&n| n < 1);\\n\\n        capacity[start..].into_iter()\\n                         .take_while(|&n| { additional -= n; additional >= 0 })\\n                         .count() as i32\\n        + start as i32\\n    }\\n}\\n```\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let     n          = rocks.len();\\n        let mut capacity   = capacity;\\n        let mut additional = additional_rocks;\\n        \\n        capacity.iter_mut().zip(rocks).for_each(|(c, r)| *c = r - *c);\\n\\n        let mut capacity = BinaryHeap::from(capacity);\\n\\n        (0..n).filter_map(|_| capacity.pop())\\n              .take_while(|&n| { additional += n; additional >= 0 })\\n              .count() as i32\\n    }\\n}\\n```\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn maximum_bags(capacity         : Vec<i32>, \\n                        rocks            : Vec<i32>, \\n                        additional_rocks : i32) \\n        -> i32 \\n    {\\n        let     n    = rocks.len();\\n        let mut sum  = 0;\\n        let mut heap = BinaryHeap::new();\\n\\n        for i in 0..n {\\n            let diff = capacity[i] - rocks[i];\\n\\n            if diff + sum <= additional_rocks {\\n                heap.push(diff);\\n                sum += diff;\\n            } else if Some(&diff) < heap.peek() {\\n                sum -= heap.pop().unwrap();\\n                sum += diff;\\n                heap.push(diff);\\n            }\\n        }\\n        heap.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221179,
                "title": "c-easy-understandable-2-solutions",
                "content": "1st Approach - \\nIntuition -\\nWe try to fill those  bags which has the minimum requirement of stones so that we can increase the number of bags with full capacity. So we create a difference array and sort it in increasing order so that bags with less requirement can be filled at the start and we can increase the total number of completely filled bags.\\n\\nCode -- >\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>diff;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            diff.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(diff.begin(),diff.end());\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            if(diff[i] <= additionalRocks){\\n                additionalRocks -= diff[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nTime Complexity - O(N) + O(NlogN) + O(N)\\nSpace Complexity - O(N)\\n\\n2nd Approach -\\nWe can create a min-heap to for the same intuition discussed in approach 1 .So we use Priority_queue to serve the purpose;\\n\\nCode - :\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            pq.push(capacity[i]-rocks[i]);\\n        }\\n        while(!pq.empty()){\\n            int s = pq.top();\\n            pq.pop();\\n            if(s <= additionalRocks){\\n                additionalRocks -= s;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nTime Complexity - O(NlogN) + O(N)\\nSpace Complexity  - O(N)\\n\\n**Please do like and upvote :) and let me know if you face any doubt regarding the code in the comment**",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>diff;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            diff.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(diff.begin(),diff.end());\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            if(diff[i] <= additionalRocks){\\n                additionalRocks -= diff[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            pq.push(capacity[i]-rocks[i]);\\n        }\\n        while(!pq.empty()){\\n            int s = pq.top();\\n            pq.pop();\\n            if(s <= additionalRocks){\\n                additionalRocks -= s;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173332,
                "title": "easy-java-solution-o-nlogn-easy-to-understand-beginner-friendly-greedy-sorting",
                "content": "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for(int i=0;i<capacity.length;i++){\\n            capacity[i] = capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        int count=0;\\n        for(int i=0;i<capacity.length;i++){\\n            if(capacity[i]<=additionalRocks){\\n                additionalRocks-= capacity[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n//Note :- Please upvote if you find it helpful ...Thank you !",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for(int i=0;i<capacity.length;i++){\\n            capacity[i] = capacity[i]-rocks[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2119372,
                "title": "c-greedy-solution-o-nlogn-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=capacity[i];\\n            if(ans>additionalRocks){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=capacity[i];\\n            if(ans>additionalRocks){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076230,
                "title": "c-easy-solution",
                "content": "```\\n int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int> v(rocks.size(),-1);\\n        for(int i=0 ; i< capacity.size() ; i++){\\n            if(capacity[i]>=rocks[i]){\\n                v[i]=capacity[i]-rocks[i];\\n            }\\n            \\n           \\n        } sort(v.begin(),v.end());\\n        \\n            for(int i=0;i<rocks.size();i++){\\n                if(additionalRocks-v[i]>=0 && v[i]) {\\n                    additionalRocks-=v[i];\\n                    count++;\\n                }\\n                if(v[i]==0) count++;\\n            }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int> v(rocks.size(),-1);\\n        for(int i=0 ; i< capacity.size() ; i++){\\n            if(capacity[i]>=rocks[i]){\\n                v[i]=capacity[i]-rocks[i];\\n            }\\n            \\n           \\n        } sort(v.begin(),v.end());\\n        \\n            for(int i=0;i<rocks.size();i++){\\n                if(additionalRocks-v[i]>=0 && v[i]) {\\n                    additionalRocks-=v[i];\\n                    count++;\\n                }\\n                if(v[i]==0) count++;\\n            }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068110,
                "title": "kotlin-solution-using-priority-queue",
                "content": "```\\nfun maximumBags(capacity: IntArray, rocks: IntArray, additionalRocks: Int): Int {\\n    var additionalRocks = additionalRocks\\n    var result = 0\\n    val pq = PriorityQueue<Int>()\\n    for (i in rocks.indices) {\\n        if (capacity[i] - rocks[i] > 0) {\\n            pq.add(capacity[i] - rocks[i])\\n        } else result++\\n    }\\n    \\n\\t// fill up best bag every time until the rocks run out\\n    while (!pq.isEmpty() && additionalRocks > 0) {\\n        val stuff = pq.poll()\\n        if (stuff > additionalRocks) {\\n            return result\\n        }\\n        additionalRocks -= stuff\\n        result++\\n    }\\n        \\n    if (pq.poll() == 0) result++\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun maximumBags(capacity: IntArray, rocks: IntArray, additionalRocks: Int): Int {\\n    var additionalRocks = additionalRocks\\n    var result = 0\\n    val pq = PriorityQueue<Int>()\\n    for (i in rocks.indices) {\\n        if (capacity[i] - rocks[i] > 0) {\\n            pq.add(capacity[i] - rocks[i])\\n        } else result++\\n    }\\n    \\n\\t// fill up best bag every time until the rocks run out\\n    while (!pq.isEmpty() && additionalRocks > 0) {\\n        val stuff = pq.poll()\\n        if (stuff > additionalRocks) {\\n            return result\\n        }\\n        additionalRocks -= stuff\\n        result++\\n    }\\n        \\n    if (pq.poll() == 0) result++\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2066181,
                "title": "simple-c-approach-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        multiset<int> s;        // multiset to store the difference between capacity and rocks in increasing order.\\n        int res=0;  \\n        for(int i=0;i<capacity.size();i++)\\n            s.insert(capacity[i]-rocks[i]);         // storing  the difference in the multiset.\\n        for(auto it:s){\\n            if(it==0)\\n\\t\\t\\t\\tres++;        // if no additional rocks are needed as the rocks are already at full capacity.\\n            else\\n            {\\n                if(additionalRocks>=it && additionalRocks>0){        //check if additional rocks are available or not.\\n                    res++;\\n                    additionalRocks-=it;\\n                }\\n            }\\n\\n        }            \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        multiset<int> s;        // multiset to store the difference between capacity and rocks in increasing order.\\n        int res=0;  \\n        for(int i=0;i<capacity.size();i++)\\n            s.insert(capacity[i]-rocks[i]);         // storing  the difference in the multiset.\\n        for(auto it:s){\\n            if(it==0)\\n\\t\\t\\t\\tres++;        // if no additional rocks are needed as the rocks are already at full capacity.\\n            else\\n            {\\n                if(additionalRocks>=it && additionalRocks>0){        //check if additional rocks are available or not.\\n                    res++;\\n                    additionalRocks-=it;\\n                }\\n            }\\n\\n        }            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063091,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int \\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<ll> space;\\n        ll ans=0;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            space.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(space.begin(),space.end());\\n        ll sum=accumulate(space.begin(),space.end(),(ll)0);\\n        if(sum<=additionalRocks)\\n        return rocks.size();\\n        else\\n        {   \\n            for(int i=0;i<space.size();i++)\\n            {\\n                if(additionalRocks>=space[i])\\n                {\\n                    ans++;\\n                    additionalRocks-=space[i];\\n                }\\n                else if(space[i]==0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int \\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<ll> space;\\n        ll ans=0;\\n        for(int i=0;i<rocks.size();i++)\\n        {\\n            space.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(space.begin(),space.end());\\n        ll sum=accumulate(space.begin(),space.end(),(ll)0);\\n        if(sum<=additionalRocks)\\n        return rocks.size();\\n        else\\n        {   \\n            for(int i=0;i<space.size();i++)\\n            {\\n                if(additionalRocks>=space[i])\\n                {\\n                    ans++;\\n                    additionalRocks-=space[i];\\n                }\\n                else if(space[i]==0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062800,
                "title": "simple-python-solution-o-n-log-n-o-n-space-o-1-space",
                "content": "1. Create a list. Then loop through the array and store the the number of rocks required to get the maximum capacity of each corresponding bag in the created list. Next we\\'ll sort the array ascendingly so that we can get the maximum number of bags of full capacity. Create a counter and loop through the list and for each required stones, deduct that from the \"additionalRocks\" and increase the counter by 1. Finally return the counter.\\n\\n\\n```\\n#  O(n)->space,  O(nlogn) -> time  \\nimport numpy as np\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        diff = np.array(capacity) - np.array(rocks)\\n        diff.sort()\\n        res = 0\\n        for i in range(len(diff)):\\n            if diff[i] <= additionalRocks:\\n                additionalRocks -= diff[i]\\n                res += 1\\n        return res\\n```\\n\\n2. Same approach as before, just store the difference of required stones in either capacity list or rocks list\\n\\n```\\n# O(1)-> space,  O(nlogn)-> time \\n\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        \\n        ans = 0\\n        for i in range(len(capacity)):\\n            capacity[i] -= rocks[i]\\n        capacity.sort()\\n        for val in capacity:\\n            if val <= additionalRocks:\\n                additionalRocks -= val\\n                ans += 1\\n        return ans\\n```\\n\\nUpvote, if you like it!!!\\nAll the best and keep coding\\uD83D\\uDE0A",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#  O(n)->space,  O(nlogn) -> time  \\nimport numpy as np\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        diff = np.array(capacity) - np.array(rocks)\\n        diff.sort()\\n        res = 0\\n        for i in range(len(diff)):\\n            if diff[i] <= additionalRocks:\\n                additionalRocks -= diff[i]\\n                res += 1\\n        return res\\n```\n```\\n# O(1)-> space,  O(nlogn)-> time \\n\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        \\n        ans = 0\\n        for i in range(len(capacity)):\\n            capacity[i] -= rocks[i]\\n        capacity.sort()\\n        for val in capacity:\\n            if val <= additionalRocks:\\n                additionalRocks -= val\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062790,
                "title": "c-using-multisets",
                "content": "# ****Using MultiSets ->****\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        // result\\n        int ans = 0;     \\n        \\n        // using multiset  //  we can also use array but we need to sort it\\n\\t\\tmultiset<int> v1;\\n        int n = rocks.size();\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff==0)     ans++;       // if zero max. capacity already\\n\\t\\t\\telse            v1.insert(diff);\\n        }\\n        \\n        for(auto &it : v1){\\n            if( it <= k  and  k > 0 ){           \\n                k -= it;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# ****Using Array ->****\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        int ans = 0;\\n        vector<int> v1;\\n        int n = rocks.size();\\n\\t\\t\\n        for(int i=0 ; i<n ; i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff==0)     ans++;\\n            else            v1.push_back(diff);\\n        }\\n        sort(v1.begin() , v1.end());\\n        \\n\\t\\tfor(auto &it : v1){\\n            if( it <= k  and  k > 0 ){           \\n                k -= it;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        // result\\n        int ans = 0;     \\n        \\n        // using multiset  //  we can also use array but we need to sort it\\n\\t\\tmultiset<int> v1;\\n        int n = rocks.size();\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff==0)     ans++;       // if zero max. capacity already\\n\\t\\t\\telse            v1.insert(diff);\\n        }\\n        \\n        for(auto &it : v1){\\n            if( it <= k  and  k > 0 ){           \\n                k -= it;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int k) {\\n        int ans = 0;\\n        vector<int> v1;\\n        int n = rocks.size();\\n\\t\\t\\n        for(int i=0 ; i<n ; i++){\\n            int diff = capacity[i] - rocks[i];\\n            if(diff==0)     ans++;\\n            else            v1.push_back(diff);\\n        }\\n        sort(v1.begin() , v1.end());\\n        \\n\\t\\tfor(auto &it : v1){\\n            if( it <= k  and  k > 0 ){           \\n                k -= it;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062750,
                "title": "greedy-solution-c",
                "content": "```\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> dif;\\n        int ans=0;\\n        for(int i=0;i<capacity.size();i++){\\n            dif.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(dif.begin(),dif.end());\\n        for(int i=0;i<dif.size();i++){\\n            if(additionalRocks<=0) break;\\n            if(dif[i]<=additionalRocks){\\n                ans++;\\n                additionalRocks-=dif[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> dif;\\n        int ans=0;\\n        for(int i=0;i<capacity.size();i++){\\n            dif.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(dif.begin(),dif.end());\\n        for(int i=0;i<dif.size();i++){\\n            if(additionalRocks<=0) break;\\n            if(dif[i]<=additionalRocks){\\n                ans++;\\n                additionalRocks-=dif[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2062323,
                "title": "c-priority-queue",
                "content": "**Time Complexity : O(nlogn)**\\n**Space Complexity : O(n)**\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        priority_queue<int,vector<int>,greater<int>> pq; // min heap\\n        int n = rocks.size(); // number of rocks\\n        int cnt=0;  // number of bags\\n        for(int i=0;i<n;i++){ // for each rock\\n            pq.push(capacity[i]-rocks[i]); // push the difference between capacity and weight of the rock\\n        }\\n        while(!pq.empty() &&additionalRocks>0){ // while there are rocks and additional rocks\\n            int top = pq.top(); // get the top element\\n            pq.pop(); // pop the top element\\n            if(top==0){ // if the top element is 0\\n                cnt++; // increase the number of bags\\n                continue; // continue\\n            }\\n            else if(top>additionalRocks) return cnt; // if the top element is greater than additional rocks then return cnt\\n            else{\\n                cnt++; // increase the number of bags\\n                additionalRocks-=top; // decrease the additional rocks\\n            } \\n        }\\n        return cnt; // return the number of bags\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        priority_queue<int,vector<int>,greater<int>> pq; // min heap\\n        int n = rocks.size(); // number of rocks\\n        int cnt=0;  // number of bags\\n        for(int i=0;i<n;i++){ // for each rock\\n            pq.push(capacity[i]-rocks[i]); // push the difference between capacity and weight of the rock\\n        }\\n        while(!pq.empty() &&additionalRocks>0){ // while there are rocks and additional rocks\\n            int top = pq.top(); // get the top element\\n            pq.pop(); // pop the top element\\n            if(top==0){ // if the top element is 0\\n                cnt++; // increase the number of bags\\n                continue; // continue\\n            }\\n            else if(top>additionalRocks) return cnt; // if the top element is greater than additional rocks then return cnt\\n            else{\\n                cnt++; // increase the number of bags\\n                additionalRocks-=top; // decrease the additional rocks\\n            } \\n        }\\n        return cnt; // return the number of bags\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062245,
                "title": "c-solution-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        long long int rem_sum=0;\\n        vector<int> rem_cap;\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++){\\n            int val=capacity[i]-rocks[i]; \\n            rem_cap.push_back(val); // store the remaining capacity of each bag in a vector\\n            rem_sum+=val;\\n        }\\n        if(rem_sum<=additionalRocks) return n; // if remaining capacity of bags is less than or\\n\\t\\t//equal to additionalRocks then return total number of bags i.e. **n**\\n\\t\\t\\n\\t\\t//now sort the remaining capacity vector\\n        sort(rem_cap.begin(),rem_cap.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ // now traverse rem_cap vector until additionalRocks over\\n            if(additionalRocks>=rem_cap[i]){\\n                additionalRocks-=rem_cap[i];\\n                i++;\\n            }else{\\n                break;\\n            }\\n            \\n        }\\n        return i; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        long long int rem_sum=0;\\n        vector<int> rem_cap;\\n        int n=rocks.size();\\n        for(int i=0;i<n;i++){\\n            int val=capacity[i]-rocks[i]; \\n            rem_cap.push_back(val); // store the remaining capacity of each bag in a vector\\n            rem_sum+=val;\\n        }\\n        if(rem_sum<=additionalRocks) return n; // if remaining capacity of bags is less than or\\n\\t\\t//equal to additionalRocks then return total number of bags i.e. **n**\\n\\t\\t\\n\\t\\t//now sort the remaining capacity vector\\n        sort(rem_cap.begin(),rem_cap.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ // now traverse rem_cap vector until additionalRocks over\\n            if(additionalRocks>=rem_cap[i]){\\n                additionalRocks-=rem_cap[i];\\n                i++;\\n            }else{\\n                break;\\n            }\\n            \\n        }\\n        return i; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062186,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        remaining = [0] * len(capacity)\\n        res = 0\\n        \\n        for i in range(len(capacity)):\\n            remaining[i] = capacity[i] - rocks[i]\\n        remaining.sort()\\n        \\n        for i in range(len(remaining)):\\n            if remaining[i] > additionalRocks:\\n                break\\n                \\n            additionalRocks -= remaining[i]\\n            res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        remaining = [0] * len(capacity)\\n        res = 0\\n        \\n        for i in range(len(capacity)):\\n            remaining[i] = capacity[i] - rocks[i]\\n        remaining.sort()\\n        \\n        for i in range(len(remaining)):\\n            if remaining[i] > additionalRocks:\\n                break\\n                \\n            additionalRocks -= remaining[i]\\n            res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062144,
                "title": "beginner-friendly-easy-to-understand-c-intution",
                "content": "Steps:\\n1) Calculate the rocks to be added for each bag by : ```capacity[i] - rocks[i]```\\n2) Sort this vector.\\n3) For each element in this array, if element is 0, i.e bag is full, increment the ans.\\n4) for non-zero element, check the additional rocks and add the rocks to bag to its full capacity.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans=0;\\n        vector<int> rockstobeadded(rocks.size(), 0);\\n\\n        for(int n=0; n<capacity.size(); n++){\\n            rockstobeadded[n] = capacity[n] - rocks[n];\\n        }\\n\\n        sort(rockstobeadded.begin(), rockstobeadded.end());\\n        \\n        for(int n=0; n<capacity.size(); n++){\\n            \\n            if(rockstobeadded[n] == 0)  ans++;\\n            \\n            else if(rockstobeadded[n] > 0){\\n                if(additionalRocks>=rockstobeadded[n]){\\n                    additionalRocks -= rockstobeadded[n]; \\n                    rockstobeadded[n] = 0;\\n                     ans++;\\n                 }\\n                 else{\\n                     rockstobeadded[n] -= additionalRocks;\\n                     additionalRocks = 0;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```capacity[i] - rocks[i]```\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans=0;\\n        vector<int> rockstobeadded(rocks.size(), 0);\\n\\n        for(int n=0; n<capacity.size(); n++){\\n            rockstobeadded[n] = capacity[n] - rocks[n];\\n        }\\n\\n        sort(rockstobeadded.begin(), rockstobeadded.end());\\n        \\n        for(int n=0; n<capacity.size(); n++){\\n            \\n            if(rockstobeadded[n] == 0)  ans++;\\n            \\n            else if(rockstobeadded[n] > 0){\\n                if(additionalRocks>=rockstobeadded[n]){\\n                    additionalRocks -= rockstobeadded[n]; \\n                    rockstobeadded[n] = 0;\\n                     ans++;\\n                 }\\n                 else{\\n                     rockstobeadded[n] -= additionalRocks;\\n                     additionalRocks = 0;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062143,
                "title": "prioritise-smaller-differences-java",
                "content": "### Logic:\\nIn this question, we would like to prioritise bags that are almost at capacity. In other words, we prefer bags where the difference between its capacity and current number of rocks (`capacity[i] - rocks[i]`) is smaller. Does this sound familiar? That\\'s right, we can just use a min heap (priority queue) and chuck all the differences into it. Then, poll out differences and subtract from additionalRocks. We stop either when our heap is empty or when we don\\'t have enough additionalRocks to provide. \\n\\n### Code:\\nFeel free to ask any questions or suggest any improvements!\\n```java\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        int n = capacity.length;\\n        PriorityQueue<Integer> differences = new PriorityQueue<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            int d = capacity[i] - rocks[i];\\n            differences.add(d);\\n        }\\n        \\n        int output = 0;\\n        while (!differences.isEmpty() && additionalRocks >= 0) {\\n            int currD = differences.poll();\\n            if (additionalRocks - currD >= 0) {\\n                additionalRocks -= currD;\\n                output++;\\n            }\\n            else break;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```\\n**Time complexity:** `O(nlogn)` since we\\'re inserting into our min heap n times and each insertion takes log(n) time.\\n**Space complexity:** `O(n)` since we\\'re filling up our heap with n differences.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        int n = capacity.length;\\n        PriorityQueue<Integer> differences = new PriorityQueue<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            int d = capacity[i] - rocks[i];\\n            differences.add(d);\\n        }\\n        \\n        int output = 0;\\n        while (!differences.isEmpty() && additionalRocks >= 0) {\\n            int currD = differences.poll();\\n            if (additionalRocks - currD >= 0) {\\n                additionalRocks -= currD;\\n                output++;\\n            }\\n            else break;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062047,
                "title": "find-remainging-rocks-for-maximum-rocks-greedy-approach-java",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n       int[] remainingRocks = new int[rocks.length];\\n        for(int i = 0; i < remainingRocks.length; i++){\\n            remainingRocks[i] = capacity[i] - rocks[i];\\n        }\\n        \\n        Arrays.sort(remainingRocks);\\n        int count = 0;\\n        for(int i = 0; i < remainingRocks.length; i++){   \\n            if(remainingRocks[i]==0 || remainingRocks[i]<=additionalRocks){\\n                additionalRocks-=remainingRocks[i];\\n                count++;\\n            }\\n        }\\n   \\n        return count;\\n    }  \\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n       int[] remainingRocks = new int[rocks.length];\\n        for(int i = 0; i < remainingRocks.length; i++){\\n            remainingRocks[i] = capacity[i] - rocks[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061944,
                "title": "clean-java-code-explained-with-comments",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        // difference array to know how many rocks we can fill to make it full capacity\\n        int total=additionalRocks;\\n        int c=0;\\n        int diff[] = new int[capacity.length];\\n        \\n        for(int i=0;i<capacity.length;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n        }\\n        //sort the array \\n        Arrays.sort(diff);\\n        \\n        // to fill most of the bags, it will be benificial for us to choose the one with the lowest difference\\n         for(int i=0;i<capacity.length;i++){\\n            if(total>=diff[i]){\\n                total-=diff[i];\\n                c++;\\n            }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        // difference array to know how many rocks we can fill to make it full capacity\\n        int total=additionalRocks;\\n        int c=0;\\n        int diff[] = new int[capacity.length];\\n        \\n        for(int i=0;i<capacity.length;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n        }\\n        //sort the array \\n        Arrays.sort(diff);\\n        \\n        // to fill most of the bags, it will be benificial for us to choose the one with the lowest difference\\n         for(int i=0;i<capacity.length;i++){\\n            if(total>=diff[i]){\\n                total-=diff[i];\\n                c++;\\n            }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061903,
                "title": "python-greedy-approach-sorting-according-to-required-rocks",
                "content": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        left = [0]*len(capacity)\\n        for i in range(len(capacity)):\\n            left[i] = capacity[i]-rocks[i]\\n        left.sort()\\n        ans = 0 \\n        while ans < len(left) and additionalRocks > 0:\\n            if additionalRocks >= left[ans]:\\n                additionalRocks -= left[ans]\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        left = [0]*len(capacity)\\n        for i in range(len(capacity)):\\n            left[i] = capacity[i]-rocks[i]\\n        left.sort()\\n        ans = 0 \\n        while ans < len(left) and additionalRocks > 0:\\n            if additionalRocks >= left[ans]:\\n                additionalRocks -= left[ans]\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061889,
                "title": "c-greedy-sort-the-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int extra) {\\n        int n=capacity.size();\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int count=0;\\n        for(auto x:diff){\\n            if(x==0) count++;\\n            else{\\n                if(extra>=x){\\n                    extra-=x;\\n                    count++;\\n                }\\n                else break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int extra) {\\n        int n=capacity.size();\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int count=0;\\n        for(auto x:diff){\\n            if(x==0) count++;\\n            else{\\n                if(extra>=x){\\n                    extra-=x;\\n                    count++;\\n                }\\n                else break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061806,
                "title": "c-2279-maximum-bags-with-full-capacity-of-rocks",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for (int i = 0; i < capacity.size(); ++i) capacity[i] -= rocks[i]; \\n        sort(capacity.begin(), capacity.end()); \\n        int ans = 0; \\n        for (int i = 0; i < capacity.size() && capacity[i] <= additionalRocks; ++ans, additionalRocks -= capacity[i++]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for (int i = 0; i < capacity.size(); ++i) capacity[i] -= rocks[i]; \\n        sort(capacity.begin(), capacity.end()); \\n        int ans = 0; \\n        for (int i = 0; i < capacity.size() && capacity[i] <= additionalRocks; ++ans, additionalRocks -= capacity[i++]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061405,
                "title": "c-simple-greedy-sorting-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>diff; int cnt=0;\\n        for(int i=0; i<capacity.size(); i++){\\n            if(capacity[i]==rocks[i])cnt++;\\n            else diff.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(diff.begin(), diff.end());\\n        for(int it: diff){\\n            if(additionalRocks-it >= 0) additionalRocks-=it,cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>diff; int cnt=0;\\n        for(int i=0; i<capacity.size(); i++){\\n            if(capacity[i]==rocks[i])cnt++;\\n            else diff.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(diff.begin(), diff.end());\\n        for(int it: diff){\\n            if(additionalRocks-it >= 0) additionalRocks-=it,cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234243,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function (capacity, rocks, additionalRocks) {\\nfor(let j=0;j<capacity.length;j++){\\n    capacity[j]=capacity[j]-rocks[j]\\n}\\ncapacity.sort((a, b) => a - b) \\n//console.log(capacity)\\nlet count=0\\nfor(let j=0;j<capacity.length;j++){\\n    if(additionalRocks===0||capacity[j]>additionalRocks){\\n        break\\n    }\\n    additionalRocks-=capacity[j]\\n    count++\\n}\\nreturn count\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} capacity\\n * @param {number[]} rocks\\n * @param {number} additionalRocks\\n * @return {number}\\n */\\nvar maximumBags = function (capacity, rocks, additionalRocks) {\\nfor(let j=0;j<capacity.length;j++){\\n    capacity[j]=capacity[j]-rocks[j]\\n}\\ncapacity.sort((a, b) => a - b) \\n//console.log(capacity)\\nlet count=0\\nfor(let j=0;j<capacity.length;j++){\\n    if(additionalRocks===0||capacity[j]>additionalRocks){\\n        break\\n    }\\n    additionalRocks-=capacity[j]\\n    count++\\n}\\nreturn count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3151089,
                "title": "greedy-approach-o-nlogn-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>res;\\n        for(int i=0;i<capacity.size();i++){\\n            res.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(res.begin(),res.end());\\n        int cnt=0;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]==0)cnt++;\\n            else if(res[i]<=additionalRocks){\\n                cnt++;\\n                additionalRocks-=res[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>res;\\n        for(int i=0;i<capacity.size();i++){\\n            res.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(res.begin(),res.end());\\n        int cnt=0;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]==0)cnt++;\\n            else if(res[i]<=additionalRocks){\\n                cnt++;\\n                additionalRocks-=res[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044874,
                "title": "java-100-faster-easy-solution-fot-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nInitially, I found the number of the empty places for each bags. ```AdditionalPlaces``` array represants these places. The first for loop does this.\\n\\nThen I sorted ```AdditionalPlaces``` by ascending order.\\n\\nThe belowing for fills bags as follows: in which bags have more empty places than others then it fills earlier. \\n```\\nfor(int i=0;i<length;i++){\\n    if(additionalPlaces[i]<=additionalRocks){\\n    additionalRocks-=additionalPlaces[i];\\n    additionalPlaces[i]=0;\\n    }\\n    else break;\\n}\\n```\\nFinally, We will found that how many 0 in ```AdditionalPlaces```. It represants filled bags count. \\n\\n\\n# My Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int length = capacity.length;\\n        int [] additionalPlaces = new int[length];\\n\\n        for(int i=0;i<length;i++){\\n            additionalPlaces[i] = capacity[i]-rocks[i];\\n        }\\n\\n        Arrays.sort(additionalPlaces);\\n\\n        for(int i=0;i<length;i++){\\n            if(additionalPlaces[i]<=additionalRocks){\\n              additionalRocks-=additionalPlaces[i];\\n              additionalPlaces[i]=0;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=length-1;i>=0;i--){\\n            if(additionalPlaces[i]==0) return i+1;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n```O(n)```\\n\\n```Please Upvote, If you find it useful.``` \\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```AdditionalPlaces```\n```AdditionalPlaces```\n```\\nfor(int i=0;i<length;i++){\\n    if(additionalPlaces[i]<=additionalRocks){\\n    additionalRocks-=additionalPlaces[i];\\n    additionalPlaces[i]=0;\\n    }\\n    else break;\\n}\\n```\n```AdditionalPlaces```\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int length = capacity.length;\\n        int [] additionalPlaces = new int[length];\\n\\n        for(int i=0;i<length;i++){\\n            additionalPlaces[i] = capacity[i]-rocks[i];\\n        }\\n\\n        Arrays.sort(additionalPlaces);\\n\\n        for(int i=0;i<length;i++){\\n            if(additionalPlaces[i]<=additionalRocks){\\n              additionalRocks-=additionalPlaces[i];\\n              additionalPlaces[i]=0;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=length-1;i>=0;i--){\\n            if(additionalPlaces[i]==0) return i+1;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```O(n)```\n```Please Upvote, If you find it useful.```",
                "codeTag": "Java"
            },
            {
                "id": 3032397,
                "title": "simple-c-solution-easy-to-understand-greedy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(Nlog(N))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        int maxFullBags = 0;\\n        for(int i=0;i<n;i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n\\n        for(int i=0;i<n;i++){\\n            if(capacity[i]==0){\\n                maxFullBags++;\\n            }\\n            if(capacity[i]>0){\\n                if(additionalRocks-capacity[i]>=0){\\n                    maxFullBags++;\\n                    additionalRocks-=capacity[i];\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return maxFullBags;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        int maxFullBags = 0;\\n        for(int i=0;i<n;i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n\\n        for(int i=0;i<n;i++){\\n            if(capacity[i]==0){\\n                maxFullBags++;\\n            }\\n            if(capacity[i]>0){\\n                if(additionalRocks-capacity[i]>=0){\\n                    maxFullBags++;\\n                    additionalRocks-=capacity[i];\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return maxFullBags;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988008,
                "title": "2279-maximum-bags-with-full-capacity-of-rocks-python-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nn is the size of rocks array\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], ar: int) -> int:\\n        dif=[]\\n        n=len(rocks)\\n        for i in range(n):\\n            dif.append(capacity[i]-rocks[i])   #Number of rocks required to get full\\n\\n        dif.sort() #sorting it in ascending order so that minimum requirement bags are filled first so that we can fill maximum number of bags\\n        i=0\\n        ans=0\\n        while i<n and ar:\\n            if dif[i]<=ar:\\n                ans+=1\\n                ar-=dif[i]\\n            i+=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], ar: int) -> int:\\n        dif=[]\\n        n=len(rocks)\\n        for i in range(n):\\n            dif.append(capacity[i]-rocks[i])   #Number of rocks required to get full\\n\\n        dif.sort() #sorting it in ascending order so that minimum requirement bags are filled first so that we can fill maximum number of bags\\n        i=0\\n        ans=0\\n        while i<n and ar:\\n            if dif[i]<=ar:\\n                ans+=1\\n                ar-=dif[i]\\n            i+=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962475,
                "title": "python3-zip-and-sorted",
                "content": "https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/submissions/\\n```\\nRuntime: 933 ms, faster than 95.35% of Python3 online submissions for Maximum Bags With Full Capacity of Rocks.\\nMemory Usage: 22.2 MB, less than 50.50% of Python3 online submissions for Maximum Bags With Full Capacity of Rocks.\\n```\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        full = 0\\n        for a in sorted(c-r for c,r in zip(capacity, rocks)):\\n            additionalRocks -= a\\n            if additionalRocks>=0:\\n                full += 1\\n            else:\\n                return full\\n        return full \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nRuntime: 933 ms, faster than 95.35% of Python3 online submissions for Maximum Bags With Full Capacity of Rocks.\\nMemory Usage: 22.2 MB, less than 50.50% of Python3 online submissions for Maximum Bags With Full Capacity of Rocks.\\n```\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        full = 0\\n        for a in sorted(c-r for c,r in zip(capacity, rocks)):\\n            additionalRocks -= a\\n            if additionalRocks>=0:\\n                full += 1\\n            else:\\n                return full\\n        return full \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962315,
                "title": "python-3-lines-efficient-solution",
                "content": "# Intuition\\nIt\\'s easy\\n\\n# Approach\\nSort difference, iterate while we can use additionalRocks\\n\\n# Complexity\\n- Time complexity:\\n$$O(N*logN)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def maximumBags(self, capacity: List[int], rocks: List[int], aRocks=1) -> int:\\n    bags, n, l = sorted(y-x for x,y in zip(rocks, capacity)), -1, len(rocks)\\n    while (n:=n+1) < l and aRocks >= bags[n]: aRocks -= bags[n]\\n    return n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n  def maximumBags(self, capacity: List[int], rocks: List[int], aRocks=1) -> int:\\n    bags, n, l = sorted(y-x for x,y in zip(rocks, capacity)), -1, len(rocks)\\n    while (n:=n+1) < l and aRocks >= bags[n]: aRocks -= bags[n]\\n    return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960015,
                "title": "0-ms-solution-in-c-100-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrok) {\\n        int n = cap.size();\\n        vector<int>rok(n);\\n        for(int i = 0; i < n; i++){\\n            rok[i] = cap[i] - rocks[i];\\n        }\\n        sort(rok.begin(), rok.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(addrok > 0){\\n                addrok = addrok - rok[i];\\n                count++;\\n                if(addrok < 0){\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrok) {\\n        int n = cap.size();\\n        vector<int>rok(n);\\n        for(int i = 0; i < n; i++){\\n            rok[i] = cap[i] - rocks[i];\\n        }\\n        sort(rok.begin(), rok.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(addrok > 0){\\n                addrok = addrok - rok[i];\\n                count++;\\n                if(addrok < 0){\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959993,
                "title": "maximum-bags-with-full-capacity-of-rocks-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrok) {\\n        int i = 0;\\n        int n = cap.size();\\n        int m = rocks.size();\\n        vector<int>rok(n);\\n        for(int i = 0; i < n; i++){\\n            rok[i] = cap[i] - rocks[i];\\n        }\\n        sort(rok.begin(), rok.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(addrok > 0){\\n                addrok = addrok - rok[i];\\n                count++;\\n                if(addrok < 0){\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& cap, vector<int>& rocks, int addrok) {\\n        int i = 0;\\n        int n = cap.size();\\n        int m = rocks.size();\\n        vector<int>rok(n);\\n        for(int i = 0; i < n; i++){\\n            rok[i] = cap[i] - rocks[i];\\n        }\\n        sort(rok.begin(), rok.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(addrok > 0){\\n                addrok = addrok - rok[i];\\n                count++;\\n                if(addrok < 0){\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959853,
                "title": "efficient-solution-using-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n      int n = capacity.size();\\n      vector<int>ans(n);\\n      for(int i=0;i<n;i++)\\n      {\\n          ans[i] = capacity[i]-rocks[i];\\n      } \\n      sort(ans.begin(),ans.end());\\n      int count = 0;\\n      for(auto x:ans){\\n          if(x==0)\\n          {\\n              count++;\\n          }\\n          else\\n          {\\n              if(additionalRocks>0 && additionalRocks>=x)\\n              {\\n                  additionalRocks -= x;\\n                  count++;\\n              }\\n          }\\n      }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n      int n = capacity.size();\\n      vector<int>ans(n);\\n      for(int i=0;i<n;i++)\\n      {\\n          ans[i] = capacity[i]-rocks[i];\\n      } \\n      sort(ans.begin(),ans.end());\\n      int count = 0;\\n      for(auto x:ans){\\n          if(x==0)\\n          {\\n              count++;\\n          }\\n          else\\n          {\\n              if(additionalRocks>0 && additionalRocks>=x)\\n              {\\n                  additionalRocks -= x;\\n                  count++;\\n              }\\n          }\\n      }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959772,
                "title": "simple-solution-explained-deeply-in-detail",
                "content": "![Adobe Scan Dec 28, 2022_1.jpg](https://assets.leetcode.com/users/images/d415ee1e-1b1e-4d77-8f5c-c85f90dd6612_1672167341.9112108.jpeg)\\n![Adobe Scan Dec 28, 2022_2.jpg](https://assets.leetcode.com/users/images/dfeb5c91-8d6d-42b6-83b3-36fdbe82b88b_1672167348.7807791.jpeg)\\n\\nNow Let\\'s See the Implementation of Above:\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        //get the number of bags\\n        int l = capacity.size();\\n\\n        //create our difference vector \\n        vector<int> difference;\\n        for(int i = 0; i < l; i++)\\n            //store difference for each index\\n            difference.push_back(capacity[i] - rocks[i]);\\n\\n        //sort the difference vector/array\\n        sort(difference.begin(), difference.end());\\n\\n        //set maxPossible(bags) to 0\\n        int maxPossible = 0;\\n        for(int element: difference){\\n            //if AddRocks goes below 0 or to 0 terminate loop\\n            if(additionalRocks <= 0) break;\\n            //update AddRocks and maxPoss in each iteration\\n            additionalRocks -= element;\\n            maxPossible++;\\n        } \\n\\n        //addRocks = 0 means we filled all possible bags\\n        //addRocks > 0 means we filled all the bags to max Capacity and were still left with additional Rocks\\n        //addRocks < 0 means we we were in the process of filling the bags but we encountered a bag which required more rocks than the remaining rocks with us, we increased the maxBags in that iteration but were never able to succeffuly fill that bag completely, so we must decrease the count for that bag when returning the answer\\n        return additionalRocks >= 0 ? maxPossible : maxPossible - 1;\\n        \\n    }\\n};\\n```\\n> ***Please UpVote if it helped you ^***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        //get the number of bags\\n        int l = capacity.size();\\n\\n        //create our difference vector \\n        vector<int> difference;\\n        for(int i = 0; i < l; i++)\\n            //store difference for each index\\n            difference.push_back(capacity[i] - rocks[i]);\\n\\n        //sort the difference vector/array\\n        sort(difference.begin(), difference.end());\\n\\n        //set maxPossible(bags) to 0\\n        int maxPossible = 0;\\n        for(int element: difference){\\n            //if AddRocks goes below 0 or to 0 terminate loop\\n            if(additionalRocks <= 0) break;\\n            //update AddRocks and maxPoss in each iteration\\n            additionalRocks -= element;\\n            maxPossible++;\\n        } \\n\\n        //addRocks = 0 means we filled all possible bags\\n        //addRocks > 0 means we filled all the bags to max Capacity and were still left with additional Rocks\\n        //addRocks < 0 means we we were in the process of filling the bags but we encountered a bag which required more rocks than the remaining rocks with us, we increased the maxBags in that iteration but were never able to succeffuly fill that bag completely, so we must decrease the count for that bag when returning the answer\\n        return additionalRocks >= 0 ? maxPossible : maxPossible - 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959712,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>free;\\n        int res=0;\\n        for(int i=0;i<capacity.size();i++)\\n        {\\n            free.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(free.begin(),free.end());\\n        for(int i=0;i<free.size();i++)\\n        {\\n            if(free[i]==0)\\n                res++;\\n            else if(additionalRocks>=free[i] && additionalRocks>0)\\n            {\\n                additionalRocks=additionalRocks-free[i];\\n                res++;\\n            }\\n            else \\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>free;\\n        int res=0;\\n        for(int i=0;i<capacity.size();i++)\\n        {\\n            free.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(free.begin(),free.end());\\n        for(int i=0;i<free.size();i++)\\n        {\\n            if(free[i]==0)\\n                res++;\\n            else if(additionalRocks>=free[i] && additionalRocks>0)\\n            {\\n                additionalRocks=additionalRocks-free[i];\\n                res++;\\n            }\\n            else \\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959704,
                "title": "maximum-bags-with-full-capacity-of-rocks",
                "content": "Runtime: 232 ms, faster than 74.94% of C++ online submissions for Maximum Bags With Full Capacity of Rocks.\\nMemory Usage: 86.7 MB, less than 67.47% of C++ online submissions for Maximum Bags With Full Capacity of Rocks.\\n\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int n=capacity.size(),count=0;\\n        vector<int>ans(n,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            ans[i] = capacity[i] - rocks[i];\\n        }\\n        sort(ans.begin(),ans.end());\\n        for (int i=0;i<n;i++)\\n        {\\n            if (additionalRocks<ans[i])\\n                break;\\n            else\\n            {\\n                additionalRocks=additionalRocks-ans[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        int n=capacity.size(),count=0;\\n        vector<int>ans(n,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            ans[i] = capacity[i] - rocks[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2959699,
                "title": "c-easy-greedy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTO fill the maximum number of bags the first approach that comes into mind is GREEDY.\\nSo we actually need to know the difference between the capacity of the bag and the actual number of rocks in it currently.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we maintain a new vector named diff and store the difference as discussed in the approach, then we sort it and then traverse it until our additionalRocks finishes and get the maximum output.\\n\\n\\nWe can space optimize it by not using an extra array \"diff\", and directly storing in the capacity or rocks array.\\n# Complexity\\n- Time complexity:\\n- O (N log N) \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O ( N )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        vector<int> diff(n);\\n\\n        for(int i =0;i<n;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n\\n        }\\n        sort(diff.begin(),diff.end());\\n\\n        int r= additionalRocks,ans=0;\\n        for(auto x:diff){\\n            if(x<=r){\\n                ans++;\\n                r-=x;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n = capacity.size();\\n        vector<int> diff(n);\\n\\n        for(int i =0;i<n;i++){\\n            diff[i]=capacity[i]-rocks[i];\\n\\n        }\\n        sort(diff.begin(),diff.end());\\n\\n        int r= additionalRocks,ans=0;\\n        for(auto x:diff){\\n            if(x<=r){\\n                ans++;\\n                r-=x;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959678,
                "title": "python-1-liner-functional-programming-beats-99-67-in-runtime-and-96-5-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedily fill the bags with least amount of remaining space until you can\\'t anymore.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Calculate the `remaining` space in the bag.\\n- Sort the `remaining` and calculate `prefix_sums`.\\n- Greedily take/select the `prefix_sums` values until you reach a value greater than `additionalRocks` (`k` in below code). These are the bags which we can fill i.e `full_bags`.\\n- Count the number of `full_bags` and return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\nSplit into multiple lines for clarity:\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int], k: int) -> int:\\n        remaining = map(sub, capacity, rocks)\\n        prefix_sums = accumulate(sorted(remaining))\\n        full_bags = takewhile(lambda x: x <= k, prefix_sums)\\n        return sum(1 for _ in full_bags)\\n```\\n\\nOriginal 1-liner:\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int], k: int) -> int:\\n        return sum(1 for _ in takewhile(\\n            lambda x: x <= k,\\n            accumulate(sorted(map(sub, capacity, rocks))),\\n        ))\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int], k: int) -> int:\\n        remaining = map(sub, capacity, rocks)\\n        prefix_sums = accumulate(sorted(remaining))\\n        full_bags = takewhile(lambda x: x <= k, prefix_sums)\\n        return sum(1 for _ in full_bags)\\n```\n```\\nclass Solution:\\n    def maximumBags(self, capacity: list[int], rocks: list[int], k: int) -> int:\\n        return sum(1 for _ in takewhile(\\n            lambda x: x <= k,\\n            accumulate(sorted(map(sub, capacity, rocks))),\\n        ))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959671,
                "title": "c-greedy-approach-maps",
                "content": "# Intuition\\nA kind of Problem which requires greedy approach\\n\\n# Approach\\nStore the difference of capacity and rocks in an ordered map. now fill the bag with lesser difference first to make them filled first. after filling them up find the difference between original and final differences. Sum the already filled caskets to yield the final result .\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<int,int> a;\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks)   {\\n        for(int i=0;i<capacity.size();i++){\\n            a[capacity[i]-rocks[i]]+=1;\\n        }//storing the differences\\n        map<int,int> b=a;//storing a copy\\n        for(auto x:a){\\n            if(x.first==0)continue;\\n            if(additionalRocks==0)break;\\n            int s=x.first*x.second;//checking the total no. capacities\\n            if(s>additionalRocks){\\n                int d=floor(additionalRocks/x.first);//rounding of to nearest decimal\\n                a[x.first]=a[x.first]-d;\\n                additionalRocks=0;\\n            }else{\\n                a[x.first]=0;//capacity is less so it gets filled\\n                additionalRocks-=s;\\n            }\\n        }     \\n        int s=b[0];//already filled caskets\\n        for(auto x:b){\\n            s+=b[x.first]-a[x.first];//finding the difference\\n        }\\n        return s;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nmap<int,int> a;\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks)   {\\n        for(int i=0;i<capacity.size();i++){\\n            a[capacity[i]-rocks[i]]+=1;\\n        }//storing the differences\\n        map<int,int> b=a;//storing a copy\\n        for(auto x:a){\\n            if(x.first==0)continue;\\n            if(additionalRocks==0)break;\\n            int s=x.first*x.second;//checking the total no. capacities\\n            if(s>additionalRocks){\\n                int d=floor(additionalRocks/x.first);//rounding of to nearest decimal\\n                a[x.first]=a[x.first]-d;\\n                additionalRocks=0;\\n            }else{\\n                a[x.first]=0;//capacity is less so it gets filled\\n                additionalRocks-=s;\\n            }\\n        }     \\n        int s=b[0];//already filled caskets\\n        for(auto x:b){\\n            s+=b[x.first]-a[x.first];//finding the difference\\n        }\\n        return s;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959605,
                "title": "my-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int len = capacity.length,t=0;\\n        \\n        for ( int i = 0; i < len; i++) \\n            capacity[i] -= rocks[i];\\n        Arrays.sort(capacity);\\n        \\n        for (int i = 0; i < len; i++) \\n            if (capacity[i] <= 0) \\n                t++;\\n            else \\n                if (capacity[i] <= additionalRocks) {\\n                    additionalRocks -= capacity[i];\\n                    capacity[i] = 0;\\n                    t++;\\n                }\\n            \\n        \\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int len = capacity.length,t=0;\\n        \\n        for ( int i = 0; i < len; i++) \\n            capacity[i] -= rocks[i];\\n        Arrays.sort(capacity);\\n        \\n        for (int i = 0; i < len; i++) \\n            if (capacity[i] <= 0) \\n                t++;\\n            else \\n                if (capacity[i] <= additionalRocks) {\\n                    additionalRocks -= capacity[i];\\n                    capacity[i] = 0;\\n                    t++;\\n                }\\n            \\n        \\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959534,
                "title": "c-optimized-sorting-greedy-beats-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        vector<int> v;\\n        int cnt = 0;\\n        \\n        for(int i=0; i<capacity.size(); i++) {\\n            v.push_back( capacity[i] - rocks[i] );\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            \\n            if(additionalRocks == 0) break;\\n            \\n            if(additionalRocks - v[i] >= 0) {\\n                additionalRocks -= v[i];\\n                v[i] = 0;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i] == 0) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        vector<int> v;\\n        int cnt = 0;\\n        \\n        for(int i=0; i<capacity.size(); i++) {\\n            v.push_back( capacity[i] - rocks[i] );\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            \\n            if(additionalRocks == 0) break;\\n            \\n            if(additionalRocks - v[i] >= 0) {\\n                additionalRocks -= v[i];\\n                v[i] = 0;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i] == 0) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959529,
                "title": "c-easy-to-understand-beats-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        vector<int> v;\\n        int cnt = 0;\\n        \\n        for(int i=0; i<capacity.size(); i++) {\\n            v.push_back( capacity[i] - rocks[i] );\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            \\n            if(additionalRocks == 0) break;\\n            \\n            if(additionalRocks - v[i] >= 0) {\\n                additionalRocks -= v[i];\\n                v[i] = 0;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i] == 0) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        \\n        vector<int> v;\\n        int cnt = 0;\\n        \\n        for(int i=0; i<capacity.size(); i++) {\\n            v.push_back( capacity[i] - rocks[i] );\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            \\n            if(additionalRocks == 0) break;\\n            \\n            if(additionalRocks - v[i] >= 0) {\\n                additionalRocks -= v[i];\\n                v[i] = 0;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i] == 0) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959476,
                "title": "java-o-nlogn-easy-intuitive-approach-clean-code",
                "content": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        for(int i=0; i<rocks.length; i++) {\\n            capacity[i] -= rocks[i];            //Modifying same array to save memory\\n        }\\n\\n        Arrays.sort(capacity);                  //Sort to fill least capacity bags first\\n        int count = 0;\\n        \\n        for(int i=0; i<rocks.length; i++) {\\n            \\n            if(capacity[i] != 0 && capacity[i] <= additionalRocks) {    //fill the bags\\n                additionalRocks -= capacity[i];\\n                capacity[i] = 0;\\n                count++;\\n            \\n            } else if(capacity[i] == 0) {       //if already 0, no need to fill, just count\\n                count++;\\n            \\n            } else if(capacity[i] > additionalRocks) {  //if rocks are not left to fill, break\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        \\n        for(int i=0; i<rocks.length; i++) {\\n            capacity[i] -= rocks[i];            //Modifying same array to save memory\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2959203,
                "title": "beats-100-easiest-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size(),i,result=0;\\n        for(i=0;i<n;i++){\\n           capacity[i]=capacity[i]-rocks[i];\\n        }\\n       sort(capacity.begin(),capacity.end());//sort in order to get max fullbags\\n        //iterte over to get number of fullbags \\n        for(i=0;i<n;i++){            \\n            if( capacity[i]>=0 && capacity[i]<=additionalRocks){\\n                result++;\\n                additionalRocks=additionalRocks-capacity[i];\\n            }\\n            else {\\n                break;           \\n            }\\n        }\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int n=rocks.size(),i,result=0;\\n        for(i=0;i<n;i++){\\n           capacity[i]=capacity[i]-rocks[i];\\n        }\\n       sort(capacity.begin(),capacity.end());//sort in order to get max fullbags\\n        //iterte over to get number of fullbags \\n        for(i=0;i<n;i++){            \\n            if( capacity[i]>=0 && capacity[i]<=additionalRocks){\\n                result++;\\n                additionalRocks=additionalRocks-capacity[i];\\n            }\\n            else {\\n                break;           \\n            }\\n        }\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959190,
                "title": "very-simple-approach-beats-100-cpp-solution",
                "content": "# Intuition\\njust find the remaining space in bag after put given rocks\\nand store its remaing capacity in an vector \\n\\nand traverse remiang capacity array and substract the addtional rock if the additional rock is more than the remaining capacity and increase the ans every time we substract and in end return ans \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> space;\\n        int ans = 0;\\n         for(int i=0;i<rocks.size();i++)\\n         {\\n             space.push_back(capacity[i]-rocks[i]);\\n         }\\n\\n        sort(space.begin(),space.end());\\n        for(int i=0;i<space.size();i++)\\n        {\\n           if(additionalRocks>=space[i])\\n           {\\n               additionalRocks -= space[i];\\n               ans++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> space;\\n        int ans = 0;\\n         for(int i=0;i<rocks.size();i++)\\n         {\\n             space.push_back(capacity[i]-rocks[i]);\\n         }\\n\\n        sort(space.begin(),space.end());\\n        for(int i=0;i<space.size();i++)\\n        {\\n           if(additionalRocks>=space[i])\\n           {\\n               additionalRocks -= space[i];\\n               ans++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959175,
                "title": "c-beats-100-tc-o-nlogn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate diff of capacity and available rocks and put that in the capacity vector. Sort it, and use a counter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for(int i=0;i<rocks.size();i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        int ch = 0;\\n        for(int i =0;i<rocks.size();i++){\\n            if(additionalRocks>=capacity[i]){\\n                ch++;\\n                additionalRocks-=capacity[i];\\n            }\\n            else break;\\n            \\n        }\\n        return ch;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        for(int i=0;i<rocks.size();i++){\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        int ch = 0;\\n        for(int i =0;i<rocks.size();i++){\\n            if(additionalRocks>=capacity[i]){\\n                ch++;\\n                additionalRocks-=capacity[i];\\n            }\\n            else break;\\n            \\n        }\\n        return ch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959157,
                "title": "100-faster-cpp-code-sorting-and-counting-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& a, vector<int>& b, int r) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        for(int i=0;i<n;i++)\\n            dp[i]=a[i]-b[i];\\n        \\n        sort(dp.begin(),dp.end());\\n        \\n        int sum=r,ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dp[i]<=sum)\\n           {\\n               sum-=dp[i];\\n               dp[i]=0;\\n           }\\n           else\\n               break;\\n       }\\n        \\n        for(auto it:dp)\\n            if(!it)\\n                ans++;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& a, vector<int>& b, int r) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        for(int i=0;i<n;i++)\\n            dp[i]=a[i]-b[i];\\n        \\n        sort(dp.begin(),dp.end());\\n        \\n        int sum=r,ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dp[i]<=sum)\\n           {\\n               sum-=dp[i];\\n               dp[i]=0;\\n           }\\n           else\\n               break;\\n       }\\n        \\n        for(auto it:dp)\\n            if(!it)\\n                ans++;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959130,
                "title": "python-most-easiest-solution-w-e",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to maximize the fully filled bags, we need to fill the bags which need less number of rocks to get filled.\\n\\nEx:\\nConsider we have additional rocks=100.\\nrocks=[100,40,60]\\ncapacity=[200,100,100]\\n\\nHere what if we use all the additional rocks to 1st bag itself. only 1 bag will get filled.\\nInorder to maximize the number of filled bags, we need to first find the required rocks for every bag to get filled.\\n\\nAfter finding this, almost 50% problem is solved. Now we have to fill the bags which need less number of rocks. So sort them in ascending order. \\n\\nlets again consider our example, Now the required rocks in each bag will look like [100,60,40]. After sorting [40,60,100].\\n\\nNow fill the bag with the additional rocks.Just delete the required rocks from additional rocks. we have to do it until additonal rocks are 0 or required rocks array is empty.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        d=[]\\n        for i in range(len(capacity)):\\n            d.append(capacity[i]-rocks[i])\\n        c=0\\n        d.sort()\\n        while len(d)>0 and additionalRocks>0:\\n            if d[0]==0:\\n                c=c+1\\n                d.pop(0)\\n            else:\\n                if d[0]<=additionalRocks:\\n                    additionalRocks-=d[0]\\n                    d.pop(0)\\n                    c=c+1\\n                else:\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        d=[]\\n        for i in range(len(capacity)):\\n            d.append(capacity[i]-rocks[i])\\n        c=0\\n        d.sort()\\n        while len(d)>0 and additionalRocks>0:\\n            if d[0]==0:\\n                c=c+1\\n                d.pop(0)\\n            else:\\n                if d[0]<=additionalRocks:\\n                    additionalRocks-=d[0]\\n                    d.pop(0)\\n                    c=c+1\\n                else:\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959091,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Intuition\\nSo as the question states we need to maximize the number of full bags, we can approach this problem in greedy way.\\n\\n# Approach\\n1)Take an array which would be storing the difference of capacity of a bag and the initial rocks in it.\\n\\n2)Then Sort the array (reason being we will first consume the minimum spaces so as to maximize the number ).\\n\\n3)Reduce the additionalStones counts and move forward in the array.\\n\\n4)At last calculate the number of zero in the ans array.\\n\\n\\n# Complexity\\n- Time complexity:\\nComplexity is O(n*log(n)) where n is the size of capacity array.\\n\\n- Space complexity:\\nSpace Complexity is O(n) where n is the size of capacity ans array we we are using.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        for(int i=0;i<capacity.size();i++)\\n            ans.push_back(capacity[i]-rocks[i]);\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        while(i<capacity.size())\\n        {\\n            if(additionalRocks<ans[i])\\n            {\\n                ans[i]-=additionalRocks;\\n                additionalRocks=0;\\n                break;\\n            }\\n            else\\n            {\\n                additionalRocks-=ans[i];\\n                ans[i]=0;\\n            }\\n            if(additionalRocks<=0)\\n                break;\\n            i++;\\n        }\\n        int fk=count(ans.begin(),ans.end(),0);\\n        return fk;\\n    }\\n};\\n```\\n\\nPlease do upvote if you find this approach helpful.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        for(int i=0;i<capacity.size();i++)\\n            ans.push_back(capacity[i]-rocks[i]);\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        while(i<capacity.size())\\n        {\\n            if(additionalRocks<ans[i])\\n            {\\n                ans[i]-=additionalRocks;\\n                additionalRocks=0;\\n                break;\\n            }\\n            else\\n            {\\n                additionalRocks-=ans[i];\\n                ans[i]=0;\\n            }\\n            if(additionalRocks<=0)\\n                break;\\n            i++;\\n        }\\n        int fk=count(ans.begin(),ans.end(),0);\\n        return fk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959090,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Intuition\\nSo as the question states we need to maximize the number of full bags, we can approach this problem in greedy way.\\n\\n# Approach\\n1)Take an array which would be storing the difference of capacity of a bag and the initial rocks in it.\\n\\n2)Then Sort the array (reason being we will first consume the minimum spaces so as to maximize the number ).\\n\\n3)Reduce the additionalStones counts and move forward in the array.\\n\\n4)At last calculate the number of zero in the ans array.\\n\\n\\n# Complexity\\n- Time complexity:\\nComplexity is O(n*log(n)) where n is the size of capacity array.\\n\\n- Space complexity:\\nSpace Complexity is O(n) where n is the size of capacity ans array we we are using.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        for(int i=0;i<capacity.size();i++)\\n            ans.push_back(capacity[i]-rocks[i]);\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        while(i<capacity.size())\\n        {\\n            if(additionalRocks<ans[i])\\n            {\\n                ans[i]-=additionalRocks;\\n                additionalRocks=0;\\n                break;\\n            }\\n            else\\n            {\\n                additionalRocks-=ans[i];\\n                ans[i]=0;\\n            }\\n            if(additionalRocks<=0)\\n                break;\\n            i++;\\n        }\\n        int fk=count(ans.begin(),ans.end(),0);\\n        return fk;\\n    }\\n};\\n```\\n\\nPlease do upvote if you find this approach helpful.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> ans;\\n        for(int i=0;i<capacity.size();i++)\\n            ans.push_back(capacity[i]-rocks[i]);\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        while(i<capacity.size())\\n        {\\n            if(additionalRocks<ans[i])\\n            {\\n                ans[i]-=additionalRocks;\\n                additionalRocks=0;\\n                break;\\n            }\\n            else\\n            {\\n                additionalRocks-=ans[i];\\n                ans[i]=0;\\n            }\\n            if(additionalRocks<=0)\\n                break;\\n            i++;\\n        }\\n        int fk=count(ans.begin(),ans.end(),0);\\n        return fk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958997,
                "title": "my-simple-java-solution",
                "content": "# Intuition\\nI have thought of simply creating a temporary array which will store the amount that each bag need to reach its full capacity.Now since we need maximum bags that can be loaded to their full capacity I have simply sorted this temporary array.Now i have added the stones from the additional amount available and reduced the same amount from additionalRocks. Finally I have counted the positions where temporary array has become 0 and thats the count of the bags that have been completely filled. Oh! wait also I have kept a count of sum of temp array and check that if the amount of stones needed to completely fill all the bags is lesser than the number of additional stones available then simply return the length of rocks array \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int temp[] = new int[capacity.length];\\n      long sum=0;\\n      for(int i=0;i<rocks.length;i++)\\n        {\\n            temp[i]=capacity[i]-rocks[i];\\n            sum=sum+(capacity[i]-rocks[i]);\\n\\n        }  \\n        if(additionalRocks>=sum)\\n        return rocks.length;\\n        Arrays.sort(temp);\\n        for(int i=0;i<rocks.length;i++)\\n        {\\n            if(additionalRocks==0)\\n            {\\n                break;\\n            }\\n            if(temp[i]<=additionalRocks)\\n            {\\n                additionalRocks-=temp[i];\\n                temp[i]=0;\\n                \\n            }\\n\\n        }\\n        int count=0;\\n        for(int i=0;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int temp[] = new int[capacity.length];\\n      long sum=0;\\n      for(int i=0;i<rocks.length;i++)\\n        {\\n            temp[i]=capacity[i]-rocks[i];\\n            sum=sum+(capacity[i]-rocks[i]);\\n\\n        }  \\n        if(additionalRocks>=sum)\\n        return rocks.length;\\n        Arrays.sort(temp);\\n        for(int i=0;i<rocks.length;i++)\\n        {\\n            if(additionalRocks==0)\\n            {\\n                break;\\n            }\\n            if(temp[i]<=additionalRocks)\\n            {\\n                additionalRocks-=temp[i];\\n                temp[i]=0;\\n                \\n            }\\n\\n        }\\n        int count=0;\\n        for(int i=0;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958870,
                "title": "java-solution-with-explanation-beats-99-11-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial rocks filled in each bag being given, our only task is to find the no. of bags that are filled to their capacity and the bags with minimum difference between their initial value and their capacity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we take an array called $$diff$$ to store the difference for each $$ith $$ bag and then sort it.\\nAfter sorting, we will end up with the array starting with bags that are already filled to their capacity followed by the bags that require least number of rocks in ascending order.\\nSo, we run a loop for all the bags until \\n1. all the bags are filled, or \\n2. all additional rocks are used.\\n\\nInitialise, $$ans$$ = 0\\n\\nIn each iteration of the loop, we have two conditions:\\n1. $$diff[i]$$ = 0\\n2. $$diff[i]$$ != 0\\n\\nFor the first condition, we increment our $$ans$$ by 1 and jump to next iteration.\\nFor the second condition, we check if we have enough addtional rocks to fill the difference in each bag, i.e., $$extra - diff[i] >= 0$$, if yes, we have found another bag that can be filled completely, so we increment $$ans$$ by 1. Next, we update the additional rocks left by updating it as $$additional rocks = additional rocks - diff[i]$$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ + $$O(n.log(n))$$(for sorting)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you liked my approach and comment down if you have a better approach.\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int extra) {\\n        int ans = 0;\\n        int n = capacity.length;\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(diff);\\n        int i = 0;\\n        while (i < n && extra > 0) {\\n            if (diff[i] == 0) ++ans;\\n            else {\\n                if (extra - diff[i] >= 0) ++ans;\\n                extra -= diff[i];\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int extra) {\\n        int ans = 0;\\n        int n = capacity.length;\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = capacity[i] - rocks[i];\\n        }\\n        Arrays.sort(diff);\\n        int i = 0;\\n        while (i < n && extra > 0) {\\n            if (diff[i] == 0) ++ans;\\n            else {\\n                if (extra - diff[i] >= 0) ++ans;\\n                extra -= diff[i];\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958665,
                "title": "easy-java-solution-tc-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) \\n    {\\n        int[] remainingCapacity = new int[rocks.length];\\n        for(int i=0; i<rocks.length; i++)\\n        {\\n            remainingCapacity[i]=capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(remainingCapacity);\\n\\n        int fullBagsCount=0;\\n        for(int i=0; i<remainingCapacity.length; i++)\\n        {\\n            if(additionalRocks>=remainingCapacity[i])\\n            {\\n                additionalRocks-=remainingCapacity[i];\\n                fullBagsCount++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return fullBagsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) \\n    {\\n        int[] remainingCapacity = new int[rocks.length];\\n        for(int i=0; i<rocks.length; i++)\\n        {\\n            remainingCapacity[i]=capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(remainingCapacity);\\n\\n        int fullBagsCount=0;\\n        for(int i=0; i<remainingCapacity.length; i++)\\n        {\\n            if(additionalRocks>=remainingCapacity[i])\\n            {\\n                additionalRocks-=remainingCapacity[i];\\n                fullBagsCount++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return fullBagsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958659,
                "title": "accepted-easy-to-understand-only-using-array-concept-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int[] remainingSpace = new int[capacity.length];\\n        for(int i =0; i<capacity.length;i++){\\n               remainingSpace[i] = capacity[i] - rocks[i];\\n        }\\n\\n        Arrays.sort(remainingSpace);\\n        int ans = 0;\\n        for(int i =0;i<capacity.length;i++){\\n            if(remainingSpace[i] == 0){\\n                ans++;\\n            }else{\\n              if(additionalRocks>=remainingSpace[i]){\\n                additionalRocks = additionalRocks - remainingSpace[i];\\n                ans++;\\n               }else{\\n                   break;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int[] remainingSpace = new int[capacity.length];\\n        for(int i =0; i<capacity.length;i++){\\n               remainingSpace[i] = capacity[i] - rocks[i];\\n        }\\n\\n        Arrays.sort(remainingSpace);\\n        int ans = 0;\\n        for(int i =0;i<capacity.length;i++){\\n            if(remainingSpace[i] == 0){\\n                ans++;\\n            }else{\\n              if(additionalRocks>=remainingSpace[i]){\\n                additionalRocks = additionalRocks - remainingSpace[i];\\n                ans++;\\n               }else{\\n                   break;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958544,
                "title": "2279-maximum-bags-with-full-capacity-of-rocks-java-solution",
                "content": "# Intuition\\n<!-- Although this problem is a medium level, but it is easy when you understand it. -->\\n\\n# Approach\\n<!-- \\n1. First create a Vaccancy array substracting the given two arrays.\\n2. Then sort the array in ascending order.\\n3. create a count to count the full-bag count\\n4. Then iterate through the vaccancy array looking for already full and need to fill areas with respect to the additionalRocks\\n5. then return the count.\\n -->\\n\\n# Complexity\\n- Time complexity:\\n<!--\\nTC: O(n)\\n -->\\n\\n- Space complexity:\\n<!-- \\nSC: O(n)\\nbut we can change the SC -> O(1) if we use the capacity array and modify it rather than using a extra array \"vaccancy.\"\\n -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n     int vaccancy[] = new int[capacity.length];\\n     for(int i=0; i<capacity.length; i++){\\n         vaccancy[i] = capacity[i]-rocks[i];\\n     }   \\n     Arrays.sort(vaccancy);\\n     int cFB = 0; //count for full bag\\n     for(int i=0; i<vaccancy.length; i++){\\n         if(vaccancy[i] == 0)\\n         {\\n             cFB++;\\n         }\\n         else{\\n             if(additionalRocks >= vaccancy[i])\\n             {\\n                 additionalRocks -=vaccancy[i];\\n                 cFB++;\\n             }\\n             else\\n             {\\n                 break;\\n             }\\n             \\n             }\\n     }\\n     return cFB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n     int vaccancy[] = new int[capacity.length];\\n     for(int i=0; i<capacity.length; i++){\\n         vaccancy[i] = capacity[i]-rocks[i];\\n     }   \\n     Arrays.sort(vaccancy);\\n     int cFB = 0; //count for full bag\\n     for(int i=0; i<vaccancy.length; i++){\\n         if(vaccancy[i] == 0)\\n         {\\n             cFB++;\\n         }\\n         else{\\n             if(additionalRocks >= vaccancy[i])\\n             {\\n                 additionalRocks -=vaccancy[i];\\n                 cFB++;\\n             }\\n             else\\n             {\\n                 break;\\n             }\\n             \\n             }\\n     }\\n     return cFB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958358,
                "title": "c-very-easy-to-understand-basic-greedy-approch",
                "content": "# Approach\\nStep 1: Create a Vacancy array from capacity[i] - rocks[i]\\nStep 2: Sort the Vacancy arrray {Here comes the greedy approach}\\nStep 3: Now just check the Additional rock value with the vacancy array and check how many zeros are there in the vacany array while updating the value of additional rock by subtracting the current interating vacany.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) -- > Inbuilt Sorting\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int ad) {\\n        \\n        vector<int> v(c.size(),0);\\n        for(int i=0;i<c.size();i++)\\n        {\\n            v[i] = c[i] - r[i];\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        int fbg = 0;\\n\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                fbg++;\\n            }\\n            else\\n            {\\n                if(ad>=v[i])\\n                {\\n                    ad = ad - v[i];\\n                    fbg++;\\n                }\\n                else\\n                break;\\n            }\\n\\n        }\\n        \\n        return fbg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int ad) {\\n        \\n        vector<int> v(c.size(),0);\\n        for(int i=0;i<c.size();i++)\\n        {\\n            v[i] = c[i] - r[i];\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        int fbg = 0;\\n\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                fbg++;\\n            }\\n            else\\n            {\\n                if(ad>=v[i])\\n                {\\n                    ad = ad - v[i];\\n                    fbg++;\\n                }\\n                else\\n                break;\\n            }\\n\\n        }\\n        \\n        return fbg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958091,
                "title": "c-easy-to-understand-tc-o-n-log-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. calculate the remaining number of rocks each bag can carry.\\n2. Sort the array which we get after step 1.\\n3. Traverse the sorted array:-\\n    3.1. If remaining capacity is zero, then we will simply increment the count.\\n    3.2. Else, we subtract capacity from additional rocks, and check:-\\n        3.2.1. If additional rocks is still positive, then increment count.\\n        3.2.1. Else, break the loop, and return count.\\n\\n# Complexity\\n- Time complexity: O(n(log n)) (Because we are sorting the array)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int cnt=0;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(), capacity.end());\\n        for(int i=0;i<n;i++) {\\n            if(capacity[i]==0) {\\n                cnt++;\\n                continue;\\n            }\\n            additionalRocks-=capacity[i];\\n            if(additionalRocks>=0) cnt++;\\n            else break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int cnt=0;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++) {\\n            capacity[i]-=rocks[i];\\n        }\\n        sort(capacity.begin(), capacity.end());\\n        for(int i=0;i<n;i++) {\\n            if(capacity[i]==0) {\\n                cnt++;\\n                continue;\\n            }\\n            additionalRocks-=capacity[i];\\n            if(additionalRocks>=0) cnt++;\\n            else break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958053,
                "title": "c-solution-o-nlogn-sorting-o-n-searching-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        int n = capacity.size();\\n\\n        for(int i=0; i<n; i++){\\n            capacity[i] = capacity[i] - rocks[i];\\n        }\\n\\n        sort(capacity.begin(),capacity.end());\\n\\n        int cnt = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(capacity[i]==0) cnt++;\\n            else if(capacity[i]-additionalRocks<=0){\\n                additionalRocks-=capacity[i];\\n                cnt++;\\n            }\\n            else break;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n\\n        int n = capacity.size();\\n\\n        for(int i=0; i<n; i++){\\n            capacity[i] = capacity[i] - rocks[i];\\n        }\\n\\n        sort(capacity.begin(),capacity.end());\\n\\n        int cnt = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(capacity[i]==0) cnt++;\\n            else if(capacity[i]-additionalRocks<=0){\\n                additionalRocks-=capacity[i];\\n                cnt++;\\n            }\\n            else break;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958016,
                "title": "get-the-difference-between-capacity-and-numbers-of-rocks-and-sort",
                "content": "# Intuition\\nGiven the capacity and number of rocks and more number of additional rocks to fill in until the additional rocks becomes zero!\\n**Appears like a Knapsack problem right?**\\nSo greedy is the first thought here !  \\n\\n# Approach\\n- Get the vacancy in each bag and store it in a array\\n- sort it , so that the bags with least number of vancancies gets filled first, hence more will get filled (greedy thought)\\n- Check whether additional rocks are left to be filled until 0 \\n- return the count as the maximum bags filled !\\n- hurrayy you solved it! \\uD83C\\uDF86\\uD83C\\uDF1A\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int ad) {\\n        int n =c.size();\\n        int ans =0;\\n        vector<int>vec(n,0);\\n        for(int i=0;i<n;i++){\\n            vec[i]=c[i]-r[i];\\n            if(!vec[i]) ans++;\\n        }\\n        long long add = (long long) ad;\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]>0){\\n                add-=vec[i];\\n                // cout<< \" rem ad \"<<ad;\\n                if(add>=0) ans++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\nDo upvote if it helps !\\u270C\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& c, vector<int>& r, int ad) {\\n        int n =c.size();\\n        int ans =0;\\n        vector<int>vec(n,0);\\n        for(int i=0;i<n;i++){\\n            vec[i]=c[i]-r[i];\\n            if(!vec[i]) ans++;\\n        }\\n        long long add = (long long) ad;\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]>0){\\n                add-=vec[i];\\n                // cout<< \" rem ad \"<<ad;\\n                if(add>=0) ans++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2958005,
                "title": "easy-c-solution-greedy",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans=0;\\n        int n= capacity.size();\\n        for (int i=0; i<n; i++){\\n            capacity[i]-= rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        for (int i=0; i<n; i++){\\n            if (capacity[i]==0){\\n                ans++;\\n                continue;\\n            }\\n            if (additionalRocks-capacity[i]>=0){\\n                ans++;\\n                additionalRocks-= capacity[i];\\n            }\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int ans=0;\\n        int n= capacity.size();\\n        for (int i=0; i<n; i++){\\n            capacity[i]-= rocks[i];\\n        }\\n        sort(capacity.begin(),capacity.end());\\n        for (int i=0; i<n; i++){\\n            if (capacity[i]==0){\\n                ans++;\\n                continue;\\n            }\\n            if (additionalRocks-capacity[i]>=0){\\n                ans++;\\n                additionalRocks-= capacity[i];\\n            }\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957967,
                "title": "python-greedy-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        N = len(capacity)\\n        left = [capacity[i]-rocks[i] for i in range(N)]\\n        left.sort()\\n        maxi = 0\\n        for l in left:\\n            if additionalRocks >= l:\\n                additionalRocks -= l\\n                maxi += 1\\n\\n        return maxi\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        N = len(capacity)\\n        left = [capacity[i]-rocks[i] for i in range(N)]\\n        left.sort()\\n        maxi = 0\\n        for l in left:\\n            if additionalRocks >= l:\\n                additionalRocks -= l\\n                maxi += 1\\n\\n        return maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957946,
                "title": "help-can-you-tell-me-the-time-complexity",
                "content": "# Time Complexity of Algorithm Using priority_queue\\n\\nThe following code uses a priority_queue. \\nI have guessed that the time complexity is **O(m * n)**;\\n**m** being the size of the rocks/capacity array;\\n**n** being the number of additionalRocks;\\n\\nMy tought was: At worst I\\'ll have to iterate over the whole array decreasing the amount of **additionalRocks** only by one at each time.\\n\\nFollows the example of worst case:\\ncapacity: \\n[2,2,2,2,2]\\nrocks:    \\n[1,1,1,1,1]\\nadditionalRocks:\\n5\\n\\nMy question is:\\nCan the priority_queue somehow make the time complexity worst?\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        bool isFull = false;\\n        int n = rocks.size();\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(capacity[i] == rocks[i]) res++;\\n            else pq.push(capacity[i] - rocks[i]);\\n        } \\n        while(!pq.empty() && pq.top() <= additionalRocks) {\\n            res++;\\n            additionalRocks -= pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        bool isFull = false;\\n        int n = rocks.size();\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(capacity[i] == rocks[i]) res++;\\n            else pq.push(capacity[i] - rocks[i]);\\n        } \\n        while(!pq.empty() && pq.top() <= additionalRocks) {\\n            res++;\\n            additionalRocks -= pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957918,
                "title": "easiest-binary-search-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int ar) {\\n        \\n        int n = rocks.size();\\n        vector <int> diff(n,0);\\n        \\n        for(int i = 0;i<n;i++){\\n            diff[i] = capacity[i] - rocks[i];\\n        }\\n        \\n        sort(diff.begin(),diff.end());\\n        \\n        vector <long long> prev(n,0);\\n        prev[0] = diff[0];\\n        \\n        for(int i = 1;i<n;i++){\\n            prev[i] = prev[i-1] + diff[i];\\n        }\\n        \\n        return upper_bound(prev.begin(),prev.end(),ar)-prev.begin();\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int ar) {\\n        \\n        int n = rocks.size();\\n        vector <int> diff(n,0);\\n        \\n        for(int i = 0;i<n;i++){\\n            diff[i] = capacity[i] - rocks[i];\\n        }\\n        \\n        sort(diff.begin(),diff.end());\\n        \\n        vector <long long> prev(n,0);\\n        prev[0] = diff[0];\\n        \\n        for(int i = 1;i<n;i++){\\n            prev[i] = prev[i-1] + diff[i];\\n        }\\n        \\n        return upper_bound(prev.begin(),prev.end(),ar)-prev.begin();\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957723,
                "title": "cpp-clear-solution-simple",
                "content": "![image.png](https://assets.leetcode.com/users/images/529b813a-6382-4924-bc80-50f8a8b26666_1672136119.8453934.png)\\n\\nUp vote if it helped you =) \\n\\n# Intuition\\nMy Intuition following that for capacity[i] - rocks[i] is the amount of rocks nneded to add to the i-th bag in order to count it as filled.\\n\\nthe probelm is that its is not enough - lets say that I have a[capacity - rocks] array that describes the missing rocks till the bas is filled. lets name it missingRocks. \\nHow would I know which of them I should fill from additionalRocks?  \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Calculating $$missingRocks[i] = capacity[i] - rocks[i]$$.\\nmissingRocks[i] is the number of rocks needed to fill the i-th bag.\\n\\n2. By sorting missingRocks, we find which of the bags requires the least amount of rocks to add, those by filling from the begining of the sorted missingRocks vector we will $$maximize$$ the amount of bags filled. \\nso -  $$sorting$$ missingRocks and adding to the final result, j, for each missingRock that we filled. In order to fill a single missingRock,\\n4. if $$additionalRocks >= missingRock $$ this missing rock can be included.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nwith n = capacity size\\n\\n- Time complexity:\\n- $$ O(n log n)$$\\nWith $$O(n)$$ for substracting and $$O(n long n)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\nAs every use of the stack/heap is a constant size of memory (not including capacity && rocks memory uses.)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        // init the missingRocks array(stored in capacity)\\n        for(int i = 0; i < capacity.size(); i++)\\n            capacity[i]-=rocks[i];\\n        \\n        // sorts the array\\n        sort(capacity.begin(),capacity.end());\\n\\n        // find how many bags we can fill using additionalRocks.\\n        // note that the cases :bag = 0, additionalRocks = 0 is handled \\n        int j = 0;\\n        for (int bag:capacity){\\n            additionalRocks -= bag;\\n            if (additionalRocks >= 0) j++;\\n            else break;\\n        } \\n\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        // init the missingRocks array(stored in capacity)\\n        for(int i = 0; i < capacity.size(); i++)\\n            capacity[i]-=rocks[i];\\n        \\n        // sorts the array\\n        sort(capacity.begin(),capacity.end());\\n\\n        // find how many bags we can fill using additionalRocks.\\n        // note that the cases :bag = 0, additionalRocks = 0 is handled \\n        int j = 0;\\n        for (int bag:capacity){\\n            additionalRocks -= bag;\\n            if (additionalRocks >= 0) j++;\\n            else break;\\n        } \\n\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957650,
                "title": "easy-solution-with-java-beats-everyone-on-this-planet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count=0;\\n        int i=0;\\n        int[] diff = new int[capacity.length];\\n        for(i=0;i<capacity.length;i++)diff[i]=capacity[i]-rocks[i];\\n        Arrays.sort(diff);\\n\\n        for(i=0;i<capacity.length;i++)\\n        {\\n            if(diff[i]==0)continue;\\n            else if(diff[i]<=additionalRocks){\\n                additionalRocks-=diff[i];\\n                diff[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n\\n        for(i=0;i<capacity.length;i++)\\n            if(diff[i]==0)count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count=0;\\n        int i=0;\\n        int[] diff = new int[capacity.length];\\n        for(i=0;i<capacity.length;i++)diff[i]=capacity[i]-rocks[i];\\n        Arrays.sort(diff);\\n\\n        for(i=0;i<capacity.length;i++)\\n        {\\n            if(diff[i]==0)continue;\\n            else if(diff[i]<=additionalRocks){\\n                additionalRocks-=diff[i];\\n                diff[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n\\n        for(i=0;i<capacity.length;i++)\\n            if(diff[i]==0)count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957602,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>v;\\n        for(int i=0; i<capacity.size(); i++){\\n            v.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        int ans=0;\\n        while(additionalRocks>0 && ans<v.size()){\\n            additionalRocks-=v[ans];\\n            ans++;\\n        }\\n        if(additionalRocks>=0){return ans;}\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>v;\\n        for(int i=0; i<capacity.size(); i++){\\n            v.push_back(capacity[i]-rocks[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        int ans=0;\\n        while(additionalRocks>0 && ans<v.size()){\\n            additionalRocks-=v[ans];\\n            ans++;\\n        }\\n        if(additionalRocks>=0){return ans;}\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957508,
                "title": "simple-o-n-solution-with-video-explanation-beats-99-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the differences in ascending order. Fill the bags with remaining additional rocks until all are used.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting and summing.\\n\\n# Complexity\\n- Time complexity: We are iterating the loop that takes O(n) time. But the arrays.sort() operation takes $$O(nlogn)$$ time. So, in total it will be: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: As we have declared another array int[] diffs of size n, the space complexity will be: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = rocks.length;\\n        int[] diffs = new int[n];\\n        for(int i=0; i<n; i++){\\n            diffs[i] = capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(diffs);\\n\\n        int bagsFilled = 0;\\n        int rocksTaken = 0;\\n\\n        for(int diff: diffs){\\n            rocksTaken+= diff;\\n            if(rocksTaken>additionalRocks){\\n                break;\\n            }\\n            bagsFilled++;\\n        }\\n        return bagsFilled;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/30df44be-760c-4c90-ba2b-64b3a46095c8_1672133371.4177244.png)\\n\\n# Video Explanation: \\n\\nhttps://youtu.be/l394ms7b3a8\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = rocks.length;\\n        int[] diffs = new int[n];\\n        for(int i=0; i<n; i++){\\n            diffs[i] = capacity[i]-rocks[i];\\n        }\\n        Arrays.sort(diffs);\\n\\n        int bagsFilled = 0;\\n        int rocksTaken = 0;\\n\\n        for(int diff: diffs){\\n            rocksTaken+= diff;\\n            if(rocksTaken>additionalRocks){\\n                break;\\n            }\\n            bagsFilled++;\\n        }\\n        return bagsFilled;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957325,
                "title": "beats-99-sorting-greedy-solution-in-java",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn order to maximize the bags that gets filled, we need start by filling the bags with the least remaining space first. Only then we will have more additional rocks to fill the rest of the bags.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for (int i = 0; i < rocks.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for (int i = 0; i < capacity.length; i++) {\\n            additionalRocks -= capacity[i];\\n            if (additionalRocks < 0) return i;\\n        }\\n        return capacity.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        for (int i = 0; i < rocks.length; i++) {\\n            capacity[i] -= rocks[i];\\n        }\\n        Arrays.sort(capacity);\\n        for (int i = 0; i < capacity.length; i++) {\\n            additionalRocks -= capacity[i];\\n            if (additionalRocks < 0) return i;\\n        }\\n        return capacity.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957287,
                "title": "easy-java-solution-easy-to-understand-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we first count the total number of elements where we doesn\\'t need any additional rocks i.e, capacity[i] <= rocks[i]\\notherwise we store the number of additional rocks it require to make it full in list i.e , list.add(capacity[i] - rocks[i])\\nafter that we store all the list elements into array and sort it. \\nand we traverse it till additionalRocks is greater than 0 or we reach the end of array.\\nand increase our count and decrease the additionalRocks by elements at corresponding elements.\\n// If you like the solution please upvote it \\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n         for(int i = 0; i < rocks.length; ++i){\\n             if(capacity[i] <= rocks[i]){\\n                 ++count;\\n             }\\n             else{\\n                 list.add(capacity[i] - rocks[i]);\\n             }\\n         }\\n         int len = list.size();\\n         int[] arr = new int[len];\\n         for(int i = 0; i < len; ++i){\\n             arr[i] = list.get(i);\\n         }\\n         Arrays.sort(arr);\\n         int i = 0;\\n         \\n         while(additionalRocks > 0 && i < len){\\n             if(additionalRocks >= arr[i]){\\n                 ++count;\\n                 additionalRocks -= arr[i];\\n                 ++i;\\n             }\\n             else{\\n                 break;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n// This code is contributed by Sunil Kumar\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int count = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n         for(int i = 0; i < rocks.length; ++i){\\n             if(capacity[i] <= rocks[i]){\\n                 ++count;\\n             }\\n             else{\\n                 list.add(capacity[i] - rocks[i]);\\n             }\\n         }\\n         int len = list.size();\\n         int[] arr = new int[len];\\n         for(int i = 0; i < len; ++i){\\n             arr[i] = list.get(i);\\n         }\\n         Arrays.sort(arr);\\n         int i = 0;\\n         \\n         while(additionalRocks > 0 && i < len){\\n             if(additionalRocks >= arr[i]){\\n                 ++count;\\n                 additionalRocks -= arr[i];\\n                 ++i;\\n             }\\n             else{\\n                 break;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n// This code is contributed by Sunil Kumar\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1729666,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729602,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729616,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1730487,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729930,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729677,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1730561,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729692,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729986,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729694,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729666,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729602,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729616,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1730487,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729930,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729677,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1730561,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729692,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729986,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729694,
                "content": [
                    {
                        "username": "crazysamurai",
                        "content": "Some days Medium is Hard others it's Easy, just like life"
                    },
                    {
                        "username": "pratikraj001",
                        "content": "this is life bro\\n"
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "true\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "quite sarcastic as life "
                    },
                    {
                        "username": "user1618PE",
                        "content": "Easy, not Medium difficulty... IMHO"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Agree"
                    },
                    {
                        "username": "xu_tony",
                        "content": "Agree."
                    },
                    {
                        "username": "suren_yeager",
                        "content": "yeah i thought it was the brute force approach. but it\\'s actually the optimal one  \\u02C3\\u0323\\u203F\\u02C2"
                    },
                    {
                        "username": "bigbullboy",
                        "content": "Yeah I was thinking that as well. I\\'m not usually able to solve mediums on my own lmao"
                    },
                    {
                        "username": "jc0222",
                        "content": "Yup...not much needed to think"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Probably should be an **Easy**-level problem, just use sorting first and then greedy."
                    },
                    {
                        "username": "mohanagnihotri245",
                        "content": "true i waiting for some edge cases but it got submitted on one go"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Sometimes discussion section makes this platform toxic, if its easy for you, try something that's challenging instead of commenting its easy, many people like me felt this is a medium problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "finally someone speaks the truth"
                    },
                    {
                        "username": "Msey",
                        "content": "fact"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Although easy, but can use any of these data structures: \n   1. Vector/List/Array (Sorting)\n   2. Priority Queue (Min-Heap)\n   3. TreeMap (Java Collections) \n"
                    },
                    {
                        "username": "dps_002",
                        "content": "my sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????\\n"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "sorting???"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Very easy question. Should not come under medium category."
                    },
                    {
                        "username": "AuHg",
                        "content": "When LC guy gives real medium question , folks in discussion section :-\\n\" This should be hard tagged question , this  was so hard  \" dang it"
                    },
                    {
                        "username": "iamvbenz1",
                        "content": "fact"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "It\\'s not a medium question which i expect :>"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "im jisoo im okay"
                    },
                    {
                        "username": "user8296H",
                        "content": "LeetCode needs to revisit its difficulty ranking algorithm for sure :)"
                    },
                    {
                        "username": "amanchandna",
                        "content": "This is an easy level problem, just basic math with sorting"
                    }
                ]
            },
            {
                "id": 1729617,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1576790,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1729966,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1729778,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1937735,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1810872,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1744852,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1744374,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1731484,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1730751,
                "content": [
                    {
                        "username": "Mike_Rye",
                        "content": "additionalRocks means remaining\\nfind difference for each [ i ] bag\\nthen start subtracting additionalrocks to difference from low -> high "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@addlurumohanraj](/addlurumohanraj) yes, because in this way, we will be able to fill more bags with less additional rocks"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "Do we need to start filling the bags that are closer to the capacity first?"
                    },
                    {
                        "username": "kapil_singh43",
                        "content": "can it be solved using knapsack?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "[@bharathi1121](/bharathi1121)  Hi you can check it here\\nhttps://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2959344/go-dp-top-down/"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "[@Jonatanlp](/Jonatanlp) could you share dp code please\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes it can solved using DP Knapsack  ( I already did both of it using greedy and DP Knapsack)\\nbut i found greedy one is more simpler and have better complexity \\n\\n"
                    },
                    {
                        "username": "msid78641",
                        "content": "No it can\\'t be just because of constraints, but if n would have been comparatively smaller then definetly it could have been done using knapsack, assume additionalRocks to be the bag and items[i] =  capacity[i]-rocks[i] where i is in range (0 < i < n) then it narrow downs to pick maximum no of items with bag size of additionalRocks"
                    },
                    {
                        "username": "rotkay",
                        "content": "it\\'s actually very similar to fractional knapsack problem, which is solved in the same way with greedy approach"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "this is not a knapsack problem. Here we have multiple sack, and each item take one unit of capacity. This is much simpler problem that knapsack. "
                    },
                    {
                        "username": "ywng",
                        "content": "why would one do so. This can be solved by a simpler and less run time complexity solution. It\\'s just kind of assignment problem of maximizing something (you can call it greedy if you like)."
                    },
                    {
                        "username": "charonme",
                        "content": "I believe the question \"Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\" COULD be interpreted to not count bags that are already at full capacity, but the examples demonstrate they didn\\'t interpret it this way"
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy if you don\\'t know the right direction.\\n\\nIf you don\\'t want to see the solution then here is some hints :\\n\\nHint 1 : If you are thinking about recursive or dynamic programming (dp) then maybe you must rethink about it because recursive solution will check all the possibility even answer is already found.\\n\\nHint 2 : Now think about real life. You want maximum number of filled bags then what will you do. You fill bags who has lots of space remain or bags who has less space remain (Greedy).\\n\\nHint 3 : You want the remaining space. You have total capacity (capacity array) of a bag and filled space (rocks array) then how you will find the reaming space.\\n"
                    },
                    {
                        "username": "TenaciousCoder16",
                        "content": "What is the SC of this code ....TC i think O(nlogn) and SC i think O(n) for the pq .....am i right ?\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        for(int i=0;i<n;i++)pq.add(capacity[i]-rocks[i]);\\n        int ans=0;\\n        while(pq.size()>0){\\n            int val=pq.poll();\\n            if(additionalRocks>=val){\\n                additionalRocks-=val;\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "dps_002",
                        "content": "Someone Explain this pls!!\\nmy sorting solution gives 75% faster\\nwhere as priority queue gives 11 % faster\\nisn\\'t their TC same i tried submitting again and again same tc\\nis it leetcode compiler or sorting is faster than priority queue one????????????????????"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/), a just little bit harder"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video \\nhttps://youtu.be/YltbWa_pMYo"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "Why does my code give TLE?\\n\\n```\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n=capacity.length, m=rocks.length;\\n        int bags=0;\\n        int i=0,j=0;\\n\\n        while(i<n && j<m)\\n        {\\n            int diff=(capacity[i]-rocks[j]);\\n            if(diff==0)\\n            bags++;\\n\\n            if(diff>0)\\n            {\\n                additionalRocks-=diff;\\n                bags++;\\n            }\\n        }\\n\\n        return bags;\\n    }\\n}\\n"
                    },
                    {
                        "username": "AuHg",
                        "content": "Your never updating i and j\\nn and m have same value"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`i` and `j` get initialized with `0`, the loop loops as long as `i<n` and `j<m`. But `i`, `j`, `n`, and `m` never get modified, they keep their original value, so the loop never ends.  \\nBTW:\\n- `n` and `m` are guaranteed to be equal. You only need one of those two variables, and similarly, you only need one of the index variables `i` and `j`.\\n- The second `if` statement fills the current bag with additional rocks. You might have to check whether you have enough additional rocks to do that.\\n- This solution starts with the first bag, fills it with additional rocks, continues with the next bag. You might want to examine the given examples whether that works because choosing which bags you want to fill is key for this problem."
                    },
                    {
                        "username": "Rhedx89",
                        "content": "capacity = [54,18,91,49,51,45,58,54,47,91,90,20,85,20,90,49,10,84,59,29,40,9,100,1,64,71,30,46,91]\\nrocks = [14,13,16,44,8,20,51,15,46,76,51,20,77,13,14,35,6,34,34,13,3,8,1,1,61,5,2,15,18]\\nadditionalRocks = 77\\noutput = 8, I do it by hand = 8\\nexcpeted = 13\\ncan somebody explain how should I do this "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Add 5 rocks to the bag with index 1.  \\nAdd 5 rocks to the bag with index 3.  \\nAdd 7 rocks to the bag with index 6.  \\nAdd 1 rock to the bag with index 8.  \\nAdd 15 rocks to the bag with index 9.  \\nAdd 0 rocks to the bag with index 11.  \\nAdd 8 rocks to the bag with index 12.  \\nAdd 7 rocks to the bag with index 13.  \\nAdd 14 rocks to the bag with index 15.  \\nAdd 4 rocks to the bag with index 16.  \\nAdd 1 rock to the bag with index 21.  \\nAdd 0 rocks to the bag with index 23.  \\nAdd 3 rocks to the bag with index 24.  \\n\\nYou\\'ve placed 70 of the 77 additional rocks into 13 bags that are now full.  \\nDoes that help?"
                    }
                ]
            },
            {
                "id": 1730720,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730710,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730651,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730548,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730515,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730503,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730449,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730415,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730348,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730273,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "Yea this should be an Easy"
                    },
                    {
                        "username": "AssPhaadCoder",
                        "content": "can someone pls help me i have made a vector of difference of capacity and rocks then sorted in nlogn. im traversing this vector to increment rocks but it gives tle error :(\\n\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int>space;\\n        for(int i=0;i<rocks.size();i++)space.push_back(capacity[i]-rocks[i]);\\n        mergeSort(space,0,space.size()-1);\\n        int i=0,count=0;\\n        while(i!=space.size()&&additionalRocks>=space[i]){\\n            if(!space[i]){\\n                i++;\\n                count=i;\\n            }\\n            if(space[i]){\\n                space[i]--;\\n                additionalRocks--;\\n                if(!space[i]){\\n                    i++;\\n                    count=i;\\n                }\\n            }\\n        }\\n        return count;\\n   }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "First of all: Please format your code. Either put a line with three backticks (<code>```</code>) before and after your code, or indent each line of your code with four *additional* spaces.  \nThe code is incomplete. It calls `mergeSort()` which is not a function in the standard libray so I guess you wrote it and I also guess it *correctly* sorts the `std::vector`, just like `std::sort()`, right?  \nTake a look at the second `if` inside the `while` loop. It repeatedly decrements `space[i]` and `additionalRocks` and then checks whether `space[i]` has become `0`. But if `space[i]` is large that can take a considerable amount of time. Can you find a faster and more direct way to perform that task? Hint: At this point you know that `additionalRocks` is greater than or equal to `rocks[i]`."
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "I have found a solution where a sorting is needed for an array size of len(capacity).\\nHas anyone solved this question without any loops? let\\'s talk about it"
                    },
                    {
                        "username": "giannicrivello",
                        "content": "Can someone help me improve my solution? I get a time limit exceeded failure on what looks like the last test case. I am trying to write my algorithm relying heavily on the STL. \\n\\n```c++\\nint maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        vector<int> diff ( rocks.size() );\\n        transform(capacity.begin(), capacity.end(), rocks.begin(), diff.begin(),\\n            minus<int>()\\n        );\\n        partition(diff.begin(), diff.end(), [](int a){ return a == 0; });\\n        sort(diff.begin(), diff.end());\\n        for(int num : diff) {\\n            cout << num << \" \";\\n        } \\n        vector<int> ans;\\n        int left_over = additionalRocks;\\n        for(int num : diff) {\\n            if(num == 0) { \\n                ans.push_back(1); \\n            }\\n            else {\\n                if(left_over >= reduce(rocks.begin(), rocks.end(), 0) ) { return rocks.size(); }\\n                while(num) {\\n                    if(left_over == 0) return ans.size();\\n                    left_over--;\\n                    num--;\\n                }\\n                ans.push_back(1);\\n            }\\n        }\\n        return ans.size();\\n}\\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- Calling `partition()` right before `sort()` is unnecessary overhead.  \\n- In the `else` branch inside the loop `reduce()` gets called over and over again. You could call it once, outside the loop. Or even better: Do you need it at all?\\n- The `while` loop decrements `left_over` and `num` by one, over and over. You could achieve the same without the inner `while` loop.\\n- After the `sort()` all elements of `diff` get printed. Is that necessary?\\n- `ans` is a `std::vector`, the value of each element is `1`. Wouldn\\'t a single integer be simpler and faster?\\n- The `for` loop handles two cases, wone where `num` is `0`, one where `num` is not `0`. Is that necessary? The code in the `else` branch would be able to handle all cases.\\n\\nWith all those simplifications the code should be fast enough.  \\nBTW: I really like the first `transform()`."
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Leetcode trying to make us feel better by making it medium XD"
                    },
                    {
                        "username": "sahil8453",
                        "content": "capacity =  [91,54,63,99,24,45,78]\\nrocks = [35,32,45,98,6,1,25]\\nadditionalRocks = 17\\noutput = 0\\nexpected = 1\\n\\nCan you somebody explain why it is expecting 1 as output here? if i place all 17 rocks in first bag then rocks[0] will be 52 and capacity[0] is 91. none of the bags are full"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "One of the bags (index 3) has a capacity of `99` and contains `98` rocks. Put one of the 17 additional rocks into it, then you have one full bag."
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "class Solution {\\npublic:\\n    \\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks){\\n        vector<int> arr;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back(capacity[i]-rocks[i]);\\n        }\\n        //sort\\n\\n        int m;\\n        for(int j=0;j<n;j++){\\n            if(arr[j]>arr[j+1])\\n            m=arr[j];\\n            arr[j]=arr[j+1];\\n            arr[j+1]=m;\\n        }\\n//count n0. of vaccancy\\n        int count=0;\\n        int i=0;\\n        while(additionalRocks!=0){\\n            additionalRocks-arr[i];\\n            i+=1;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(arr[j]==0)\\n            count+=count;\\n        }\\n        return count;\\n    }\\n};\\nwhy this is not running? plz help"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The second loop is supposed to sort the vector `arr`, right? That doesn\\'t work, for two reasons: (1) without curly braces the `if` statement applies only to immediate single statement, not to all three. And (2) the loop repeatedly swaps two adjacent elements if the first one is greater. That does not sort the whole `arr`. Did you consider calling `sort()`?\\nAlso, `additionalRocks-arr[i];` is just a subtraction, did you want to assign the result so some variable?"
                    },
                    {
                        "username": "Bhaiyaji",
                        "content": "use priority que to solve it."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Try to fill the value to the Bag with less remain Capacity, since we want to maximize the  number of Bags.\\n\\nSimple Approach with Explanation : https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2958498/java-sorting-simple-approach/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s an easy question, but still if u feel stuck, here\\'s a tip**\\n//storing the gap between capacity and rocks ith bag has     \\n//sorting the array     \\n// while we have not reached the end of the array and additional rocks remains        \\n//if capacity is already fulfilled then count that bag too\\n//else if we have enough rocks to fulfill the capacity, do it and increment the count of bags(don\\'t forget to decrement the count of additional rocks by the amount of capacity to just fulfilled)\\n"
                    }
                ]
            },
            {
                "id": 1730202,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730188,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730093,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730086,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730059,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730052,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730044,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1730016,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1729993,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            },
            {
                "id": 1729933,
                "content": [
                    {
                        "username": "shaheryar3",
                        "content": "This should be easy"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I agree with others. This problem should be under the easy lv"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints: \\n1. Use greedy algorithm.\\n2. Be greedy to fill the bags with the lowest space first and increment the counter."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "This is a recursive solution but gives TLE as expected; but when i tried to do memoization it gives wrong answer. anyone knows the reason? \\n\\nclass Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n        int n = capacity.length;\\n        if(n==0) return 0;\\n        int x = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),additionalRocks);\\n        int y=-1;\\n        if(additionalRocks-capacity[0]+rocks[0] >= 0){\\n            y = maximumBags(Arrays.copyOfRange(capacity,1,n),Arrays.copyOfRange(rocks,1,n),     additionalRocks-capacity[0]+rocks[0]);\\n        }\\n        return Math.max(x,y+1);\\n    }\\n}\\n "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "got it, just has to take proper hash value. that corrects WA but still gives TLE"
                    },
                    {
                        "username": "shricodev",
                        "content": "It is a easy level question. Sort by remaining capacity and then take the greedy approach. :)"
                    },
                    {
                        "username": "HumbleEmperor",
                        "content": "Please support If I am wrong or right. Here\\'s how I approached this problem. \\n1. First I found the difference of each box by subtracting each element with the corresponding one in the other array.\\n2. Then apply sorting to the question so that number of boxes to get filled in each is available in sorted form from lowest to highest. \\n3. Then subtract one by one each left out from the totalrocks available till the array is done or the totalrocks becomes zero.\\n\\nI did write the code but it\\'s giving errors. Please help in this regard. "
                    },
                    {
                        "username": "ihagverdi",
                        "content": "The approach seems right, check the code if everything suits the approach."
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Just think max capacity is given and already how much is filled is also given....so we can simply find out  how much more to be filled to attain max capacity. It is given to find max bags that can be filled completely..so if we can simply arrange it in ascending order then we can simply count bags from start until no more additional rock is left"
                    },
                    {
                        "username": "pun33t14",
                        "content": "And here I was trying DP here...anyone else\\uD83E\\uDD72??...got MLE"
                    },
                    {
                        "username": "bharathi1121",
                        "content": "yep i tried with dp but got TLE. check my comment. Think you tried push dp. i also tried that but got WA. could you share your code\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "no need to use Dp in such an easy solution, just use simple approach substrct the rocks from capacity and stored it, now sort it, now in loop substract the stored one with additional rocks and check condition if (ad>0) then what or (ad==0) and so on"
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {\\n        int count=0;\\n        vector<int>v;\\n        int n=capacity.size();\\n        for(int i=0;i<n;i++){\\n            int x=capacity[i]-rocks[i];\\n            v.push_back(x);\\n        }\\n        for(int i=0;i<n;i++){\\n            additionalRocks-=v[i];\\n            v[i]=0;\\n            if(additionalRocks>0 && additionalRocks<v[i]) {\\n            continue;}\\n            else if(additionalRocks<=0) break;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0) count++;\\n             \\n        }\\n        return count;\\n        //for(int i=0;i<n;i++){\\n         //   if(v[i]==0){\\n           //     count++;\\n             //   continue;\\n            //}\\n            //else{\\n              //  additionalRocks=additionalRocks-v[i];\\n                //count++;\\n                //if(additionalRocks==0) break;\\n            //}\\n        //}\\n        //return count;\\n    }\\n};\\nWhat is wrong in this solution?? Please answer"
                    },
                    {
                        "username": "user8296H",
                        "content": "You must sort your v vector first in ascending order. That way you take the bags that are already full or require lowest amount of additional rocks. So, you can maximize the bags count that are going to be full. "
                    },
                    {
                        "username": "Ansh_gupta310",
                        "content": "Can we do this by DP? if yes, can someone please share the code.."
                    },
                    {
                        "username": "bharathi1121",
                        "content": "check my comment, but it gives TLE\\n"
                    }
                ]
            }
        ]
    }
]