[
    {
        "title": "Number of Ways to Build Sturdy Brick Wall",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568750,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1708150,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1955096,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1930709,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1825547,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counting Words With a Given Prefix",
        "question_content": "<p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>\n\n<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802497,
                "title": "c-easiest-solution-substring",
                "content": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```\\nPlease Upvote, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802490,
                "title": "java-python-3-1-liners-and-a-follow-up",
                "content": "\\n\\n```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```\\n\\n----\\n\\n**Follow-up:**\\n\\n*Q*: A followup question from Google: what if the words are sorted lexicographically? -- credit to **@blackspinner**\\n*A*: We can use binary search twice to locate the lower and upper bounds of the words that have the same prefix. Therefore, the time cost is O(klogn). e.g., \\nAssume `perf = \"abcd\"`, we can search `\"abcd\"` and `\"abce\"` respectively.\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1803108,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802494,
                "title": "python3-java-c-find-indexof",
                "content": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "solutionTags": [],
                "code": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802788,
                "title": "one-liner-count-if",
                "content": "**C++**\\n```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809593,
                "title": "python-one-line-simple-solution",
                "content": "**Python**\\n\\n```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802715,
                "title": "trie-vs-brute-force-vs-find",
                "content": "**Trie Method**:\\n\\n1. First put all the words in the trie and keep on incrementing counting of prefix after every letter.\\n2. Now traverse prefix and get the count , number of word this prefix has occured.\\n\\n**It is a Standard Trie Implementation ALgorithm**\\n**C++**\\n  \\n    struct Node{\\n      Node* links[26];\\n      int prefix=0;\\n        \\n      bool contains(char c){\\n         return links[c-\\'a\\']!=0;\\n      }    \\n    \\n      void create(char c,Node* node){\\n          links[c-\\'a\\']=node;\\n      }\\n    \\n      void increment(){\\n          prefix++;\\n      }\\n    \\n      int count(){\\n          return prefix;\\n      }\\n    \\n      Node* next(char c){\\n          return links[c-\\'a\\'];\\n      }\\n    };\\n\\t\\n\\t//Trie Class\\n    class Trie{\\n      Node* root; \\n      public:\\n   \\n      Trie(){\\n          root=new Node();\\n      }\\n\\t  \\n      //insert words\\n      void insert(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n             if(!ptr->contains(i))  ptr->create(i,new Node());\\n             ptr=ptr->next(i);\\n             ptr->increment();\\n          }\\n      }\\n\\t  \\n      //return count of given prefix\\n      int cnt_pref(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n              if(!ptr->contains(i)) return 0;\\n              ptr=ptr->next(i);\\n          }\\n          return ptr->count();\\n      }\\n    };\\n\\t\\n\\t//input class\\n\\tclass Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }\\n    };\\n**Time** - O(number of words * average length of words + prefix_length)\\n**Space** - O(Average length * 26)\\n\\n# Find() Algorithm Method:\\n   \\n   \\n    int prefixCount(vector<string>& words, string &pref) {\\n        int cnt=0;\\n        for(auto i:words){\\n            auto q= i.find(pref);\\n            if(q!=string::npos and q==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * M)\\n**Space** - O(1)\\n\\t\\n# Brute Force\\t\\n\\n     bool check(string &x,string &y,int i){\\n\\t        if(i==y.size()) return true;\\n            return x[i]==y[i]? check(x,y,i+1) : false;\\n\\t }\\n\\t \\n     int prefixCount(vector<string>& words, string &pref){\\n        int cnt=0;\\n        for(auto i:words){\\n            if(i.size()<pref.size()) continue;\\n            cnt+= check(i,pref,0)? 1 : 0 ;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * min(pref.size(),average length of strings)\\n**Space** - O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1802447,
                "title": "c-with-explanation-easy",
                "content": "**Explanation-**\\nCheck if word contains pref, and if it contains then it should be at ```0th``` position\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```0th```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581816,
                "title": "python-easy-and-straight-forward-approach",
                "content": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1814309,
                "title": "javascript-easy-to-understand-1-line",
                "content": "The core strategy for this problem is straightforward:\\n- traverse the list\\n- check each word is with a given prefix\\n\\nI guess there won\\'t be any problem with how to do the traversal. So, the only problem is how to check the prefix?\\n\\nWe could use `RegExp`, `indexOf`, `startsWith`, or even `slice` the first part.\\nJust choose anyone you like, here are 2 samples from me:\\n\\n## Sample 1\\n\\n```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\\n\\n## Sample 2\\n\\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802677,
                "title": "javascript-1-line-solution",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555249,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848590,
                "title": "c-solution-using-substr",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802520,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682359,
                "title": "simplest-python-solution-use-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534682,
                "title": "simple-easy-java-solution-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160664,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854383,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726749,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034337,
                "title": "java-beginner-friendly-fast-solution",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }\\n      }\\n      return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1823579,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803163,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802965,
                "title": "simple-short-c",
                "content": "**Counting Words With a Given Prefix**\\nTravel each word in words and check if it\\'s size is greater or equal to size if prefix and compare the substring of length n(size of prefix) with prefix, if equal increase count.\\n\\n```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802930,
                "title": "easy-c-solution-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802627,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802436,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968993,
                "title": "check-if-a-word-occurs-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/15db9f0b-0bd0-4e79-90ae-f5166da971ac_1693163848.8008177.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853168,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(s.length)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579916,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575096,
                "title": "java-easy-solution-100-beats",
                "content": "# Approach\\n\\n1. Initialize a variable `count` to 0. This variable will keep track of the number of strings in the `words` array that contain `pref` as a prefix.\\n\\n2. Iterate through each string `word` in the `words` array using a for-each loop.\\n\\n3. For each `word`, check if it starts with the `pref` string using the `startsWith()` method. This method returns `true` if the `word` starts with the `pref` string, and `false` otherwise.\\n\\n4. If the `startsWith()` method returns `true`, increment the `count` variable by 1.\\n\\n5. After iterating through all the strings in the `words` array, the `count` variable will contain the total number of strings that have `pref` as a prefix.\\n\\n6. Return the value of the `count` variable.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533558,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443720,
                "title": "substr-solution-easy-c",
                "content": "`Please Upvote If you Like !!!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338829,
                "title": "simple-approach-explained-for-beginners",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all understand the question take your time ; \\nAfter this Google it what you want;\\nDo not use chatGPT it will directly jumps to the solution with example.\\nFor example I don\\'t know about startsWith() func;\\nJust type on google \"i want to check a string contains at prefix or not\";\\nThe only you need in programming is to apply basic if, else and for loop and that is more than enough to enter in the world of DSA\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254512,
                "title": "counting-words-with-a-given-prefix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247423,
                "title": "counting-words-with-a-given-prefix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![countingwords.PNG](https://assets.leetcode.com/users/images/8d68c99b-176b-4804-a2bf-630bc38328e6_1677757448.8018465.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864108,
                "title": "c-short-4-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2705558,
                "title": "cpp-simple-solution-95-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695836,
                "title": "python-simple-solution-in-5-lines-faster-than-93-39",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694136,
                "title": "java-1ms-fast-solution",
                "content": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594345,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572272,
                "title": "4-lines-java-easy-code",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189043,
                "title": "java-stream-for-loop-solution",
                "content": "# For LOOP && STRING.STARTSWITH || STREAM FILTER && COUNT #\\n`Unfortunately, both functions are not as fast as you think \\uD83D\\uDE29`\\n\\n``Faster function than the latter \\uD83E\\uDD13``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n``Eazy function \\uD83D\\uDE0E ``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175494,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048962,
                "title": "easy-python-solution-for-beginners",
                "content": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903737,
                "title": "easy-solution-o-n-complexity-one-liner-without-using-startswith-inbuilt-function",
                "content": "Aint no brainer to use startswith function and compare the prefix of string. \\nI came up with the easiest solution that can be easiily understood by anyone , be it a beginner or a pro!\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```\\n\\n**If this helped PLEASE UPVOTE!**\\nThanks for stopping by!\\nHave a good day:)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862998,
                "title": "java-one-liner",
                "content": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1819619,
                "title": "kotlin-1-line",
                "content": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807311,
                "title": "c-1-liner-linq",
                "content": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806042,
                "title": "java-indexof-100",
                "content": "if you like this solution pls upvote :)\\n\\nJAVA\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804613,
                "title": "c-simple-solution-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804393,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803276,
                "title": "leetcode-2185-counting-words-with-a-given-prefix-100-faster",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802865,
                "title": "javascript-startswith-method",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802740,
                "title": "simple-python-solution",
                "content": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "codeTag": "Java"
            },
            {
                "id": 1802639,
                "title": "c-readable-code-concise-solution",
                "content": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802620,
                "title": "can-t-be-more-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }\\n        }\\n        return count; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4009632,
                "title": "different-approach-using-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n*Initialize a count variable to keep track of words with the given prefix.\\n*Iterate through each word in the array.\\n*Compare characters between the word and the prefix.\\n*If they match, increment the count.\\n*If the count reaches the length of the prefix, increment the count of words with the prefix.\\nReturn the count as the result.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656007,
                "title": "beginners-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    read the code once you will get it\\n\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498495,
                "title": "rust-0-ms",
                "content": "\\n```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337663,
                "title": "easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301114,
                "title": "very-easy-simple-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210317,
                "title": "java-solution-using-method",
                "content": "This method uses the method (startsWith),which is used to check the starting of both the string.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163839,
                "title": "beats-100-time-complexity",
                "content": "![Screenshot 2023-02-09 at 4.10.32 PM.png](https://assets.leetcode.com/users/images/6fee551e-5497-4942-9fc7-ab61903482cc_1675939587.9287362.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the first pref.length characters of words[i] and pref, and keep count.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161282,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131974,
                "title": "best-c-code-easy-to-understand-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIF FOUND USEFULL DO UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131970,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "Beats 95%+ in Runtime.....\\u270C\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\nHope you like the code implementation, make sure to upvote \\u270C\\nGood day, keep coding .....",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099858,
                "title": "c-no-built-in-functions",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868181,
                "title": "javascript-faster-than-98-23-memory-beats-96-25",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/2d582eb8-b759-41f7-9c46-1653faf86581_1669947042.89424.png)\\n![image.png](https://assets.leetcode.com/users/images/73988b56-2668-4549-b940-e30511568004_1669946746.8101223.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825979,
                "title": "javascript",
                "content": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2825074,
                "title": "rust-oneline-beats-100-vim-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHave a loop go over all words, check if it starts with pref, then count a variable up that will be returned at the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\\nThen relaised I was writing rust and filter() exists so I rewrote it.\\n\\n# Code\\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733892,
                "title": "trie-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694295,
                "title": "java",
                "content": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672549,
                "title": "java-startswith-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655074,
                "title": "javascript-easy-solution-in-one-line",
                "content": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630977,
                "title": "3-line-c-solution",
                "content": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2627768,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608393,
                "title": "2185-javascript-1-line-solution-o-nm",
                "content": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567197,
                "title": "simple-c-solution",
                "content": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2540990,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531620,
                "title": "python-counting-words-with-a-given-prefix",
                "content": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2460351,
                "title": "c-faster-than-98-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            } \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457824,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446970,
                "title": "javascript-best-solution-easy-understanding-100-faster-approach-beginner-friendly",
                "content": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437628,
                "title": "easy-to-understand-implementation-java",
                "content": "Initiate linear loop in the array and check if length of word is greater then prefix length so you skip\\nelse you check for matching condition using equals.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398493,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384110,
                "title": "python-trie-prefix-tree-solution",
                "content": "A simple python solution using [Trie](https://en.wikipedia.org/wiki/Trie)\\nDoes this problem need a trie? No! But I solved it using a Tire anyway. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336912,
                "title": "counting-words-with-a-given-prefix",
                "content": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2321239,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```\\n\\n##### Please upvote\\n[https://github.com/Reehan9/Leetcode-Solutions](http://)",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321058,
                "title": "easy-c-solution-using-substring-operations",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```\\n\\n**Please Upvote If You Find It Useful\\n   Thank You!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298978,
                "title": "counting-words-with-a-given-prefix-with-python3",
                "content": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "codeTag": "Python3"
            },
            {
                "id": 2278482,
                "title": "easy-javascript-solution",
                "content": "# Runtime: 58 ms, faster than 98.27% of JavaScript online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 42.5 MB, less than 80.94% of JavaScript online submissions for Counting Words With a Given Prefix.\\n\\n```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235920,
                "title": "c-using-substr-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221645,
                "title": "python-solution-for-beginners-by-beginner",
                "content": "**Runtime: 45 ms, faster than 84.18% of Python3 online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 13.9 MB, less than 96.55% of Python3 online submissions for Counting Words With a Given Prefix.**\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219621,
                "title": "c-one-line-count-if",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179351,
                "title": "easy-c-solution",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2117918,
                "title": "c-best-one-liner-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }\\n      }\\n        return c;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2104242,
                "title": "javascript-solution-without-using-any-built-in-functions",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067484,
                "title": "easy-c-approach",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2044122,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965549,
                "title": "using-trie-data-structure",
                "content": "\\tclass TrieNode{\\n\\t\\tpublic :\\n\\t\\tchar data;\\n\\t\\tTrieNode* child[26];\\n\\t\\tint wordend;\\n\\t\\tbool is_end;\\n\\t\\tTrieNode(){\\n\\t\\t\\twordend=0;\\n\\t\\t\\tis_end=false;\\n\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\tchild[i]=NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid insert(TrieNode* root,string s){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tint  index=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL){\\n\\t\\t\\t\\t\\tcurr->child[index]= new TrieNode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr->child[index]->wordend++;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\tcurr->is_end=true;\\n\\t\\t}\\n\\t\\tint count_prefix(TrieNode* root,string prefix){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<prefix.size(); i++){\\n\\t\\t\\t\\tint index=prefix[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL)\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn curr->wordend;        \\n\\t\\t}\\n\\n\\t};\\n\\tclass Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}\\n\\t\\t\\treturn count_prefix(root,pref);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1960839,
                "title": "basic-c-o-n-time-complexity-code",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isprefix(string word,string prefix)\\n    {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<word.length() && j<prefix.length())\\n        {\\n            if(word[i]!=prefix[j])\\n            {\\n                break;\\n            }\\n            i++;\\n            j++;\\n            c++;\\n        }\\n        if(c==prefix.length())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(isprefix(words[i],pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925154,
                "title": "java-1ms",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1877195,
                "title": "simple-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871318,
                "title": "python3-1-line",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867008,
                "title": "simple-python-solution-easy-to-understand",
                "content": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1861908,
                "title": "python-trie-solution",
                "content": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854979,
                "title": "1ms-java-solution-easy-to-understand",
                "content": "Hope this helps!!\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852307,
                "title": "python-ez-readable-code-2-ways-regex-solution",
                "content": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\\nNow, We can use the ^ if we want to attack it by way of RegEx:\\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1842983,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841783,
                "title": "simple-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838595,
                "title": "straightforward-java-solution-without-string-functions-runtime-0-ms",
                "content": "**Runtime**: 0 ms, faster than 100.00%, **Memory Usage**: 42.2 MB, less than 90.31%.\\n\\n```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836245,
                "title": "best-simplest-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828878,
                "title": "java-1-liner",
                "content": ">**T/S:** O(mn)/O(1), where m = size(words), n = size(pref)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n**Version 2:** 1 liner using [Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828550,
                "title": "c-simplest-and-cleanest-code-for-quick-understanding",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826783,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1825064,
                "title": "6-lines-python-code-intuitive-approach",
                "content": "Count length of prefix and check the starting part of every word in words for the prefix and increment count.\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824609,
                "title": "python-97-45-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1818658,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818362,
                "title": "simple-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818244,
                "title": "java-2-solutions-easy-implementations",
                "content": "**Solution 1:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809765,
                "title": "super-easy-to-understand-c-code",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809676,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }\\n            return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1807915,
                "title": "c-one-line-linq-solution",
                "content": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806964,
                "title": "my-java-solution-1-straight-forward-approach-2-using-trie-ds",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\\n\\n\\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806641,
                "title": "simple-solution",
                "content": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "solutionTags": [],
                "code": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1805758,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805056,
                "title": "scala-one-liner",
                "content": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1804593,
                "title": "java-multiple-approaches",
                "content": "**Approach 1:** Using String charAt and comparing char by char\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Approach 2:** Using string indexOf\\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 3:** Using String startsWith\\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 4:** Using Trie data structure. One can argue trie might not be required for this problem but its a good way to practice and implement it\\n\\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803726,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803668,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803656,
                "title": "c-easy-to-understand",
                "content": "*here we are watching for prefixes in every string in vector of strings.*\\n*the simple way or brtue force approach is to check for the prefixes that matches or not and for that we use **substr** function to access the substring which we require to check for the prefix* \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ctr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1803645,
                "title": "1-liner-in-js",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803451,
                "title": "c-very-easy-easy-to-understand-simple-code",
                "content": "Just do the dry one line by line this code, very easy to understand\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803429,
                "title": "java-c-solution-100",
                "content": "**C++ Solution**\\n\\n```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\\n\\n**JAVA Solution**\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803323,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803176,
                "title": "swift-1-liner-24-ms-14-8-mb",
                "content": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802989,
                "title": "c-easy-solution-only-5-line",
                "content": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802900,
                "title": "c-solution",
                "content": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1802858,
                "title": "very-simple-solution-with-explnation",
                "content": "\\tIst we traverse  then we find the  pref ans should we conatin 0th postion  then ans ++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802840,
                "title": "easy-js-javascript",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802793,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802737,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802718,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802705,
                "title": "c-easy-to-understand-simple-solution",
                "content": "**Do upvote If this helped!!**\\n```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802702,
                "title": "c-simple-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802672,
                "title": "cpp-easiset-solution-begineer-friendly",
                "content": "**Apporaoch** \\n* Just Traverse through each and every word.\\n* Find if any substring from starting position and of preifix size matches to prefix.\\n```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802644,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802624,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802623,
                "title": "java-string-startswtih-simple-solution",
                "content": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802591,
                "title": "easiest-short-sol-99-faster",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857039,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845553,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865308,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1846487,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837157,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835596,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]