[
    {
        "title": "Last Stone Weight II",
        "question_content": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:\n\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n\nAt the end of the game, there is at most one stone left.\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\n&nbsp;\nExample 1:\n\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.\n\nExample 2:\n\nInput: stones = [31,26,33,21,40]\nOutput: 5\n\n&nbsp;\nConstraints:\n\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 100",
        "solutions": [
            {
                "id": 294888,
                "title": "java-c-python-easy-knapsacks-dp",
                "content": "# **Intuition**\\nSame problem as:\\nDivide all numbers into two groups,\\nwhat is the minimum difference between the sum of two groups.\\nNow it\\'s a easy classic knapsack problem.\\n<br>\\n\\n\\n# **Brief Prove**\\nAll cases of \"cancellation of rocks\" can be expressed by two knapsacks.\\nAnd the last stone value equals to the difference of these two knapsacks\\nIt needs to be noticed that the opposite proposition is wrong.\\n<br>\\n\\n# **Solution 1**\\nVery classic knapsack problem solved by DP.\\nIn this solution, I use `dp` to record the achievable sum of the smaller group.\\n`dp[x] = 1` means the sum `x` is possible.\\n\\nTime `O(NS)`,\\nSpace `O(S)` space, where `S = sum(A)`.\\n<br>\\n\\n**Java, use array:**\\n```java\\n    public int lastStoneWeightII(int[] A) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = Math.min(1500, sumA); i >= a; --i)\\n                dp[i] |= dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\\n\\n**C++, use bitset:**\\n```cpp\\n    int lastStoneWeightII(vector<int> A) {\\n        bitset<1501> dp = {1};\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = min(1500, sumA); i >= a; --i)\\n                dp[i] = dp[i] + dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\\n\\n**Python, use set:**\\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        sumA = sum(A)\\n        for a in A:\\n            dp |= {a + i for i in dp}\\n        return min(abs(sumA - i - i) for i in dp)\\n```\\n<br>\\n\\n\\n# **Solution 2**\\nAdapted dp to this problem.\\nIn this solution, I use `dp` to record the achievable diff of one group.\\nIf `x` in the set `dp`, it means the difference `x` is achievable currently.\\n\\nTime `O(NS)` time,\\nSpace `O(S)` space, where `S = sum(A)`.\\n<br>\\n\\n**Python, use set:**\\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        for a in A:\\n            dp = {a + x for x in dp} | {abs(a - x) for x in dp}\\n        return min(dp)\\n```\\n\\n**Python, 1-line version**\\n```py\\n    def lastStoneWeightII(self, A):\\n        return min(reduce(lambda dp, y: {x + y for x in dp} | {abs(x - y) for x in dp}, A, {0}))\\n```\\n<br>\\n\\n\\n# **Follow-up**\\nAs this problem will be quite boring as Q4 (if you read my post),\\nI\\'ll leave you a slightly harder problem as follow-up just for more fun.\\nQuestion: Return the **biggest** possible weight of this stone?\\n<br>\\n\\n\\n# **FAQ (Some high voted questions)**\\n**Question:** How is it a knapsack problem?\\nMy understanding of Knapsack problem is this-\\nYou are given a set of items , for each of which we have a weight `w[i]` and value `v[i]`.\\nNow we have a bag for capacity `W` and we maximize our profit.\\n**Answer:**\\n`w[i] = stones[i]`\\n`v[i] = stones[i]`\\n`W = sum(stones) / 2`\\n<br>\\n\\n**Question:** Why the minimum result of cancellation is equal to minimum knapsack partition?\\n**Answer:**\\n1. One cancellation can be represented as one grouping.\\nOne grouping can be represented as one knapsack partition.\\n2. If the grouping difference < max(A), it can be realized by a cancellation.\\nWith the 2 conclusions above,\\nwe can know that the minimum result of cancellation is equal to minimum grouping difference,\\nwhich we solved by knapsack problem.\\n<br>\\n\\n**Question:** In some version of solution, what does the magic number 1500 mean?\\n**Answer:**\\nThe `dp[i]` present if the sum of one group can be `i`.\\nSo we can only record the smaller one for less space cost,\\nwhich less than half of the upper bound of total sum 3000.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int lastStoneWeightII(int[] A) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = Math.min(1500, sumA); i >= a; --i)\\n                dp[i] |= dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\n```cpp\\n    int lastStoneWeightII(vector<int> A) {\\n        bitset<1501> dp = {1};\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = min(1500, sumA); i >= a; --i)\\n                dp[i] = dp[i] + dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        sumA = sum(A)\\n        for a in A:\\n            dp |= {a + i for i in dp}\\n        return min(abs(sumA - i - i) for i in dp)\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        for a in A:\\n            dp = {a + x for x in dp} | {abs(a - x) for x in dp}\\n        return min(dp)\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        return min(reduce(lambda dp, y: {x + y for x in dp} | {abs(x - y) for x in dp}, A, {0}))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295167,
                "title": "java-beat-100-with-nice-explanation",
                "content": "```\\n/**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n\\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n\\ndp[i][j]   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    i ranges from (sum of all elements) {1..n}\\n    j ranges from  {1..n}\\n\\nsame as 494. Target Sum\\n\\n*/\\n\\n\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S = 0, S2 = 0;\\n        for (int s : stones) S += s;\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[S + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[0][i] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int s = 1; s <= S / 2; s++) {\\n                if (dp[s][i - 1] || (s >= stones[i - 1] && dp[s - stones[i - 1]][i - 1])) {\\n                    dp[s][i] = true;\\n                    S2 = Math.max(S2, s);\\n                }\\n            }\\n        }\\n        return S - 2 * S2;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n\\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n\\ndp[i][j]   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    i ranges from (sum of all elements) {1..n}\\n    j ranges from  {1..n}\\n\\nsame as 494. Target Sum\\n\\n*/\\n\\n\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S = 0, S2 = 0;\\n        for (int s : stones) S += s;\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[S + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[0][i] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int s = 1; s <= S / 2; s++) {\\n                if (dp[s][i - 1] || (s >= stones[i - 1] && dp[s - stones[i - 1]][i - 1])) {\\n                    dp[s][i] = true;\\n                    S2 = Math.max(S2, s);\\n                }\\n            }\\n        }\\n        return S - 2 * S2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653550,
                "title": "trying-to-explain-a-bit-logic-behind-trick",
                "content": "int lastStoneWeightII(vector<int>& stones) {\\n        //let say array be [a,b,c,d]\\n        //answer = (a+b)-(c+d)   OR\\n        //answer = a-(b+c+d)   Or\\n        //answer = (d+b)-(a+c) and so on.. any combination could be possible\\n        //notice that in general I can say that\\n        //answer = S1-S2\\n        //where S1 is sum of some of the numbers and S2 is sum of rest of numbers\\n\\t\\t//also note that S1+S2 = SUM (sum of all numbers)\\n        //S1 >= S2 beacuse negative answer is not possible\\n        //now we have to minimise answer\\n        //answer = SUM - 2*S2 (Just substituting S1 by SUM-S2)\\n        //To minimise answer S2 has to be maximum\\n        //Now, max value of S2 is SUM/2 (bigger than this and answer would be negative which is not possible)\\n        //so the question reduces to find closest sum (sum of numbers) to (SUM/2)\\n        //now this could be understood as subset sum problem or 0/1 knapsack problem\\n        \\n        int sum = 0;\\n        int total = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++) {\\n            total+=stones[i];\\n        }\\n        sum = total/2;\\n        vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n        for(int i =1;i<=n;i++) {\\n            for(int j = 1;j<=sum;j++) {\\n                if(stones[i-1]>j) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-stones[i-1]]+stones[i-1]);\\n                }\\n            }\\n        }\\n        return total-(2*dp[n][sum]);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int lastStoneWeightII(vector<int>& stones) {\\n        //let say array be [a,b,c,d]\\n        //answer = (a+b)-(c+d)   OR\\n        //answer = a-(b+c+d)   Or\\n        //answer = (d+b)-(a+c) and so on.. any combination could be possible\\n        //notice that in general I can say that\\n        //answer = S1-S2\\n        //where S1 is sum of some of the numbers and S2 is sum of rest of numbers\\n\\t\\t//also note that S1+S2 = SUM (sum of all numbers)\\n        //S1 >= S2 beacuse negative answer is not possible\\n        //now we have to minimise answer\\n        //answer = SUM - 2*S2 (Just substituting S1 by SUM-S2)\\n        //To minimise answer S2 has to be maximum\\n        //Now, max value of S2 is SUM/2 (bigger than this and answer would be negative which is not possible)\\n        //so the question reduces to find closest sum (sum of numbers) to (SUM/2)\\n        //now this could be understood as subset sum problem or 0/1 knapsack problem\\n        \\n        int sum = 0;\\n        int total = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++) {\\n            total+=stones[i];\\n        }\\n        sum = total/2;\\n        vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n        for(int i =1;i<=n;i++) {\\n            for(int j = 1;j<=sum;j++) {\\n                if(stones[i-1]>j) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-stones[i-1]]+stones[i-1]);\\n                }\\n            }\\n        }\\n        return total-(2*dp[n][sum]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 294881,
                "title": "another-kind-of-coin-change-problem",
                "content": "same as [494 target sum](https://leetcode.com/problems/target-sum/), it is recommended to look at the description(only description) of the 494 before looking at the following content.\\n\\nfor three number `a1, a2, a3`, according to the order of our choice,\\nthere are `8-2=6` different cases:\\n1. a1 - (a2 - a3) = a1 - a2 + a3\\n2. (a2 - a3) - a1 = -a1 + a2 - a3\\n3. a1 - (a3 - a2) = a1 + a2 - a3\\n4. (a3 - a2) - a1 = -a1 - a2 + a3\\n5. a2 - (a1 - a3) = -a1 + a2 + a3\\n6. (a1 - a3) - a2 = a1 - a2 - a3\\n7. a2 - (a3 - a1) = a1 + a2 - a3   `same as case 3`\\n8. (a3 - a1) - a2 = -a1 - a2 + a3  `same as case 4`\\n9. a3 - (a1 - a2) = -a1 + a2 + a3  `same as case 5`\\n10. (a1 - a2) - a3 = a1 - a2 - a3  `same as case 6`\\n11. a3 - (a2 - a1) = a1 - a2 + a3  `same as case 1`\\n12. (a2 - a1) - a3 = -a1 + a2 - a3 `same as case 2`\\n\\nfor each number, we can add \\'+\\' or \\'-\\' before it. there are totally 2^3 = 8 cases\\nbut it cannot be all positive or all negtive, so it will decrease 2 cases.\\n\\nthe answer is choose some numbers to be positive, others negtive.\\nassume `psum` is the sum of positive number.\\nOur goal is to minimize `psum - (sum(stones)-psum) = 2*psum - sum(stones)`\\n\\n```python\\n# 60ms\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        s = sum(stones)\\n        dp = [0] * (s + 1)\\n        dp[0] = 1\\n        for i in range(len(stones)):\\n            for j in range(len(dp)-1, -1, -1):\\n                if j - stones[i] < 0: break\\n                if dp[j-stones[i]]:\\n                    dp[j] = 1\\n        \\n        res = s + 1\\n        for psum in range(1, s+1):\\n            if dp[psum] and 2*psum-s >= 0:\\n                res = min(res, 2*psum-s)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n# 60ms\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        s = sum(stones)\\n        dp = [0] * (s + 1)\\n        dp[0] = 1\\n        for i in range(len(stones)):\\n            for j in range(len(dp)-1, -1, -1):\\n                if j - stones[i] < 0: break\\n                if dp[j-stones[i]]:\\n                    dp[j] = 1\\n        \\n        res = s + 1\\n        for psum in range(1, s+1):\\n            if dp[psum] and 2*psum-s >= 0:\\n                res = min(res, 2*psum-s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294995,
                "title": "c-4-lines-epic-smash",
                "content": "# Intuition\\nYou can merge stones into 2 giant ones, and do the epic smash.\\n\\nIn other words, you can split all stones into two groups by applying either plus or minus sign to each stone\\'s value.\\n# Top-Down Solution\\nRun DFS tracking the running sum, and try adding and subtracting the current stone. In the end, return the result if it\\'s not negative.\\n\\nUse memoization for the current stone ```[1, 30]``` and running sum ```[-3000, 3000]```.\\n\\nThis can be futher optimized, but the runtime of this solution is already 4 ms.\\n```cpp\\nshort dp[30][6000] = {};\\nint lastStoneWeightII(vector<int>& A, int s = 0, int i = 0) {\\n    if (i == A.size()) \\n        return s < 0 ? 100 : s;\\n    if (dp[i][s + 3000] == 0) \\n        dp[i][s + 3000] = 1 + min(lastStoneWeightII(A, s + A[i], i + 1),\\n            lastStoneWeightII(A, s - A[i], i + 1));\\n    return dp[i][s + 3000] - 1;\\n}\\n```\\n# Bottom-Up Solution\\nWe add/subtract each stone to/from all possible sums achievable after processing previous stones. In the end, we return the smallest absolute value.\\n\\nTo track possible sums, we need to use hash set to avoid duplicates (and TLE). We could also use a byte array, but the code seemed a bit more complicated to me.\\n```cpp\\nint lastStoneWeightII(vector<int>& A) {\\n  unordered_set<int> s1 = { 0 };\\n  for (auto i : A) {\\n    unordered_set<int> s2;\\n    for (auto j : s1) \\n        s2.insert({ j - i, j + i });\\n    swap(s1, s2);\\n  }\\n  return abs(*min_element(begin(s1), end(s1), [](int i, int j) { return abs(i) < abs(j); }));\\n}\\n```",
                "solutionTags": [],
                "code": "```[1, 30]```\n```[-3000, 3000]```\n```cpp\\nshort dp[30][6000] = {};\\nint lastStoneWeightII(vector<int>& A, int s = 0, int i = 0) {\\n    if (i == A.size()) \\n        return s < 0 ? 100 : s;\\n    if (dp[i][s + 3000] == 0) \\n        dp[i][s + 3000] = 1 + min(lastStoneWeightII(A, s + A[i], i + 1),\\n            lastStoneWeightII(A, s - A[i], i + 1));\\n    return dp[i][s + 3000] - 1;\\n}\\n```\n```cpp\\nint lastStoneWeightII(vector<int>& A) {\\n  unordered_set<int> s1 = { 0 };\\n  for (auto i : A) {\\n    unordered_set<int> s2;\\n    for (auto j : s1) \\n        s2.insert({ j - i, j + i });\\n    swap(s1, s2);\\n  }\\n  return abs(*min_element(begin(s1), end(s1), [](int i, int j) { return abs(i) < abs(j); }));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402213,
                "title": "python-solution-based-on-0-1-knapsack",
                "content": "The value of the final rock would be a summation of all values with +/- signs. As we are trying to minimize the size of the final rock, we need to find a partition of numbers in the array into two subsets, which have the least amount of differenc in their summations. \\nWe can reformulate this as a 0-1 Knapsack, i.e. collecting some rocks, where the weights of the rocks is maximized and  their total weight does not exceed half of the total weight of the rocks.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        \\n        Max_weight = int(total/2)\\n        \\n        current = (Max_weight+1)*[0]\\n        \\n        for v in stones:\\n            for w in range(Max_weight, -1, -1):\\n                if w-v>=0:\\n                    current[w] = max(v + current[w-v], current[w])\\n            \\n           \\n        return total-2*current[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        \\n        Max_weight = int(total/2)\\n        \\n        current = (Max_weight+1)*[0]\\n        \\n        for v in stones:\\n            for w in range(Max_weight, -1, -1):\\n                if w-v>=0:\\n                    current[w] = max(v + current[w-v], current[w])\\n            \\n           \\n        return total-2*current[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509493,
                "title": "java-many-solutions",
                "content": "**\\u2714\\uFE0F Solution 1: Bruteforce**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int a : arr) {\\n            HashSet<Integer> set2 = new HashSet<>();\\n            for (int x : set) {\\n                set2.add(x - a);\\n                set2.add(x + a);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int x : set)\\n            min = Math.min(min, Math.abs(x));\\n        return min;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*sum)`\\n- Space: `O(sum)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP Solution**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n`dp[i][j]`   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    `i` ranges from (sum of all elements) `{1..n}`\\n    `j` ranges from  `{1..n}`\\n\\n**DP 1**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        int n = arr.length;\\n        int sum = 0;\\n        for (int a : arr) sum += a;\\n\\n        boolean[][] dp = new boolean[n + 1][sum + 1];\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= arr[i - 1])\\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[n][i]) return sum - i - i;\\n        return 0;\\n    }\\n```\\nComplexity:\\n- Time & Space: `O(n*sum)`\\n\\n**DP 2: Space Optimized**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += a;\\n            for (int i = Math.min(sum, 1500); i >= a; --i) {\\n                dp[i] |= dp[i - a];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[i]) return sum - i - 1;\\n        return 0;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*sum)`\\n- Space: `O(sum)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int a : arr) {\\n            HashSet<Integer> set2 = new HashSet<>();\\n            for (int x : set) {\\n                set2.add(x - a);\\n                set2.add(x + a);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int x : set)\\n            min = Math.min(min, Math.abs(x));\\n        return min;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        int n = arr.length;\\n        int sum = 0;\\n        for (int a : arr) sum += a;\\n\\n        boolean[][] dp = new boolean[n + 1][sum + 1];\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= arr[i - 1])\\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[n][i]) return sum - i - i;\\n        return 0;\\n    }\\n```\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += a;\\n            for (int i = Math.min(sum, 1500); i >= a; --i) {\\n                dp[i] |= dp[i - a];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[i]) return sum - i - 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294932,
                "title": "concise-c-solution-another-way-of-thinking-of-this-problem",
                "content": "The idea is simple, we can transfer this problem to: add `+` and `-` between each number( for the first number, we can consider it as `-n` or `+n`), find the minimum result. we can solve it by using DFS, but it will `TLE`, the complexity will be O(2^n).   \\nwe can use `set` to store all possible results for the first `i` numbers, we can avoid the same results are repeated in `set`, and we use these results to calculate the new possible results with current number. Finally, we find the minimum result in the `set`, note that the negative results should be positive by using `abs`.\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> s = {0};\\n        for(int i = 0; i < stones.size(); ++i) {\\n            int n = stones[i];\\n            auto t = s;\\n            s = {};\\n            for(auto num : t) {\\n                s.insert(num + n);\\n                s.insert(num - n);\\n            }\\n        }\\n        for(auto n : s){\\n            ans = min(ans, abs(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> s = {0};\\n        for(int i = 0; i < stones.size(); ++i) {\\n            int n = stones[i];\\n            auto t = s;\\n            s = {};\\n            for(auto num : t) {\\n                s.insert(num + n);\\n                s.insert(num - n);\\n            }\\n        }\\n        for(auto n : s){\\n            ans = min(ans, abs(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725708,
                "title": "similar-to-minimum-subset-sum-difference-aditya-verma-s-style-recursion-memoization-optimized-dp",
                "content": "##### \\u2728INTUITION: \\n\\n> **for every example, actually certain elements are being added and certain elements are being subtracted\\n    - for eg: 2 7 4 1 8 1 \\n    - => (8-7)  (4-2)  (1-1) lets say in first go we smashed these stones\\n    - => 1 2 0 - in the second go we can smash 2 and 1 and weight of left stone will be 1 which is minimum\\n    - => basically this is equivalent to (8-7) - (4-2) + (1-1) = 8 + 2 + 1 - 7 - 4 - 1\\n    - => 8 + 2 + 1 - 7 - 4 - 1 this is equal to (8, 2, 1) - (7, 4, 1) \\n    - => overall it is equal to dividing the stones array such that their difference is least - which gives us least weight\\n    - therefore, this is exactly similar to minimum subset sum difference problem\\n    - approach: recursion -> memoization -> optimized dp**\\n\\n##### \\uD83C\\uDFAF1. RECURSION: \\n\\n >**recursion: TLE \\uD83E\\uDD72\\n    approach: for every element I have 2 choices, whether to give it \"+\" sign or \"-\" sign\\n    as we can either add that elemnt or subtract it\\n    then we find out by which path we get the minimum answer as we want total sum to be as least as possible\\n    so once we cover all elements we check what is the sum:\\n         => if negative: not possible as remaining stone cannot have negative weight, so we return infinity\\n         => if positive: then we return whatever the currSum was, and then check from which sign we are getting minimum answer**\\n\\t\\t \\n```\\nint lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\\n\\n##### \\uD83C\\uDFAF2. (a) MEMOIZATION (method 1):\\n> **memoization(Aditya Verma\\'s style):  TLE \\uD83E\\uDD72\\n    1. memo matrix\\n    2. just add 2 lines in recursive code that if we find a case which is already pre-computed, then we don\\'t do recursive calls for the same**\\n\\n```\\nint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        if(currSum > 0 && memo[i][currSum] != -1)\\n        {\\n            return memo[i][currSum];\\n        }\\n        if(currSum > 0) return memo[i][currSum] = min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n        else return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\\n\\n##### \\uD83C\\uDFAF2. (b) MEMOIZATION (method 2):\\n> **rather than giving two choices of + and - until last index it would be better if we keep diving the sum into 2 parts and at end return absolute sum\\n> ACCEPTED\\uD83D\\uDC99**\\n    \\n\\tint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int sum1, int sum2)\\n    {\\n        if(i == n)\\n        {\\n            return abs(sum1-sum2);\\n        }\\n        if(memo[i][sum1] != -1)\\n        {\\n            return memo[i][sum1];\\n        }\\n        return memo[i][sum1] = min(lastStoneWeightIIRecursive(stones, n, i+1, sum1 + stones[i], sum2), lastStoneWeightIIRecursive(stones, n, i+1, sum1, sum2 + stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0, 0);\\n        return minWeight;        \\n    }\\n\\t\\n\\t\\n##### \\uD83C\\uDFAF2. (b) OPTIMIZED DP APPROACH (method 2):\\n>**optimized dp approach(aditya verma\\'s style)\\uD83C\\uDF86\\n    => converting recursive code to iterative code**\\n\\t\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        // dp part is exactly same as minimum subset sum difference problem\\n        \\n        bool dp[n + 1][totalSum + 1];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0] = true;\\n        }\\n        for(int j=1; j<totalSum+1; j++)\\n        {\\n            dp[0][j] = false;\\n        }\\n        // filing the matrix\\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<totalSum+1; j++)\\n            {\\n                if(stones[i-1] <= j)\\n                {\\n                    dp[i][j] = ((dp[i-1][j - stones[i-1]]) || dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n        int minWeight = INT_MAX;\\n        \\n\\t    for(int i=totalSum/2; i>=0; i--)\\n\\t    {\\n\\t        if(dp[n][i] == true) \\n\\t        {\\n\\t            minWeight = totalSum - (2*i);\\n\\t            break;\\n\\t        }\\n\\t    }\\n\\t    return minWeight;       \\n   }\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\n```\\nint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        if(currSum > 0 && memo[i][currSum] != -1)\\n        {\\n            return memo[i][currSum];\\n        }\\n        if(currSum > 0) return memo[i][currSum] = min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n        else return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        // dp part is exactly same as minimum subset sum difference problem\\n        \\n        bool dp[n + 1][totalSum + 1];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0] = true;\\n        }\\n        for(int j=1; j<totalSum+1; j++)\\n        {\\n            dp[0][j] = false;\\n        }\\n        // filing the matrix\\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<totalSum+1; j++)\\n            {\\n                if(stones[i-1] <= j)\\n                {\\n                    dp[i][j] = ((dp[i-1][j - stones[i-1]]) || dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n        int minWeight = INT_MAX;\\n        \\n\\t    for(int i=totalSum/2; i>=0; i--)\\n\\t    {\\n\\t        if(dp[n][i] == true) \\n\\t        {\\n\\t            minWeight = totalSum - (2*i);\\n\\t            break;\\n\\t        }\\n\\t    }\\n\\t    return minWeight;       \\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979653,
                "title": "java-clear-explanation-dp",
                "content": "\\n\\n\\n\\n\\n**What the question says**-\"We have a collection of rocks, each rock has a positive integer weight.\\n\\nEach turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\\n\\nIf x == y, both stones are totally destroyed;\\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\\nAt the end, there is at most 1 stone left.  Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)\"\\n\\n **What it actually means** - \"Divide the array into two arrays such that the difference between the sums of the two individual arrays is the minimum\"\\n\\nNow,\\nOur best case scenario would be the case:\\n1>where all elements are same(so we can use the condition 1 in the question (x==y)) and everything cancels out and the answer is simply zero)\\n2>Difference of the sum of two individual arrays is equal to 0.\\n\\n**So our best case answer is 0**\\n\\n*So  , now we will try to reach as close a possible to our best case answer and try to find the array whose sum is totalSum/2(where totalSum is the sum of all array elements).*\\n\\n**One more thing  -\\nLets say S is the sum of all array elements\\nS2 is our nearest sum to S/2 that we can find ,\\nthen , our answer would be S-2*S2(why?)\\nWell because ,S-S2 is simply the sum of the other array , but we need to find the difference between the two individual  arrays.\\nIn other words :\\nS=S1+S2\\nWe need to find S1-S2\\nTherefore we return S-S2-S2, which is nothing but S-2*S2 because S-S2 gives us S1 , and hence again subtracting gives us S1-S2.**\\n\\nThe rest of the logic is pretty simple.\\nWe use DP to find this S2(standard stuff).\\n\\n**dp[i][j] = can sum \\'i\\' be found by using 0 - j-1th elements ?**\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S=0;\\n        for(int i: stones)\\n            S+=i;\\n        int S2=0;\\n        int n=stones.length;\\n        //maximise S2\\n        boolean[][] dp = new boolean[S/2 +1][n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=true;\\n        //zero sum is always possible(just dont take any element in the array)\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int s=1;s<=S/2;s++)\\n            {\\n                if(dp[s][i-1] || (s>=stones[i-1] &&dp[s-stones[i-1]][i-1]))\\n                {\\n                    dp[s][i]=true;\\n                    S2=Math.max(s,S2);\\n                }\\n                \\n            }\\n        }\\n        return S-2*S2;\\n        \\n    }\\n}\\n```\\n\\nHope you understood the logic.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S=0;\\n        for(int i: stones)\\n            S+=i;\\n        int S2=0;\\n        int n=stones.length;\\n        //maximise S2\\n        boolean[][] dp = new boolean[S/2 +1][n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=true;\\n        //zero sum is always possible(just dont take any element in the array)\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int s=1;s<=S/2;s++)\\n            {\\n                if(dp[s][i-1] || (s>=stones[i-1] &&dp[s-stones[i-1]][i-1]))\\n                {\\n                    dp[s][i]=true;\\n                    S2=Math.max(s,S2);\\n                }\\n                \\n            }\\n        }\\n        return S-2*S2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295209,
                "title": "stupidly-easy-python-brute-force-memorization",
                "content": "Idea: Split `S` into two sets `S1` and `S2`, such that difference `|sum(S1) - sum(S2)|` is minimal\\nApproach: Brute Force -> **Too slow** -> Memorization\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:        \\n        mem = {} #Mem\\n        \\n        def explore(a, b, stones):\\n            if len(stones) == 0:\\n                return abs(a-b)\\n            \\n            entry = (a, b, len(stones)) #Mem\\n            if entry in mem:\\n                return mem[entry]\\n            \\n            s = stones.pop()\\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\\n            stones.append(s)\\n            \\n            mem[entry] = m #Mem\\n            return m\\n        \\n        return explore(0, 0, stones)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:        \\n        mem = {} #Mem\\n        \\n        def explore(a, b, stones):\\n            if len(stones) == 0:\\n                return abs(a-b)\\n            \\n            entry = (a, b, len(stones)) #Mem\\n            if entry in mem:\\n                return mem[entry]\\n            \\n            s = stones.pop()\\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\\n            stones.append(s)\\n            \\n            mem[entry] = m #Mem\\n            return m\\n        \\n        return explore(0, 0, stones)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235478,
                "title": "easy-dp-solution-with-full-explanation-in-c",
                "content": "So, if you look the problem carefully you will find this is the problem of minimum subset sum difference, if you can\\'t, I\\'ll show you how. \\nSee the main line is that we have to store the value y-x where y and x are the weights of any two choosen stones. And if the weights are same both the stones will be destroyed, this sums up the problem as we have two divide the array stones in two subsets in such a way that the difference between the sums of the subsets should be minimum.\\n\\nNow in order to solve the minimum subset sum difference problem we have to find two subsets say S1 and S2 but we can write S2 as (Sum-S1) where sum is the sum of all the elements in the array stones. Now our task is to minimise abs(Sum-(2*S1)).\\nIn order to handle the absolute value we will take S2>S1.\\n\\nNow we have to find the values S1 can take and return the max of them in order to min the above equation (as S1 is +ve). In order to do that we will maintain an array dp[n+1][sum+1] and for it\\'s last row if(dp[n][j]==true) we will push the corresponding j value to a vector.\\n\\nAt the end we have to find the max value of the resultant vector say its max.\\nSo return sum-(2*max)\\nHit like if you like my approach :-).\\nAnd here is the simple code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0, n=stones.size();\\n        for(int i=0; i<n; i++){\\n            sum += stones[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(stones[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        vector<int> temp;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true){\\n                temp.push_back(j);\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0; i<temp.size(); i++){\\n            if(temp[i]>max)\\n                max=temp[i];\\n        }\\n        \\n        int res = sum - (2*max);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0, n=stones.size();\\n        for(int i=0; i<n; i++){\\n            sum += stones[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(stones[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        vector<int> temp;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true){\\n                temp.push_back(j);\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0; i<temp.size(); i++){\\n            if(temp[i]>max)\\n                max=temp[i];\\n        }\\n        \\n        int res = sum - (2*max);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246290,
                "title": "c-bottom-up-dp-explanation",
                "content": "```\\n//Concept Used - Minimum Subset Sum Difference\\nint lastStoneWeightII(vector<int>& stones) \\n    {\\n        //1.Mark true for all the possible subset sum\\n        //2.Check for the minimum difference out of all the marked \\n        //elements\\n        int n = stones.size();\\n        int sum = 0; \\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n     \\n        // Create an array to store results of subproblems\\n        bool t[n + 1][sum + 1];\\n     \\n        // Initialize first column as true. 0 sum is possible \\n        // with all elements.\\n        for (int i = 0; i <= n; i++)\\n            t[i][0] = true;\\n     \\n        // Initialize top row, except dp[0][0], as false. With\\n        // 0 elements, no other sum except 0 is possible\\n        for (int i = 1; i <= sum; i++)\\n            t[0][i] = false;\\n     \\n        // Fill the partition table in bottom up manner\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= sum; j++)\\n            {\\n                if (stones[i - 1] <= j)\\n                    t[i][j] = t[i - 1][j - stones[i - 1]] || t[i- 1][j];\\n                else\\n                     t[i][j] = t[i - 1][j];\\n             }\\n        }\\n      \\n        // Initialize difference of two sums. \\n        int diff = INT_MAX;\\n         \\n        // Find the largest j such that dp[n][j]\\n        // is true where j loops from sum/2 t0 0\\n        for (int j = sum/2; j >= 0; j--)\\n        {\\n            //Find the minimum difference\\n            if (t[n][j] == true)\\n              diff = min(diff, sum - 2*j);\\n        }\\n        \\n        return diff;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Concept Used - Minimum Subset Sum Difference\\nint lastStoneWeightII(vector<int>& stones) \\n    {\\n        //1.Mark true for all the possible subset sum\\n        //2.Check for the minimum difference out of all the marked \\n        //elements\\n        int n = stones.size();\\n        int sum = 0; \\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n     \\n        // Create an array to store results of subproblems\\n        bool t[n + 1][sum + 1];\\n     \\n        // Initialize first column as true. 0 sum is possible \\n        // with all elements.\\n        for (int i = 0; i <= n; i++)\\n            t[i][0] = true;\\n     \\n        // Initialize top row, except dp[0][0], as false. With\\n        // 0 elements, no other sum except 0 is possible\\n        for (int i = 1; i <= sum; i++)\\n            t[0][i] = false;\\n     \\n        // Fill the partition table in bottom up manner\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= sum; j++)\\n            {\\n                if (stones[i - 1] <= j)\\n                    t[i][j] = t[i - 1][j - stones[i - 1]] || t[i- 1][j];\\n                else\\n                     t[i][j] = t[i - 1][j];\\n             }\\n        }\\n      \\n        // Initialize difference of two sums. \\n        int diff = INT_MAX;\\n         \\n        // Find the largest j such that dp[n][j]\\n        // is true where j loops from sum/2 t0 0\\n        for (int j = sum/2; j >= 0; j--)\\n        {\\n            //Find the minimum difference\\n            if (t[n][j] == true)\\n              diff = min(diff, sum - 2*j);\\n        }\\n        \\n        return diff;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272897,
                "title": "simple-java-implementation-knapsack",
                "content": "This question can be construed as 0/1 Knapsack problem. We can maintain 2 sacks **sumL** and **sumR**. For every stone we have two choices either we put the stone in sumL or in sumR. Once we have the recursive solution in place, its just a matter of visualising recursive tree to figure out that we are calculating same problem multiple times and can use top down dp with memoization.\\n\\nupvote if you like the solution.\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sumStWt = 0;\\n        for(int stone : stones){\\n            sumStWt += stone;\\n        }\\n        Integer[][] dp = new Integer[stones.length][sumStWt];\\n        return helper(stones, 0, 0, 0, dp);\\n    }\\n    \\n    private int helper(int[] stones, int index, int sumL, int sumR, Integer[][] dp) {\\n        if(index == stones.length){\\n            return Math.abs(sumL - sumR);\\n        }\\n        \\n        if(dp[index][sumL] != null) {\\n            return dp[index][sumL];\\n        }\\n        \\n        dp[index][sumL] = Math.min(helper(stones, index+1, sumL + stones[index], sumR, dp) , helper(stones, index+1, sumL, sumR + stones[index], dp));\\n        return dp[index][sumL];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sumStWt = 0;\\n        for(int stone : stones){\\n            sumStWt += stone;\\n        }\\n        Integer[][] dp = new Integer[stones.length][sumStWt];\\n        return helper(stones, 0, 0, 0, dp);\\n    }\\n    \\n    private int helper(int[] stones, int index, int sumL, int sumR, Integer[][] dp) {\\n        if(index == stones.length){\\n            return Math.abs(sumL - sumR);\\n        }\\n        \\n        if(dp[index][sumL] != null) {\\n            return dp[index][sumL];\\n        }\\n        \\n        dp[index][sumL] = Math.min(helper(stones, index+1, sumL + stones[index], sumR, dp) , helper(stones, index+1, sumL, sumR + stones[index], dp));\\n        return dp[index][sumL];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295063,
                "title": "screencast-of-weekly-contest-137",
                "content": "https://www.youtube.com/watch?v=jSsd3ZhGiSo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=jSsd3ZhGiSo",
                "codeTag": "Unknown"
            },
            {
                "id": 794493,
                "title": "c-recur-memo-bottom-up-dp-using-minimum-subset-difference-concept",
                "content": "This is similar to the problem \"Minimum Subset Difference\"\\ni.e.  Split the array into two subsets (S1, S2), such that absolute difference between \\nsum(S1) and sum(S2) is minimum.\\nNOTE: sum(S1)  = sum of all elements in subset S1\\n\\n```\\n//Approach-1 (Recursion + Memo)\\nclass Solution {\\npublic:\\n    int t[31][5051];\\n    int minDiffSubset(vector<int>& stones, int n, int s1, int sum) {\\n        if(n == 0)\\n            return abs(sum-2*s1);\\n        \\n        if(t[n][s1] != -1)\\n            return t[n][s1];\\n        \\n        return t[n][s1] = min(minDiffSubset(stones, n-1, s1+stones[n-1], sum), //take\\n                              minDiffSubset(stones, n-1, s1, sum));            //don\\'t take\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n   = stones.size();\\n        return minDiffSubset(stones, n, 0, sum);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n\\t\\t//It\\'s not possible to get a subset sum if we have 0 elements\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n\\t\\t\\n\\t\\t//It\\'s always possible to get a subset sum 0 (i.e. empty subset)\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int j = sum/2;\\n        while(j >= 0) {\\n            if(t[n][j])\\n                break;\\n            j--;\\n        }\\n        return sum-2*j;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n = stones.size();\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion + Memo)\\nclass Solution {\\npublic:\\n    int t[31][5051];\\n    int minDiffSubset(vector<int>& stones, int n, int s1, int sum) {\\n        if(n == 0)\\n            return abs(sum-2*s1);\\n        \\n        if(t[n][s1] != -1)\\n            return t[n][s1];\\n        \\n        return t[n][s1] = min(minDiffSubset(stones, n-1, s1+stones[n-1], sum), //take\\n                              minDiffSubset(stones, n-1, s1, sum));            //don\\'t take\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n   = stones.size();\\n        return minDiffSubset(stones, n, 0, sum);\\n    }\\n};\\n```\n```\\n//Approach-2 (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n\\t\\t//It\\'s not possible to get a subset sum if we have 0 elements\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n\\t\\t\\n\\t\\t//It\\'s always possible to get a subset sum 0 (i.e. empty subset)\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int j = sum/2;\\n        while(j >= 0) {\\n            if(t[n][j])\\n                break;\\n            j--;\\n        }\\n        return sum-2*j;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n = stones.size();\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859641,
                "title": "python3-dp-with-extensive-though-process-explanation-and-clean-code",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \"\"\"\\n        Main tricks here are to notice that:\\n        - Given stones = [y1, y2, x1, x2], let\\'s assume we pick y1 - x1 and y2 - x2 in a first pass. \\n        - The new stones array is [y1-x1, y2-x2] assuming that x1 and x2 vanished. Then in the second pass, we do (y1 - x1) - (y2 - x2) to get the final answer. \\n        - Note that we can re-write: (y1 - x1) - (y2 - x2) as (y1 + x2) - (y2 + x1).\\nWe now notice that what we want is two subarrays of stones that have minimum difference between their sums: min(sp1 - sp2)\\n        - Now note that we can write target = sum(stones) = sp1 + sp2. We can further write the min objective min(sp1 - sp2) = min((sp1 + sp2) - (sp2 + sp2)) = min(target - 2*sp2).\\n        - What value of sp2 will minimize this objective? sp2 = target // 2. So if we can partition the initial stones array into two subarrays of equal sum target // 2, then the final answer is the min = 0. \\n        - If this partitioning is not possible, partitioning so that sp2 is as close to target // 2 as possible will do.\\n        - Basically we can re-write the min objective min(target - 2 * sp2) = max(sp2) with constraint sp2 <= target // 2\\n        \"\"\"\\n        target = sum(stones)\\n        dp = [0] * (target // 2 + 1)\\n        \\n        for stonew in stones:\\n            for partition_sum in range(target // 2, 0, -1):\\n                if partition_sum >= stonew:\\n                    dp[partition_sum] = max(dp[partition_sum], dp[partition_sum - stonew] + stonew)\\n                    \\n        return target - 2* dp[target // 2]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \"\"\"\\n        Main tricks here are to notice that:\\n        - Given stones = [y1, y2, x1, x2], let\\'s assume we pick y1 - x1 and y2 - x2 in a first pass. \\n        - The new stones array is [y1-x1, y2-x2] assuming that x1 and x2 vanished. Then in the second pass, we do (y1 - x1) - (y2 - x2) to get the final answer. \\n        - Note that we can re-write: (y1 - x1) - (y2 - x2) as (y1 + x2) - (y2 + x1).\\nWe now notice that what we want is two subarrays of stones that have minimum difference between their sums: min(sp1 - sp2)\\n        - Now note that we can write target = sum(stones) = sp1 + sp2. We can further write the min objective min(sp1 - sp2) = min((sp1 + sp2) - (sp2 + sp2)) = min(target - 2*sp2).\\n        - What value of sp2 will minimize this objective? sp2 = target // 2. So if we can partition the initial stones array into two subarrays of equal sum target // 2, then the final answer is the min = 0. \\n        - If this partitioning is not possible, partitioning so that sp2 is as close to target // 2 as possible will do.\\n        - Basically we can re-write the min objective min(target - 2 * sp2) = max(sp2) with constraint sp2 <= target // 2\\n        \"\"\"\\n        target = sum(stones)\\n        dp = [0] * (target // 2 + 1)\\n        \\n        for stonew in stones:\\n            for partition_sum in range(target // 2, 0, -1):\\n                if partition_sum >= stonew:\\n                    dp[partition_sum] = max(dp[partition_sum], dp[partition_sum - stonew] + stonew)\\n                    \\n        return target - 2* dp[target // 2]",
                "codeTag": "Java"
            },
            {
                "id": 693314,
                "title": "why-won-t-a-greedy-solution-using-a-heap-work",
                "content": "Reading the problem statement, the first thing that came to my mind was to create a MAX heap of stones. Then, in each iteration take out the largest 2 stones and smash them. The result of the smash would be added to the heap.\\n\\nFollowing is the code I implemented. But, it passed for 74 / 82 test cases. The test case for which it failed for-\\n`[31,26,33,21,40]`\\n\\nCan somebody explain me why the greedy solution fails here? More importantly how do you conclude that a certain solution(especially greddy) is correct for the problem.\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int l = stones.size();\\n        if(l==0)return 0;\\n        if(l==1)return stones[0];\\n        \\n        priority_queue<int,vector<int>,less<int>> pq;\\n        for(auto& s:stones)\\n            pq.push(s);\\n        \\n        int a,b;\\n        while(!pq.empty()){\\n            a = pq.top();pq.pop();\\n            if(pq.empty())break;\\n            b = pq.top();pq.pop();\\n            a = a-b;\\n            if(a>0)pq.push(a);\\n        }\\n        return a;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int l = stones.size();\\n        if(l==0)return 0;\\n        if(l==1)return stones[0];\\n        \\n        priority_queue<int,vector<int>,less<int>> pq;\\n        for(auto& s:stones)\\n            pq.push(s);\\n        \\n        int a,b;\\n        while(!pq.empty()){\\n            a = pq.top();pq.pop();\\n            if(pq.empty())break;\\n            b = pq.top();pq.pop();\\n            a = a-b;\\n            if(a>0)pq.push(a);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558188,
                "title": "python-very-simple-recursion-memoization-solution-with-explanation",
                "content": "The secret for this question is in the hint.\\nPicking 2 stones x,y and calculating y-x is the same as summing all stones using positive or negative values (i.e. calculating the sum of every combination of + or - sign for each stone). \\nThis is trivial to solve with backtracking (recursion). Unfortunately, the time complexity is exponential O(2^n) but we can speed it up a bit using memoization.\\n\\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        def dp(i, s): #arguments are stone index and current sum\\n            if i == len(stones): #end of array, return the current sum (abs)\\n                return abs(s)\\n            if (i,s) not in memo:\\n                memo[(i,s)] = min(dp(i+1,s+stones[i]),dp(i+1,s-stones[i])) #try summing or subtracting each stone value\\n            return memo[(i,s)]\\n        \\n        memo = {}\\n        return dp(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        def dp(i, s): #arguments are stone index and current sum\\n            if i == len(stones): #end of array, return the current sum (abs)\\n                return abs(s)\\n            if (i,s) not in memo:\\n                memo[(i,s)] = min(dp(i+1,s+stones[i]),dp(i+1,s-stones[i])) #try summing or subtracting each stone value\\n            return memo[(i,s)]\\n        \\n        memo = {}\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295130,
                "title": "java-iterative",
                "content": "+stones[i] or -stones[i], iterator until all stones has added.\\n\\nFor [1,2,3,6] as example:\\nthe smallest result could be the +1+2+3-6 = 0, we could not only smash 6 since it is the biggest weight.\\nbut it equivalent to -1-2-3+6, which means \\n1.smash (6,1) = 5\\n2.smash((6,1), 2) = 3\\n3.smash(((6,1), 2), 3) = 0\\n\\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(stones[0]);\\n        set.add(-stones[0]);\\n        for(int i=1;i<stones.length;i++){\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int item : set){\\n                set2.add(item + stones[i]);\\n                set2.add(item - stones[i]);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int item : set) min = Math.min(Math.abs(item), min);\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeightII(int[] stones) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(stones[0]);\\n        set.add(-stones[0]);\\n        for(int i=1;i<stones.length;i++){\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int item : set){\\n                set2.add(item + stones[i]);\\n                set2.add(item - stones[i]);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int item : set) min = Math.min(Math.abs(item), min);\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652169,
                "title": "c-recursion-memoization-clean-code",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/432175da-6447-4694-8f49-34187b5b3d22_1664733371.5316546.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int val,vector<int>& st,int n){ \\n\\t\\t\\t\\tif(i==n){\\n\\t\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint pos= st[i]+f(i+1,val+st[i],st,n);\\n\\t\\t\\t\\tint neg= -st[i]+f(i+1,val-st[i],st,n);\\n\\t\\t\\t\\treturn min(pos,neg);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint lastStoneWeightII(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\treturn f(0,0,st,n);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method - 2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/d55483e6-32c0-4d60-9587-872e0bbd083a_1664734339.1050684.png)\\n\\n**T->O(6000 x n) && S->O(6000 x n) + O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int val,vector<int>& st,int n,vector<vector<int>>& dp){ \\n\\t\\t\\tif(i==n){\\n\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][val+3000]!=-1) return dp[i][val+3000];\\n\\t\\t\\tint pos= st[i]+f(i+1,val+st[i],st,n,dp);\\n\\t\\t\\tint neg= -st[i]+f(i+1,val-st[i],st,n,dp);\\n\\t\\t\\treturn dp[i][val+3000]=min(pos,neg);\\n\\t\\t}\\n\\n\\t\\tint lastStoneWeightII(vector<int>& st) {\\n\\t\\t\\tint n=st.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(6000,-1));\\n\\t\\t\\treturn f(0,0,st,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int val,vector<int>& st,int n){ \\n\\t\\t\\t\\tif(i==n){\\n\\t\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1445462,
                "title": "python-dp-memoization-minimumm-subset-sum-difference",
                "content": "This problem can be translated to a minimum subset sum difference problem.\\na.k.a we want to split the stones into two set whoses weight sum difference is minimum.\\n\\nIf we can get a recursive implementation, it is easy to convert to a memoization question.\\nFirst let\\'s get a brute force recursive implementation.\\nEach stone will either add to first set or second set, we need to find all possible ways and get the optimal solution.\\n\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\t\"\"\"\\n\\tTime: O(2^N)\\n\\t\"\"\"\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\t\\t\\n\\t\\t# Each stone will either add to first set or second set. \\n        diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n        diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n\\n        return min(diff_1, diff_2)\\n```\\n\\n\\nNow let\\'s move to second part, translate the recursive code to memoization. \\nWhile most people use memoization to describe this kind of solution, it is basically using a cache.\\n\\n\\nThe idea of memoization is caching.\\nWe need to figure out 3 things\\n1. What\\'s the key and value of cache\\n2. When to set cache key\\n3. When to get cache key\\n\\nIn fact the key will be the method signatures that we pass to the recursive function, and the value the the difference.\\nTherfore we need something like\\n```\\ncache[index][sum1][sum2] = diff\\n```\\n\\nAlthough dp usually use array or multi dimensional arrays, they are just special case of hashmap whose key is integer.\\n\\nWe can simplfiy our cache\\nto \\n```\\ncache[index][sum1#sum2] = diff\\n```\\nor \\n```\\ncache[index#sum1#sum2] = diff\\n```\\n\\n\\nIf we look at the codes below, you can find it how easy to translate a brute force implementaion by using cache.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = [{} for i in range(len(stones) + 1)]  # key: index,  value is another map\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\n        key = str(sum_1)+\\'#\\' + str(sum_2)  # get key\\n\\t\\t\\n        if key not in self.cache[index]:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[index][key] = min(diff_1, diff_2) # set value\\n\\n        return self.cache[index][key]  # get value\\n```\\n\\nor \\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = {}\\n        \\n        return self.recursive(stones, 0, 0, 0)\\n    \\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n        key = str(index) + \\'#\\' + str(sum_1)+\\'#\\'+ str(sum_2)\\n        if  key not in self.cache:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[key] = min(diff_1, diff_2)\\n        \\n        return self.cache[key] \\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\t\"\"\"\\n\\tTime: O(2^N)\\n\\t\"\"\"\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\t\\t\\n\\t\\t# Each stone will either add to first set or second set. \\n        diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n        diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n\\n        return min(diff_1, diff_2)\\n```\n```\\ncache[index][sum1][sum2] = diff\\n```\n```\\ncache[index][sum1#sum2] = diff\\n```\n```\\ncache[index#sum1#sum2] = diff\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = [{} for i in range(len(stones) + 1)]  # key: index,  value is another map\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\n        key = str(sum_1)+\\'#\\' + str(sum_2)  # get key\\n\\t\\t\\n        if key not in self.cache[index]:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[index][key] = min(diff_1, diff_2) # set value\\n\\n        return self.cache[index][key]  # get value\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = {}\\n        \\n        return self.recursive(stones, 0, 0, 0)\\n    \\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n        key = str(index) + \\'#\\' + str(sum_1)+\\'#\\'+ str(sum_2)\\n        if  key not in self.cache:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[key] = min(diff_1, diff_2)\\n        \\n        return self.cache[key] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331314,
                "title": "very-very-simple-explanation-with-easy-proof-and-python3-code",
                "content": "stones = [a,b,c,d]\\n\\nlets assume optimal way to smash stones is first smash d and c, new stones becomes d-c then smash new stone with b, new stone becomes b-**(d-c)** then smash with a, last stone becomes **(b-(d-c))**-a\\n\\nsimplifying equation becomes :\\n(b+c) - (d+a), and we want to minimize this.\\n\\ninstead of previous way lets assume optimal way to smash stones is first smash d and a, new stones becomes d-a, then smash c and b, new stone becomes (c-b) then smash both new stones, last stone becomes (b-c) - (d-a)\\n\\nsimplifying equation becomes :\\n(b+a) - (c+d), and we want to minimize this.\\n\\nso problem essentiantly becomes :-\\n**divide the given set into two subsets such that difference between their sum in minimmum**.\\n\\nwhich is easier to solve.\\n\\n**Approach** : \\n\\nwe have to divide it into two parts, focus on the smaller part (sum wise), just like subset sum problem we will try to find all possible sum we can form for this part, upto sum(stones)//2, because smaller part\\'s sum will not exceed sum(stones)//2.\\n\\nthen optimal sum for this part is that which is closest to sum(stones)//2, and sum for other part is sum(stones) - sum_part_1\\nso ans = sum_part_2 - sum_part_1\\n\\nhere is the **python code** :-\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        req=sum(stones)//2\\n        \\n        dp=[False for i in range(req+1)]\\n        dp[0]=True\\n        \\n        for s in stones:\\n            for i in range(req,-1,-1):\\n                if i-s>=0 and dp[i-s]==True:\\n                    dp[i]=True\\n           \\n        for i in range(req,-1,-1):\\n            if dp[i]==True:\\n                return sum(stones)-2*i\\n            \\n```\\n\\n**Do upvote** if you feel like it, and comment for any doubts. \\nhappy coding :-)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        req=sum(stones)//2\\n        \\n        dp=[False for i in range(req+1)]\\n        dp[0]=True\\n        \\n        for s in stones:\\n            for i in range(req,-1,-1):\\n                if i-s>=0 and dp[i-s]==True:\\n                    dp[i]=True\\n           \\n        for i in range(req,-1,-1):\\n            if dp[i]==True:\\n                return sum(stones)-2*i\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 811106,
                "title": "a-dp-solution-with-1-d-dp-matrix",
                "content": "The question is based on 0-1 Knapsack algorithm. \\n\\nLets divide the whole array into two subarrays *A1* and *A2* such that in each iteration, we choose one element of A1 and another of A2 and perform the operation. \\n\\nImagine that we have [2 , 3, 4, 5] as input.\\nLet A1= [2, 3] and A2 = [4, 5]. \\nThen after two operations, we have\\nA1= [0,0], A2 = [2,2]. \\nNow we subtract one element of A2 from the other to get answer as 0. \\n\\nLets now say that since 4- 2 = 5- 3, if we have to reduce the difference betwen sum of elements in each subarrays after all the operations, thenwe swap 2 with 4 andget A1 = [0,0] and A2 = [0,0] after the two operations.\\n\\nSo our problem reduces to finding two subarrays A1 , A2 (A1 union A2 = A), such that the difference between the sum of elements in A1 and A2 is minimum.\\n\\nS1 = sum of elements in A1\\nS2 = sum of elements in A2\\n\\nS1 + S2 = total sum\\nS2 - S1 = difference\\n\\nsubtracting (2) from (1), \\n2*S1 = total - diff\\nthat is diff = total - 2*S1\\n\\nSince we are seeking the difference which is non-negative, without loss of generality S1<= S2. \\n\\nIn the best case diff = 0 = total - 2* S1\\nSo we iterate from 0 to total/2 and find the maximum sum possible with a subarray of weights.\\n\\ndp[i] represents whether the weight i can be found using some elements of the input array.\\n\\n        int total = 0;\\n        for(auto x: stones){\\n            total += x; \\n        }\\n        \\n        vector<bool> dp(total/2 + 1, false);\\n        dp[0] = true;\\n        \\n        for(auto i : stones){\\n            for(int j = total/2 - i ; j >= 0; j-- ){\\n                if(dp[j]){\\n                    dp[j + i] = true;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        for(int i = 0; i<=total/2 ; i++){\\n            if(dp[i] == true){\\n                ans = i;\\n            }\\n        }\\n        \\n        return total - 2*ans;\\n\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "The question is based on 0-1 Knapsack algorithm. \\n\\nLets divide the whole array into two subarrays *A1* and *A2* such that in each iteration, we choose one element of A1 and another of A2 and perform the operation. \\n\\nImagine that we have [2 , 3, 4, 5] as input.\\nLet A1= [2, 3] and A2 = [4, 5]. \\nThen after two operations, we have\\nA1= [0,0], A2 = [2,2]. \\nNow we subtract one element of A2 from the other to get answer as 0. \\n\\nLets now say that since 4- 2 = 5- 3, if we have to reduce the difference betwen sum of elements in each subarrays after all the operations, thenwe swap 2 with 4 andget A1 = [0,0] and A2 = [0,0] after the two operations.\\n\\nSo our problem reduces to finding two subarrays A1 , A2 (A1 union A2 = A), such that the difference between the sum of elements in A1 and A2 is minimum.\\n\\nS1 = sum of elements in A1\\nS2 = sum of elements in A2\\n\\nS1 + S2 = total sum\\nS2 - S1 = difference\\n\\nsubtracting (2) from (1), \\n2*S1 = total - diff\\nthat is diff = total - 2*S1\\n\\nSince we are seeking the difference which is non-negative, without loss of generality S1<= S2. \\n\\nIn the best case diff = 0 = total - 2* S1\\nSo we iterate from 0 to total/2 and find the maximum sum possible with a subarray of weights.\\n\\ndp[i] represents whether the weight i can be found using some elements of the input array.\\n\\n        int total = 0;\\n        for(auto x: stones){\\n            total += x; \\n        }\\n        \\n        vector<bool> dp(total/2 + 1, false);\\n        dp[0] = true;\\n        \\n        for(auto i : stones){\\n            for(int j = total/2 - i ; j >= 0; j-- ){\\n                if(dp[j]){\\n                    dp[j + i] = true;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        for(int i = 0; i<=total/2 ; i++){\\n            if(dp[i] == true){\\n                ans = i;\\n            }\\n        }\\n        \\n        return total - 2*ans;\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 974638,
                "title": "c-easy-understanding-complete-explanation",
                "content": "```c++\\nint lastStoneWeightII(vector<int>& stones) {\\n    /*\\n        To understand the problem, here is my intuition\\n        Forget about stones colliding, we have numbers and we should put + and - in the right places\\n        to get the minimum number in the end.\\n\\n        What is the minimum number(at the end) possible?\\n        -> 0\\n\\n        What should be the condition to get zero as the end result?\\n        -> let\\'s say we have an array like [1,5,11,5] which can be split into two sets of equal sum\\n            set1 = {5, 5, 1} set2 = {11} sum of both these set is 11 so if we put all \\'-\\' to one of the set\\n            we get 0\\n            5 + 5 + 1 - 11\\n\\n        How is that related to this problem?\\n        -> We are asked to minimize the end result, so if we are able to get two sets with minimum difference\\n           that should give us the result.\\n\\n        How to get the sets?\\n        -> Our end result would be S1 - S2, which is sum of set1 - sum of set2. In the ideal case S1 == S2\\n           The Ideal case would be equal partition and also thing to notice here is, if it is ideal case then\\n            totalSum = 2 * S2 in other terms S2 = totalSum/2;\\n        -> We should try to choose elements whose sum is close to(ideally equal to) totalSum/2.\\n        -> S1 = totalSum - S2; \\n        -> diff = S1 - S2; in other terms diff = totalSum - (2 * S2); diff should be our end result\\n    */\\n\\n    int totalSum = accumulate(stones.begin(), stones.end(), totalSum);\\n    int target = totalSum/2, n = stones.size();\\n\\n    vector<int> dp(target+1, 0);\\n\\n    for(int stone: stones)\\n        for(int j = target; j >=stone; j--)\\n            dp[j] = max(dp[j] , stone + dp[j - stone]);\\n\\n    return totalSum - 2 * dp[target];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nint lastStoneWeightII(vector<int>& stones) {\\n    /*\\n        To understand the problem, here is my intuition\\n        Forget about stones colliding, we have numbers and we should put + and - in the right places\\n        to get the minimum number in the end.\\n\\n        What is the minimum number(at the end) possible?\\n        -> 0\\n\\n        What should be the condition to get zero as the end result?\\n        -> let\\'s say we have an array like [1,5,11,5] which can be split into two sets of equal sum\\n            set1 = {5, 5, 1} set2 = {11} sum of both these set is 11 so if we put all \\'-\\' to one of the set\\n            we get 0\\n            5 + 5 + 1 - 11\\n\\n        How is that related to this problem?\\n        -> We are asked to minimize the end result, so if we are able to get two sets with minimum difference\\n           that should give us the result.\\n\\n        How to get the sets?\\n        -> Our end result would be S1 - S2, which is sum of set1 - sum of set2. In the ideal case S1 == S2\\n           The Ideal case would be equal partition and also thing to notice here is, if it is ideal case then\\n            totalSum = 2 * S2 in other terms S2 = totalSum/2;\\n        -> We should try to choose elements whose sum is close to(ideally equal to) totalSum/2.\\n        -> S1 = totalSum - S2; \\n        -> diff = S1 - S2; in other terms diff = totalSum - (2 * S2); diff should be our end result\\n    */\\n\\n    int totalSum = accumulate(stones.begin(), stones.end(), totalSum);\\n    int target = totalSum/2, n = stones.size();\\n\\n    vector<int> dp(target+1, 0);\\n\\n    for(int stone: stones)\\n        for(int j = target; j >=stone; j--)\\n            dp[j] = max(dp[j] , stone + dp[j - stone]);\\n\\n    return totalSum - 2 * dp[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955251,
                "title": "dp-using-minimum-subset-sum-difference",
                "content": "*         we need to calculate all the possible subsequence sums\\n*         then find the difference between each possible sum to find the minimum difference\\n*         possible sum can be found by (subsequence sum equals a given target)\\n*         possible subsequence sum (s1) and (s2) needs to be found such that absolute difference : |s1 - s2| is minimum\\n*         lets assume s1 < s2 in the range of potential sum results we only consider s1 < totalSum/2 and s2 > totalSum/2\\n*         hence for ex: totalSum = 23; then s1 < 11 and s2 > 11\\n*         so we need to find all s1\\'s such that (totalSum - 2*s1) is minimum\\n\\n```\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        boolean[][] t = subsequenceSum(stones);\\n        final int totalSum = IntStream.of(stones).sum();\\n        final int N = stones.length;\\n        \\n        int diff = Integer.MAX_VALUE;\\n        \\n        int k = 0;\\n        int mid = totalSum/2;\\n        while(k <= mid) {\\n            if( t [ N ] [ k ] ) {\\n                int currDiff = (totalSum - 2*k);\\n                diff = Math.min(diff, (currDiff));\\n            }\\n            k++;\\n        }\\n        return diff;\\n    }\\n    \\n    private boolean[][] subsequenceSum(int[] stones) {\\n        final int totalSum = IntStream.of(stones).sum();\\n        boolean[][] t = new boolean[stones.length+1][totalSum+1];\\n        initialize(t);\\n        \\n        for (int i=1; i<t.length; i++) {\\n            for (int j=1; j<t[0].length; j++) {\\n                if (stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j] || t[i-1][j-(stones[i-1])];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }   \\n        }\\n        return t;\\n    }\\n    \\n    private void initialize(boolean[][] t) {\\n        for (int j = 0; j<t[0].length; j++) {t[0][j] = false;}\\n        for (int i = 0; i<t.length; i++) {t[i][0] = true;}\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        boolean[][] t = subsequenceSum(stones);\\n        final int totalSum = IntStream.of(stones).sum();\\n        final int N = stones.length;\\n        \\n        int diff = Integer.MAX_VALUE;\\n        \\n        int k = 0;\\n        int mid = totalSum/2;\\n        while(k <= mid) {\\n            if( t [ N ] [ k ] ) {\\n                int currDiff = (totalSum - 2*k);\\n                diff = Math.min(diff, (currDiff));\\n            }\\n            k++;\\n        }\\n        return diff;\\n    }\\n    \\n    private boolean[][] subsequenceSum(int[] stones) {\\n        final int totalSum = IntStream.of(stones).sum();\\n        boolean[][] t = new boolean[stones.length+1][totalSum+1];\\n        initialize(t);\\n        \\n        for (int i=1; i<t.length; i++) {\\n            for (int j=1; j<t[0].length; j++) {\\n                if (stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j] || t[i-1][j-(stones[i-1])];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }   \\n        }\\n        return t;\\n    }\\n    \\n    private void initialize(boolean[][] t) {\\n        for (int j = 0; j<t[0].length; j++) {t[0][j] = false;}\\n        for (int i = 0; i<t.length; i++) {t[i][0] = true;}\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 778403,
                "title": "javascript-solution-top-down-approach-with-memoization-and-bottom-up-approach-dp",
                "content": "**Top Down Approach with Memoization**\\n\\n```\\nvar lastStoneWeightII = function(stones) {\\n    const memo = new Map();\\n    return findMinWeight(0, 0, 0);\\n    \\n    function findMinWeight(index, weight1, weight2) {\\n        const key = `${index}#${weight1}#${weight2}`;\\n        \\n        // base case\\n        if (index == stones.length) return Math.abs(weight1 - weight2);\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const currWeight = stones[index];\\n        const min =  Math.min(\\n            findMinWeight(index + 1, weight1 + currWeight, weight2), \\n            findMinWeight(index + 1, weight1, weight2 + currWeight\\n        ));\\n        \\n        memo.set(key, min);\\n        return min;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom Up Approach (DP)**\\n\\n```\\nvar lastStoneWeightII = function(stones) {\\n    const m = stones.length;\\n    \\n    let sum = 0;\\n    \\n    for (const weight of stones) {\\n        sum += weight;\\n    }\\n    \\n    const half = Math.floor(sum / 2);\\n    \\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = new Array(half + 1).fill(false);\\n        dp[i][0] = true;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let i = 1; i <= m; i++) {\\n        const weight = stones[i - 1];\\n        \\n        for (let j = 1; j <= half; j++) {\\n            const rem = j - weight;\\n        \\n            if (rem >= 0 && dp[i - 1][rem] == true) dp[i][j] = true;\\n            else dp[i][j] = dp[i - 1][j];\\n            \\n            if (dp[i][j] == true) max = Math.max(max, j);\\n        }\\n    }\\n    \\n    return sum - (2 * max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar lastStoneWeightII = function(stones) {\\n    const memo = new Map();\\n    return findMinWeight(0, 0, 0);\\n    \\n    function findMinWeight(index, weight1, weight2) {\\n        const key = `${index}#${weight1}#${weight2}`;\\n        \\n        // base case\\n        if (index == stones.length) return Math.abs(weight1 - weight2);\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const currWeight = stones[index];\\n        const min =  Math.min(\\n            findMinWeight(index + 1, weight1 + currWeight, weight2), \\n            findMinWeight(index + 1, weight1, weight2 + currWeight\\n        ));\\n        \\n        memo.set(key, min);\\n        return min;\\n    }\\n};\\n```\n```\\nvar lastStoneWeightII = function(stones) {\\n    const m = stones.length;\\n    \\n    let sum = 0;\\n    \\n    for (const weight of stones) {\\n        sum += weight;\\n    }\\n    \\n    const half = Math.floor(sum / 2);\\n    \\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = new Array(half + 1).fill(false);\\n        dp[i][0] = true;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let i = 1; i <= m; i++) {\\n        const weight = stones[i - 1];\\n        \\n        for (let j = 1; j <= half; j++) {\\n            const rem = j - weight;\\n        \\n            if (rem >= 0 && dp[i - 1][rem] == true) dp[i][j] = true;\\n            else dp[i][j] = dp[i - 1][j];\\n            \\n            if (dp[i][j] == true) max = Math.max(max, j);\\n        }\\n    }\\n    \\n    return sum - (2 * max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612241,
                "title": "c-easy-to-understand-top-down-approach-recursive",
                "content": "```\\n// at every point,  we have two choices it will be -ve or +ve\\nclass Solution {\\n    map<pair<int,int>, int> dp;\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        dp.clear();\\n        return solve(stones, 0, stones.size(), 0);\\n    }\\n    int solve(vector<int>&a, int i, int n, int sum) {\\n        if(i >= n) {\\n            return abs(sum);\\n        }\\n        if(dp.find({i,sum}) != dp.end()) return dp[{i,sum}];\\n        \\n        int ans = INT_MAX;\\n        ans = min(ans, solve(a, i + 1, n , sum - a[i]));\\n        ans = min(ans, solve(a, i + 1, n , sum + a[i]));\\n        return dp[{i,sum}] = ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// at every point,  we have two choices it will be -ve or +ve\\nclass Solution {\\n    map<pair<int,int>, int> dp;\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        dp.clear();\\n        return solve(stones, 0, stones.size(), 0);\\n    }\\n    int solve(vector<int>&a, int i, int n, int sum) {\\n        if(i >= n) {\\n            return abs(sum);\\n        }\\n        if(dp.find({i,sum}) != dp.end()) return dp[{i,sum}];\\n        \\n        int ans = INT_MAX;\\n        ans = min(ans, solve(a, i + 1, n , sum - a[i]));\\n        ans = min(ans, solve(a, i + 1, n , sum + a[i]));\\n        return dp[{i,sum}] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616167,
                "title": "python-make-two-subsets-and-distribute",
                "content": "I looked at each element and added it either to subset 1 ```s1``` or subset 2 ```s2```.\\nWhen the array was exhausted, I return the absolute difference between the two.\\nThe function that called the base-case-hitting function chooses the minimum.\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(idx, s1, s2):\\n            if idx == len(stones):\\n                return abs(s1 - s2)\\n            a = recurse(idx + 1, s1 + stones[idx], s2)\\n            b = recurse(idx + 1, s1, s2 + stones[idx])\\n            return min(a, b)\\n        return recurse(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```s1```\n```s2```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(idx, s1, s2):\\n            if idx == len(stones):\\n                return abs(s1 - s2)\\n            a = recurse(idx + 1, s1 + stones[idx], s2)\\n            b = recurse(idx + 1, s1, s2 + stones[idx])\\n            return min(a, b)\\n        return recurse(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629918,
                "title": "attempt-to-explain-the-dp-solution",
                "content": "The idea is to split the stones into 2 groups such that sum(grp 1)-sum(grp2) is minimum.\\n\\nWHY???\\n\\nsuppose stones are (a b c d)\\n(a>b>c>d)\\nyou break a and b first...\\na-b c d\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nbreak c and d now                                                                                           \\na-b c-d                                                                                                                                                    \\nsuppose a-b>c-d                                                                                            \\nnow break both                                                                                              \\na-b-(c-d)=(a+d)-(b+c)           \\n\\n\\nif u broke in some other order\\n\\na b c d\\na-b c d\\na-b-c d\\na-b-c-d=a-(b+c+d)\\n\\npoint being...in the end final result is basically sum(grp1)-sum(grp2)\\n\\nTo get all possible sums--\\n```\\n        vector<int> dp(3001,0);\\n\\t\\t//getting sum 0 is possible(take no elements)\\n\\t\\tdp[0]=1;\\n        for (int a : A) {\\n            sum+= a;\\n            for (int i = sum; i >= a; --i)\\n\\t\\t\\t//since if sum \\'i-a\\' is possible...sum i is also possible as \\'a\\' i an element..classic dp\\n                dp[i] = dp[i]+dp[i - a];\\n        }\\n```\\nnow idea sum of grp1 is sum/2...so that difference becomes zero...so try from sum/2 to 0 and return the first possible sum found along the way.\\n\\nWHAT TO RETURN???\\n\\nsum of group1=i\\nsum of group 2=sum-i\\nsum(group2)>sum(group1)\\nSOOO return sum-i-i.\\n```\\n\\tfor (int i = sum / 2; i >= 0; --i)\\n\\t{\\n        if (dp[i]) return sum - i - i;\\n    }\\n```\\nHope i could help!\\n\\n",
                "solutionTags": [],
                "code": "```\\n        vector<int> dp(3001,0);\\n\\t\\t//getting sum 0 is possible(take no elements)\\n\\t\\tdp[0]=1;\\n        for (int a : A) {\\n            sum+= a;\\n            for (int i = sum; i >= a; --i)\\n\\t\\t\\t//since if sum \\'i-a\\' is possible...sum i is also possible as \\'a\\' i an element..classic dp\\n                dp[i] = dp[i]+dp[i - a];\\n        }\\n```\n```\\n\\tfor (int i = sum / 2; i >= 0; --i)\\n\\t{\\n        if (dp[i]) return sum - i - i;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305770,
                "title": "c-easy-understanding-solution-recursion-memoization",
                "content": "**this problem is similar as minimum diffrence b/w two partiton of array**\\n```\\nclass Solution {\\npublic:\\n    int dp[31][3001];\\n    int solve(vector<int>& s,int idx,int a,int b)\\n    {\\n        int diff=abs(a-b);\\n        \\n        if(idx==s.size())\\n            return diff ;\\n        \\n        if(dp[idx][diff]!=-1)\\n            return dp[idx][diff];\\n        \\n        int k=min(solve(s,idx+1,a+s[idx],b),solve(s,idx+1,a,b+s[idx]));\\n        \\n        return dp[idx][diff]=k;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(stones,0,0,0);\\n    }\\n};\\n//feel free to ask any doubt in comment section . it\\'s a good problem;\\n//if you like the solution then please upvote it :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[31][3001];\\n    int solve(vector<int>& s,int idx,int a,int b)\\n    {\\n        int diff=abs(a-b);\\n        \\n        if(idx==s.size())\\n            return diff ;\\n        \\n        if(dp[idx][diff]!=-1)\\n            return dp[idx][diff];\\n        \\n        int k=min(solve(s,idx+1,a+s[idx],b),solve(s,idx+1,a,b+s[idx]));\\n        \\n        return dp[idx][diff]=k;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1429005,
                "title": "python-one-dimensional-dp-solution-minimum-subset-difference-0-1-knapsack",
                "content": "A variation of the classical knapsack problem, the idea here is that we have to find a subset such that it\\'s sum is less than or equal to the half of the sum of the entire array. Only then will the difference of the two resulting subsets be minimum. In other words -\\n\\n\\t\\tsum(any_one_subset)  <= sum(given_array)\\n\\t\\t\\nOnce we have found this sum, the answer will simply be the twice of the subset sum subtracted from the total sum. Here\\'s the simple maths -\\n\\t\\t\\n\\t\\tsum(subset1) + sum(subset2) = sum(given_array)\\n\\t\\tsum(subset2) = sum(given_array) - sum(subset1) \\n\\t\\t\\nSo, using this relation - \\n\\t\\t\\n\\t\\t=> ans = sum(subset2) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1)*2 ---------------> ANSWER\\n\\t\\t\\nSo now the problem is reduced to the following statement, how to find a subset such that it\\'s sum is less than or equal to half of the sum of given array? We will use simple knapsack logic, where the total capacity is half of the sum of given array and values of the elements are equal to their corresponding weights, i.e. the values and weights are one and the same thing. Below is the implementation in the form of a one dimensional dp array, hope this was useful!\\t\\n\\t\\n```class Solution(object):\\n    def lastStoneWeightII(self, stones):\\n\\t\\n        req = sum(stones)//2        \\n        dp = [0 for i in range(req+1)]\\n        \\n        for nums in stones:\\n            for w in range(req, nums-1, -1): \\n\\t\\t\\t\\tdp[w] = max(dp[w], dp[w-nums] + nums)\\n                \\n        return sum(stones) - 2*dp[req]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "A variation of the classical knapsack problem, the idea here is that we have to find a subset such that it\\'s sum is less than or equal to the half of the sum of the entire array. Only then will the difference of the two resulting subsets be minimum. In other words -\\n\\n\\t\\tsum(any_one_subset)  <= sum(given_array)\\n\\t\\t\\nOnce we have found this sum, the answer will simply be the twice of the subset sum subtracted from the total sum. Here\\'s the simple maths -\\n\\t\\t\\n\\t\\tsum(subset1) + sum(subset2) = sum(given_array)\\n\\t\\tsum(subset2) = sum(given_array) - sum(subset1) \\n\\t\\t\\nSo, using this relation - \\n\\t\\t\\n\\t\\t=> ans = sum(subset2) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1)*2 ---------------> ANSWER\\n\\t\\t\\nSo now the problem is reduced to the following statement, how to find a subset such that it\\'s sum is less than or equal to half of the sum of given array? We will use simple knapsack logic, where the total capacity is half of the sum of given array and values of the elements are equal to their corresponding weights, i.e. the values and weights are one and the same thing. Below is the implementation in the form of a one dimensional dp array, hope this was useful!\\t\\n\\t\\n```class Solution(object):\\n    def lastStoneWeightII(self, stones):\\n\\t\\n        req = sum(stones)//2        \\n        dp = [0 for i in range(req+1)]\\n        \\n        for nums in stones:\\n            for w in range(req, nums-1, -1): \\n\\t\\t\\t\\tdp[w] = max(dp[w], dp[w-nums] + nums)\\n                \\n        return sum(stones) - 2*dp[req]",
                "codeTag": "Java"
            },
            {
                "id": 1321918,
                "title": "c-knapsack-problem-beat-100-with-explanation",
                "content": "This question equals to partition an array into 2 subsets so that their sum difference is minimum.\\nSuppose given stones array is [a,b,c,d]\\nif we select a and c stone new array=[a-c,b,d]\\nsimilarly array will change to ==> [b-a+c,d]==>[d-b+a-c]==>[(a+d)-(b+c)]==>s1-s2.\\ns1 + s2  = sum, \\ns1 - s2 = difference \\ndifference = s - 2 * s2 \\nminimize difference equals to maximize s2 \\nWe have to find s2 maximum valid value between 0 and s/2.\\n**Using 2d dp array**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<vector<bool>> dp(n+1,vector<bool> (s/2+1,false));\\n        dp[0][0]=true;\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s/2;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j>=stones[i-1]){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```\\n\\n**Using 1d dp array**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<bool> dp(s/2+1,false);\\n        dp[0]=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=s/2;j>=stones[i];j--){\\n                dp[j]=dp[j] || dp[j-stones[i]];\\n                if(dp[j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<vector<bool>> dp(n+1,vector<bool> (s/2+1,false));\\n        dp[0][0]=true;\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s/2;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j>=stones[i-1]){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<bool> dp(s/2+1,false);\\n        dp[0]=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=s/2;j>=stones[i];j--){\\n                dp[j]=dp[j] || dp[j-stones[i]];\\n                if(dp[j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065553,
                "title": "c-dp-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Let\\'s take an example with stones = [a,b,c,d], such that the optimal solution has the following operations:\\n    x = a - b -> stones = [x, c, d]\\n    y = c - d -> stones = [x, y]\\n    z = x - y -> stones = [z], where z is the smallest possible weight.\\n\\n    We can then write the optimal solution z in the following form:\\n    z = x - y = a - b - (c - d) = (a + d) - (b + c)\\n    This leads us to observe that we can write any optimal solution as the difference between two sums. In this case:\\n    X = a + d\\n    Y = b + c\\n    So we have X - Y = z and we also know that X + Y = sum.\\n\\n    We can then say that z = X - Y = sum - Y - Y = sum - 2Y.\\n    So if we want to minimize the solution z, we need to minimize sum - 2Y.\\n\\tThis means Y needs to be as close to sum/2 as possible, without exceeding it.\\n    \\n\\tWe can find a sum Y that satisifies this with dynamic programming.\\n\\tThe solution will then be z = X - Y = sum - 2 * Y.\\n    */\\n    int lastStoneWeightII(vector<int>& stones)\\n    {\\n        int sum = std::accumulate(stones.begin(), stones.end(), 0);\\n        int half = sum / 2;\\n        std::vector<bool> can_reach(half + 1, false);\\n        can_reach[0] = true;\\n         \\n        int max_reached = 0;\\n        for (int stone : stones)\\n        {\\n            for (int i = half; i >= stone; i--)\\n            {\\n                if (!can_reach[i])\\n                {\\n                    can_reach[i] = can_reach[i - stone];\\n                    if (can_reach[i])\\n                        max_reached = max(max_reached, i);\\n                }\\n            }\\n        }\\n\\n        return sum - 2 * max_reached;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Let\\'s take an example with stones = [a,b,c,d], such that the optimal solution has the following operations:\\n    x = a - b -> stones = [x, c, d]\\n    y = c - d -> stones = [x, y]\\n    z = x - y -> stones = [z], where z is the smallest possible weight.\\n\\n    We can then write the optimal solution z in the following form:\\n    z = x - y = a - b - (c - d) = (a + d) - (b + c)\\n    This leads us to observe that we can write any optimal solution as the difference between two sums. In this case:\\n    X = a + d\\n    Y = b + c\\n    So we have X - Y = z and we also know that X + Y = sum.\\n\\n    We can then say that z = X - Y = sum - Y - Y = sum - 2Y.\\n    So if we want to minimize the solution z, we need to minimize sum - 2Y.\\n\\tThis means Y needs to be as close to sum/2 as possible, without exceeding it.\\n    \\n\\tWe can find a sum Y that satisifies this with dynamic programming.\\n\\tThe solution will then be z = X - Y = sum - 2 * Y.\\n    */\\n    int lastStoneWeightII(vector<int>& stones)\\n    {\\n        int sum = std::accumulate(stones.begin(), stones.end(), 0);\\n        int half = sum / 2;\\n        std::vector<bool> can_reach(half + 1, false);\\n        can_reach[0] = true;\\n         \\n        int max_reached = 0;\\n        for (int stone : stones)\\n        {\\n            for (int i = half; i >= stone; i--)\\n            {\\n                if (!can_reach[i])\\n                {\\n                    can_reach[i] = can_reach[i - stone];\\n                    if (can_reach[i])\\n                        max_reached = max(max_reached, i);\\n                }\\n            }\\n        }\\n\\n        return sum - 2 * max_reached;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773257,
                "title": "hopefully-you-understand-my-comments",
                "content": "```\\nclass Solution {\\n    /*\\n    This problem is the same as if we divide the array into two subarrays and find \\n    the min difference of the two sums.\\n    \\n    Two subsets sum:\\n    S1 + S2 = S\\n    \\n    S1 - S2 = diff, we want minimize diff\\n    (S1 + S2 - S2) - S2 = diff\\n    (S1 + S2) - S2 - S2 = diff\\n    S - 2 * S2 = diff\\n    \\n    S is the total sum, and to make diff min, need to make S2 as big as possible\\n    Also, 2 * S2 = S is when diff = 0, so S2 = S / 2, which is the max S2 can be\\n    but not everytime S2 is the same as S/2\\n\\t\\n\\tUse DP like 0/1 knapsack problem,\\n\\tdp[i][j] means from stone 0 to stone i, we could fit them into a bag size of j\\n    \\n    Here is how dp looks like\\n    1 means from stone0 to stone_i, there could fit into a bag of size b_j\\n    It\\'s like 0/1 knapsack problem where stone 0 to stone i can be fit into a bag \\n\\n           0 1 2 3 4 5 ... sum/2  <-- bag size \\n    stone0 1 0 0 0 0 0 ... 0\\n    stone1 1\\n    stone2 1\\n    stone3 1\\n    .\\n    .\\n    .\\n    \\n    dp[i][0] for all i is 1 because all the sub-arrays have a sub-array that has a sum of 0.\\n    \\n    Transition function:\\n    if(dp[i-1][j] == 1) dp[i][j] = 1\\n    This means from stone 0 to stone i-1, if it is a fit, they could fit into a bag of size j\\n    at i as well\\n    \\n    Or\\n    \\n    if current bag size > curr stone && dp[i-1][j - stones[i-1]], then dp[i][j] = 1.\\n    If we decide to use current stone: stones[i-1], then what is the solution\\n    when the bag size is j - stones[i-1] ? And since we used current stone, we\\n    have i - 1 as well. Current stone is stones[i], current bag size is j. Since \\n     i stats at 1, that is why stones[i-1] but not stones[i] as stone starts at 0 index\\n    */\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        int len = stones.length;\\n        for(int s : stones) sum += s;\\n       \\n        int[][] dp = new int[len+1][sum/2+1]; // could also be a boolean matrix\\n        int S2 = 0; // need to max S2\\n        for(int i = 0; i < dp.length; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i = 1; i < dp.length; i++){\\n            for(int j = 1; j < dp[0].length; j++){\\n                if(dp[i-1][j] == 1 || (j >= stones[i-1] && dp[i-1][j-stones[i-1]] == 1)){\\n                    dp[i][j] = 1;\\n                    S2 = Math.max(S2, j);   \\n                }\\n  \\n            }\\n        }\\n      \\n        return sum - 2 * S2; // remember S - 2 * S2 = diff\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    This problem is the same as if we divide the array into two subarrays and find \\n    the min difference of the two sums.\\n    \\n    Two subsets sum:\\n    S1 + S2 = S\\n    \\n    S1 - S2 = diff, we want minimize diff\\n    (S1 + S2 - S2) - S2 = diff\\n    (S1 + S2) - S2 - S2 = diff\\n    S - 2 * S2 = diff\\n    \\n    S is the total sum, and to make diff min, need to make S2 as big as possible\\n    Also, 2 * S2 = S is when diff = 0, so S2 = S / 2, which is the max S2 can be\\n    but not everytime S2 is the same as S/2\\n\\t\\n\\tUse DP like 0/1 knapsack problem,\\n\\tdp[i][j] means from stone 0 to stone i, we could fit them into a bag size of j\\n    \\n    Here is how dp looks like\\n    1 means from stone0 to stone_i, there could fit into a bag of size b_j\\n    It\\'s like 0/1 knapsack problem where stone 0 to stone i can be fit into a bag \\n\\n           0 1 2 3 4 5 ... sum/2  <-- bag size \\n    stone0 1 0 0 0 0 0 ... 0\\n    stone1 1\\n    stone2 1\\n    stone3 1\\n    .\\n    .\\n    .\\n    \\n    dp[i][0] for all i is 1 because all the sub-arrays have a sub-array that has a sum of 0.\\n    \\n    Transition function:\\n    if(dp[i-1][j] == 1) dp[i][j] = 1\\n    This means from stone 0 to stone i-1, if it is a fit, they could fit into a bag of size j\\n    at i as well\\n    \\n    Or\\n    \\n    if current bag size > curr stone && dp[i-1][j - stones[i-1]], then dp[i][j] = 1.\\n    If we decide to use current stone: stones[i-1], then what is the solution\\n    when the bag size is j - stones[i-1] ? And since we used current stone, we\\n    have i - 1 as well. Current stone is stones[i], current bag size is j. Since \\n     i stats at 1, that is why stones[i-1] but not stones[i] as stone starts at 0 index\\n    */\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        int len = stones.length;\\n        for(int s : stones) sum += s;\\n       \\n        int[][] dp = new int[len+1][sum/2+1]; // could also be a boolean matrix\\n        int S2 = 0; // need to max S2\\n        for(int i = 0; i < dp.length; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i = 1; i < dp.length; i++){\\n            for(int j = 1; j < dp[0].length; j++){\\n                if(dp[i-1][j] == 1 || (j >= stones[i-1] && dp[i-1][j-stones[i-1]] == 1)){\\n                    dp[i][j] = 1;\\n                    S2 = Math.max(S2, j);   \\n                }\\n  \\n            }\\n        }\\n      \\n        return sum - 2 * S2; // remember S - 2 * S2 = diff\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296441,
                "title": "simple-and-easy-to-understand-dp-solution-with-explanation-494-target-sum",
                "content": "Thanks a lot for some hint from the thread, I finally managed to AC this problem, and it is also my first time AC with harder 2D dp problem.\\n* Thought: This is equal to: partition the array into 2 independent set and try to minimize |sum_set1 - sum_set2|\\n\\t* Step 1. Build a dp array with row being the stones using [0, n] and col being all the possible sum. i.e. dp[i][j]\\nis true if we can use up to i stones making the subset sum up to j\\n\\t* Step 2. Iterate throught the DP array, and check if\\n\\t\\t* Type 1. The w of current stone already exceeds (>) the sum up to j, then we should exclude this stone, dp[i][j] = dp[i - 1][j]\\n\\t\\t* Type 2. Otherwise (<=) We can either use this stone, then we may query the position at [i][j - stones[i - 1]] to see if previously the weight sum of j - stones[i - 1] can be achieved, OR we do not use this one, and merely the stones from 0 to i - 1 already satisfies, so answer will be dp[i-1][j] || dp[i - 1][j - stones[i - 1]]\\n\\t* Step 3. If we want to minimize the difference, then the sum of 2 subsets (ans = sum_set1 - (sum - sum_set1)) should be as close as possible. Hence we iterate the last row starting from **sum / 2** to see if dp[i][j] is true and update the answer if answer  >= 0\\n```cpp\\nclass Solution {\\n    public:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n = stones.size();\\n        if(n == 1)\\n        {\\n            return stones[0];\\n        }\\n        \\n        bool dp[102][30002] = {0}; // Step 1.\\n        int res = INT_MAX, sum = 0;\\n        for(int i = 0; i <= n; i++) // Step 1.\\n        {\\n            dp[i][0] = 1;\\n            if(i < n)\\n            {\\n                sum += stones[i];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) // Step 2.\\n        {\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < stones[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j]; // S2 Type 1\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - stones[i - 1]]; // S2 Type 2\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int j = sum / 2; j <= sum; j++) // Step 3.\\n        {\\n            if(2 * j - sum >= 0 && dp[n][j])\\n            {\\n                res = min(res, 2 * j - sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd here also comes the solution for [494. Target Sum](https://leetcode.com/problems/target-sum/)\\n```cpp\\nclass Solution {\\n    public:\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        \\n        if(n == 1)\\n        {\\n            return nums[0] == abs(target) ? 1 : 0;\\n        }\\n        \\n        int dp[21][1001] = {0};\\n        int res = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            dp[i][0] = nums[i - 1] == 0 ? 1 << i : dp[i - 1][0];\\n            sum += nums[i - 1];\\n        }\\n\\n        for(int i = 1; i <= n; i++) \\n\\t\\t{\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < nums[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n        \\n        for(int j = 0; j <= sum; j++)\\n        {\\n            if(j * 2 - sum == target && dp[n][j])\\n            {\\n                res = dp[n][j];\\n\\t\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlthough the code may seems tedious and not efficient, it is my first time solved the problem by myself without asking anyone, only query some information from CLRS book, I will keep bettering myself :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n = stones.size();\\n        if(n == 1)\\n        {\\n            return stones[0];\\n        }\\n        \\n        bool dp[102][30002] = {0}; // Step 1.\\n        int res = INT_MAX, sum = 0;\\n        for(int i = 0; i <= n; i++) // Step 1.\\n        {\\n            dp[i][0] = 1;\\n            if(i < n)\\n            {\\n                sum += stones[i];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) // Step 2.\\n        {\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < stones[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j]; // S2 Type 1\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - stones[i - 1]]; // S2 Type 2\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int j = sum / 2; j <= sum; j++) // Step 3.\\n        {\\n            if(2 * j - sum >= 0 && dp[n][j])\\n            {\\n                res = min(res, 2 * j - sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    public:\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        \\n        if(n == 1)\\n        {\\n            return nums[0] == abs(target) ? 1 : 0;\\n        }\\n        \\n        int dp[21][1001] = {0};\\n        int res = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            dp[i][0] = nums[i - 1] == 0 ? 1 << i : dp[i - 1][0];\\n            sum += nums[i - 1];\\n        }\\n\\n        for(int i = 1; i <= n; i++) \\n\\t\\t{\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < nums[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n        \\n        for(int j = 0; j <= sum; j++)\\n        {\\n            if(j * 2 - sum == target && dp[n][j])\\n            {\\n                res = dp[n][j];\\n\\t\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050237,
                "title": "python-tired-of-it-me-too",
                "content": "There are three steps to see the solution:\\n* first, the problem reduces to creating two mega-stones (credits to @votrubac) between which we have the minimum weight difference. Creating them translates to the formation of two sets.\\n* then, in an ideal scenario, two stones of the same weight would result in a zero weight upon smashing. Great! Our purpose is to create two stones of roughly half the total weight.\\n* next, chasing half the total weight is the same as stealing as much as you can when you know you have half of a backpack. \\n\\nSo, in a sense, it becomes the 0/1 knapsack, but a little different. \\n\\nPresumably, you know a version of the Knapsack, and there was this idea of ***whether stealing the ith item would increase the final profit***. So, it should be the same, but with a subtle twist. We translate the question from Knapsack\\'s problem to ***whether we should add the ith stone to the current mega-stone or not***. \\n\\nThe difference that could drive you crazy is that we are not maximizing the profit. Nor are we minimizing the difference between some current weights and the half. \\n\\nWe are simply deciding ***whether a capacity could be reached with or without the ith stone***. Why? Because after that, we will look for the maximum capacity that could be reached in the interval 1 to half of the total weights. If it is precisely half of the total weight, it would be wonderful. Now, think of this. For the 0/1 knapsack, the capacity was there for us to wonder if we could somehow maximize the profit given this new volume. Unfortunately, it is not the thing here.\\n\\n### Start small, O(2^n) time\\n\\nIn the following code snippet, you can see the idea of maximizing the profit for Knapsack. It also depicts the idea of whether you want to use item i, or you don\\'t. That\\'s denoted by `with_i` and `without_i`.\\n```\\ndef og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```\\n\\nExample:\\n```\\nvalues = [60, 100, 120]\\nweights = [10, 20, 30]\\nT = 50 \\n```\\n\\nDetails:\\n* **n is the number of items**\\n* **k(n, T)** is a shortcut for og_knapsack\\n* **wi** is a shortcut for ith weight\\n* **cap** is a shortcut for the current capacity\\n* **T is the total capacity**\\n\\n![image](https://assets.leetcode.com/users/images/628835e3-d7ce-4988-a4b1-8c3b74e791f6_1652860271.2631743.png)\\n\\nGreen dots denote that we want the ith item, while the red ones that we do not. The yellow ones are for the case where T became 0, so whether we want an item or we do not want it, it does not matter because the backpack is packed.\\n\\n### Improve to O(nT) time\\n\\nGreat Alex, but why can\\'t we stop here and call it a day? Because the `og_knapsack()` has a time complexity of O(2^n). Yikes, not great for 150 stones, right? \\n\\nWe use a matrix `M` to store intermediary results. This matrix is the key to solving this problem in under 2^150 stones. \\n\\n```\\ndef knapsack(values, weights, T):\\n    \\'\\'\\' Dynamic with O(n*T) time and space. \\'\\'\\'\\n    n = len(weights)\\n    M = [[0 for x in range(T + 1)] for y in range(n + 1)]\\n\\n    for wi in range(n+1):\\n        for cap in range(T+1):\\n            if wi == 0 or cap == 0:\\n                continue\\n            if weights[wi - 1] > cap:\\n                M[wi][cap] = M[wi - 1][cap]\\n            else:\\n                with_wi = values[wi - 1] + M[wi - 1][cap - weights[wi - 1]]\\n                without_wi = M[wi - 1][cap]\\n                M[wi][cap] = max(with_wi, without_wi)\\n\\n    return M[n][T]\\n```\\n\\n## Adapt the O(nT) to the problem of the stones\\n\\nThe adaption is the solution to another problem - the minimum difference between subsets.\\n\\nDetails:\\n* **si** is a shortcut for ith stone weight\\n* **cap** is a shortcut for the current capacity\\n\\n```\\ndef solution(stones):\\n\\tT = sum(stones)\\n\\tH = T // 2\\n\\n\\tn = len(stones)\\n\\tM = [[False for _ in range(H+1)] for _ in range(n+1)]\\n\\tfor i in range(n+1):\\n\\t\\tM[i][0] = True\\n\\n\\tfor si in range(1, n+1):\\n\\t\\tfor cap in range(1, H+1):\\n\\t\\t\\tif si == 0 or cap == 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif stones[si-1] > cap:\\n\\t\\t\\t\\tM[si][cap] = M[si-1][cap]\\n\\t\\t\\telse:\\n\\t\\t\\t\\twithout_si = M[si-1][cap - stones[si-1]]\\n\\t\\t\\t\\twith_si = M[si-1][cap]\\n\\t\\t\\t\\tM[si][cap] = with_si | without_si\\n\\n\\tmax_cap, cap = H, 0 \\n\\twhile max_cap >= 0:\\n\\t\\tif M[n][max_cap] == True:\\n\\t\\t\\tcap = max_cap \\n\\t\\t\\tbreak\\n\\t\\tmax_cap -= 1\\n\\n\\treturn T - 2 * max_cap\\n```\\n\\nLook over the following example:\\n```\\nstones = [2, 1, 3, 7]\\n```\\n\\nDetails:\\n* the columns represent possible capacities up to half the weight of the stones (13 total, 6 half)\\n* the rows are the indexes of the stones\\n* M[si][cap] represents whether for `1 to si` there is a posibility to sum to exactly `cap`\\n\\n![image](https://assets.leetcode.com/users/images/ff7064cc-0a64-4ed8-801f-2d30feb81edf_1652863034.9182944.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```\n```\\nvalues = [60, 100, 120]\\nweights = [10, 20, 30]\\nT = 50 \\n```\n```\\ndef knapsack(values, weights, T):\\n    \\'\\'\\' Dynamic with O(n*T) time and space. \\'\\'\\'\\n    n = len(weights)\\n    M = [[0 for x in range(T + 1)] for y in range(n + 1)]\\n\\n    for wi in range(n+1):\\n        for cap in range(T+1):\\n            if wi == 0 or cap == 0:\\n                continue\\n            if weights[wi - 1] > cap:\\n                M[wi][cap] = M[wi - 1][cap]\\n            else:\\n                with_wi = values[wi - 1] + M[wi - 1][cap - weights[wi - 1]]\\n                without_wi = M[wi - 1][cap]\\n                M[wi][cap] = max(with_wi, without_wi)\\n\\n    return M[n][T]\\n```\n```\\ndef solution(stones):\\n\\tT = sum(stones)\\n\\tH = T // 2\\n\\n\\tn = len(stones)\\n\\tM = [[False for _ in range(H+1)] for _ in range(n+1)]\\n\\tfor i in range(n+1):\\n\\t\\tM[i][0] = True\\n\\n\\tfor si in range(1, n+1):\\n\\t\\tfor cap in range(1, H+1):\\n\\t\\t\\tif si == 0 or cap == 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif stones[si-1] > cap:\\n\\t\\t\\t\\tM[si][cap] = M[si-1][cap]\\n\\t\\t\\telse:\\n\\t\\t\\t\\twithout_si = M[si-1][cap - stones[si-1]]\\n\\t\\t\\t\\twith_si = M[si-1][cap]\\n\\t\\t\\t\\tM[si][cap] = with_si | without_si\\n\\n\\tmax_cap, cap = H, 0 \\n\\twhile max_cap >= 0:\\n\\t\\tif M[n][max_cap] == True:\\n\\t\\t\\tcap = max_cap \\n\\t\\t\\tbreak\\n\\t\\tmax_cap -= 1\\n\\n\\treturn T - 2 * max_cap\\n```\n```\\nstones = [2, 1, 3, 7]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1597401,
                "title": "java-with-comments-knapsack-dp",
                "content": "```\\n public int lastStoneWeightII(int[] stones) {\\n        //sack: capacity of stones\\n        int sack = Arrays.stream(stones).sum();\\n        // sack2: half the capacity\\n        // to minize the difference betwen two sacks (e.g. sack - 2*sack2 )\\n        int sack2 = sack/2;\\n        //since it\\'s NOT un-bounded sack will use 2D matrix to avoid repetition \\n        //usually 1D array is used when repetition is allowed\\n        //(e.g. coin change problem with infinite coin sources)\\n        //There is another trick, where we can avoid this 2D array, for simplicity let\\'s stick with it\\n        int[][]dp = new int[stones.length+1][sack2+1];\\n        for(int r=1; r<dp.length; r++) {\\n            for(int c=1 ; c< dp[0].length; c++) {\\n                // in all the cases this value will be considered\\n                // an element just above current cell\\n                dp[r][c] = dp[r-1][c];\\n                //ans will be effected only when stone weight>=c\\n                //c: sum so far\\n                if(c>=stones[r-1]) {\\n                    //remaining weight after current stone is used\\n                    int remaining = c-stones[r-1];\\n                    //if current stone is used\\n                    //go to previous row and fetch value of remaining val                \\n                    int currentPlusRemaining = dp[r-1][remaining] + stones[r-1];\\n                    int valueWithoutCurrent = dp[r-1][c];\\n                    dp[r][c] = Math.max(currentPlusRemaining, valueWithoutCurrent);                    \\n                }\\n            }\\n        }\\n        // stack: full sum\\n        // dp[dp.length-1][dp[0].length-1]): half the stack\\n        \\n        return sack - (2*dp[dp.length-1][dp[0].length-1]);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int lastStoneWeightII(int[] stones) {\\n        //sack: capacity of stones\\n        int sack = Arrays.stream(stones).sum();\\n        // sack2: half the capacity\\n        // to minize the difference betwen two sacks (e.g. sack - 2*sack2 )\\n        int sack2 = sack/2;\\n        //since it\\'s NOT un-bounded sack will use 2D matrix to avoid repetition \\n        //usually 1D array is used when repetition is allowed\\n        //(e.g. coin change problem with infinite coin sources)\\n        //There is another trick, where we can avoid this 2D array, for simplicity let\\'s stick with it\\n        int[][]dp = new int[stones.length+1][sack2+1];\\n        for(int r=1; r<dp.length; r++) {\\n            for(int c=1 ; c< dp[0].length; c++) {\\n                // in all the cases this value will be considered\\n                // an element just above current cell\\n                dp[r][c] = dp[r-1][c];\\n                //ans will be effected only when stone weight>=c\\n                //c: sum so far\\n                if(c>=stones[r-1]) {\\n                    //remaining weight after current stone is used\\n                    int remaining = c-stones[r-1];\\n                    //if current stone is used\\n                    //go to previous row and fetch value of remaining val                \\n                    int currentPlusRemaining = dp[r-1][remaining] + stones[r-1];\\n                    int valueWithoutCurrent = dp[r-1][c];\\n                    dp[r][c] = Math.max(currentPlusRemaining, valueWithoutCurrent);                    \\n                }\\n            }\\n        }\\n        // stack: full sum\\n        // dp[dp.length-1][dp[0].length-1]): half the stack\\n        \\n        return sack - (2*dp[dp.length-1][dp[0].length-1]);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430241,
                "title": "cpp-bottom-up-dp-explained-using-subset-sum-variation-of-0-1-knapsack",
                "content": "Approach: This is a very basic question of 0-1 Knapsack and is direct implementation of Subset Sum using Dynamic Programming.\\n\\nExplanation : Basically we are trying to convert this problem into Subset Sum which can easily be solved using DP. First we calculate the range of the stones array.\\n\\n![image](https://assets.leetcode.com/users/images/d6c15435-8c55-45bf-9c39-6e7f4f271929_1630132814.121952.png)\\n\\nRange = summation of all elements of array.\\n\\nWe calculate the range to then reduce the number of dependencies from 2 to 1 i.e. first there were two parameters Subset 1 and Subset 2 and after calculating the range for the same, we can then reduce the dependency from 2 to 1 because other subset sum can be calculated by subtracting the first one from the range.\\n\\nThen we apply the standard subset sum rules to 2D grid that we create to solve the problem in which we declare the first column with true and the first row with false.\\n\\nThen we simply calculate the subset sum.\\n\\nWe then check in the last row from right to left from mid searching for true. First index to give us true ( row-wise ) will be the correct ans i.e. Subset Sum1 and we can simply calculate the final ans as :\\n\\n``` Range - ( 2* index) ```\\n\\nhere index is the index on which we got ``` true```\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int range = 0 ;\\n        \\n        for(int ctr = 0 ; ctr < stones.size() ; ctr++)\\n            range+=stones[ctr];\\n        \\n        bool dp[stones.size()+1][range/2+1];\\n        \\n        for(int ctr = 0 ; ctr <= stones.size() ; ctr++)\\n            dp[ctr][0] = true;\\n        \\n        for(int ctr = 1 ; ctr <= range/2 ; ctr++)\\n            dp[0][ctr] = false;\\n        \\n        for(int row = 1 ; row <= stones.size() ; row++)\\n            for(int col = 1 ; col <= range/2 ; col ++)\\n            {\\n                if(stones[row-1]<=col)\\n                {\\n                    dp[row][col] = dp[row-1][col] || dp[row-1][col-stones[row-1]];\\n                }\\n                else\\n                {\\n                    dp[row][col] = dp[row-1][col];\\n                }\\n            }\\n        \\n        for(int ctr = range/2 ; ctr >= 0 ; ctr --)\\n        {\\n            if(dp[stones.size()][ctr] == true)\\n            {\\n                return abs(range - (2*ctr));\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nPS : This is the best code but still if you think that there is a better alternative than this then feel free to share in the comments. Thanks in advance for help \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` Range - ( 2* index) ```\n``` true```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int range = 0 ;\\n        \\n        for(int ctr = 0 ; ctr < stones.size() ; ctr++)\\n            range+=stones[ctr];\\n        \\n        bool dp[stones.size()+1][range/2+1];\\n        \\n        for(int ctr = 0 ; ctr <= stones.size() ; ctr++)\\n            dp[ctr][0] = true;\\n        \\n        for(int ctr = 1 ; ctr <= range/2 ; ctr++)\\n            dp[0][ctr] = false;\\n        \\n        for(int row = 1 ; row <= stones.size() ; row++)\\n            for(int col = 1 ; col <= range/2 ; col ++)\\n            {\\n                if(stones[row-1]<=col)\\n                {\\n                    dp[row][col] = dp[row-1][col] || dp[row-1][col-stones[row-1]];\\n                }\\n                else\\n                {\\n                    dp[row][col] = dp[row-1][col];\\n                }\\n            }\\n        \\n        for(int ctr = range/2 ; ctr >= 0 ; ctr --)\\n        {\\n            if(dp[stones.size()][ctr] == true)\\n            {\\n                return abs(range - (2*ctr));\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162871,
                "title": "java-0-1-knapsack-dp-coin-change-explanation",
                "content": "**Idea**\\n\\n* Divide the weights into two groups and minimize the difference between those two groups.\\n* Try to maximize weight in a group with capacity `sum(stones) / 2`\\n\\nWith the above idea, the problem reduces to [322. Coin Change](https://leetcode.com/problems/coin-change/).\\n\\n**Why Knapsack?**\\n\\nKnapsack problem:\\n\\n* Given a maximum weight capacity\\n* Given item weights\\n* Given item values\\n* Maximize the values while ensuring items\\' weights sum to below the capacity\\n\\n\\n**DP recurrence**\\n\\nLet dp(i, j) be the maximum sum of weights when considering stones[0] ... stones[i - 1] with capacity j.\\n\\n`dp(i, j) = max(dp(i-1, j), dp(i-1, j - stones[i - 1]) + stones[i - 1])`\\n\\nAnother ways to think about the above is: maximum \\'value\\' between two cases:\\n\\n1. not picking the current stone at all, \\n2. picking the current stone\\n\\nActually, this recurrence is similar to that of [322. Coin Change](https://leetcode.com/problems/coin-change/):\\n\\n`dp(i, j) = min(dp(i-1, j), dp(i - 1, j - stones[i - 1]) + 1`\\n\\nThe difference is that, in that problem, we are taking the *minimum* of *number of coins*. Hence we used `min` and `+ 1` as the addition to the value.\\n\\n**Code**\\n\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = addAll(stones);\\n        int halfSum = sum / 2;\\n\\n        int[] dp = new int[halfSum + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = halfSum; j >= stones[i-1]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - stones[i-1]] + stones[i-1]);\\n            }\\n        }\\n\\n        return sum - 2 * dp[halfSum];\\n    }\\n\\n    private int addAll(int[] arr) {\\n        int ret = 0;\\n\\n        for (int num : arr) {\\n            ret += num;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```\\n\\n**Analysis**\\n\\nLet N = |stones|, M = sum of the stone weights\\n\\n* Time complexity: ~O(NM)\\n* Space complexity: ~O(M)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = addAll(stones);\\n        int halfSum = sum / 2;\\n\\n        int[] dp = new int[halfSum + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = halfSum; j >= stones[i-1]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - stones[i-1]] + stones[i-1]);\\n            }\\n        }\\n\\n        return sum - 2 * dp[halfSum];\\n    }\\n\\n    private int addAll(int[] arr) {\\n        int ret = 0;\\n\\n        for (int num : arr) {\\n            ret += num;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938051,
                "title": "java-recursion-memoisation-intuitive-solution-with-explanation",
                "content": "You have the find the minValue that can be retrieved after combining all the stones.\\n\\n**How can you combine the stones ?**\\nSo basically you need to divide the contents of the array into two subgroups such that the difference of Sum of value of group1 and sumOf values of group2 is min.\\n\\nsuppose you have 5 elements in the array : a1, a2 , a3, a4, a5\\n\\nyou have created the two sub groups\\n\\n{a1,a2,a4}        and    {a3,a5}\\n\\nAnswer will be the difference of these subGroup: \\n\\n```\\nminDifference = abs ( a1+a2+a4 - a3 -a5)\\n```\\n\\nwith you look care fully basically you need to find the min of the above equation. => each element can be added as +a or -a \\nint the final computation and the absolute value of that needs to be minimised.\\n\\n\\n\\nApproach : \\nstart dfs from start index, and for each node the next possible value can be +a or -a and the sum from that will be absolute value of existing sum+a or existing sum -a.\\n\\n\\n```\\nclass Solution {\\n    public HashMap<String,Integer> cache ;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return dfs(nums,target,0,0);\\n    }\\n    \\n    HashMap<String,Integer> cache;\\n    public int lastStoneWeightII(int[] stones) {\\n        cache = new HashMap<>();\\n        return dfs(0,0,stones);\\n    }\\n    \\n    public int dfs(int index, int sum , int[] stones) {\\n        String key = index+\",\"+sum;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        if(index== stones.length) {\\n            return sum;\\n        }\\n        int currentValue = stones[index];\\n        int left = dfs(index+1,sum+currentValue,stones);\\n        int right = dfs(index+1,Math.abs(sum-currentValue),stones);\\n        int result = Math.min(left,right);\\n        cache.put(key,result);\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nminDifference = abs ( a1+a2+a4 - a3 -a5)\\n```\n```\\nclass Solution {\\n    public HashMap<String,Integer> cache ;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return dfs(nums,target,0,0);\\n    }\\n    \\n    HashMap<String,Integer> cache;\\n    public int lastStoneWeightII(int[] stones) {\\n        cache = new HashMap<>();\\n        return dfs(0,0,stones);\\n    }\\n    \\n    public int dfs(int index, int sum , int[] stones) {\\n        String key = index+\",\"+sum;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        if(index== stones.length) {\\n            return sum;\\n        }\\n        int currentValue = stones[index];\\n        int left = dfs(index+1,sum+currentValue,stones);\\n        int right = dfs(index+1,Math.abs(sum-currentValue),stones);\\n        int result = Math.min(left,right);\\n        cache.put(key,result);\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430221,
                "title": "cpp-dp-concise-bottom-up-approach-0ms",
                "content": "This is a classic knapsack minimum subset sum difference  problem. Just check for the maximum possible sum we can get from stones vector in between 0  and sum of stones / 2.\\n    \\n\\n```\\nclass Solution {\\npublic:\\n   \\n    bool subsetSum(vector<int>& stones, int sum, vector<vector<bool>> &dp)\\n    {\\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= sum; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= sum; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        return dp[stones.size()][sum];\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        vector<vector<bool>> dp(stones.size() + 1, vector<bool>(range / 2 + 1, false));\\n        \\n       subsetSum(stones, range / 2, dp);\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[dp.size() - 1][idx] == true)  return abs(range - (2 * idx));\\n\\n        return 0; \\n    }\\n};\\n```\\n\\nThis code gives 4ms but when we take array instead of vector, it gave 0ms i.e 100% faster.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        bool dp[stones.size() + 1][range / 2 + 1];\\n        \\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= range / 2; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= range / 2; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[stones.size()][idx] == true)  return abs(range - (2 * idx));\\n        \\n        return 0; \\n    }\\n};\\n```\\n```\\nReturning (range - 2 * idx) \\n    As Range(total sum of stones) = sum2 + sum1\\n     sum2 = Range - sum1\\n\\t \\n   thereby minimum subset difference would be \\n      diff = sum2 - sum1;\\n\\t       =  range - 2 * sum1 \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool subsetSum(vector<int>& stones, int sum, vector<vector<bool>> &dp)\\n    {\\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= sum; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= sum; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        return dp[stones.size()][sum];\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        vector<vector<bool>> dp(stones.size() + 1, vector<bool>(range / 2 + 1, false));\\n        \\n       subsetSum(stones, range / 2, dp);\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[dp.size() - 1][idx] == true)  return abs(range - (2 * idx));\\n\\n        return 0; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        bool dp[stones.size() + 1][range / 2 + 1];\\n        \\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= range / 2; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= range / 2; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[stones.size()][idx] == true)  return abs(range - (2 * idx));\\n        \\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297883,
                "title": "c-dp-with-clear-explanation-and-code-comments",
                "content": "**The problem is equivalent to \"putting the stones into two groups, such that the weight sums of the two groups have minimal difference.\"**\\nFor example, given three stones with weights `A>B>C`. \\nPossible outcomes are `|A-(B-C)|`, `|(A-B)-C|`, `|(A-C)-B|`..., \\n, or simply,  `|A-B+C|`, `|A-B-C|`, `|A-C-B|` ... (Stones with positive weights are in one group and ones with negative weights are in the other).\\n\\nWithout lost of generarity, we assume that two groups have weights `P` and `N`, where `P \\u2265 N`. Moreover, the sum of all stones is `sum = P+N`.\\nThus, `P = sum-N` and the last stone weight is `P-N = sum-2N \\u2265 0`.\\nTherefore, we have the **bound of `N \\u2A7D sum/2`**.\\n\\nNow, we\\'re going find out all possible `N` such that `N \\u2A7D sum/2`.\\nWe use a table to store whether a weight `N` is possible, given a number of stones (from 0 to stones.length).\\nThe table `possible_N_table` is a 2-D boolean vector with idexes of the given stone number and `N`.\\n\\n1. Initually, all values in `possible_N_table` is `false`, except `possible_N_table[0][0] = true`. (Given no stone, the only possible `N` is 0).\\n2. Now we give the stone one-by-one (say given the stone `0...i`) and update the vector `possible_N_table[i]` by looking into every possible `N`s.\\n\\tIf current `N` is not possible to reach, skip this round. (for example, \"given no stone but N=1\" is not possible. Thus, `possible_N_table[0][1] = false` by default.)\\n\\t\\n\\tOtherwise:\\n    a. if the stone is NOT included to N, `N` remains the same and `possible_N_table[i+1][N] = true`\\n\\tb. if the stone is included to N, `new_N = N + stone[i]` and `possible_N_table[i+1][new_N] = true`\\n\\t    Meanwhile, max_N is recorded.\\n3. Finally, compute the last stone weight with `P-N = sum-2N`.\\n\\n\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        if (stones.size() == 1)\\n            return stones[0];\\n        \\n        // Compute half sum for N < sum/2\\n        int sum = 0;\\n        for (int& stone: stones){\\n            sum += stone;\\n        }\\n        int half_sum = sum/2;    // Half sum\\n        \\n        // Compute maximum possible of N\\n        vector<vector<bool>> possible_N_table(stones.size()+1, vector<bool> (half_sum+1, false));\\n        possible_N_table[0][0] = true;           // if no stone is picked the diff = 0\\n        int max_N = 0;\\n        \\n        for (int i = 0; i < stones.size(); i++){\\n            for (int N = 0; N <= half_sum; N++){    // j is possible_N\\n                if (possible_N_table[i][N]){     // Before taking the stone, if the value is possible\\n                    \\n                    // Case 1: don\\'t take current stone i\\n                    possible_N_table[i+1][N] = true; // i+1 is the table idx in the table\\n                    \\n                    // Case 2: take current stone i\\n                    int new_N = N + stones[i];\\n                    if (new_N <= half_sum){\\n                        possible_N_table[i+1][new_N] = true; // i+1 is the table idx in the table\\n                        max_N = max(max_N, new_N);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum - 2*max_N;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint lastStoneWeightII(vector<int>& stones) {\\n        if (stones.size() == 1)\\n            return stones[0];\\n        \\n        // Compute half sum for N < sum/2\\n        int sum = 0;\\n        for (int& stone: stones){\\n            sum += stone;\\n        }\\n        int half_sum = sum/2;    // Half sum\\n        \\n        // Compute maximum possible of N\\n        vector<vector<bool>> possible_N_table(stones.size()+1, vector<bool> (half_sum+1, false));\\n        possible_N_table[0][0] = true;           // if no stone is picked the diff = 0\\n        int max_N = 0;\\n        \\n        for (int i = 0; i < stones.size(); i++){\\n            for (int N = 0; N <= half_sum; N++){    // j is possible_N\\n                if (possible_N_table[i][N]){     // Before taking the stone, if the value is possible\\n                    \\n                    // Case 1: don\\'t take current stone i\\n                    possible_N_table[i+1][N] = true; // i+1 is the table idx in the table\\n                    \\n                    // Case 2: take current stone i\\n                    int new_N = N + stones[i];\\n                    if (new_N <= half_sum){\\n                        possible_N_table[i+1][new_N] = true; // i+1 is the table idx in the table\\n                        max_N = max(max_N, new_N);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum - 2*max_N;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166167,
                "title": "clean-100-python-solution-self-explained-dp-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\ndp[i][t] = considering stones[0~i-1], if it can sum up to target t\\n\\nTime: O(SN), S is the sum of stone weight. N is the number of stones.\\nSpace: O(SN), can reduce to O(S).\\n\"\"\"\\n\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        total = sum(stones)\\n        target = total/2\\n        dp = [[False for _ in xrange(target+1)] for _ in xrange(len(stones)+1)]\\n        dp[0][0] = True\\n        \\n        maxSum = 0\\n        # Keep trace of the max sum that stones can sum up to.\\n        \\n        for i in xrange(1, len(stones)+1):\\n            for t in xrange(target+1):\\n                if (dp[i-1][t] or (t-stones[i-1]>=0 and dp[i-1][t-stones[i-1]])):\\n                    # it can sum up to t considering stones[0~i-2]\\n                    # OR\\n                    # it can sum up to t considering stones[0~i-1]\\n                    dp[i][t] = True\\n                    maxSum = max(maxSum, t)\\n                    if t==target: return total-maxSum*2\\n        \\n        # Two collection of stones will be total-maxSum and maxSum\\n        # (total-maxSum) - maxSum => total-maxSum*2\\n        return total-maxSum*2\\n\\n\"\"\"\\nSimilar Problems: 322, 377, 416, 494, 1043, 1049, 1220, 1230, 1262, 1269\\t\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\ndp[i][t] = considering stones[0~i-1], if it can sum up to target t\\n\\nTime: O(SN), S is the sum of stone weight. N is the number of stones.\\nSpace: O(SN), can reduce to O(S).\\n\"\"\"\\n\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        total = sum(stones)\\n        target = total/2\\n        dp = [[False for _ in xrange(target+1)] for _ in xrange(len(stones)+1)]\\n        dp[0][0] = True\\n        \\n        maxSum = 0\\n        # Keep trace of the max sum that stones can sum up to.\\n        \\n        for i in xrange(1, len(stones)+1):\\n            for t in xrange(target+1):\\n                if (dp[i-1][t] or (t-stones[i-1]>=0 and dp[i-1][t-stones[i-1]])):\\n                    # it can sum up to t considering stones[0~i-2]\\n                    # OR\\n                    # it can sum up to t considering stones[0~i-1]\\n                    dp[i][t] = True\\n                    maxSum = max(maxSum, t)\\n                    if t==target: return total-maxSum*2\\n        \\n        # Two collection of stones will be total-maxSum and maxSum\\n        # (total-maxSum) - maxSum => total-maxSum*2\\n        return total-maxSum*2\\n\\n\"\"\"\\nSimilar Problems: 322, 377, 416, 494, 1043, 1049, 1220, 1230, 1262, 1269\\t\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016005,
                "title": "bottom-up-in-0ms-beats-100-and-top-down-beats-100-in-space-recursive-bottom-up-top-down-approach",
                "content": "Recurssive approach:-\\n```\\nint las(vector<int>& st, int s1,int s2,int n){\\n        if(n==0)\\n            return abs(s1-s2);/when n==0 return the absolute diff. then\\n        return min(las(st,s1+st[n-1],s2,n-1),las(st,s1,s2+st[n-1],n-1));//add any of the one subset\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        return las(stones,0,0,n);\\n    }\\n```\\nMemoisation of DP, very simple\\n```\\n    int las(vector<int>& st, int s1,int s2,int n,vector<vector<int>> &dp){\\n        if(n==0)\\n        return dp[n][s1]=abs(s1-s2);\\n        if(dp[n][s1]!=-1)\\n            return dp[n][s1];\\n        return dp[n][s1]=min(las(st,s1+st[n-1],s2,n-1,dp),las(st,s1,s2+st[n-1],n-1,dp));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<vector<int>> vec( n+1 , vector<int> (3001, -1));\\n        return las(stones,0,0,n,vec);\\n    }\\n```\\nDynamic approach:-\\n```\\nint lastStoneWeightII(vector<int>& st) {\\n        int n=st.size();\\n        int sum=0;\\n        //find sum of all\\n        for(int i=0;i<n;i++)\\n            sum+=st[i]; \\n        //applied algo to find if given sum is present or not in the array\\n        bool dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=false;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(st[i-1]<=j)\\n                    dp[i][j]=dp[i-1][j-st[i-1]] || dp[i-1][j];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        //simply see the target one by one so that the absolute difference between the sum of subsets become minimum\\n        for(int x=sum%2==0?sum/2:sum/2+1;x<=sum;x++){\\n        if(dp[n][x]==true)//if find any then return that otherwise increment and check again\\n            return 2*x-sum;\\n            }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint las(vector<int>& st, int s1,int s2,int n){\\n        if(n==0)\\n            return abs(s1-s2);/when n==0 return the absolute diff. then\\n        return min(las(st,s1+st[n-1],s2,n-1),las(st,s1,s2+st[n-1],n-1));//add any of the one subset\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        return las(stones,0,0,n);\\n    }\\n```\n```\\n    int las(vector<int>& st, int s1,int s2,int n,vector<vector<int>> &dp){\\n        if(n==0)\\n        return dp[n][s1]=abs(s1-s2);\\n        if(dp[n][s1]!=-1)\\n            return dp[n][s1];\\n        return dp[n][s1]=min(las(st,s1+st[n-1],s2,n-1,dp),las(st,s1,s2+st[n-1],n-1,dp));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<vector<int>> vec( n+1 , vector<int> (3001, -1));\\n        return las(stones,0,0,n,vec);\\n    }\\n```\n```\\nint lastStoneWeightII(vector<int>& st) {\\n        int n=st.size();\\n        int sum=0;\\n        //find sum of all\\n        for(int i=0;i<n;i++)\\n            sum+=st[i]; \\n        //applied algo to find if given sum is present or not in the array\\n        bool dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=false;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(st[i-1]<=j)\\n                    dp[i][j]=dp[i-1][j-st[i-1]] || dp[i-1][j];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        //simply see the target one by one so that the absolute difference between the sum of subsets become minimum\\n        for(int x=sum%2==0?sum/2:sum/2+1;x<=sum;x++){\\n        if(dp[n][x]==true)//if find any then return that otherwise increment and check again\\n            return 2*x-sum;\\n            }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305126,
                "title": "c-9line",
                "content": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(),0);\\n        int minDiff = sum;\\n        vector<bool> dp(sum+1, 0);\\n        dp[0] = true;\\n        for(auto x:stones)\\n            for (int i = dp.size()-1; i >=0; i--) if(dp[i]) dp[i+x] = true;  \\n        for(int i=0;i<dp.size();i++)\\n            if(dp[i]) minDiff = min(minDiff, abs(i*2-sum));\\n        return minDiff;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(),0);\\n        int minDiff = sum;\\n        vector<bool> dp(sum+1, 0);\\n        dp[0] = true;\\n        for(auto x:stones)\\n            for (int i = dp.size()-1; i >=0; i--) if(dp[i]) dp[i+x] = true;  \\n        for(int i=0;i<dp.size();i++)\\n            if(dp[i]) minDiff = min(minDiff, abs(i*2-sum));\\n        return minDiff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295020,
                "title": "python-solution-easy-to-understand",
                "content": "we could split the stones into two piles `A` and `B`, so that `abs( A - B )` has a minimum value.  Thus each stone is either in pile `A` or pile `B`. now we simply need to figure out how to spilt the stones. \\nas metioned above, each stone is only in one of the two piles, let\\'s denote `dp[i]` as whether to put the `i-th`(starting from 0) stone in to `A` or `B`. \\n* if we put it into `A`, then for all the results that before the `i-th` stone, we add the weight of `i-th` stone to them.\\n* if we put it into `B`, then for all the results that before the `i-th` stone, we subtract the weight of `i-th` stone from them.\\nkeep doing this until we put the last stone into calculation. at this point, we simply take a look at final results and the minimum abs value is the answer. below is the code:\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones) -> int:\\n        dp = [[]]\\n        dp[0] = [stones[0],stones[0] * (-1)]\\n        for i in range(1,len(stones)):\\n            dp.append([e + stones[i] for e in dp[i - 1]] + [e - stones[i] for e in dp[i - 1]])\\n            dp[i] = list(set(dp[i]))\\n        total = list(set(abs(e) for e in dp[-1]))\\n        total.sort()\\n        return total[0]\\n```\\nactually, we don\\'t need to keep track of dp arrays of all the stones, only the dp array of previous stone that matters.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones) -> int:\\n        dp = [[]]\\n        dp[0] = [stones[0],stones[0] * (-1)]\\n        for i in range(1,len(stones)):\\n            dp.append([e + stones[i] for e in dp[i - 1]] + [e - stones[i] for e in dp[i - 1]])\\n            dp[i] = list(set(dp[i]))\\n        total = list(set(abs(e) for e in dp[-1]))\\n        total.sort()\\n        return total[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346390,
                "title": "c-explaining-intuition-behind-dp",
                "content": "Suppose we have a list of stones as [x,y,z]\\n\\n`[x,y,z]`\\n\\n- Trial 1\\n\\n\\tIf we combine x & y, and x >= y we are left with,\\n\\t`[x-y,z]`\\n\\tThen if we combine (x-y) & z, and z >= (x-y) we are left with\\n\\t`[z-x+y]`\\n\\t\\n- Trial 2\\n\\tIf we combine x & z, and z >= x we are left with,\\n\\t`[z-x,y]`\\n\\tThen if we combine (z-x) & y, and (z-x) >= y we are left with\\n\\t`[z-x-y]`\\n\\t\\nUsing these obsevations we can deduce that our final answer would be the result of sum stones gettting added and some getting subtracted. Say all stones which are added have a sum of **positiveSum** and all stones which are subtracted have a sum **negativeSum**, our final answer is **positiveSum - negativeSum** and this value has to be minimised. This essentially breaks down the problem into the classical DP problem of dividing a set into two sets such that difference between sum of two sets is minimised.\\n\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n\\tint n = stones.size();\\n\\tint sum = accumulate(stones.begin(), stones.end(), 0);\\n\\n\\tint halfSum = sum/2, negativeSum = 0;\\n\\tvector<bool> possible(halfSum+1, false);\\n\\tpossible[0] = true;\\n\\n\\tfor(int stone : stones) {\\n\\t\\tfor(int target = halfSum ; target >= 1 ; target--) {\\n\\t\\t\\tbool exclude = possible[target];\\n\\t\\t\\tbool include = (stone <= target) ? possible[target - stone] : false;\\n\\t\\t\\tpossible[target] = exclude or include;\\n\\t\\t\\tif(possible[target]) negativeSum = max(negativeSum, target);\\n\\t\\t}\\n\\t}\\n\\n\\tint positiveSum = sum - negativeSum;\\n\\treturn positiveSum - negativeSum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint lastStoneWeightII(vector<int>& stones) {\\n\\tint n = stones.size();\\n\\tint sum = accumulate(stones.begin(), stones.end(), 0);\\n\\n\\tint halfSum = sum/2, negativeSum = 0;\\n\\tvector<bool> possible(halfSum+1, false);\\n\\tpossible[0] = true;\\n\\n\\tfor(int stone : stones) {\\n\\t\\tfor(int target = halfSum ; target >= 1 ; target--) {\\n\\t\\t\\tbool exclude = possible[target];\\n\\t\\t\\tbool include = (stone <= target) ? possible[target - stone] : false;\\n\\t\\t\\tpossible[target] = exclude or include;\\n\\t\\t\\tif(possible[target]) negativeSum = max(negativeSum, target);\\n\\t\\t}\\n\\t}\\n\\n\\tint positiveSum = sum - negativeSum;\\n\\treturn positiveSum - negativeSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156639,
                "title": "dp-recursive-o-n-sum-stones-proof-of-why-partitioning-work-intuitive",
                "content": "![image](https://assets.leetcode.com/users/images/eb74b4c9-af93-489b-a219-5607eecbc554_1618325804.9613392.png)\\n\\nInspired by the Idea given by @shawshawwan discuss post :\\n https://leetcode.com/problems/last-stone-weight-ii/discuss/295167/Java-beat-100-with-nice-explanation\\n \\n Proof of why partitioning works: (Idea inspired by  @Pritam-Das)\\n\\n![image](https://assets.leetcode.com/users/images/3af61321-244d-4575-81c5-dd10310b22f2_1618330738.324079.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto ele:stones) sum+=ele;\\n        int ans = 0;\\n        \\n        int dp[n+2][2][sum+2];\\n        memset(dp,-1,sizeof(dp));\\n        \\n        std::function<int(int,int,int)> f = [&](int i, int take, int s){\\n            if(dp[i][take][s]!=-1) return dp[i][take][s];\\n            if(take){\\n                int t_s = s;\\n                t_s+=stones[i];\\n                if(i+1<n){\\n                    if(t_s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = stones[i] + max(f(i+1,1,t_s),f(i+1,0,t_s));\\n                    else return dp[i][take][s] = stones[i] + f(i+1,0,t_s);\\n                }\\n                else return dp[i][take][s] = stones[i];\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = max(f(i+1,1,s),f(i+1,0,s));\\n                    else return dp[i][take][s] = f(i+1,0,s);\\n                }\\n                else return dp[i][take][s] = 0;\\n            }\\n        };\\n        ans = 0;\\n        if(stones[0]<=(sum/2)){\\n            ans=max({ans,f(0,1,0),f(0,0,0)});\\n        }\\n        else ans=max(ans,f(0,0,0));\\n        \\n        return sum-(2*ans);\\n            \\n    }\\n};\\n```\\n\\nPS: I started writing blogs on some problems from Leetcode, Codeforces. Here\\u2019s the link of My blog (https://algorithmsplayground.blogspot.com/). If you are interested please check out the same.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto ele:stones) sum+=ele;\\n        int ans = 0;\\n        \\n        int dp[n+2][2][sum+2];\\n        memset(dp,-1,sizeof(dp));\\n        \\n        std::function<int(int,int,int)> f = [&](int i, int take, int s){\\n            if(dp[i][take][s]!=-1) return dp[i][take][s];\\n            if(take){\\n                int t_s = s;\\n                t_s+=stones[i];\\n                if(i+1<n){\\n                    if(t_s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = stones[i] + max(f(i+1,1,t_s),f(i+1,0,t_s));\\n                    else return dp[i][take][s] = stones[i] + f(i+1,0,t_s);\\n                }\\n                else return dp[i][take][s] = stones[i];\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = max(f(i+1,1,s),f(i+1,0,s));\\n                    else return dp[i][take][s] = f(i+1,0,s);\\n                }\\n                else return dp[i][take][s] = 0;\\n            }\\n        };\\n        ans = 0;\\n        if(stones[0]<=(sum/2)){\\n            ans=max({ans,f(0,1,0),f(0,0,0)});\\n        }\\n        else ans=max(ans,f(0,0,0));\\n        \\n        return sum-(2*ans);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799933,
                "title": "c-greedy-vs-dp-a-simple-approach",
                "content": "First let\\'s talk about why greedy doesnt work here(at least for all the cases).I tried using greedy and only 72/84 cases passesd then I was pondering which are the cases that are failing.\\nSo then it struck me that whenever the larger elements sum equal to some smaller elements sum or near the values it fails because in Greedy I was sorting the array and looking for the neighbouring difference from left and right and take minimum of that but I forgot to consider the case where I had to deal with non-adjacent neighbours.\\n\\nThe idea behind this solution is to simply divide the array into two subsets such that difference of sum of subsets is minimum.\\n\\nBelow is the greedy solution which **doesnt work** because of the above reasons and it is also hard to bring out the intuition why Greedy doesnt work,But we can surely say why DP works because it looks for all Optimal solutions. \\n\\n**Greedy solution**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        priority_queue<int> pqmax;\\n        priority_queue<int,vector<int>,greater<int> > pqmin;\\n        int n = stones.size();\\n        if(n == 1)\\n            return stones[0];\\n        for(auto &x : stones)\\n        {\\n            pqmax.push(x);\\n            pqmin.push(x);\\n        }\\n        while(pqmax.size() > 1)\\n        {\\n            int x = pqmax.top();\\n            pqmax.pop();\\n            int y = pqmax.top();\\n            pqmax.pop();\\n            if(x != y)\\n                pqmax.push(abs(x-y));\\n        }\\n        while(pqmin.size() > 1)\\n        {\\n            int x = pqmin.top();\\n            pqmin.pop();\\n            int y = pqmin.top();\\n            pqmin.pop();\\n            if(x != y)\\n                pqmin.push(abs(x-y));\\n        }\\n        if(pqmax.empty() || pqmin.empty())\\n            return 0;\\n        return min(pqmax.top(),pqmin.top());\\n    }\\n};\\n```\\n\\nHere is the **correct solution** based on dividing the subsets.\\n\\n**DP solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > dp;\\n    int find_ans(vector<int>& A,int i,int calsum,int sum)\\n    {\\n        if(i == 0)\\n            return abs((sum-calsum)-calsum);\\n        if(dp[i][calsum] != -1)\\n            return dp[i][calsum];\\n        return dp[i][calsum] = min(find_ans(A,i-1,calsum+A[i-1],sum),\\n                               find_ans(A,i-1,calsum,sum));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto &x : stones)\\n            sum += x;\\n        dp.resize(n+1,vector<int>(sum+1,-1));\\n        return find_ans(stones,n,0,sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        priority_queue<int> pqmax;\\n        priority_queue<int,vector<int>,greater<int> > pqmin;\\n        int n = stones.size();\\n        if(n == 1)\\n            return stones[0];\\n        for(auto &x : stones)\\n        {\\n            pqmax.push(x);\\n            pqmin.push(x);\\n        }\\n        while(pqmax.size() > 1)\\n        {\\n            int x = pqmax.top();\\n            pqmax.pop();\\n            int y = pqmax.top();\\n            pqmax.pop();\\n            if(x != y)\\n                pqmax.push(abs(x-y));\\n        }\\n        while(pqmin.size() > 1)\\n        {\\n            int x = pqmin.top();\\n            pqmin.pop();\\n            int y = pqmin.top();\\n            pqmin.pop();\\n            if(x != y)\\n                pqmin.push(abs(x-y));\\n        }\\n        if(pqmax.empty() || pqmin.empty())\\n            return 0;\\n        return min(pqmax.top(),pqmin.top());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > dp;\\n    int find_ans(vector<int>& A,int i,int calsum,int sum)\\n    {\\n        if(i == 0)\\n            return abs((sum-calsum)-calsum);\\n        if(dp[i][calsum] != -1)\\n            return dp[i][calsum];\\n        return dp[i][calsum] = min(find_ans(A,i-1,calsum+A[i-1],sum),\\n                               find_ans(A,i-1,calsum,sum));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto &x : stones)\\n            sum += x;\\n        dp.resize(n+1,vector<int>(sum+1,-1));\\n        return find_ans(stones,n,0,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467073,
                "title": "c-solution-beats-100-in-memory-and-speed",
                "content": "```\\n/*\\n    https://leetcode.com/problems/last-stone-weight-ii/\\n    TC: O(n * S), S: total sum of elements\\n    SC: O(S)\\n    \\n    This problem can be transformed to another problem, it is 494. Target Stone problem on LC.\\n    Here we need to smash the rocks to get the min final weight. The thing to note here is the order\\n    in which the stones can be smashed. The problem looks like a simulation problem where you need to push the\\n    new smashed weight and run the simulation till we have only one or zero rock. But another way of thinking\\n    is that if we can group the stones in two groups such that diff of the two groups is min, then also the\\n    problem is solved. Everytime we get |x -y| the extra weight is nothing but the surplus diff in x and this diff\\n    is used in the next iteration of simulation. So by forming two max groups P and N, we also account for the surplus of each stone in the group only and when they are smashed the net diff gives us the same effect as simulation.\\n    \\n    So the problem in hand: P - N = Target(T)\\n    We try to maximize both P and N to get the min T.\\n    This can be done using DP.\\n    \\n    P - N = T\\n    2P - P - N = T\\n    2P = T + S, sum(S) = N + P\\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightTabular(vector<int>& stones){\\n        // calculate the sum of all values\\n        int total = accumulate(stones.begin(), stones.end(), 0);\\n        int min_weight = total;\\n        \\n        // dp(i): can P with sum \\'i\\' be formed \\n        vector<bool> dp(total/2 + 1, false);\\n        //getting a sum of zero is always possible\\n        dp[0] = true;\\n        \\n        for(const int& stone: stones) {\\n            for(int i = total/2; i >= stone; i--) {\\n                dp[i] = dp[i] || dp[i - stone];\\n                \\n                // 2P = T + S, we need to find min(T)\\n                int target = abs(2*i - total);\\n                if(dp[i])\\n                    min_weight = min(min_weight, target);\\n            }\\n        }\\n        \\n        return min_weight;\\n    }\\n    \\n    // driver \\n    int lastStoneWeightII(vector<int>& stones) {\\n        return lastStoneWeightTabular(stones);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/last-stone-weight-ii/\\n    TC: O(n * S), S: total sum of elements\\n    SC: O(S)\\n    \\n    This problem can be transformed to another problem, it is 494. Target Stone problem on LC.\\n    Here we need to smash the rocks to get the min final weight. The thing to note here is the order\\n    in which the stones can be smashed. The problem looks like a simulation problem where you need to push the\\n    new smashed weight and run the simulation till we have only one or zero rock. But another way of thinking\\n    is that if we can group the stones in two groups such that diff of the two groups is min, then also the\\n    problem is solved. Everytime we get |x -y| the extra weight is nothing but the surplus diff in x and this diff\\n    is used in the next iteration of simulation. So by forming two max groups P and N, we also account for the surplus of each stone in the group only and when they are smashed the net diff gives us the same effect as simulation.\\n    \\n    So the problem in hand: P - N = Target(T)\\n    We try to maximize both P and N to get the min T.\\n    This can be done using DP.\\n    \\n    P - N = T\\n    2P - P - N = T\\n    2P = T + S, sum(S) = N + P\\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightTabular(vector<int>& stones){\\n        // calculate the sum of all values\\n        int total = accumulate(stones.begin(), stones.end(), 0);\\n        int min_weight = total;\\n        \\n        // dp(i): can P with sum \\'i\\' be formed \\n        vector<bool> dp(total/2 + 1, false);\\n        //getting a sum of zero is always possible\\n        dp[0] = true;\\n        \\n        for(const int& stone: stones) {\\n            for(int i = total/2; i >= stone; i--) {\\n                dp[i] = dp[i] || dp[i - stone];\\n                \\n                // 2P = T + S, we need to find min(T)\\n                int target = abs(2*i - total);\\n                if(dp[i])\\n                    min_weight = min(min_weight, target);\\n            }\\n        }\\n        \\n        return min_weight;\\n    }\\n    \\n    // driver \\n    int lastStoneWeightII(vector<int>& stones) {\\n        return lastStoneWeightTabular(stones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461955,
                "title": "python3-all-possible-sums",
                "content": "I did not see the knapsack intuition when solving this problem.\\nBut since the weight of the final stone will be a formation sum of all stones with +- signs (because any new stones is an absolute difference of two stones). So, I approach this by generating all possible sums. \\n\\n```python\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        s = {0}\\n        for st in stones:\\n            tmp = set()\\n            for i in s:\\n                tmp.add(abs(i + st))\\n                tmp.add(abs(i - st))\\n            s = tmp\\n        return min(s) if len(s) > 0 else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        s = {0}\\n        for st in stones:\\n            tmp = set()\\n            for i in s:\\n                tmp.add(abs(i + st))\\n                tmp.add(abs(i - st))\\n            s = tmp\\n        return min(s) if len(s) > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401408,
                "title": "c-my-second-practice-is-to-study-the-code-and-then-write-some-explanation",
                "content": "Oct. 9, 2019\\n1049. Last Stone Weight II\\n**Problem rephrase 1 minute Warmup**\\nTwo stones smash - [2, 4], after smash, x = 2 , y = 4, left: 2\\nAsking minimum left. \\nInput: [2,7,4,1,8,1]\\nOutput: 1\\n\\nIt is a good idea to learn to write more than one solution. What I did is to study the most popular post in the discussion post, and then I wrote one C# solution. \\n\\nIt is important to read the case study I prepare first, and then it will be much easy to follow the design of the solution. \\n\\n**Case study**\\nGiven the array with values [31, 26, 33, 21, 40], the sum of the array is 151, let us denote it as Sum. Sum/ 2 will be 75. We can divide into two sets, [33, 40] and [31, 26, 21], the sum of first array is 73, and the sum of second array is 78, the minimum difference is 5. \\n\\nBut if we update the loop from ascending (this is descending, (**for (int i = Math.Min(1500, prefixSum); i >= item; i--)**), one number may be used more than once, so that minimum difference can be one. Since [26, 26, 23] can be an array, but 26 is counted twice, the sum of the array is 75, so 151 - 2 * 75 = 1. \\n\\n**The challenges**\\n1. How to design the solution so that each stone will be at most counted once to the sum? \\n2. Argue to yourself, why order does not matter? We can count each stone at most once in any sum, but which goes first does not matter. \\n\\nHere are highlights:\\n1. Understand how to convert the problem to classical Knapsack problem to divide array into two sets; \\n2. Understand how to find all possible sum using all stones available, make sure that one stone can only be used at most once for each sum;\\n3. Most challenging problem is to design the search using descending order. Detail see my first practice if you have questions. [Here](https://leetcode.com/problems/last-stone-weight-ii/discuss/400758/C-Convert-to-classical-algorithm-Knapsack-problem) is the post. \\n4. Go over a test case and learn the case study before working on the solution. \\n\\nAdded on Oct. 28, 2020\\n**Warmup dynamic programming idea**\\nLet me work on test case [1, 2, 3, 4], since maximum length is 30, maximum value 100, so the length of array 4 maximum value is 200. Declare bool dp[201], default value false. \\n\\nWe know any i (1 to 4) combination of those 4 stones should be true.\\ndp[1] = true\\ndp[2] = true\\ndp[3] = true\\ndp[4] = true\\nSum of the array is 10, so dp[10] = true. \\nHow to build the value from bottom up? \\nBrute force solution to search, given any stone in the stones.\\nStone can be any order, not necessary sorted. \\nstarting from maximum value 200, for example, stone is 3, \\ndp[200] = true if dp[200 - 3] is true, simple version in programming language, dp[200] |= dp[197], | is bit manipulation OR operator in C#. \\ncontinue to work on dp[199] until dp[3], 3 >= given stone value = 3. \\nIn order to find minimum weight, go from index = 200 to search if dp[index] is true with decrement value 1. \\n\\nSimilar idea can be found in another dynamic programming algorithm, 472. Concatenated Words, [here](https://leetcode.com/problems/concatenated-words/discuss/903610/c-break-into-hashset-dp-problem) is my practice with explanation. \\n\\n**Dynamic programming algorithm Advice**\\n\\n[DP for Beginners [Problems | Patterns | Sample Solutions]](https://leetcode.com/discuss/general-discussion/662866/dp-for-beginners-problems-patterns-sample-solutions)\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1049_last_stone_weight_II___lee215\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP\\n        /// \\n        /// The idea is to implement the solution using time complexity O(NS), N is length of the array, S is the sum of the array. \\n        /// space complexity is O(S), where S = sum of the array stones. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int LastStoneWeightII(int[] stones)\\n        {\\n            // length <= 30, value of stones [1, 100], maximum sum is 3000\\n            var dp = new bool[1501];\\n\\n            dp[0] = true;\\n            var sum = stones.Sum();\\n\\n            var prefixSum = 0; \\n\\n            foreach (var item in stones)\\n            {\\n                prefixSum += item;\\n                for (int i = Math.Min(1500, prefixSum); i >= item; i--)\\n                {\\n                    dp[i] |= dp[i - item];  // logical OR operator\\n                }\\n            }\\n\\n            for(int i = sum/2; i > 0; i--)\\n            {\\n                if(dp[i])\\n                {\\n                    return sum - i * 2; \\n                }\\n            }\\n\\n            return 0; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1049_last_stone_weight_II___lee215\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP\\n        /// \\n        /// The idea is to implement the solution using time complexity O(NS), N is length of the array, S is the sum of the array. \\n        /// space complexity is O(S), where S = sum of the array stones. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int LastStoneWeightII(int[] stones)\\n        {\\n            // length <= 30, value of stones [1, 100], maximum sum is 3000\\n            var dp = new bool[1501];\\n\\n            dp[0] = true;\\n            var sum = stones.Sum();\\n\\n            var prefixSum = 0; \\n\\n            foreach (var item in stones)\\n            {\\n                prefixSum += item;\\n                for (int i = Math.Min(1500, prefixSum); i >= item; i--)\\n                {\\n                    dp[i] |= dp[i - item];  // logical OR operator\\n                }\\n            }\\n\\n            for(int i = sum/2; i > 0; i--)\\n            {\\n                if(dp[i])\\n                {\\n                    return sum - i * 2; \\n                }\\n            }\\n\\n            return 0; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295401,
                "title": "c-dp-inspired-by-the-hints-double-100-with-explanation",
                "content": "The normal way to break a DP question is try to think how we can solve new question with bigger scope from results of previous question of smaller scope. Take this question for example:\\n1. We will need to figure out how we can get miminum stone left for stones [a0, a1, ... , an] based on if we can somehow know the minimus stone left for stones [a0, a1, ... , an-1]\\n2. The naive thought will be if I can know all the possible left stones from [[a0, a1, ... , an-1]], say it is [L1, L2, ... Lm], then we can konw the final results based on minium of [abs(L1 - an), abs(L2 - an), ... abs(Lm - an)]\\n3. But this could be wrong, say we have stone 8 and previous stone [1, 2, 4], the possible outcome of [1, 2, 4] are [1, 3], then combine with 8 we can results from [5, 7], while the correct final result should be 1\\n4. Based on the hints \"Use dynamic programming: for every possible sum with N stones, those sums +x or -x is possible with N+1 stones, where x is the value of the newest stone.\"\\n5. We can know that we should not only get valid left stones from previous smaller scope question we should also get \"currently unvalid left stones\", which is all positive or all negative, cause they could become valid combine with the new stone. So the leftstones of [1,2,4] should be [-7, -5, -3, -1, 1, 3, 5, 7]\\n6. If we combine with 8 we can get [-15, -13, -11, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15], and the final result will be the smallest number from the possible result >= 0\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> stoneLeft;\\n        for (int& stone : stones) {\\n            if (stoneLeft.empty()) {\\n                stoneLeft.insert(stone);\\n                stoneLeft.insert(-stone);\\n            }\\n            else {\\n                unordered_set<int> temp;\\n                for (int left : stoneLeft) {\\n                    temp.insert(left + stone);\\n                    temp.insert(left - stone);\\n                }\\n                stoneLeft = temp;\\n            }\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int left : stoneLeft) {\\n            if (left >= 0) {\\n                result = min(left, result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> stoneLeft;\\n        for (int& stone : stones) {\\n            if (stoneLeft.empty()) {\\n                stoneLeft.insert(stone);\\n                stoneLeft.insert(-stone);\\n            }\\n            else {\\n                unordered_set<int> temp;\\n                for (int left : stoneLeft) {\\n                    temp.insert(left + stone);\\n                    temp.insert(left - stone);\\n                }\\n                stoneLeft = temp;\\n            }\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int left : stoneLeft) {\\n            if (left >= 0) {\\n                result = min(left, result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295030,
                "title": "share-my-java-solution-knapsacks-problem",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int ele: stones){\\n            sum+=ele;\\n        }\\n        int total_sum = sum;\\n        int n = stones.length;\\n        sum/=2;\\n        \\n        boolean[][] dp = new boolean[sum+1][n+1];\\n        for(int j=0;j<=n;j++){\\n            dp[0][j] = true;\\n        }\\n        int max = 0;\\n        for(int i=1;i<=sum;i++){\\n            for(int j=1;j<=stones.length;j++){\\n                if(dp[i][j-1]==true || (i>=stones[j-1] && dp[i-stones[j-1]][j-1])){\\n                    dp[i][j] = true;\\n                    max = Math.max(i, max);\\n                }\\n            }\\n        }\\n        \\n        \\n        return total_sum-max*2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int ele: stones){\\n            sum+=ele;\\n        }\\n        int total_sum = sum;\\n        int n = stones.length;\\n        sum/=2;\\n        \\n        boolean[][] dp = new boolean[sum+1][n+1];\\n        for(int j=0;j<=n;j++){\\n            dp[0][j] = true;\\n        }\\n        int max = 0;\\n        for(int i=1;i<=sum;i++){\\n            for(int j=1;j<=stones.length;j++){\\n                if(dp[i][j-1]==true || (i>=stones[j-1] && dp[i-stones[j-1]][j-1])){\\n                    dp[i][j] = true;\\n                    max = Math.max(i, max);\\n                }\\n            }\\n        }\\n        \\n        \\n        return total_sum-max*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611670,
                "title": "0-1-knapsack-variant-aditya-verma-s-approach",
                "content": "# Intuition\\nLet\\'s take the example of the array [2, 7, 4, 1, 8, 1]:\\n\\n- We start by smashing the stones in pairs: (8-7), (4-2), (1-1).\\n- This reduces the array to [1, 2, 0].\\n- In the second go, we can smash 2 and 1 together, resulting in a single stone with a weight of 1, which is the minimum weight possible.\\n- Essentially, this process can be represented as: (8-7) - (4-2) + (1-1) = 8 + 2 + 1 - 7 - 4 - 1.\\n- Further simplifying, we can express this as: (8, 2, 1) - (7, 4, 1).\\n- In essence, this operation is equivalent to dividing the stones into two subsets such that their difference is minimized, which results in the smallest weight difference.\\n- Therefore, this problem aligns with the concept of the minimum subset sum difference problem.\\n\\n# Complexity\\n- Time complexity:\\n    - The code utilizes a dynamic programming approach to solve the minimum subset sum difference problem.\\n    - Constructing the t table requires iterating over n elements and sum/2 elements, resulting in a nested loop with a time complexity of O(n * sum/2).\\n    - Finding the minimum difference by scanning the last row of the table requires iterating from sum/2 to 0, resulting in a linear time complexity of O(sum/2).\\n    - Overall, the time complexity of the minDiffSubset function is O(n * sum/2).\\n\\n- Space complexity:\\n    - The space complexity of the code is determined by the size of the t table, which is a 2D vector of dimensions (n+1) x (sum/2+1).\\n    - Therefore, the space complexity is O(n * sum/2).\\n\\n# Code\\n```\\nclass Solution {\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int i = sum/2;\\n        for(; i>=0; i--) {\\n            if(t[n][i] == true)\\n                break;\\n        }\\n        return (sum-2*i);\\n    }\\n\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++){\\n            sum+=stones[i];\\n        }\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int i = sum/2;\\n        for(; i>=0; i--) {\\n            if(t[n][i] == true)\\n                break;\\n        }\\n        return (sum-2*i);\\n    }\\n\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++){\\n            sum+=stones[i];\\n        }\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435484,
                "title": "python-similar-to-knapsack-dp-top-down-recursion-only",
                "content": "At first I am actually stuck, really confuse as to finding the recurrence relation.\\n\\nAt first I thought this problem would be divide and conquer using left and right pointer, and choosing minLeft stone, rightStone and i th stone.\\n\\nAlready coded that and completely wrong. After few test cases.\\n\\nSo I give up and browsing through discussion. I found this article helpful https://leetcode.com/problems/last-stone-weight-ii/discuss/653550/Trying-to-Explain-A-bit-(logic-behind-trick)\\n\\nThis 5 lines explanation of that article give me some clue immediately also plus knapsack keyword in some of the titles\\n```\\n//let say array be [a,b,c,d]\\n//answer = (a+b)-(c+d) OR\\n//answer = a-(b+c+d) Or\\n//answer = (d+b)-(a+c) and so on.. any combination could be possible\\n//notice that in general I can say that\\n//answer = S1-S2\\n```\\n\\nSo if there are array [a,b,c,d]\\n\\nyou can combine them like this\\n+a+b+c+d = gap1\\n+a+b+c-d = gap2\\n+a+b-c+d = gap3\\n+a+b-c-d = gap3\\nso on\\n\\nSo i notice that I can propagate the sum from left to right\\n\\nwhat happen at the end?\\n\\nwe only get the absolute value of each gap and then search for minimum\\n\\nLook, we aim a result that the one closest to zero.\\n\\nHere is the full code (memoized using @cache python feature (similar to using HashMap to memoize based on params))\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @cache\\n        def dfs(idx, curW):\\n            if idx==len(stones):\\n                return abs(curW)\\n            return min(\\n                dfs(idx+1, curW+stones[idx]),\\n                dfs(idx+1, curW-stones[idx])\\n            )\\n        return dfs(0,0)\\n```\\n\\n\\nTime Complexity = O(N * S)\\nSpace Complexity = O(N * S)\\nS is possible sum value, in my case (based on constraints) S = stones.length * stonesPossibleValue * 2 = 30 * 100 * 2 = 6000\\n\\n2 comes from minus and plus sign of curW\\n\\nUsually after you get the recursion, then you can move forward to Bottom Up, I will leave that to you as homework.\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n//let say array be [a,b,c,d]\\n//answer = (a+b)-(c+d) OR\\n//answer = a-(b+c+d) Or\\n//answer = (d+b)-(a+c) and so on.. any combination could be possible\\n//notice that in general I can say that\\n//answer = S1-S2\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @cache\\n        def dfs(idx, curW):\\n            if idx==len(stones):\\n                return abs(curW)\\n            return min(\\n                dfs(idx+1, curW+stones[idx]),\\n                dfs(idx+1, curW-stones[idx])\\n            )\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184148,
                "title": "c-knapsack-type-dp-with-intuition",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[31][3001];\\n    vector <int> stones;\\n    int sm = 0;\\n    // state - level, positive sum till now\\n    \\n    /*\\n    let a,b,c,d be the weight of stones initially\\n    all possible configurations like +a-b+c+d,-a-b-c+d etc can be achieved\\n    i.e (+/-)a (+/-)b (+/-) c (+/-)d\\n    so the problem now is by assigning a positive or neg sign in front of each number we have to get smallest positive sum\\n    after finding the soln, we can backtrack and get the number which contribute positively and which contribute negatively\\n    to simulate the process to get the answer what we can do is:\\n    take largest from positive side and from negative side, say they are x1 and x2\\n    we need x1-x2 so if x1>x2 we put x1-x2 in positive side , if x1<x2 we put x2-x1 in negative side so that it becomes x1-x2 in next step\\n    so the process can be simulated in this way to assign the correct signs\\n    */\\n    \\n    int rec(int level,int pos){\\n        if(level == stones.size()){\\n            int neg = sm-pos;\\n            if(pos<neg) return 1e9;\\n            return pos-neg;\\n        }\\n        if(dp[level][pos] != -1) return dp[level][pos];\\n        int ans = min(rec(level+1,pos),rec(level+1,pos+stones[level]));\\n        return dp[level][pos] = ans;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& _stones) {\\n        stones = _stones;\\n        for(auto val:stones) sm+=val;\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[31][3001];\\n    vector <int> stones;\\n    int sm = 0;\\n    // state - level, positive sum till now\\n    \\n    /*\\n    let a,b,c,d be the weight of stones initially\\n    all possible configurations like +a-b+c+d,-a-b-c+d etc can be achieved\\n    i.e (+/-)a (+/-)b (+/-) c (+/-)d\\n    so the problem now is by assigning a positive or neg sign in front of each number we have to get smallest positive sum\\n    after finding the soln, we can backtrack and get the number which contribute positively and which contribute negatively\\n    to simulate the process to get the answer what we can do is:\\n    take largest from positive side and from negative side, say they are x1 and x2\\n    we need x1-x2 so if x1>x2 we put x1-x2 in positive side , if x1<x2 we put x2-x1 in negative side so that it becomes x1-x2 in next step\\n    so the process can be simulated in this way to assign the correct signs\\n    */\\n    \\n    int rec(int level,int pos){\\n        if(level == stones.size()){\\n            int neg = sm-pos;\\n            if(pos<neg) return 1e9;\\n            return pos-neg;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780759,
                "title": "c-easy-solution-minimum-subset-difference-similar-problem",
                "content": "```\\nProblem is similar or combination of 2 or more basic problems of DP\\n1. Equal Partition Sum\\n2. Minimum Diff Subset\\n```\\n\\n```\\nGiven Problem is a combination of these 2 problems\\n```\\n\\n```\\nWHAT PROBLEM WANTS OR HOW TO SOLVE ???\\n\\nBasically we have to find minimum weight of the stones which remain after striking or return 0 if non of them remains.\\nQuestion also provides some parameters for striking \\n1. if weight of two stones is equal then they both destroys.\\n2. if there is difference in weight of there stones then subtract and smaller one get removed and larger one get updated value of there difference.\\n```\\n\\n\\n```\\nIf i say we don\\'t require all these things, then it loos like quite interesting BUT how let me share with you.\\nIf you have done problem of Equal partition sum then you can realize it with it. In that problem we have partition the given array in such a way that the difference of 2 subset will be 0. \\nSo you can relate this problem with that. In this we also need to find two subset such that for there difference we get a minimum value. It can be 0 or anything.\\nFor that problem and solution it i am sharing the link [ https://leetcode.com/problems/partition-equal-subset-sum/discuss/1773198/cdp-problemusing-2-different-method-with-proper-explanation ]\\n\\nSo first part for partition is solved in that way next remaining part is to get that minimum difference.\\nSo first talk about little bit of maths and array partition.\\nI know i have to divide that array in two parts so to get subset which can provide the minimum difference.\\nIf i talk about the patition part, the basic subset if i get a maximum difference then i want one empty subset and one subset which contain all the element of array. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t { array }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /              \\\\\\n\\t\\t\\t\\t\\t\\t        subset 1          subset 2\\n\\t\\t\\t\\t\\t\\t\\t     \\t|                 |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tS1                S2\\nS1 is the sum of all element in subset 1.\\nS2 is the sum of all element of subset 2.\\nwe have to find \\n\\t\\t\\t\\tMinimum (S1 - S2) or (S2-S1).\\nSo to in more generalized form of it what i do i\\'ll make subset 1 of smaller element  and for subset 2 element.\\nWe can find it without doing anything.\\nBUT HOW ??\\nIts simple i know the value of the element will lie in range 0 to sum of all element.\\nBut most important thingh is that its not fix all the points between that range(in simple words my sum range ) will lie in my subset.\\nso don\\'t go recklessly.\\nI know my subset 1 element.\\nAnd i know \\n\\t\\t\\t\\tS1 + S2  = sum (range).\\nTherefore \\n\\t\\t\\t\\tS2 = sum - S1 ;\\nSo i can find that subset 2 element by just minus but that thing i don\\'t want.\\nMost Important thing i want the difference.\\nLets derive a formula for it\\nI know \\n\\t\\t\\tS2 - S1 = minimum\\nAnd i have \\n\\t\\t\\tS2 = Range - S1\\nBy using that 2 formula i can derive this \\n\\t\\t  Range - S1 - S1 = minimum.\\nTherefore \\n\\t\\t\\t Minimum = Range - 2*S1.\\nNow i have subset 1 element and the range (which is simply the sum of element).\\nAnd for S1 element we can traverse the last row of my DP matrix.\\nand get the minimum abs value of my difference.\\n```\\n\\n```\\nI am assuming that the viewer have a basic idea of DP with iterative method.\\n```\\n\\n```\\nIf You like this pls UpVote it helps me to stay +ve and motivated\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n\\t\\tint N=stones.size();\\n\\t\\t\\n        int sum=0,diff;\\n        \\n\\t\\tfor(int i=0;i<N;i++)\\n            sum+=stones[i];\\n\\t\\t\\t\\n        int T[N+1][sum+1];\\n        \\n\\t\\t for (int i = 0; i < N + 1; ++i)  \\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < sum + 1; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tT[i][j] = 0;          //for my first row because there is no empty error whose have any sum value other than 0. \\n\\t\\t\\t    if (j == 0)     //for my first column because there is no any non +ve empty error whose have sum value eq to 0 \\n\\t\\t\\t\\t\\tT[i][j] = 1;\\n        }\\n    }\\n\\n        for (int i = 1; i < N + 1; ++i)                   \\n        {\\n            for (int j = 1; j < sum + 1; ++j)\\n            {\\n                if (stones[i - 1] <= j)      //if my weight of stone is less than corresponding weights of sum row\\n                    T[i][j] = T[i - 1][j] || T[i - 1][j - stones[i - 1]];\\n                else\\n                    T[i][j] = T[i - 1][j];\\n            }\\n        }\\n        int mn=INT_MAX;\\n\\t\\t\\n        for(int j=0;j<=sum;j++)\\n            if(T[N][j])\\n                mn=min(mn,abs(sum-2*j));\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nProblem is similar or combination of 2 or more basic problems of DP\\n1. Equal Partition Sum\\n2. Minimum Diff Subset\\n```\n```\\nGiven Problem is a combination of these 2 problems\\n```\n```\\nWHAT PROBLEM WANTS OR HOW TO SOLVE ???\\n\\nBasically we have to find minimum weight of the stones which remain after striking or return 0 if non of them remains.\\nQuestion also provides some parameters for striking \\n1. if weight of two stones is equal then they both destroys.\\n2. if there is difference in weight of there stones then subtract and smaller one get removed and larger one get updated value of there difference.\\n```\n```\\nIf i say we don\\'t require all these things, then it loos like quite interesting BUT how let me share with you.\\nIf you have done problem of Equal partition sum then you can realize it with it. In that problem we have partition the given array in such a way that the difference of 2 subset will be 0. \\nSo you can relate this problem with that. In this we also need to find two subset such that for there difference we get a minimum value. It can be 0 or anything.\\nFor that problem and solution it i am sharing the link [ https://leetcode.com/problems/partition-equal-subset-sum/discuss/1773198/cdp-problemusing-2-different-method-with-proper-explanation ]\\n\\nSo first part for partition is solved in that way next remaining part is to get that minimum difference.\\nSo first talk about little bit of maths and array partition.\\nI know i have to divide that array in two parts so to get subset which can provide the minimum difference.\\nIf i talk about the patition part, the basic subset if i get a maximum difference then i want one empty subset and one subset which contain all the element of array. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t { array }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /              \\\\\\n\\t\\t\\t\\t\\t\\t        subset 1          subset 2\\n\\t\\t\\t\\t\\t\\t\\t     \\t|                 |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tS1                S2\\nS1 is the sum of all element in subset 1.\\nS2 is the sum of all element of subset 2.\\nwe have to find \\n\\t\\t\\t\\tMinimum (S1 - S2) or (S2-S1).\\nSo to in more generalized form of it what i do i\\'ll make subset 1 of smaller element  and for subset 2 element.\\nWe can find it without doing anything.\\nBUT HOW ??\\nIts simple i know the value of the element will lie in range 0 to sum of all element.\\nBut most important thingh is that its not fix all the points between that range(in simple words my sum range ) will lie in my subset.\\nso don\\'t go recklessly.\\nI know my subset 1 element.\\nAnd i know \\n\\t\\t\\t\\tS1 + S2  = sum (range).\\nTherefore \\n\\t\\t\\t\\tS2 = sum - S1 ;\\nSo i can find that subset 2 element by just minus but that thing i don\\'t want.\\nMost Important thing i want the difference.\\nLets derive a formula for it\\nI know \\n\\t\\t\\tS2 - S1 = minimum\\nAnd i have \\n\\t\\t\\tS2 = Range - S1\\nBy using that 2 formula i can derive this \\n\\t\\t  Range - S1 - S1 = minimum.\\nTherefore \\n\\t\\t\\t Minimum = Range - 2*S1.\\nNow i have subset 1 element and the range (which is simply the sum of element).\\nAnd for S1 element we can traverse the last row of my DP matrix.\\nand get the minimum abs value of my difference.\\n```\n```\\nI am assuming that the viewer have a basic idea of DP with iterative method.\\n```\n```\\nIf You like this pls UpVote it helps me to stay +ve and motivated\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n\\t\\tint N=stones.size();\\n\\t\\t\\n        int sum=0,diff;\\n        \\n\\t\\tfor(int i=0;i<N;i++)\\n            sum+=stones[i];\\n\\t\\t\\t\\n        int T[N+1][sum+1];\\n        \\n\\t\\t for (int i = 0; i < N + 1; ++i)  \\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < sum + 1; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tT[i][j] = 0;          //for my first row because there is no empty error whose have any sum value other than 0. \\n\\t\\t\\t    if (j == 0)     //for my first column because there is no any non +ve empty error whose have sum value eq to 0 \\n\\t\\t\\t\\t\\tT[i][j] = 1;\\n        }\\n    }\\n\\n        for (int i = 1; i < N + 1; ++i)                   \\n        {\\n            for (int j = 1; j < sum + 1; ++j)\\n            {\\n                if (stones[i - 1] <= j)      //if my weight of stone is less than corresponding weights of sum row\\n                    T[i][j] = T[i - 1][j] || T[i - 1][j - stones[i - 1]];\\n                else\\n                    T[i][j] = T[i - 1][j];\\n            }\\n        }\\n        int mn=INT_MAX;\\n\\t\\t\\n        for(int j=0;j<=sum;j++)\\n            if(T[N][j])\\n                mn=min(mn,abs(sum-2*j));\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779759,
                "title": "using-subset-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(dp, -1, sizeof(dp));\\n        int sum = 0;\\n        for(auto i : stones)\\n            sum += i;\\n        \\n        int mindiff = INT_MAX;\\n        for(int i = (sum/2)+1; i >= 0; i--)     // i is sum of the partation\\n            if(SubsetSum(stones, i, 0)) \\n                mindiff = min(mindiff, abs((sum - i)-i)); \\n        \\n        return mindiff;\\n    }\\n    \\n    bool SubsetSum(vector<int>& v, int target, int i) {\\n        if(target == 0)\\n            return 1;\\n        if(i >= v.size())\\n            return 0;\\n        \\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        \\n        \\n        if(v[i] > target)\\n            return dp[i][target] = SubsetSum(v, target, i+1);\\n        return dp[i][target] = SubsetSum(v, target - v[i], i+1) || SubsetSum(v, target, i+1);\\n    }\\n    \\n    private :\\n    int dp[35][3005];\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(dp, -1, sizeof(dp));\\n        int sum = 0;\\n        for(auto i : stones)\\n            sum += i;\\n        \\n        int mindiff = INT_MAX;\\n        for(int i = (sum/2)+1; i >= 0; i--)     // i is sum of the partation\\n            if(SubsetSum(stones, i, 0)) \\n                mindiff = min(mindiff, abs((sum - i)-i)); \\n        \\n        return mindiff;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1474793,
                "title": "python-multiple-recursive-and-dp-solutions",
                "content": "__Solution 1__: Recursive solution with 2 options in each state. Either add or subtract element in `stones`. Use caching: O(sum\\\\*L).\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(csum, i):\\n            if i < 0 and csum >= 0: return csum\\n            if i < 0: return float(\\'inf\\')\\n            return min(dfs(csum+stones[i], i-1), dfs(csum-stones[i], i-1))\\n        return dfs(0, len(stones)-1)\\n```\\n__Solution 2__: Find subsequence with sum closest (and smaller) to `sum(stones)/2`. \\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return -float(\\'inf\\')\\n            if i < 0 or diff == 0: return 0 \\n            return max(stones[i] + dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        S = sum(stones)\\n        return S - int(2*dfs(S/2, len(stones)-1))\\n```\\n__Solution 3__: (alternative to solution 2). Find subsequence with sum closest (and smaller) to `sum(stones)/2`. \\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # O(sum*len(stones)) time and space\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return float(\\'inf\\')\\n            if i < 0 or diff == 0: return diff \\n            return min(dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        return int(2*dfs(sum(stones)/2, len(stones)-1))\\n ```\\n__Solution 4__: DP. Find subsequence with sum closest (and smaller) to `sum(stones)/2`. Similar to knapsack 0-1.\\n```           \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and space\\n        L = len(stones)\\n        S = sum(stones)\\n        dp = [[0]*(S//2+1) for _ in range(L+1)]\\n        for i in range(1, L+1):\\n            for j in range(1, S//2+1):\\n                if stones[i-1] <= j:\\n                    dp[i][j] = max(dp[i-1][j], stones[i-1]+dp[i-1][j-stones[i-1]])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return S -2*dp[L][-1]\\n```\\n__Solution 5__: DP but with O(sum) in space.\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and O(sum) space\\n        S = sum(stones)\\n        dp = [0]*(S//2+1)\\n        for i in range(len(stones)):\\n            for j in range(S//2, stones[i]-1, -1):\\n                    dp[j] = max(dp[j], stones[i]+dp[j-stones[i]])\\n        return S-2*dp[-1]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(csum, i):\\n            if i < 0 and csum >= 0: return csum\\n            if i < 0: return float(\\'inf\\')\\n            return min(dfs(csum+stones[i], i-1), dfs(csum-stones[i], i-1))\\n        return dfs(0, len(stones)-1)\\n```\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return -float(\\'inf\\')\\n            if i < 0 or diff == 0: return 0 \\n            return max(stones[i] + dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        S = sum(stones)\\n        return S - int(2*dfs(S/2, len(stones)-1))\\n```\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # O(sum*len(stones)) time and space\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return float(\\'inf\\')\\n            if i < 0 or diff == 0: return diff \\n            return min(dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        return int(2*dfs(sum(stones)/2, len(stones)-1))\\n ```\n```           \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and space\\n        L = len(stones)\\n        S = sum(stones)\\n        dp = [[0]*(S//2+1) for _ in range(L+1)]\\n        for i in range(1, L+1):\\n            for j in range(1, S//2+1):\\n                if stones[i-1] <= j:\\n                    dp[i][j] = max(dp[i-1][j], stones[i-1]+dp[i-1][j-stones[i-1]])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return S -2*dp[L][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1420720,
                "title": "java-bottom-up-dp-explained-using-minimum-subset-difference",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n\\n        //  Input: a, b\\n        // Smash them, answer: (a) - (b)\\n\\n        // Input: a, b, c\\n        // Smash them, answer: (a) - (b - c)\\n\\n        // Input: a, b, c, d\\n        // Smash them, answer: (a - b) - (c - d) => (a + d) - (b + c)\\n\\n        // The same property holds true if the elements are re-ordered to \\n        //          [c, a, d, b]. \\n        // Answer: (c - a) - (d - b) => (c + b) - (a + d) : this final subtraction is the last stone left\\n\\n        //we need to divide the array into two subarrays such that their diffrence is minimum\\n        //s2-s1 is minimum\\n        //s1+s2 = sum;\\n        int sum = 0;\\n        for(int stone : stones) {\\n            sum += stone;\\n        }\\n        //so we have to minimise sum-2*s1\\n        //range of s1 is from 0 to sum\\n        //so let us find all valid values of s1 such for the given stone array\\n        //this can be found using subset sum algorithm and then we can take the bottom row of the dp table to fish out the true value\\'s from it\\n        //then we can use the true values upto sum/2 since we leave the remaining valid sums for s2\\n        boolean[] s1 = subsetSum(stones, stones.length, sum);\\n        List<Integer> validS1 = new ArrayList<Integer>();\\n        for(int i = 0; i <= sum/2; i++) {\\n            if(s1[i] == true)\\n                validS1.add(i);\\n        }\\n        //now let\\'s calculate min sum-2*s1 from this\\n        int min = Integer.MAX_VALUE;\\n        for(int sum1 : validS1) {\\n            min = Math.min(min, sum - (2*sum1));\\n        }\\n        return min;\\n    }\\n    private boolean[] subsetSum(int[] stones, int n, int target) {\\n        boolean[][] dp = new boolean[n+1][target+1];\\n        for(int i = 0; i < dp.length; i++) {\\n            for(int j = 0; j < dp[i].length; j++) {\\n                if(i == 0)\\n                    dp[i][j] = false;\\n                if(j == 0)\\n                    dp[i][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[i].length; j++) {\\n                if(stones[i-1] <= j) {\\n                    dp[i][j] = dp[i-1][j-stones[i-1]] || dp[i-1][j];\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n\\n        //  Input: a, b\\n        // Smash them, answer: (a) - (b)\\n\\n        // Input: a, b, c\\n        // Smash them, answer: (a) - (b - c)\\n\\n        // Input: a, b, c, d\\n        // Smash them, answer: (a - b) - (c - d) => (a + d) - (b + c)\\n\\n        // The same property holds true if the elements are re-ordered to \\n        //          [c, a, d, b]. \\n        // Answer: (c - a) - (d - b) => (c + b) - (a + d) : this final subtraction is the last stone left\\n\\n        //we need to divide the array into two subarrays such that their diffrence is minimum\\n        //s2-s1 is minimum\\n        //s1+s2 = sum;\\n        int sum = 0;\\n        for(int stone : stones) {\\n            sum += stone;\\n        }\\n        //so we have to minimise sum-2*s1\\n        //range of s1 is from 0 to sum\\n        //so let us find all valid values of s1 such for the given stone array\\n        //this can be found using subset sum algorithm and then we can take the bottom row of the dp table to fish out the true value\\'s from it\\n        //then we can use the true values upto sum/2 since we leave the remaining valid sums for s2\\n        boolean[] s1 = subsetSum(stones, stones.length, sum);\\n        List<Integer> validS1 = new ArrayList<Integer>();\\n        for(int i = 0; i <= sum/2; i++) {\\n            if(s1[i] == true)\\n                validS1.add(i);\\n        }\\n        //now let\\'s calculate min sum-2*s1 from this\\n        int min = Integer.MAX_VALUE;\\n        for(int sum1 : validS1) {\\n            min = Math.min(min, sum - (2*sum1));\\n        }\\n        return min;\\n    }\\n    private boolean[] subsetSum(int[] stones, int n, int target) {\\n        boolean[][] dp = new boolean[n+1][target+1];\\n        for(int i = 0; i < dp.length; i++) {\\n            for(int j = 0; j < dp[i].length; j++) {\\n                if(i == 0)\\n                    dp[i][j] = false;\\n                if(j == 0)\\n                    dp[i][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[i].length; j++) {\\n                if(stones[i-1] <= j) {\\n                    dp[i][j] = dp[i-1][j-stones[i-1]] || dp[i-1][j];\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241376,
                "title": "minimum-subset-problem-dp-o-n-2-aditya-verma-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size(),m=0;\\n        \\n        for(int i=0;i<n;i++){\\n            m+=stones[i];\\n        }\\n        \\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        \\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;//as u can always have a {} subset\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(j>=stones[i-1]){//include or exclude either ways we want subset sum\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else{//exclude\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        // s1+s2=r and s1-s2=-diff then 2s1=r-diff so differetiate u get s1=r/2  r=m in this case\\n        int s1=m/2;\\n        for(int j=s1;j>=0;j--){\\n            if (dp[n][j]){//ie j is max available s1\\n                s1=j;\\n                break;\\n            } \\n        }\\n        \\n        int s2=m-s1;\\n        \\n        return s2-s1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size(),m=0;\\n        \\n        for(int i=0;i<n;i++){\\n            m+=stones[i];\\n        }\\n        \\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        \\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;//as u can always have a {} subset\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(j>=stones[i-1]){//include or exclude either ways we want subset sum\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else{//exclude\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        // s1+s2=r and s1-s2=-diff then 2s1=r-diff so differetiate u get s1=r/2  r=m in this case\\n        int s1=m/2;\\n        for(int j=s1;j>=0;j--){\\n            if (dp[n][j]){//ie j is max available s1\\n                s1=j;\\n                break;\\n            } \\n        }\\n        \\n        int s2=m-s1;\\n        \\n        return s2-s1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111561,
                "title": "my-solution-with-explanation-java-01-knapsack",
                "content": "## Explanation\\nFirst let\\'s recall what is the 01 Knapsack problem? Basically we are given two arrays weight array and value array. We are then given a MAX_CAPACITY. Our task is to find the max sum of subset of value such that the sum of weights of this subset is smaller than or equal to MAX_CAPACITY.\\n\\nNow, let\\'s come back to our [question](https://leetcode.com/problems/last-stone-weight-ii/).\\nLet\\'s say we have 4 stones, [a, b, c, d] \\n1. Smashed a and b  -->  [ a-b, c, d]\\n2. Smashed c and a-b --> [c-a+b, d]\\n3. Smashed the remaining two stones --> [c-a+b-d]\\nSo if you observe the final stone is the sum such that some of the stones have + sign and some of them have - sign. Lets say the sum1 of the stones with + sign is S1, and with - sign is S2.\\n\\nNow, \\nS1 + S2 = Total_Sum_of_Array ( say S ) ...... (1)\\nAlso our answer is S1 - S2 = diff ................... (2)\\n\\nS1 - S2 = diff ( from (2) )\\nS1 - S2 + 2xS2 - 2xS2  = diff ( adding and subtracting 2xS2)\\nS1 + S2  - 2xS2 = diff\\nS - 2xS2 = diff ( from (1) )\\nNow, our task is to minimize this diff, which is equivalent to maximizing S2 ?\\nWhat can the min value of diff be? 0 right? So what can the max value of S2 be ? S/2 !  \\n \\nWell well, isnt that the classic 01 knapsack problem? :D\\n\\n## Code\\nclass Solution {\\n    \\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        \\n        int sum = 0;\\n        for(int val:stones) sum += val;\\n        \\n        return sum - 2*knapSack(sum/2, stones, stones, stones.length);\\n        \\n    }\\n    \\n    static int knapSack(int cap, int wt[], int val[], int n){ \\n         // your code here \\n         \\n        if(n == 0) return 0;\\n         \\n\\t\\tint max = 0;\\n\\t\\tint[][] dp = new int[n][cap + 1];\\n\\n\\t\\tfor (int j = wt[0]; j <= cap; j++) {\\n\\t\\t\\tdp[0][j] = val[0];\\n\\t\\t\\tmax = Math.max(dp[0][j], max);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j <= cap; j++) {\\n\\t\\t\\t\\tif (j >= wt[i])\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - wt[i]] + val[i];\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n\\t\\t\\t\\tmax = Math.max(dp[i][j], max);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max;\\n        \\n    } \\n}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        \\n        int sum = 0;\\n        for(int val:stones) sum += val;\\n        \\n        return sum - 2*knapSack(sum/2, stones, stones, stones.length);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1013873,
                "title": "python3-top-down-dp",
                "content": "**Algo**\\nDefine `fn(i, v)` for minimum weight of `stones[i:]` given existing weight. Then, \\n\\n`fn(i, v) = min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))`.\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, v): \\n            \"\"\"Return minimum weight of stones[i:] given existing weight.\"\"\"\\n            if i == len(stones): return abs(v)\\n            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))\\n        \\n        return fn(0, 0)\\n```\\n\\n**Analysis**\\nTime complexity `O(NS)`\\nSpace complexity `O(NS)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, v): \\n            \"\"\"Return minimum weight of stones[i:] given existing weight.\"\"\"\\n            if i == len(stones): return abs(v)\\n            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))\\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971999,
                "title": "easy-to-understand-code-java",
                "content": "I think [here](https://leetcode.com/problems/last-stone-weight-ii/discuss/296350/Explaining-why-this-problem-is-equals-to-finding-the-difference-between-the-sum-of-two-groups) it\\'s properly explained why this problem is same as finding minimum difference between the sum of two groups. \\n```\\nclass Solution {\\n    int totalSum;\\n    public int lastStoneWeightII(int[] stones) {\\n        totalSum = 0;\\n        for(int x : stones)\\n            totalSum += x;\\n        return helper(stones, 0, 0, new Integer[stones.length+1][stones.length*100+1]);\\n    }\\n\\t// currWeight : current sum of first subset\\n    public int helper(int[] stones, int index, int currWeight, Integer[][] dp) {\\n        if(dp[index][currWeight] != null)\\n            return dp[index][currWeight];\\n        int ans = 0;\\n        if(index == stones.length)\\n            ans = Math.abs(2 * currWeight - totalSum);   // difference of sums of 2 sets = Math.abs(first_sum - second_sum) = Math.abs(first_sum - (totalSum - first_sum)) = Math.abs(2 * first_sum - totalSum)\\n        else \\n            ans = Math.min(\\n                            helper(stones, index+1, currWeight, dp),\\n                            helper(stones, index+1, currWeight+stones[index], dp)\\n                            );\\n        return dp[index][currWeight] = ans;\\n    }\\n}\\n```\\nTime Complexity : O(N * N * 100)\\nSpace Complexity : O(N * N * 100)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int totalSum;\\n    public int lastStoneWeightII(int[] stones) {\\n        totalSum = 0;\\n        for(int x : stones)\\n            totalSum += x;\\n        return helper(stones, 0, 0, new Integer[stones.length+1][stones.length*100+1]);\\n    }\\n\\t// currWeight : current sum of first subset\\n    public int helper(int[] stones, int index, int currWeight, Integer[][] dp) {\\n        if(dp[index][currWeight] != null)\\n            return dp[index][currWeight];\\n        int ans = 0;\\n        if(index == stones.length)\\n            ans = Math.abs(2 * currWeight - totalSum);   // difference of sums of 2 sets = Math.abs(first_sum - second_sum) = Math.abs(first_sum - (totalSum - first_sum)) = Math.abs(2 * first_sum - totalSum)\\n        else \\n            ans = Math.min(\\n                            helper(stones, index+1, currWeight, dp),\\n                            helper(stones, index+1, currWeight+stones[index], dp)\\n                            );\\n        return dp[index][currWeight] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651894,
                "title": "memoization-based-java-solution",
                "content": "The crux of the problem revolves around finding the minimum difference between 2 subsets of the given array. Used a simple recursive helper, and the intermediately calculated sum as key for memoization.\\nHope it helps\\n\\n```\\n    public int lastStoneWeightII(int[] stones)\\n    {\\n        if(stones==null || stones.length==0)\\n            return 0;\\n        int sum=0;\\n        for(int s:stones)\\n            sum+=s;\\n\\n        return helper(stones,sum,0,0,new HashMap<Integer,Integer>());\\n    }\\n    public int helper(int[] stones, int sum, int idx, int s, Map<Integer,Integer> map)\\n    {\\n        if(idx==stones.length)\\n            return Math.abs((sum-s)-s);\\n        if(map.containsKey(s))\\n            return map.get(s);\\n        int c1=helper(stones,sum,idx+1,s+stones[idx],map);\\n        int c2=helper(stones,sum,idx+1,s,map);\\n        map.put(s,Math.min(c1,c2));\\n        return Math.min(c1,c2);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The crux of the problem revolves around finding the minimum difference between 2 subsets of the given array. Used a simple recursive helper, and the intermediately calculated sum as key for memoization.\\nHope it helps\\n\\n```\\n    public int lastStoneWeightII(int[] stones)\\n    {\\n        if(stones==null || stones.length==0)\\n            return 0;\\n        int sum=0;\\n        for(int s:stones)\\n            sum+=s;\\n\\n        return helper(stones,sum,0,0,new HashMap<Integer,Integer>());\\n    }\\n    public int helper(int[] stones, int sum, int idx, int s, Map<Integer,Integer> map)\\n    {\\n        if(idx==stones.length)\\n            return Math.abs((sum-s)-s);\\n        if(map.containsKey(s))\\n            return map.get(s);\\n        int c1=helper(stones,sum,idx+1,s+stones[idx],map);\\n        int c2=helper(stones,sum,idx+1,s,map);\\n        map.put(s,Math.min(c1,c2));\\n        return Math.min(c1,c2);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 632247,
                "title": "simple-and-clear-explanation-of-c-solution-based-on-knapsack-problem",
                "content": "\\n# A CPP Implementation of above discussed solution here\\nhttps://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here/277732\\n\\nHi! I\\'ve noticed that many solutions and not easy to understand for people like me who do not have much practice in DP, So I\\'m providing an easy to understand solution based on knapsack problem.\\nKeep Practising! Cheers!\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int w = sum/2, n = stones.size();\\n        vector<vector<int>> dp(n+1, vector<int>(w+1));\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j< w+1; j++){\\n                int withOutCurr = dp[i-1][j], withCurr = 0;\\n                if(j>=stones[i-1]){\\n                    withCurr = stones[i-1] + dp[i-1][j-stones[i-1]];\\n                }\\n                dp[i][j] = max(withOutCurr, withCurr);\\n            }\\n        }\\n        int sumA = dp[n][w], sumB = sum - sumA;\\n        return sumB - sumA;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int w = sum/2, n = stones.size();\\n        vector<vector<int>> dp(n+1, vector<int>(w+1));\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j< w+1; j++){\\n                int withOutCurr = dp[i-1][j], withCurr = 0;\\n                if(j>=stones[i-1]){\\n                    withCurr = stones[i-1] + dp[i-1][j-stones[i-1]];\\n                }\\n                dp[i][j] = max(withOutCurr, withCurr);\\n            }\\n        }\\n        int sumA = dp[n][w], sumB = sum - sumA;\\n        return sumB - sumA;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597041,
                "title": "java-recursion-with-dp",
                "content": "The idea is to put numbers into 2 diffrrent sets and minimize the diff between the sets, and the order in which the numbers are added in the set has no consequence on the final output, it only matters which number is added to which set \\nMeanwhile the number to be added cares only about the diff between the sum of two sets and tries to minimise this diff.\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int i =0;i<stones.length;i++){\\n            sum+=stones[i];\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        Integer [][] dp =  new Integer[stones.length][sum+1];\\n        int result = aux(dp,0,0,0,stones);\\n        return result;\\n    }\\n    \\n    public int aux(Integer [][] dp,int sum1, int sum2,int i,int [] stones){\\n        if(i<stones.length){\\n            if(dp[i][Math.abs(sum1-sum2)]==null){\\n                dp[i][Math.abs(sum1-sum2)]= Math.min(aux(dp,sum1+stones[i],sum2,i+1,stones),aux(dp,sum1,sum2+stones[i],i+1,stones));\\n            }return dp[i][Math.abs(sum1-sum2)];\\n        }\\n        return Math.abs(sum1-sum2);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int i =0;i<stones.length;i++){\\n            sum+=stones[i];\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        Integer [][] dp =  new Integer[stones.length][sum+1];\\n        int result = aux(dp,0,0,0,stones);\\n        return result;\\n    }\\n    \\n    public int aux(Integer [][] dp,int sum1, int sum2,int i,int [] stones){\\n        if(i<stones.length){\\n            if(dp[i][Math.abs(sum1-sum2)]==null){\\n                dp[i][Math.abs(sum1-sum2)]= Math.min(aux(dp,sum1+stones[i],sum2,i+1,stones),aux(dp,sum1,sum2+stones[i],i+1,stones));\\n            }return dp[i][Math.abs(sum1-sum2)];\\n        }\\n        return Math.abs(sum1-sum2);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561834,
                "title": "c-extremely-easy-solution-memoisation",
                "content": "First of all boiling down the prob to  -> Dividing into 2 groups such that their difference is minimum and that min. difference is the ans\\n\\nNow How ??????\\nEx: a,b,c,d are the stones, then lets say, the sequence be (c & d) then b - ( c - d ) then with a : a - ( b - ( c - d ) ) which is equal to ( a+c ) - ( b+d )\\nNow for this case  the 2 groups will be {a,c } & {b,d} and we have our ans = ( a+c ) - ( b+d );\\n\\nTo solve this we will imagine a bag of size ( SUM / 2 )  (here SUM is sum of all stones )\\nand now we want to fill the bag to the fullest :\\n\\nFor this in our reccursive function we will make 2 decisions:\\na) including the current stone in the sum \\nb) not including it in the current sum\\nAnd out out of these 2 we will return the max out of these two.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int index,int this_sum,int req,vector<int>&stones,vector<vector<int>>&dp){\\n        if(this_sum>req)\\n            return -1;\\n        if(this_sum==req)\\n            return req;\\n        if(index<0)\\n            return this_sum;\\n        int rem = req-this_sum;\\n        if(dp[index][rem]!=INT_MIN)\\n            return dp[index][rem];\\n        \\n        int ans1 = comp(index-1,this_sum+stones[index],req,stones,dp);\\n        int ans2 = comp(index-1,this_sum,req,stones,dp);\\n        \\n        dp[index][rem]=max(ans1,ans2);\\n        \\n        return dp[index][rem];\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto e:stones){\\n            sum+=e;\\n        }\\n        int req = sum/2;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(req+1,INT_MIN));\\n        int max_sum  = comp(stones.size()-1,0,req,stones,dp);\\n        return abs(sum-max_sum-max_sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int index,int this_sum,int req,vector<int>&stones,vector<vector<int>>&dp){\\n        if(this_sum>req)\\n            return -1;\\n        if(this_sum==req)\\n            return req;\\n        if(index<0)\\n            return this_sum;\\n        int rem = req-this_sum;\\n        if(dp[index][rem]!=INT_MIN)\\n            return dp[index][rem];\\n        \\n        int ans1 = comp(index-1,this_sum+stones[index],req,stones,dp);\\n        int ans2 = comp(index-1,this_sum,req,stones,dp);\\n        \\n        dp[index][rem]=max(ans1,ans2);\\n        \\n        return dp[index][rem];\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto e:stones){\\n            sum+=e;\\n        }\\n        int req = sum/2;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(req+1,INT_MIN));\\n        int max_sum  = comp(stones.size()-1,0,req,stones,dp);\\n        return abs(sum-max_sum-max_sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497742,
                "title": "java-solution-using-1d-dp-array-run-time-1ms",
                "content": "```\\n/**\\nThis Problem is similar https://leetcode.com/problems/partition-equal-subset-sum/\\n\\nHere instead of equal subset, have to find nearly equal subsets.\\nDifference between those nearly equal subset is the final answer\\n*/\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       \\n       int total = 0;\\n       for(int x: stones)\\n           total += x;\\n        \\n        int half = total/2;\\n        boolean[] dp = new boolean[half+1];\\n        dp[0] = true;\\n        \\n        for(int stone : stones){\\n            for(int sum=half; sum>=0;sum--){\\n                if(sum >= stone){\\n                    dp[sum] = dp[sum] || dp[sum-stone];\\n                }\\n            }\\n        }\\n        //Get the maximum possible partitionValue\\n        int partitionValue=0;\\n        for(int i=half;i>=0;i--){\\n            if(dp[i]){\\n               partitionValue = i;\\n               break;\\n            }\\n        }\\n        int secondHalf = total-partitionValue;\\n        return (secondHalf-partitionValue);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThis Problem is similar https://leetcode.com/problems/partition-equal-subset-sum/\\n\\nHere instead of equal subset, have to find nearly equal subsets.\\nDifference between those nearly equal subset is the final answer\\n*/\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       \\n       int total = 0;\\n       for(int x: stones)\\n           total += x;\\n        \\n        int half = total/2;\\n        boolean[] dp = new boolean[half+1];\\n        dp[0] = true;\\n        \\n        for(int stone : stones){\\n            for(int sum=half; sum>=0;sum--){\\n                if(sum >= stone){\\n                    dp[sum] = dp[sum] || dp[sum-stone];\\n                }\\n            }\\n        }\\n        //Get the maximum possible partitionValue\\n        int partitionValue=0;\\n        for(int i=half;i>=0;i--){\\n            if(dp[i]){\\n               partitionValue = i;\\n               break;\\n            }\\n        }\\n        int secondHalf = total-partitionValue;\\n        return (secondHalf-partitionValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480969,
                "title": "java-dp-solution-with-explanation",
                "content": "To find how to split, we will convert this into two arrays, such that the sum of second array is close to sum(stones) / 2, i.e we will mold this question into a 0-1Knapsack problem, where total weight we could put in knapsack would be sum(stones_weights\\')/2.\\n\\nHere 2d matrix dp[i][j] will denote the total weight we could get with i stones, and target weight j.\\nFor every stone, we could either put it in knapsack (stones[i-1] + dp[i - 1][j - stones[i-1]]) or we wont put it (dp[i - 1][j]).\\n\\nHope this helps!\\n\\n```\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        if (stones.length == 2) return Math.abs(stones[0] - stones[1]);\\n        int sum = 0;\\n        for (int n : stones) {\\n            sum += n;\\n        }\\n\\n        int target = sum / 2;\\n\\n        int[][] dp = new int[stones.length+1][target+1];\\n\\n        for (int i = 1; i <= stones.length; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (j < stones[i-1]) {\\n                    dp[i][j] = dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = Math.max(stones[i-1] + dp[i - 1][j - stones[i-1]], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        return Math.abs(sum - 2*dp[stones.length][target]);\\n    }",
                "solutionTags": [],
                "code": "To find how to split, we will convert this into two arrays, such that the sum of second array is close to sum(stones) / 2, i.e we will mold this question into a 0-1Knapsack problem, where total weight we could put in knapsack would be sum(stones_weights\\')/2.\\n\\nHere 2d matrix dp[i][j] will denote the total weight we could get with i stones, and target weight j.\\nFor every stone, we could either put it in knapsack (stones[i-1] + dp[i - 1][j - stones[i-1]]) or we wont put it (dp[i - 1][j]).\\n\\nHope this helps!\\n\\n```\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        if (stones.length == 2) return Math.abs(stones[0] - stones[1]);\\n        int sum = 0;\\n        for (int n : stones) {\\n            sum += n;\\n        }\\n\\n        int target = sum / 2;\\n\\n        int[][] dp = new int[stones.length+1][target+1];\\n\\n        for (int i = 1; i <= stones.length; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (j < stones[i-1]) {\\n                    dp[i][j] = dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = Math.max(stones[i-1] + dp[i - 1][j - stones[i-1]], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        return Math.abs(sum - 2*dp[stones.length][target]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 385784,
                "title": "the-minimum-diffenence-can-always-be-realized-through-cancelation",
                "content": "We know this problem can be solved by grouping the stones into two groups and find the minimum difference of the two groups, which can be solved by 0/1 Knapsacks DP (See https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP by lee215).\\nEvery cancellation can be transfered to the difference between two groups but the reverse is not true: not every grouping can be realized by cancellation. So how do we prove that the minimum sum difference can be realized by cancellation? I didn\\'t find any clear explanation on this. Following is my though on this.\\nSuppose the bigger group is S2 and the smaller group is S1. S is the total sum. We have\\n```\\nS = S1 + S2\\nmin(S2 - S1) -> min(S - 2 * S1) -> max(S1) while S1 <= S / 2 and S1 <= S2\\n```\\nOur goal is to maximize the smaller group and the boundary is S/2.\\nNow suppose we\\'ve found the solution.\\n`S1 = a + b + c ... + e, S2 = x + y + z` and S1 is the maximum value we can have to satisfy the conditions. Then the question becomes whether this can be realized by cancellation. \\nBefore we do that we need to think in what condition this cannot be realized by cancellation. Every element in group S1 will have a minus sign before them in the final answer, meaning each time they are smashed with another stone in group S2. If it cannot be realized by a cancellation, it means there are more than 1 stones left after all the stones in S1 have been smashed. Suppose the last stone to be smashed in S1 is c. The stones left in S2 is a, b. (a is the masimu weight stone in S2 and b is created after smashing other stones in S2 with those from S2).\\n```\\na + b >= c\\na >= b ( we should always try to pick a lighter stone in S2 to smash with stones in S1)\\n```\\nIf b > c, then there will be two stones with positive signs left so it cannot be realized by cancellation. Otherwise it can always be smashed in the way `a - (c - b)`. But if b > c then we have\\n```\\na + c >= b\\nb > c. \\n```\\nIn other words, we can move b to the right side (group S1) to make it bigger, which is conflict with our premise that S1 is the biggest one we can have. Thus b <= c and the last step can always be a smash between two stones. \\nIt\\'s kind of tricky and I am not sure if I explain it clearly or not. But hopefully it can help you to understand the question.\\nHappy coding!",
                "solutionTags": [],
                "code": "```\\nS = S1 + S2\\nmin(S2 - S1) -> min(S - 2 * S1) -> max(S1) while S1 <= S / 2 and S1 <= S2\\n```\n```\\na + b >= c\\na >= b ( we should always try to pick a lighter stone in S2 to smash with stones in S1)\\n```\n```\\na + c >= b\\nb > c. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347885,
                "title": "python-time-o-sum-stones-n-space-o-2-sum-stones",
                "content": "```python\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = set()\\n        res.add(stones[0])\\n        for n in stones[1:]:\\n            newres = set()\\n            for m in res:\\n                newres.add(n+m)\\n                newres.add(abs(n-m))\\n            res = newres\\n        return min(res)\\n```\\nIn the set, it represents all possibilities of sums of stones of final states and intermediate states. \\nSince the final state is always smaller than its intermediate states, the minimum final states is smaller than or equal to all final states and intermediate states.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = set()\\n        res.add(stones[0])\\n        for n in stones[1:]:\\n            newres = set()\\n            for m in res:\\n                newres.add(n+m)\\n                newres.add(abs(n-m))\\n            res = newres\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295759,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\npublic int lastStoneWeightII(int[] stones) {\\n\\n\\tif (stones == null || stones.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// This problem resembles 494. Target Sum\\n\\n\\t// Use the idea that we need to split array into two sets: Pos and Neg\\n\\t// and minimize the difference: Pos - Neg = diff\\n\\t// Also, we know Pos + Neg = Sum, where Sum is the sum of all elements.\\n\\t// So, we can derive diff = Sum - 2Neg. It means we need to maximize Neg.\\n\\t// Another option is diff = 2Pos - Sum and minimize Pos.\\n\\t// Note, Neg is not greater than Sum/2, let\\'s use it.\\n\\n\\t// Use dp[Sum/2 + 1] of boolean values.\\n\\t// dp[i] will hold true if this Neg value is achievable.\\n\\n\\t// calculate Sum\\n\\t// Can be combined with the next cycle\\n\\tint sum = 0;\\n\\tfor (int stone : stones) {\\n\\t\\tsum += stone;\\n\\t}\\n\\n\\tboolean[] dp = new boolean[sum/2 + 1];\\n\\tdp[0] = true; // The first achievable dp spot, but not a solution in this problem\\n\\tint minDiff = Integer.MAX_VALUE;\\n\\tfor(int stone : stones) {\\n\\t\\tfor (int j=sum/2; j>=stone; j--) {\\n\\t\\t\\tdp[j] |= dp[j-stone];\\n\\t\\t\\tif (dp[j]) {\\n\\t\\t\\t\\tminDiff = Math.min(minDiff, sum - 2*j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minDiff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeightII(int[] stones) {\\n\\n\\tif (stones == null || stones.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// This problem resembles 494. Target Sum\\n\\n\\t// Use the idea that we need to split array into two sets: Pos and Neg\\n\\t// and minimize the difference: Pos - Neg = diff\\n\\t// Also, we know Pos + Neg = Sum, where Sum is the sum of all elements.\\n\\t// So, we can derive diff = Sum - 2Neg. It means we need to maximize Neg.\\n\\t// Another option is diff = 2Pos - Sum and minimize Pos.\\n\\t// Note, Neg is not greater than Sum/2, let\\'s use it.\\n\\n\\t// Use dp[Sum/2 + 1] of boolean values.\\n\\t// dp[i] will hold true if this Neg value is achievable.\\n\\n\\t// calculate Sum\\n\\t// Can be combined with the next cycle\\n\\tint sum = 0;\\n\\tfor (int stone : stones) {\\n\\t\\tsum += stone;\\n\\t}\\n\\n\\tboolean[] dp = new boolean[sum/2 + 1];\\n\\tdp[0] = true; // The first achievable dp spot, but not a solution in this problem\\n\\tint minDiff = Integer.MAX_VALUE;\\n\\tfor(int stone : stones) {\\n\\t\\tfor (int j=sum/2; j>=stone; j--) {\\n\\t\\t\\tdp[j] |= dp[j-stone];\\n\\t\\t\\tif (dp[j]) {\\n\\t\\t\\t\\tminDiff = Math.min(minDiff, sum - 2*j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minDiff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294984,
                "title": "python-randomness-is-your-friend",
                "content": "The maximum length of input is 30 and the maximum of each element is 100.\\n\\nSo it\\'s reasonable to solve by randomness.\\n\\nIt doesn\\'t guarentee the method will pass everytime.\\nBut I think 500 rounds is enough to get accepted with very little risk.\\n```\\n\\tdef lastStoneWeightII(self, stones):\\n        \\n        mini = 9999\\n        \\n        # try 500 rounds\\n        for r in range(500):\\n            s = list(stones)\\n            while len(s)>1:\\n                # pick index\\n                [x,y] = random.sample(range(len(s)), 2)\\n\\n                x = s[x]\\n                y = s[y]\\n\\n                s.remove(x)\\n                s.remove(y)\\n                if x!=y:\\n                    s.append(abs(x-y))\\n            \\n            if s:\\n                mini = min(mini,s[0])\\n            else:\\n                return 0\\n            \\n        return mini",
                "solutionTags": [],
                "code": "The maximum length of input is 30 and the maximum of each element is 100.\\n\\nSo it\\'s reasonable to solve by randomness.\\n\\nIt doesn\\'t guarentee the method will pass everytime.\\nBut I think 500 rounds is enough to get accepted with very little risk.\\n```\\n\\tdef lastStoneWeightII(self, stones):\\n        \\n        mini = 9999\\n        \\n        # try 500 rounds\\n        for r in range(500):\\n            s = list(stones)\\n            while len(s)>1:\\n                # pick index\\n                [x,y] = random.sample(range(len(s)), 2)\\n\\n                x = s[x]\\n                y = s[y]\\n\\n                s.remove(x)\\n                s.remove(y)\\n                if x!=y:\\n                    s.append(abs(x-y))\\n            \\n            if s:\\n                mini = min(mini,s[0])\\n            else:\\n                return 0\\n            \\n        return mini",
                "codeTag": "Python3"
            },
            {
                "id": 294882,
                "title": "simple-brute-force-approach",
                "content": "This question is equivalent to [Partition a set into two subsets such that the difference of subset sums is minimum.\\n](https://www.geeksforgeeks.org/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/) \\n\\nFor example, we take array [2,3,3,2,5]. We parition it into two sets  [2,3,2] and [3,5], with sum 7 and 8 respectively. If we have collision with numbers from set 1 with those of set 2, only 7~8=1 will remain.\\n\\nWe have only 30 stones with maximum weight of 100 each. So, total weight will be between 1 to 3000. Since only 3000 possible weights for set 1, so We can apply brute force approach to calculate list of all possible weights of set 1. \\n\\nWeight for set 2 is  (total weight- weight of set 1). \\n\\nThen minimum difference between set 1 and set 2 can be found iteratively.\\n\\n```\\n\\tint lastStoneWeightII(vector<int>& stones) {\\n        \\n        /* total weight of stones */\\n        int total=std::accumulate(stones.begin(),stones.end(),0);\\n        \\n        /* all possible weight of set 1 */\\n        std::unordered_set<int> weights;\\n        \\n        /* brute force approach to calculate all possible weight */\\n        for(int n:stones){\\n            std::unordered_set<int> temp=weights;\\n            temp.insert(n);\\n            \\n\\t\\t\\t/* add new stone weight to previous set of weights */\\n            for(int weight:weights){\\n                temp.insert(weight+n);\\n            }\\n            \\n            weights=std::move(temp);\\n        }\\n        \\n        \\n        int res=INT_MAX;\\n        /* calculating minimum difference of set 1 and 2 */\\n        for(int weight:weights){\\n            res=std::min(res,std::abs(weight-(total-weight))); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint lastStoneWeightII(vector<int>& stones) {\\n        \\n        /* total weight of stones */\\n        int total=std::accumulate(stones.begin(),stones.end(),0);\\n        \\n        /* all possible weight of set 1 */\\n        std::unordered_set<int> weights;\\n        \\n        /* brute force approach to calculate all possible weight */\\n        for(int n:stones){\\n            std::unordered_set<int> temp=weights;\\n            temp.insert(n);\\n            \\n\\t\\t\\t/* add new stone weight to previous set of weights */\\n            for(int weight:weights){\\n                temp.insert(weight+n);\\n            }\\n            \\n            weights=std::move(temp);\\n        }\\n        \\n        \\n        int res=INT_MAX;\\n        /* calculating minimum difference of set 1 and 2 */\\n        for(int weight:weights){\\n            res=std::min(res,std::abs(weight-(total-weight))); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638604,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = 0;\\n        for (int stone : stones) {\\n            sum += stone;\\n        }\\n        \\n        boolean[] dp = new boolean[sum / 2 + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stone = stones[i];\\n            for (int j = sum / 2; j >= stone; j--) {\\n                if (dp[j - stone]) {\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        \\n        int i = sum / 2;\\n        while (i >= 0 && !dp[i]) {\\n            i--;\\n        }\\n        \\n        return sum - 2 * i;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = 0;\\n        for (int stone : stones) {\\n            sum += stone;\\n        }\\n        \\n        boolean[] dp = new boolean[sum / 2 + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stone = stones[i];\\n            for (int j = sum / 2; j >= stone; j--) {\\n                if (dp[j - stone]) {\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        \\n        int i = sum / 2;\\n        while (i >= 0 && !dp[i]) {\\n            i--;\\n        }\\n        \\n        return sum - 2 * i;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555831,
                "title": "c-dp-knapsack-variation-subset-sum-variation",
                "content": "# Approach\\nFind the maximum subset sum close to **(sum of all elements)/2**. As there will be some stones which will add their value and some which will subtract their value hence in order to minimize the final stone weight we need to divide the stones array into two subsets, one with maximum positive sum less than or equal to **(sum of all)/2**. And finally we will subtract the subset sum from total sum which will give us the negative subset sum i.e. the stones whose values will be subtracted. We will finally subtract that value from the positive subset sum which will give us the final answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[3001][31];\\n    int solve(int idx,int w,vector<int>& stones)\\n    {\\n        if(idx<0 || w==0)\\n        return 0;\\n        if(dp[w][idx]!=-1)\\n        return dp[w][idx];\\n        int take = 0,notTake = 0;\\n        if(w-stones[idx]>=0)\\n        take = stones[idx]+solve(idx-1,w-stones[idx],stones);\\n        notTake = solve(idx-1,w,stones);\\n        return dp[w][idx] = max(take,notTake);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto &i:stones)\\n        sum+=i;\\n        int n = stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum1 = solve(n-1,sum/2,stones);\\n        return (sum-2*sum1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[3001][31];\\n    int solve(int idx,int w,vector<int>& stones)\\n    {\\n        if(idx<0 || w==0)\\n        return 0;\\n        if(dp[w][idx]!=-1)\\n        return dp[w][idx];\\n        int take = 0,notTake = 0;\\n        if(w-stones[idx]>=0)\\n        take = stones[idx]+solve(idx-1,w-stones[idx],stones);\\n        notTake = solve(idx-1,w,stones);\\n        return dp[w][idx] = max(take,notTake);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto &i:stones)\\n        sum+=i;\\n        int n = stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum1 = solve(n-1,sum/2,stones);\\n        return (sum-2*sum1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103982,
                "title": "c-recursion-memoization-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecusion + Memoization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will check every possible combination.\\n- take one time in a positve side. \\n- another time in a negative side.\\n- given constraints are 1 <= stones.length <= 30 & 1 <= stones[i] <= 100\\n- max. and min. value can be 30*(100) & 30*(-100) -> 3000 to -3000\\n- that is why dp vector is (n+1)*(6000)\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*(3000))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*6000 + runtime stack)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nint solve(vector<int>& stones,int idx,int value,vector<vector<int>>& dp){\\n    //base case\\n    if(idx==stones.size()){\\n        if(value<0)return 1e9;\\n        return 0;\\n    }\\n    // value can be -3000 to +3000 that is why [value + 3000] \\n    if(dp[idx][value+3000]!=-1)return dp[idx][value+3000];\\n    //condition\\n    int ans1 = stones[idx] + solve(stones,idx+1,value+stones[idx],dp);\\n    int ans2 = -stones[idx] + solve(stones,idx+1,value-stones[idx],dp);\\n    return dp[idx][value+3000] = min(ans1,ans2);\\n}\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int>(6000,-1));\\n        return solve(stones,0,0,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nint solve(vector<int>& stones,int idx,int value,vector<vector<int>>& dp){\\n    //base case\\n    if(idx==stones.size()){\\n        if(value<0)return 1e9;\\n        return 0;\\n    }\\n    // value can be -3000 to +3000 that is why [value + 3000] \\n    if(dp[idx][value+3000]!=-1)return dp[idx][value+3000];\\n    //condition\\n    int ans1 = stones[idx] + solve(stones,idx+1,value+stones[idx],dp);\\n    int ans2 = -stones[idx] + solve(stones,idx+1,value-stones[idx],dp);\\n    return dp[idx][value+3000] = min(ans1,ans2);\\n}\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int>(6000,-1));\\n        return solve(stones,0,0,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564431,
                "title": "c-recursion-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int minWeight(vector<int> &stones, int index, int weight_one, int weight_two, vector<vector<int>> &memo) {\\n        if(index >= stones.size()) \\n            return abs(weight_one - weight_two);\\n        \\n        if(memo[index][abs(weight_one - weight_two)] != -1)\\n            return memo[index][abs(weight_one - weight_two)];\\n        \\n        int option_one = minWeight(stones, index + 1, weight_one + stones.at(index), weight_two, memo);\\n        int option_two = minWeight(stones, index + 1, weight_one, weight_two + stones.at(index), memo);\\n        \\n        return memo[index][abs(weight_one - weight_two)] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> memo(stones.size(), vector<int>(stones.size() * 100 + 1, -1));\\n        \\n        return minWeight(stones, 0, 0, 0, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int minWeight(vector<int> &stones, int index, int weight_one, int weight_two, vector<vector<int>> &memo) {\\n        if(index >= stones.size()) \\n            return abs(weight_one - weight_two);\\n        \\n        if(memo[index][abs(weight_one - weight_two)] != -1)\\n            return memo[index][abs(weight_one - weight_two)];\\n        \\n        int option_one = minWeight(stones, index + 1, weight_one + stones.at(index), weight_two, memo);\\n        int option_two = minWeight(stones, index + 1, weight_one, weight_two + stones.at(index), memo);\\n        \\n        return memo[index][abs(weight_one - weight_two)] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> memo(stones.size(), vector<int>(stones.size() * 100 + 1, -1));\\n        \\n        return minWeight(stones, 0, 0, 0, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221189,
                "title": "c-solution-with-explanation",
                "content": "Transfer the question into a 0/1 knapsack problem:\\n\\nThe process that we are smashing 2 stones each time and put back repeatedly, is equivalent to find difference between total weights of two subsets of stones. The smallest left stone weight is transfered to \"find the smallest difference between the 2 subsets\\' weights\".\\n\\n\\nBy knowing the total wieght of given list of stone \"*W*\", the question can be further transfer to: find a subset of stones, such that the subset\\'s total weight is closest to the *W/2* (but no larger than it).\\n\\nThe result is simply \\n> *2 x difference between the W/2 and the closest weight you just found*.\\n\\n\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int total_weight = 0;\\n        for(int stone: stones) {\\n            total_weight += stone;\\n        }\\n\\t\\tint target_weight = total_weight/2;\\n\\n        int memo[stones.size() + 1][target_weight + 1];\\n        memset(memo, 0, sizeof(memo));\\n        \\n        for(int i = 1; i <= stones.size(); i++) {\\n            for(int j = 1; j <= target_weight; j++) {\\n                int curr_weight = stones[i - 1];\\n                if(curr_weight > j) { \\n                    memo[i][j] = memo[i - 1][j];\\n                    continue;\\n                }       \\n                memo[i][j] = max(memo[i - 1][j], memo[i - 1][j - curr_weight] + curr_weight);\\n            }\\n        }\\n        return total_weight - memo[stones.size() ][target_weight]*2;\\n    }\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Transfer the question into a 0/1 knapsack problem:\\n\\nThe process that we are smashing 2 stones each time and put back repeatedly, is equivalent to find difference between total weights of two subsets of stones. The smallest left stone weight is transfered to \"find the smallest difference between the 2 subsets\\' weights\".\\n\\n\\nBy knowing the total wieght of given list of stone \"*W*\", the question can be further transfer to: find a subset of stones, such that the subset\\'s total weight is closest to the *W/2* (but no larger than it).\\n\\nThe result is simply \\n> *2 x difference between the W/2 and the closest weight you just found*.\\n\\n\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int total_weight = 0;\\n        for(int stone: stones) {\\n            total_weight += stone;\\n        }\\n\\t\\tint target_weight = total_weight/2;\\n\\n        int memo[stones.size() + 1][target_weight + 1];\\n        memset(memo, 0, sizeof(memo));\\n        \\n        for(int i = 1; i <= stones.size(); i++) {\\n            for(int j = 1; j <= target_weight; j++) {\\n                int curr_weight = stones[i - 1];\\n                if(curr_weight > j) { \\n                    memo[i][j] = memo[i - 1][j];\\n                    continue;\\n                }       \\n                memo[i][j] = max(memo[i - 1][j], memo[i - 1][j - curr_weight] + curr_weight);\\n            }\\n        }\\n        return total_weight - memo[stones.size() ][target_weight]*2;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2116046,
                "title": "c-easy-to-undestand-simple-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int total;\\n    int solve(vector<int> &v,int i,int n,int sum,vector<vector<int> > &memo)\\n    {\\n        if(i==n)\\n        {\\n            return abs(total-2*sum);\\n        }\\n        if(memo[i][sum]!=-1)\\n        {\\n            return memo[i][sum];\\n        }\\n        int pick,nonpick;\\n        pick=solve(v,i+1,n,sum+v[i],memo);\\n        nonpick=solve(v,i+1,n,sum,memo);\\n        return memo[i][sum]=min(pick,nonpick);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        total=accumulate(stones.begin(),stones.end(),0);\\n        vector<vector<int> > memo(n+1,vector<int>(3001,-1));\\n        return solve(stones,0,n,0,memo);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int total;\\n    int solve(vector<int> &v,int i,int n,int sum,vector<vector<int> > &memo)\\n    {\\n        if(i==n)\\n        {\\n            return abs(total-2*sum);\\n        }\\n        if(memo[i][sum]!=-1)\\n        {\\n            return memo[i][sum];\\n        }\\n        int pick,nonpick;\\n        pick=solve(v,i+1,n,sum+v[i],memo);\\n        nonpick=solve(v,i+1,n,sum,memo);\\n        return memo[i][sum]=min(pick,nonpick);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        total=accumulate(stones.begin(),stones.end(),0);\\n        vector<vector<int> > memo(n+1,vector<int>(3001,-1));\\n        return solve(stones,0,n,0,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833304,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        vector <vector <int>> dp (n + 1, vector <int> (sum + 1, 0));\\n        // dp[index][target] -> maximum value <= target upto index\\n        \\n        for(int i = 1 ; i < n + 1 ; i ++){\\n            for (int j = 1 ; j < sum + 1; j ++){\\n                 \\n                    int not_consider = dp[i-1][j];\\n                    int consider = 0;\\n                    if( stones[i - 1] <= j) \\n                        consider = stones[i-1] + dp[i-1][j - stones[i- 1]];\\n                    dp[i][j] = max(consider, not_consider);\\n                \\n            }\\n        }\\n\\n        int target = sum / 2;\\n        return sum - (2 *dp[n][target]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        vector <vector <int>> dp (n + 1, vector <int> (sum + 1, 0));\\n        // dp[index][target] -> maximum value <= target upto index\\n        \\n        for(int i = 1 ; i < n + 1 ; i ++){\\n            for (int j = 1 ; j < sum + 1; j ++){\\n                 \\n                    int not_consider = dp[i-1][j];\\n                    int consider = 0;\\n                    if( stones[i - 1] <= j) \\n                        consider = stones[i-1] + dp[i-1][j - stones[i- 1]];\\n                    dp[i][j] = max(consider, not_consider);\\n                \\n            }\\n        }\\n\\n        int target = sum / 2;\\n        return sum - (2 *dp[n][target]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668115,
                "title": "c-detail-explanation-dp-approach",
                "content": "```\\n// Idea:\\n// We can approach this question from a greedy POV.\\n//\\n// Let\\'s say we have 2 stones, to have the minimum remaining weight\\n// the two stones should have as little weight difference as possible.\\n//\\n// How about 3 stones? We should seperate the stones into 2 set so that\\n// the difference between the sets are minimal.\\n//     e.g. [1,2,3] -> [1,2] [3], result = 0\\n//\\n// Now we start to see that our goal is to divide the stones into 2 sets,\\n// let\\'s say S1 and S2, where the total weights of S1 is smaller or equal\\n// to half of the total weight. For easier implementation, we choose S1.\\n//\\n// The problem then boils down to how we can find a subset of stones that\\n// has the cloest sum to totalWeight / 2. Note that in case where totalWeight\\n// is odd, stones can never cancel out and at least have a subset weight\\n// difference of 1, so we will still take totalWeight / 2 as our goal.\\n//\\n// Let\\'s say we have a set of [1,2,3]. Our goal is to pick a subset of rocks\\n// haveing weight = 6 / 2 = 3.\\n//\\n// First we build a DP, where each slot represents a possible subset weight\\n// up to half of total weight, init slot 0 as True since we don\\'t need rocks\\n// to reach weight = 0.\\n//\\n// Note that for subsets, we care about combination rather than permutation,\\n// so the order of rocks we pick is irrelavent to the result.\\n//\\n// dp 0 1 2 3\\n//    T F F F\\n//\\n// Let\\'s throw rock with weight = 1 into the subset. Based on our initial case\\n// we know that a subset of 0 rocks have weight of zero. Based on this, we can\\n// calculate subset with 1 rock, where rock weight = 1.\\n//\\n// dp 0 1 2 3\\n//    T T F F\\n//\\n// For the second rock, we pick rock with weight = 2. We know the base case of\\n// 0 rocks = 0 weight, and 1 rock = 1 weight. Based on the calculated result\\n// we know the subset weight of 1 rock where rock weight = 2 and 2 rocks where\\n// rock weight = 1 + 2. i.e.\\n//\\n// dp 0 1 2 3\\n//    T T T T\\n//\\n// Note that our subset weight can reach totalWeight / 2. Thus our result is 0.\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n\\n        int totalWeight = 0;\\n        int halfWeight;\\n        for (int &eachS : stones) {\\n            totalWeight += eachS;\\n        }\\n        \\n        halfWeight = (totalWeight >> 1);\\n        \\n        vector<bool> dp (halfWeight + 1, false); // O(W) space\\n        dp[0] = true; // base case\\n        \\n        // O(NW) time\\n        for (int i = 0; i < stones.size(); i++) {\\n            if (stones[i] > halfWeight) continue;\\n            for (int j = halfWeight; j >= stones[i]; j--) {\\n                if (dp[j - stones[i]]) dp[j] = true;\\n            }\\n        }\\n        \\n        int cloestWeight = halfWeight;\\n        while (!dp[cloestWeight]) {\\n            cloestWeight--;\\n        }\\n        \\n        return totalWeight - (cloestWeight << 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Idea:\\n// We can approach this question from a greedy POV.\\n//\\n// Let\\'s say we have 2 stones, to have the minimum remaining weight\\n// the two stones should have as little weight difference as possible.\\n//\\n// How about 3 stones? We should seperate the stones into 2 set so that\\n// the difference between the sets are minimal.\\n//     e.g. [1,2,3] -> [1,2] [3], result = 0\\n//\\n// Now we start to see that our goal is to divide the stones into 2 sets,\\n// let\\'s say S1 and S2, where the total weights of S1 is smaller or equal\\n// to half of the total weight. For easier implementation, we choose S1.\\n//\\n// The problem then boils down to how we can find a subset of stones that\\n// has the cloest sum to totalWeight / 2. Note that in case where totalWeight\\n// is odd, stones can never cancel out and at least have a subset weight\\n// difference of 1, so we will still take totalWeight / 2 as our goal.\\n//\\n// Let\\'s say we have a set of [1,2,3]. Our goal is to pick a subset of rocks\\n// haveing weight = 6 / 2 = 3.\\n//\\n// First we build a DP, where each slot represents a possible subset weight\\n// up to half of total weight, init slot 0 as True since we don\\'t need rocks\\n// to reach weight = 0.\\n//\\n// Note that for subsets, we care about combination rather than permutation,\\n// so the order of rocks we pick is irrelavent to the result.\\n//\\n// dp 0 1 2 3\\n//    T F F F\\n//\\n// Let\\'s throw rock with weight = 1 into the subset. Based on our initial case\\n// we know that a subset of 0 rocks have weight of zero. Based on this, we can\\n// calculate subset with 1 rock, where rock weight = 1.\\n//\\n// dp 0 1 2 3\\n//    T T F F\\n//\\n// For the second rock, we pick rock with weight = 2. We know the base case of\\n// 0 rocks = 0 weight, and 1 rock = 1 weight. Based on the calculated result\\n// we know the subset weight of 1 rock where rock weight = 2 and 2 rocks where\\n// rock weight = 1 + 2. i.e.\\n//\\n// dp 0 1 2 3\\n//    T T T T\\n//\\n// Note that our subset weight can reach totalWeight / 2. Thus our result is 0.\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n\\n        int totalWeight = 0;\\n        int halfWeight;\\n        for (int &eachS : stones) {\\n            totalWeight += eachS;\\n        }\\n        \\n        halfWeight = (totalWeight >> 1);\\n        \\n        vector<bool> dp (halfWeight + 1, false); // O(W) space\\n        dp[0] = true; // base case\\n        \\n        // O(NW) time\\n        for (int i = 0; i < stones.size(); i++) {\\n            if (stones[i] > halfWeight) continue;\\n            for (int j = halfWeight; j >= stones[i]; j--) {\\n                if (dp[j - stones[i]]) dp[j] = true;\\n            }\\n        }\\n        \\n        int cloestWeight = halfWeight;\\n        while (!dp[cloestWeight]) {\\n            cloestWeight--;\\n        }\\n        \\n        return totalWeight - (cloestWeight << 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636900,
                "title": "py3-last-stone-wt",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        ans = float(\\'inf\\')\\n        @cache\\n        def dp(i,A):\\n            nonlocal ans\\n            \\n            if i == len(stones):\\n                if A >= 0: ans = min(ans, A)\\n                return\\n            \\n            dp(i+1, A+stones[i])\\n            dp(i+1, A-stones[i])\\n        \\n        dp(0,0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        ans = float(\\'inf\\')\\n        @cache\\n        def dp(i,A):\\n            nonlocal ans\\n            \\n            if i == len(stones):\\n                if A >= 0: ans = min(ans, A)\\n                return\\n            \\n            dp(i+1, A+stones[i])\\n            dp(i+1, A-stones[i])\\n        \\n        dp(0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631347,
                "title": "java-3-sloutions-top-down-recursive-bottom-up-dp-meet-in-the-middle-commented",
                "content": "# Time complexity comparisions-\\n**Source**- https://www.baeldung.com/cs/subset-of-numbers-closest-to-target\\n\\n![image](https://assets.leetcode.com/users/images/fb971567-79a1-4507-972b-c0878a2ed67c_1639655221.249506.png)\\n\\n*The dynamic programming may sound like the best solution with the lowest complexity. However, keep in mind that the dynamic programming solution is related to k. On the other hand, the backtracking and the meet-in-the-middle approaches are not related to k.*\\n\\n*The backtracking and the meet-in-the-middle approaches are better used when the value of k is considerable. On the contrary, if the value of k is small, the dynamic programming approach is considered a better option.*\\n\\n**For more details on meet in the middle algo please have a look at this-**https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/discuss/1622681/java-detailed-explanation-with-intuition-meet-in-the-middle-similar-questions\\n\\n# Top Down with Memoization\\n\\n```\\n// Java Top down recursive soltuion\\n// similar to knapsack problem\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\nclass Solution {\\n    Integer[][] dp;\\n    private int findLowerBoundTargetSum(int[] stones,int target, int start,int currSum){\\n        if(start==stones.length){\\n            return currSum;\\n        }\\n        if(dp[start][currSum]!=null){\\n            return dp[start][currSum];\\n        }\\n        \\n        if(stones[start]+currSum>target){\\n            return dp[start][currSum]=findLowerBoundTargetSum(stones,target,start+1,currSum);\\n        }else{\\n            return dp[start][currSum]=Math.max(findLowerBoundTargetSum(stones,target,start+1,currSum+stones[start]),\\n                                          findLowerBoundTargetSum(stones,target,start+1,currSum));\\n        }\\n        \\n    }\\n    public int lastStoneWeightII(int[] stones) {\\n        int n= stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // since we have to minimize the diff bw two subset sums\\n        // ideal subset sums=sum/2, we wll try to find a sum from the subsets which is\\n        // as close to sum/2 as possible=lower bound of sum/2\\n        \\n        // then S2-S1--> we need to minimize, S1+S2=sum, S2=sum-S1 -> minimize Sum-2S1\\n        int target=(sum>>1);\\n        dp=new Integer[n][(sum>>1)+1];\\n        int maxSum=findLowerBoundTargetSum(stones,target,0,0);\\n        return sum-2*maxSum;\\n    }\\n}\\n```\\n\\n# Bottom up DP\\n```\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\n// same as subset sum diff- minimize TotalSum-2S1\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n=stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // we have enumerated all the vlaues till sum/2 and find what is the\\n        // sum value we have for all our array elements which is as close to sum/2\\n        // or is sum/2\\n        boolean[][] dp=new boolean[n+1][sum/2+1];\\n        \\n        // when sum is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;\\n        }\\n        \\n        // here the last row tells us that if that particular sum exist for all the\\n        // elements of out array.\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=sum/2;j++){\\n                if(j<stones[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<=sum/2;i++){\\n            if(dp[n][i]){// sum exixts\\n                min=Math.min(min,sum-2*i);// take the max sum\\n            }\\n        }\\n        return min;\\n    }\\n    \\n}\\n```\\n\\n# Meet in the middle\\n```\\n// meet in the middle approach\\n// 2^20~10^6, 10^8=1 sec, so 40*2^20~10^7 so good to go for n<=50\\n// Tc- o(2^n/2*n)\\n// Space-0(2^n/2+2^n/2)\\nclass Solution {\\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i : set1) {\\n\\t\\t\\t// lower bound using binary search\\n\\t\\t\\tint posi = Arrays.binarySearch(set2, target - i);\\n\\t\\t\\tif (posi < 0) {\\n\\t\\t\\t\\tint pos = -1 * (posi + 1);\\n\\t\\t\\t\\tint low = pos - 1;\\n\\t\\t\\t\\tif (low >= 0) {\\n\\t\\t\\t\\t\\tmax = Math.max(max, set2[low] + i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax = Math.max(max, set2[posi] + i);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\\n\\n# Another way of using binary search for finding lower bound\\n```\\n// meet in the middle approach\\nclass Solution {\\n    \\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int set1Num : set1) {\\n\\t\\t\\tint low = 0, high = set2.length - 1;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\t\\tif (set1Num + set2[mid] <= target) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, set1Num + set2[mid]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\n// Java Top down recursive soltuion\\n// similar to knapsack problem\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\nclass Solution {\\n    Integer[][] dp;\\n    private int findLowerBoundTargetSum(int[] stones,int target, int start,int currSum){\\n        if(start==stones.length){\\n            return currSum;\\n        }\\n        if(dp[start][currSum]!=null){\\n            return dp[start][currSum];\\n        }\\n        \\n        if(stones[start]+currSum>target){\\n            return dp[start][currSum]=findLowerBoundTargetSum(stones,target,start+1,currSum);\\n        }else{\\n            return dp[start][currSum]=Math.max(findLowerBoundTargetSum(stones,target,start+1,currSum+stones[start]),\\n                                          findLowerBoundTargetSum(stones,target,start+1,currSum));\\n        }\\n        \\n    }\\n    public int lastStoneWeightII(int[] stones) {\\n        int n= stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // since we have to minimize the diff bw two subset sums\\n        // ideal subset sums=sum/2, we wll try to find a sum from the subsets which is\\n        // as close to sum/2 as possible=lower bound of sum/2\\n        \\n        // then S2-S1--> we need to minimize, S1+S2=sum, S2=sum-S1 -> minimize Sum-2S1\\n        int target=(sum>>1);\\n        dp=new Integer[n][(sum>>1)+1];\\n        int maxSum=findLowerBoundTargetSum(stones,target,0,0);\\n        return sum-2*maxSum;\\n    }\\n}\\n```\n```\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\n// same as subset sum diff- minimize TotalSum-2S1\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n=stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // we have enumerated all the vlaues till sum/2 and find what is the\\n        // sum value we have for all our array elements which is as close to sum/2\\n        // or is sum/2\\n        boolean[][] dp=new boolean[n+1][sum/2+1];\\n        \\n        // when sum is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;\\n        }\\n        \\n        // here the last row tells us that if that particular sum exist for all the\\n        // elements of out array.\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=sum/2;j++){\\n                if(j<stones[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<=sum/2;i++){\\n            if(dp[n][i]){// sum exixts\\n                min=Math.min(min,sum-2*i);// take the max sum\\n            }\\n        }\\n        return min;\\n    }\\n    \\n}\\n```\n```\\n// meet in the middle approach\\n// 2^20~10^6, 10^8=1 sec, so 40*2^20~10^7 so good to go for n<=50\\n// Tc- o(2^n/2*n)\\n// Space-0(2^n/2+2^n/2)\\nclass Solution {\\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i : set1) {\\n\\t\\t\\t// lower bound using binary search\\n\\t\\t\\tint posi = Arrays.binarySearch(set2, target - i);\\n\\t\\t\\tif (posi < 0) {\\n\\t\\t\\t\\tint pos = -1 * (posi + 1);\\n\\t\\t\\t\\tint low = pos - 1;\\n\\t\\t\\t\\tif (low >= 0) {\\n\\t\\t\\t\\t\\tmax = Math.max(max, set2[low] + i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax = Math.max(max, set2[posi] + i);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\n```\\n// meet in the middle approach\\nclass Solution {\\n    \\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int set1Num : set1) {\\n\\t\\t\\tint low = 0, high = set2.length - 1;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\t\\tif (set1Num + set2[mid] <= target) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, set1Num + set2[mid]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575298,
                "title": "knapsack-minimum-subset-sum-difference-c-commented",
                "content": "```\\nvector<int> last_row_subset_sum(vector<int>& stones, int range){\\n        int n = stones.size();\\n        bool dp[n+1][range+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=range; j++){\\n                if(i == 0) dp[i][j] = false;\\n                if(j == 0) dp[i][j] = true;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 1; j<=range; j++){\\n                if(stones[i-1]<=j) dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                else if(stones[i-1]>j) dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        vector<int> v; //to store last row\\n        \\n        //we go to range/2 because if we go beyond range/2 we start getting redundant values for s1 as s1+s2 = range\\n        for(int i = 0; i<=range/2; i++){\\n            if(dp[n][i]) v.push_back(i);\\n        }\\n        \\n        return v;\\n        \\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n     \\n        /*Why this problem is equivalent to minimum subset sum difference?\\n        2,7,4,1,8,1 => (7-2),4,1,8,1 => (7-2-4),1,8,1 => (7-2-4-1),8,1 => (8-(7-2-4-1)),1 => (8-7+2+4+1-1) => ((8+2+4+1)-(1+7)) = 7\\n        There can be other such configurations as above. We need to find the one which gives us the minimum difference!\\n        Thus we need to partition the array in such a way so as to minimize the difference between the two subarrays*/\\n        \\n        /*  minimize(s1-s2) => minimize(range-2s1) since range = s1+s2\\n            Thus, we need to minimize s1\\n        */\\n        \\n        int range = 0 ;\\n        \\n        for(auto x : stones) range += x;\\n        \\n        //last row gives those instances from [0 to range] where it is actually possible to form a subset s1 \\n        vector<int> v = last_row_subset_sum(stones,range); \\n        \\n        //we then find at what value of s1 is the difference minimum (remember s2-s1 = range - 2s1)\\n        int mn = INT_MAX;\\n        for(auto x : v) mn = min(mn,range-2*x);\\n        \\n        return mn;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int> last_row_subset_sum(vector<int>& stones, int range){\\n        int n = stones.size();\\n        bool dp[n+1][range+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=range; j++){\\n                if(i == 0) dp[i][j] = false;\\n                if(j == 0) dp[i][j] = true;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 1; j<=range; j++){\\n                if(stones[i-1]<=j) dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                else if(stones[i-1]>j) dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        vector<int> v; //to store last row\\n        \\n        //we go to range/2 because if we go beyond range/2 we start getting redundant values for s1 as s1+s2 = range\\n        for(int i = 0; i<=range/2; i++){\\n            if(dp[n][i]) v.push_back(i);\\n        }\\n        \\n        return v;\\n        \\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n     \\n        /*Why this problem is equivalent to minimum subset sum difference?\\n        2,7,4,1,8,1 => (7-2),4,1,8,1 => (7-2-4),1,8,1 => (7-2-4-1),8,1 => (8-(7-2-4-1)),1 => (8-7+2+4+1-1) => ((8+2+4+1)-(1+7)) = 7\\n        There can be other such configurations as above. We need to find the one which gives us the minimum difference!\\n        Thus we need to partition the array in such a way so as to minimize the difference between the two subarrays*/\\n        \\n        /*  minimize(s1-s2) => minimize(range-2s1) since range = s1+s2\\n            Thus, we need to minimize s1\\n        */\\n        \\n        int range = 0 ;\\n        \\n        for(auto x : stones) range += x;\\n        \\n        //last row gives those instances from [0 to range] where it is actually possible to form a subset s1 \\n        vector<int> v = last_row_subset_sum(stones,range); \\n        \\n        //we then find at what value of s1 is the difference minimum (remember s2-s1 = range - 2s1)\\n        int mn = INT_MAX;\\n        for(auto x : v) mn = min(mn,range-2*x);\\n        \\n        return mn;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524395,
                "title": "dp-python-solution-with-small-explanation-explained",
                "content": "Looking at a few examples: \\n[1, 1] => this is obviously zero 1- 1 = 0\\n[1, 4, 2, 3] => [1, 4 | 2, 3] we are doing substraction when we combine 2 stones.  \\n\\nIn general we see that we want min(sum(subset(a)) - sum(subset(b)))\\nThis degrades to:  416. Partition Equal Subset Sum.  \\n\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        target = sum(stones) // 2\\n        can_get_value = [False] * (target + 1)\\n        can_get_value [0] = True\\n\\n        for stone in stones:\\n            for i in range(target, stone - 1, -1):\\n                can_get_value[i] |= can_get_value[i - stone]\\n\\n        i = target\\n        while i > 0:\\n            if can_get_value[i]:\\n                break\\n            i -= 1\\n\\n        return (sum(stones) - i * 2)\\n\\t\\t```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        target = sum(stones) // 2\\n        can_get_value = [False] * (target + 1)\\n        can_get_value [0] = True\\n\\n        for stone in stones:\\n            for i in range(target, stone - 1, -1):\\n                can_get_value[i] |= can_get_value[i - stone]\\n\\n        i = target\\n        while i > 0:\\n            if can_get_value[i]:\\n                break\\n            i -= 1\\n\\n        return (sum(stones) - i * 2)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1441132,
                "title": "knapsack-01-maths-explained-faster-than-100-c",
                "content": "Let me break down this question for you it is nothing but finding the minimum difference of subset sum or minimum sum partitioning.\\nSo lets say we have an array {1,6,11,5}\\nwe can write on difference as {1,5,6} {11} and the difference will be out answer.\\n\\nTo get the answer we can do thing for every single subset but the time complexity will be huge.\\nLets do it using little maths and DP.\\n\\n**Math behind the problem:**\\n* let the sum of the entire array be sum.\\n* let s1 be the subset 1 and s2 be the subset 2.\\n* s1+s2 will alway be equal to sum...\\n* lets assume that s1 is smaller than s2. So i can say that s1 will always be smaller than my total sum\\'s half.(Think about it if you don\\'t agree).\\n* So if s1 is smaller value so i can say that s1 is smaller than or equal to sum/2; (equal only when sum is even)\\n* s1+s2=sum                                  (  equation:1)\\n* s2=sum-s1         (equation:2)\\n* s1+(sum-s1)=sum  (from equation 1 and 2)\\n* so now my s1=s1 and my s2 =sum-s1\\n* so s2-s1=sum-2*s1\\n\\n\\nif you understood how i got this relation **(s2-s1=sum-2*s1)** then congratulations you understood my maths otherwise please comment you doubt.\\n\\n\\nour job is to find the minimum value of this equation.\\n\\nso we need sum and s1. \\n\\nFor finding sum just use a loop super simple.\\nfor finding s1 use subset sum knapsack problem and store if it is present obviously there will be multiple values for s1.\\nUse the equation to find the min difference.\\n\\n\\nhere is the link for the explanation of the code subset sum please check it out !!! [here](https://leetcode.com/problems/partition-equal-subset-sum/discuss/1439183/recursive-memoization-top-down-all-approaches-explained-with-code-c)\\n\\nhere is the code for what i just said.\\n```\\n int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            sum+=stones[i];\\n        }\\n        vector<int> check(sum+1,0);\\n        vector<int> pr;\\n        \\n        int n=stones.size();\\n        \\n        int dp[n+1][sum+1];\\n        int rs=sum;\\n        sum=sum/2;\\n        for(int i=0;i<sum+1;i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<=sum;i++)\\n        {\\n            \\n            if(dp[n][i]==1)\\n            {\\n                pr.push_back(i);\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<pr.size();i++)\\n        {\\n            ans=min(ans,rs-2*pr[i]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**please upvote if i made you understand the problem.\\n#happy_coding\\n**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            sum+=stones[i];\\n        }\\n        vector<int> check(sum+1,0);\\n        vector<int> pr;\\n        \\n        int n=stones.size();\\n        \\n        int dp[n+1][sum+1];\\n        int rs=sum;\\n        sum=sum/2;\\n        for(int i=0;i<sum+1;i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<=sum;i++)\\n        {\\n            \\n            if(dp[n][i]==1)\\n            {\\n                pr.push_back(i);\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<pr.size();i++)\\n        {\\n            ans=min(ans,rs-2*pr[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429854,
                "title": "detailed-explain-with-math-why-this-can-be-transfer-to-0-1-knapsack-problem",
                "content": "![image](https://assets.leetcode.com/users/images/44c91bc4-cc64-49f8-a7a5-b713c1674c4b_1630108183.9865239.png)\\n\\nThen transfer this problem to a 0 - 1 knapsack problem: fill the knapsack with the capcity equal to half the total sum of stone weight.\\n\\nhttps://en.wikipedia.org/wiki/Knapsack_problem\\n\\nFor me it\\'s hard to related this to knapsack even after looking at others\\'s explains. Hope this helps.\\n\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        m = total // 2\\n        n = len(stones)\\n        \\n        note = [[False] * (m + 1) for i in range(n + 1)]\\n        note[0][0] = True\\n        \\n        s = 0\\n        for i in range(1, n + 1):\\n            note[i][0] = True\\n            temp = stones[i - 1]\\n            for j in range(1, m +1):\\n                note[i][j] = note[i - 1][j] or (j - temp >= 0 and note[i - 1][j - temp])\\n                \\n                if j > s and note[i][j]:\\n                    s = j\\n                    \\n        return total - 2 * s",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/44c91bc4-cc64-49f8-a7a5-b713c1674c4b_1630108183.9865239.png)\\n\\nThen transfer this problem to a 0 - 1 knapsack problem: fill the knapsack with the capcity equal to half the total sum of stone weight.\\n\\nhttps://en.wikipedia.org/wiki/Knapsack_problem\\n\\nFor me it\\'s hard to related this to knapsack even after looking at others\\'s explains. Hope this helps.\\n\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        m = total // 2\\n        n = len(stones)\\n        \\n        note = [[False] * (m + 1) for i in range(n + 1)]\\n        note[0][0] = True\\n        \\n        s = 0\\n        for i in range(1, n + 1):\\n            note[i][0] = True\\n            temp = stones[i - 1]\\n            for j in range(1, m +1):\\n                note[i][j] = note[i - 1][j] or (j - temp >= 0 and note[i - 1][j - temp])\\n                \\n                if j > s and note[i][j]:\\n                    s = j\\n                    \\n        return total - 2 * s",
                "codeTag": "Java"
            },
            {
                "id": 1369499,
                "title": "simple-c-0ms-beats-100-based-on-equal-subset-sum-problem",
                "content": "If we divide array elements into two subsets :\\nWe just need to find the minimum difference between sum of those suubset elements.\\ni.e : minimum of : abs(sum(subset1) - sum(subset2))\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(),stones.end(),0);\\n        int halfSum = totalSum/2;\\n        bool dp[n+1][halfSum+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=halfSum;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = true;\\n                }\\n                else if(i==0){\\n                    dp[i][j] = false;\\n                }\\n                else if(j==0){\\n                    dp[i][j] = true;\\n                }\\n                else{\\n                    if(stones[i-1] > j){\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                    }\\n                }\\n            }\\n        }\\n        int partOne;\\n        for(int i=halfSum;i>=0;i--){\\n            if(dp[n][i] == true){\\n                partOne = i;\\n                break;\\n            }\\n        }\\n        int partTwo = totalSum - partOne;\\n        return abs(partOne-partTwo);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(),stones.end(),0);\\n        int halfSum = totalSum/2;\\n        bool dp[n+1][halfSum+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=halfSum;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = true;\\n                }\\n                else if(i==0){\\n                    dp[i][j] = false;\\n                }\\n                else if(j==0){\\n                    dp[i][j] = true;\\n                }\\n                else{\\n                    if(stones[i-1] > j){\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                    }\\n                }\\n            }\\n        }\\n        int partOne;\\n        for(int i=halfSum;i>=0;i--){\\n            if(dp[n][i] == true){\\n                partOne = i;\\n                break;\\n            }\\n        }\\n        int partTwo = totalSum - partOne;\\n        return abs(partOne-partTwo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256526,
                "title": "c-solution-using-dp-with-memoization",
                "content": "```\\nclass Solution {\\n    unordered_map<string, int> memo;\\npublic:\\n    int helper(vector<int>& stones, int idx, int currSum) {\\n        string key = to_string(idx) + \"*\" + to_string(currSum);\\n        if (idx >= stones.size())\\n            return abs(currSum);\\n\\n        if (memo.count(key)) return memo[key];\\n\\n        int currAns = 0;\\n\\n        currAns = helper(stones, idx + 1, currSum + stones[idx]);\\n        currAns = min(currAns, helper(stones, idx + 1, currSum - stones[idx]));\\n\\n        return memo[key] = currAns;\\n\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        return helper(stones, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> memo;\\npublic:\\n    int helper(vector<int>& stones, int idx, int currSum) {\\n        string key = to_string(idx) + \"*\" + to_string(currSum);\\n        if (idx >= stones.size())\\n            return abs(currSum);\\n\\n        if (memo.count(key)) return memo[key];\\n\\n        int currAns = 0;\\n\\n        currAns = helper(stones, idx + 1, currSum + stones[idx]);\\n        currAns = min(currAns, helper(stones, idx + 1, currSum - stones[idx]));\\n\\n        return memo[key] = currAns;\\n\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        return helper(stones, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226779,
                "title": "javascript-dp",
                "content": "Main idea: try to split the stones into two piles of the same weight as possible, in other word, see how much weight we can get by adding stones in a bag that has sum/2 capacity. now it becomes a 0/1 knapsack problem\\n```\\nvar lastStoneWeightII = function(stones) {\\n    var sum = stones.reduce((a, b) => a + b);\\n    var target = Math.ceil(sum / 2);\\n    var dp = new Array(target + 1).fill(0);\\n    for(var i = 0; i < stones.length; i++) {\\n        for(var j = target; j >= stones[i]; j--) {\\n            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\\n        }\\n    }\\n    return Math.abs(2 * dp[target] - sum);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastStoneWeightII = function(stones) {\\n    var sum = stones.reduce((a, b) => a + b);\\n    var target = Math.ceil(sum / 2);\\n    var dp = new Array(target + 1).fill(0);\\n    for(var i = 0; i < stones.length; i++) {\\n        for(var j = target; j >= stones[i]; j--) {\\n            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\\n        }\\n    }\\n    return Math.abs(2 * dp[target] - sum);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196755,
                "title": "python-0-1-knapsack-solution",
                "content": "The problem can be re-written as \"choose a subset of the stones in which the total weight of the subset of stones is as close to half of the weight of all the stones as possible\". This is essentially the 0/1 knapsack problem where the \"value\" and the \"weight\" of each item is the same and the \"max weight\" is half of the total weight of the stones \\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        def knapsack(items, max_weight):\\n            dp = [[0 for i in range(max_weight+1)] for j in range(len(items))]\\n            for i,item in enumerate(items):\\n                for weight in range(max_weight+1):\\n                    if item <= weight:\\n                        dp[i][weight] = max(dp[i-1][weight], dp[i-1][weight-item]+item)\\n                    else:\\n                        dp[i][weight] = dp[i-1][weight]\\n            return dp[-1][-1]\\n\\t\\t\\t\\n        s = sum(stones)\\n        return s - 2*knapsack(stones,s//2) \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        def knapsack(items, max_weight):\\n            dp = [[0 for i in range(max_weight+1)] for j in range(len(items))]\\n            for i,item in enumerate(items):\\n                for weight in range(max_weight+1):\\n                    if item <= weight:\\n                        dp[i][weight] = max(dp[i-1][weight], dp[i-1][weight-item]+item)\\n                    else:\\n                        dp[i][weight] = dp[i-1][weight]\\n            return dp[-1][-1]\\n\\t\\t\\t\\n        s = sum(stones)\\n        return s - 2*knapsack(stones,s//2) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107526,
                "title": "0-ms-faster-than-100-00-of-c-knapsack-problem-breakdown-into-subset-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int range=0;\\n        for(auto a: stones){\\n            range+=a;\\n        }\\n        bool dp[n+1][range+1];\\n        for(int i=0;i<=n;i++){\\n         for(int j=0;j<=range;j++){\\n            if(i==0) dp[i][j]=false;\\n            if(j==0) dp[i][j]=true;\\n          }   \\n        }\\n        for(int i=1;i<=n;i++){\\n         for(int j=1;j<=range;j++){\\n            if(stones[i-1]<=j) dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n             else dp[i][j]=dp[i-1][j];\\n          }   \\n        }\\n        vector<int>v;\\n        for(int j=0;j<=range;j++){\\n            if(dp[n][j]==true) v.push_back(j);\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0;i<v.size();i++){\\n            mn=min(mn,abs(range-2*v[i]));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int range=0;\\n        for(auto a: stones){\\n            range+=a;\\n        }\\n        bool dp[n+1][range+1];\\n        for(int i=0;i<=n;i++){\\n         for(int j=0;j<=range;j++){\\n            if(i==0) dp[i][j]=false;\\n            if(j==0) dp[i][j]=true;\\n          }   \\n        }\\n        for(int i=1;i<=n;i++){\\n         for(int j=1;j<=range;j++){\\n            if(stones[i-1]<=j) dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n             else dp[i][j]=dp[i-1][j];\\n          }   \\n        }\\n        vector<int>v;\\n        for(int j=0;j<=range;j++){\\n            if(dp[n][j]==true) v.push_back(j);\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0;i<v.size();i++){\\n            mn=min(mn,abs(range-2*v[i]));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088727,
                "title": "javascript-easy-knapsack-dp",
                "content": "I think this is the classic problem of 0/1 knapsack called Minimum subset difference.\\nBasically we have to find two subset in such a way that the difference between the  subset is minimal.\\n```\\nvar lastStoneWeightII = function(arr) {\\n   let tar =0\\n  for(let i =0;i<arr.length;i++){\\n      tar+=arr[i]\\n  }\\n  let dp = Array(arr.length+1).fill().map(()=>Array((Math.floor(tar/2))+1))\\nfor(let i =0;i<=arr.length;i++){\\n  for(let j =0;j<=tar;j++){\\n    if(i===0){\\n      dp[i][j] = false\\n    }\\n    if(j===0){\\n      dp[i][j] = true\\n    }\\n  }\\n}\\nfor(let i =1;i<=arr.length;i++){\\n  for(let j =1;j<=Math.floor(tar/2);j++){\\n    if(arr[i-1]<=j){\\n      dp[i][j]=dp[i-1][j-arr[i-1]]||dp[i-1][j]\\n    }else{\\n      dp[i][j] = dp[i-1][j]\\n    }\\n  }\\n}\\n  for(let k= Math.floor(tar/2);k>=0;k--){\\n    if(dp[arr.length][k]===true){\\n       return tar-(2*k)\\n    }\\n  } \\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar lastStoneWeightII = function(arr) {\\n   let tar =0\\n  for(let i =0;i<arr.length;i++){\\n      tar+=arr[i]\\n  }\\n  let dp = Array(arr.length+1).fill().map(()=>Array((Math.floor(tar/2))+1))\\nfor(let i =0;i<=arr.length;i++){\\n  for(let j =0;j<=tar;j++){\\n    if(i===0){\\n      dp[i][j] = false\\n    }\\n    if(j===0){\\n      dp[i][j] = true\\n    }\\n  }\\n}\\nfor(let i =1;i<=arr.length;i++){\\n  for(let j =1;j<=Math.floor(tar/2);j++){\\n    if(arr[i-1]<=j){\\n      dp[i][j]=dp[i-1][j-arr[i-1]]||dp[i-1][j]\\n    }else{\\n      dp[i][j] = dp[i-1][j]\\n    }\\n  }\\n}\\n  for(let k= Math.floor(tar/2);k>=0;k--){\\n    if(dp[arr.length][k]===true){\\n       return tar-(2*k)\\n    }\\n  } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077244,
                "title": "java-knapsack-like-1d-boolean-array-1-ms-99",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int s: stones) {\\n            sum += s;\\n        }\\n        int w = (sum+1)/2;\\n        boolean dp[] = new boolean[w+1];\\n        int max = 0;\\n\\n        for(int s: stones) {\\n            for(int i=w; i>s; i--) {\\n                if(dp[i-s]) {\\n                    dp[i] = true;\\n                    max = Math.max(max, i);\\n                }\\n            }\\n            max = Math.max(max, s);\\n            dp[s] = true;\\n        }\\n\\n        return Math.abs(sum-2*max);\\n    }\\n}\\n```\\nTime: O(mn)\\n\\nExplanation:\\nObjective is to split the array into 2 sub-arrays so that the difference is minimized.\\nSo, just check if half the sum or less can be achieved, i.e. `w = (sum+1)/2.`\\nWhichever sum from `0 to w`, can be achieved, make them true in the `dp`.\\nWe don\\'t need extra checks to have the minimum number of elements in the target sub-array, like knapsack, hence a boolean array is enough.\\n\\n`max` is closest weight to `w` that is true;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int s: stones) {\\n            sum += s;\\n        }\\n        int w = (sum+1)/2;\\n        boolean dp[] = new boolean[w+1];\\n        int max = 0;\\n\\n        for(int s: stones) {\\n            for(int i=w; i>s; i--) {\\n                if(dp[i-s]) {\\n                    dp[i] = true;\\n                    max = Math.max(max, i);\\n                }\\n            }\\n            max = Math.max(max, s);\\n            dp[s] = true;\\n        }\\n\\n        return Math.abs(sum-2*max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051227,
                "title": "java-top-down-recursive",
                "content": "```\\nclass Solution {\\n    \\n    private Integer[][] cache;\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        //min(S[p1] - S[p2])\\n        //S[p1] + S[p2] = total\\n        //S[p1] = total - S[p2]\\n        //min(total - 2 * S[p2]) and total - 2 * s[p2] >= 0\\n        //s[p2] <= total / 2\\n        int total = 0;\\n        for(int i : stones) {\\n            total += i;\\n        }\\n        cache = new Integer[stones.length][(total >> 1) + 1];\\n        int maxSum = getMaxPartSum(stones, 0, total >> 1, 0);\\n        return Math.abs(total - maxSum - maxSum);\\n    }\\n    \\n    private int getMaxPartSum(int[] nums, int i, int cap, int runningSum) {\\n        //base case\\n        if(i == nums.length) {\\n            return runningSum;\\n        }\\n        if(null != cache[i][runningSum]) {\\n            return cache[i][runningSum];\\n        }\\n        if(nums[i] + runningSum <= cap) {\\n            //case1: Choose this no\\n            int t1 = getMaxPartSum(nums, i + 1, cap, runningSum + nums[i]);\\n            //case2: Don\\'t choose this no\\n            int t2 = getMaxPartSum(nums, i + 1, cap, runningSum);\\n            cache[i][runningSum] = Math.max(t1, t2);\\n        } else {\\n            //no choice but to skip this\\n            cache[i][runningSum] = getMaxPartSum(nums, i + 1, cap, runningSum);\\n        }\\n        return cache[i][runningSum];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private Integer[][] cache;\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        //min(S[p1] - S[p2])\\n        //S[p1] + S[p2] = total\\n        //S[p1] = total - S[p2]\\n        //min(total - 2 * S[p2]) and total - 2 * s[p2] >= 0\\n        //s[p2] <= total / 2\\n        int total = 0;\\n        for(int i : stones) {\\n            total += i;\\n        }\\n        cache = new Integer[stones.length][(total >> 1) + 1];\\n        int maxSum = getMaxPartSum(stones, 0, total >> 1, 0);\\n        return Math.abs(total - maxSum - maxSum);\\n    }\\n    \\n    private int getMaxPartSum(int[] nums, int i, int cap, int runningSum) {\\n        //base case\\n        if(i == nums.length) {\\n            return runningSum;\\n        }\\n        if(null != cache[i][runningSum]) {\\n            return cache[i][runningSum];\\n        }\\n        if(nums[i] + runningSum <= cap) {\\n            //case1: Choose this no\\n            int t1 = getMaxPartSum(nums, i + 1, cap, runningSum + nums[i]);\\n            //case2: Don\\'t choose this no\\n            int t2 = getMaxPartSum(nums, i + 1, cap, runningSum);\\n            cache[i][runningSum] = Math.max(t1, t2);\\n        } else {\\n            //no choice but to skip this\\n            cache[i][runningSum] = getMaxPartSum(nums, i + 1, cap, runningSum);\\n        }\\n        return cache[i][runningSum];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004976,
                "title": "c-minimum-subset-sum-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=stones[i];\\n       int s=sum/2;\\n        int ans=INT_MAX;\\n        bool t[n+1][s+1];\\n        vector<int> v;\\n        \\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=true;\\n        for(int i=1;i<s+1;i++)\\n            t[0][i]=false;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s+1;j++){\\n                if(stones[i-1]<=j){\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                }\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        \\n        for(int i=1;i<s+1;i++)\\n        {\\n         if(t[n][i] == true)\\n       \\t   v.push_back(i);\\n        }\\n        \\n        for(int i : v){\\n            ans=min(ans, sum-(2*i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=stones[i];\\n       int s=sum/2;\\n        int ans=INT_MAX;\\n        bool t[n+1][s+1];\\n        vector<int> v;\\n        \\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=true;\\n        for(int i=1;i<s+1;i++)\\n            t[0][i]=false;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s+1;j++){\\n                if(stones[i-1]<=j){\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                }\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        \\n        for(int i=1;i<s+1;i++)\\n        {\\n         if(t[n][i] == true)\\n       \\t   v.push_back(i);\\n        }\\n        \\n        for(int i : v){\\n            ans=min(ans, sum-(2*i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984927,
                "title": "c-solution-similar-to-min-sum-partition-problem-of-dp",
                "content": "```\\n    int solve(vector<int> nums,int range)\\n{\\n\\tint sum = range/2;\\n\\tint n = nums.size();\\n\\tvector<int> candidates;\\n\\tint ans = INT_MAX;\\n\\tvector<vector<bool>> dp(n+1,vector<bool>(sum+1));\\n\\tfor(int i  = 0;i<n+1;i++)\\n\\t\\tdp[i][0] = true;\\n\\tfor(int i = 1;i<sum+1;i++)\\n\\t\\tdp[0][i] = false;\\n\\tfor(int i = 1;i<n+1;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<sum+1;j++)\\n\\t\\t{\\n           if(nums[i-1] <=j)\\n           \\tdp[i][j] = dp[i-1][j - nums[i-1]] || dp[i-1][j];\\n           else\\n           \\tdp[i][j] = dp[i-1][j];\\n\\t\\t}\\n\\t}\\n    for(int i = 1;i<sum+1;i++)\\n    {\\n       if(dp[n][i] == true)\\n       \\tcandidates.push_back(i);\\n    }\\n    for(int i:candidates)\\n    \\tans = min(ans,range - (2 * i));\\nreturn ans;\\n}\\n\\n\\n\\nint lastStoneWeightII(vector<int>& stones) {\\n   int range = 0;\\n   for(int i:stones)\\n   \\t   range+=i;\\n   \\treturn solve(stones,range);\\n}\\n",
                "solutionTags": [],
                "code": "```\\n    int solve(vector<int> nums,int range)\\n{\\n\\tint sum = range/2;\\n\\tint n = nums.size();\\n\\tvector<int> candidates;\\n\\tint ans = INT_MAX;\\n\\tvector<vector<bool>> dp(n+1,vector<bool>(sum+1));\\n\\tfor(int i  = 0;i<n+1;i++)\\n\\t\\tdp[i][0] = true;\\n\\tfor(int i = 1;i<sum+1;i++)\\n\\t\\tdp[0][i] = false;\\n\\tfor(int i = 1;i<n+1;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<sum+1;j++)\\n\\t\\t{\\n           if(nums[i-1] <=j)\\n           \\tdp[i][j] = dp[i-1][j - nums[i-1]] || dp[i-1][j];\\n           else\\n           \\tdp[i][j] = dp[i-1][j];\\n\\t\\t}\\n\\t}\\n    for(int i = 1;i<sum+1;i++)\\n    {\\n       if(dp[n][i] == true)\\n       \\tcandidates.push_back(i);\\n    }\\n    for(int i:candidates)\\n    \\tans = min(ans,range - (2 * i));\\nreturn ans;\\n}\\n\\n\\n\\nint lastStoneWeightII(vector<int>& stones) {\\n   int range = 0;\\n   for(int i:stones)\\n   \\t   range+=i;\\n   \\treturn solve(stones,range);\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 977681,
                "title": "python-solution-beat-99-using-set",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones)==1:\\n            return stones[0]\\n        s=set()\\n        s.add(stones[0])\\n        s.add(-stones[0])\\n        dp=set()\\n        for i in range(1,len(stones)):\\n            for j in s:\\n                dp.add(abs(j-stones[i]))\\n                dp.add(abs(j+stones[i]))\\n            s=dp\\n            dp=set()\\n        return min(s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones)==1:\\n            return stones[0]\\n        s=set()\\n        s.add(stones[0])\\n        s.add(-stones[0])\\n        dp=set()\\n        for i in range(1,len(stones)):\\n            for j in s:\\n                dp.add(abs(j-stones[i]))\\n                dp.add(abs(j+stones[i]))\\n            s=dp\\n            dp=set()\\n        return min(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950456,
                "title": "c-knapsack-dp-explained",
                "content": "I\\'m posting this to whomever, like me, did not grasp the fact that this problem could be reduced to the knapsack problem at first.\\n\\nThe main issue here is that, if you go and write down the expression for the problem like:\\nV = [a, b, c, d, e]\\n\\nAssuming steps to one solution are:\\nx = a-b, then y=c-d, then z=x-e, then S=y-z.\\n\\nThat is the same thing as saying:\\nS= (c-d)-(x-e) = (c-d)-((a-b)-e) = (c+b+e)-(d+a)\\n\\nWhen S is the minimun possible value. And you can rearrange any other combination like this.\\n\\nWhich reduces this problem to finding whichever subset of V with the maximum somatorium is still smaller than the half of the total.\\n\\nSay W = [a1, a2, a3 ...] is a subset of V, then Sum(W) < Sum(V), but Sum(W) must be the maximun possible, so that we have the minimun difference from it to the remaing set V[...] - W[...].\\n\\nThat is exactly the knapsack problem, but with float numbers, dont forget that part.\\nYou can definetly optimize this answer by getting rid of the floats, thought.\\n\\n```\\nclass Solution {\\npublic:\\n    #define INF 100000\\n    std::map<pair<int,float>,float> memo;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        float half = accumulate(stones.begin(), stones.end(), 0)/(float)2;\\n        return remainderKnapsack(stones, 0, half)*2;\\n    }\\n    float remainderKnapsack(vector<int>& stones, int i, float capacity) {\\n        float result = 0;\\n        if (capacity < 0) {\\n            return INF;\\n        }\\n        if (i == stones.size()) {\\n            return capacity;\\n        }\\n        if (memo.count(pair<int,float>({i, capacity}))) {\\n            return memo[pair<int,float>({i, capacity})];\\n        }\\n        return memo[pair<int,float>({i, capacity})] = min(remainderKnapsack(stones, i+1, capacity), remainderKnapsack(stones, i+1, capacity -stones[i]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define INF 100000\\n    std::map<pair<int,float>,float> memo;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        float half = accumulate(stones.begin(), stones.end(), 0)/(float)2;\\n        return remainderKnapsack(stones, 0, half)*2;\\n    }\\n    float remainderKnapsack(vector<int>& stones, int i, float capacity) {\\n        float result = 0;\\n        if (capacity < 0) {\\n            return INF;\\n        }\\n        if (i == stones.size()) {\\n            return capacity;\\n        }\\n        if (memo.count(pair<int,float>({i, capacity}))) {\\n            return memo[pair<int,float>({i, capacity})];\\n        }\\n        return memo[pair<int,float>({i, capacity})] = min(remainderKnapsack(stones, i+1, capacity), remainderKnapsack(stones, i+1, capacity -stones[i]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916052,
                "title": "c-beats-100-subset-sum-dp",
                "content": "**Objective:** We need to partition the array into two subsets such that the difference of their sums is minimised. \\nOf the given denominations of stones, we need to see the maximum target achievable. (0<target<=stone_sum/2)\\n**dp[i][j]** tells whether target **j** is achievable or not with atmost **i** stones.\\nSo, find the max **j** that can be achieved. let it be **s**, return **abs(2*s - stone_sum)**.\\n\\nA similar approach in Python can be found here https://www.youtube.com/watch?v=0RGxWCE2vzM&t=3s\\n\\n\\n```\\nint sum(vector<int>v)\\n    {\\n        int s=0;\\n        for(int i=0;i<v.size();i++)\\n            s+=v[i];\\n        return s;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int stone_sum = sum(stones);\\n        int target = stone_sum%2==0? stone_sum/2 : (stone_sum +1)/2;\\n        \\n        int dp[n+1][target+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=target;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=true;\\n                else\\n                    dp[i][j]=false;\\n            }\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j] = dp[i-1][j]|dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                if(dp[i][j]==true)\\n                    s = max(s,j);\\n            }\\n        }\\n        \\n        return abs(2*s-stone_sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(vector<int>v)\\n    {\\n        int s=0;\\n        for(int i=0;i<v.size();i++)\\n            s+=v[i];\\n        return s;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int stone_sum = sum(stones);\\n        int target = stone_sum%2==0? stone_sum/2 : (stone_sum +1)/2;\\n        \\n        int dp[n+1][target+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=target;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=true;\\n                else\\n                    dp[i][j]=false;\\n            }\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j] = dp[i-1][j]|dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                if(dp[i][j]==true)\\n                    s = max(s,j);\\n            }\\n        }\\n        \\n        return abs(2*s-stone_sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908871,
                "title": "java-dp-solution-faster-than-90",
                "content": "```\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length, sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n\\n        boolean[] f = new boolean[sum/2+1];\\n        Arrays.fill(f, false);\\n        f[0] = true;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = sum / 2; j >= stones[i]; j--)\\n                f[j] = f[j] || f[j - stones[i]];\\n\\n        for (int i = sum / 2; i >= 0; i--)\\n            if (f[i])\\n                return sum - i - i;\\n\\n        return sum;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length, sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n\\n        boolean[] f = new boolean[sum/2+1];\\n        Arrays.fill(f, false);\\n        f[0] = true;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = sum / 2; j >= stones[i]; j--)\\n                f[j] = f[j] || f[j - stones[i]];\\n\\n        for (int i = sum / 2; i >= 0; i--)\\n            if (f[i])\\n                return sum - i - i;\\n\\n        return sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897003,
                "title": "a-replica-of-divide-array-into-two-subsequences-with-min-sum-difference",
                "content": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n            s+=stones[i];\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1));\\n        \\n        for(int i=1;i<=s;i++)\\n            dp[0][i]=0;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        int i;\\n        for( i=s/2;i>=0;i--)\\n        {\\n            if(dp[n][i]==1)\\n                break;\\n        }\\n        \\n        int ans=(s-i)-i>0?s-i-i:0;\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n            s+=stones[i];\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1));\\n        \\n        for(int i=1;i<=s;i++)\\n            dp[0][i]=0;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 802680,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int totsum = 0;\\n        \\n        for(auto stone: stones) totsum+=stone;\\n        \\n        int sum = (totsum%2) ? totsum/2 +1 : totsum/2;\\n        \\n        bool dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=sum;i++)\\n            dp[0][i] = false;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0] = true;\\n        \\n        int maxx = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[i][j] = dp[i-1][j];\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]) maxx = max(maxx,j);\\n            }\\n        }\\n        \\n        int first = maxx;\\n        int second = totsum-maxx;\\n        \\n        return abs(first-second);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int totsum = 0;\\n        \\n        for(auto stone: stones) totsum+=stone;\\n        \\n        int sum = (totsum%2) ? totsum/2 +1 : totsum/2;\\n        \\n        bool dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=sum;i++)\\n            dp[0][i] = false;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0] = true;\\n        \\n        int maxx = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[i][j] = dp[i-1][j];\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]) maxx = max(maxx,j);\\n            }\\n        }\\n        \\n        int first = maxx;\\n        int second = totsum-maxx;\\n        \\n        return abs(first-second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749263,
                "title": "c-0ms-dp",
                "content": "see [this](https://www.***.org/0-1-knapsack-problem-dp-10/) for understandig the concept\\n```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int m;\\n        \\n        for(int x : stones) sum += x;\\n        m = sum/2;\\n    \\n        vector<vector<int>> dp(2,vector<int>(m+1,0));\\n        \\n        for(int x : stones){\\n            for(int i = x ; i < dp[0].size() ; i++){\\n                dp[1][i] = max(dp[0][i],dp[0][i-x]+x);\\n            }\\n            dp[0] = dp[1];\\n        }\\n        return sum-(2*dp[1][m]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int m;\\n        \\n        for(int x : stones) sum += x;\\n        m = sum/2;\\n    \\n        vector<vector<int>> dp(2,vector<int>(m+1,0));\\n        \\n        for(int x : stones){\\n            for(int i = x ; i < dp[0].size() ; i++){\\n                dp[1][i] = max(dp[0][i],dp[0][i-x]+x);\\n            }\\n            dp[0] = dp[1];\\n        }\\n        return sum-(2*dp[1][m]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725095,
                "title": "well-explained-java-solution-with-diagram",
                "content": "**Solution 1**\\n\\nThis question is same as partitioning array into 2 subsets where difference is minimal. \\nWe divide the array into P & N, Let\\'s say that\\n P = sum of subset of Positive Numbers\\n N = sum of subset of Negative Numbers\\n (1) P+N = Sum\\n (2) P-N = Diff\\n   -> P+N-P+N =Sum - diff\\n    -> 2N = Sum-diff\\n    -> diff = Sum - 2N      // So, minimum diff equals maximum N.\\n\\nTo find maximum N, let\\'s assume diff is 0, since that is the minimum possible value of diff, so with this we can know the maximum possible value of N. So now with diff 0 the equation is : 2N = Sum, so N = Sum/2\\n\\nSo to find the maximum possible value of N, it can be anywhere from 0 to Sum/2;\\n\\n![image](https://assets.leetcode.com/users/images/bcc48dc0-1729-4afb-8bcf-a010e02e614c_1594179779.8837605.png)\\n\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int N = stones.length;\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        boolean[][] dp = new boolean[N+1][maxSumForNegativeNumbers+1];\\n        \\n        for(int i=0;i<=N;i++){\\n            dp[i][0] = true;\\n        }\\n            \\n        \\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<=maxSumForNegativeNumbers;j++){\\n                if(j>=stones[i-1] && dp[i-1][j-stones[i-1]]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n                else if(dp[i-1][j]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n            }   \\n        }\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n}\\n```\\n\\n**Solution 2** - Similar to [Target Sum](https://leetcode.com/problems/target-sum/) (it utilizes subsetsum2d method) \\n\\n![image](https://assets.leetcode.com/users/images/d27abd5a-5350-444e-9aaf-012818bfa186_1594179817.5170486.png)\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        \\n        actualSumForNegativeNumbers = subsetSum2d(stones,maxSumForNegativeNumbers);\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n    \\n    private int subsetSum2d(int[] nums, int target) {\\n        //dp[i][j]: the number of subsets that can sum to target j with the first j numbers\\n        int[][] dp = new int[nums.length + 1][target + 1];      \\n        for(int i=0;i<=nums.length;i++)\\n            dp[i][0] = 1;\\n        \\n        int N = 0;\\n\\n         for (int i = 1; i <= nums.length;  i++) {\\n             for (int j = 1; j <= target;  j++) {\\n                 if (j >= nums[i - 1]) {\\n                     dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                 } else {\\n                     dp[i][j] = dp[i - 1][j];\\n                 }\\n                 // since we need to get the max possible value of j, which is sum of Negative subset\\n                 N = dp[i][j]!=0 ? Math.max(N,j) : N;\\n             }          \\n         }\\n\\n\\n         return N;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int N = stones.length;\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        boolean[][] dp = new boolean[N+1][maxSumForNegativeNumbers+1];\\n        \\n        for(int i=0;i<=N;i++){\\n            dp[i][0] = true;\\n        }\\n            \\n        \\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<=maxSumForNegativeNumbers;j++){\\n                if(j>=stones[i-1] && dp[i-1][j-stones[i-1]]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n                else if(dp[i-1][j]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n            }   \\n        }\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        \\n        actualSumForNegativeNumbers = subsetSum2d(stones,maxSumForNegativeNumbers);\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n    \\n    private int subsetSum2d(int[] nums, int target) {\\n        //dp[i][j]: the number of subsets that can sum to target j with the first j numbers\\n        int[][] dp = new int[nums.length + 1][target + 1];      \\n        for(int i=0;i<=nums.length;i++)\\n            dp[i][0] = 1;\\n        \\n        int N = 0;\\n\\n         for (int i = 1; i <= nums.length;  i++) {\\n             for (int j = 1; j <= target;  j++) {\\n                 if (j >= nums[i - 1]) {\\n                     dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                 } else {\\n                     dp[i][j] = dp[i - 1][j];\\n                 }\\n                 // since we need to get the max possible value of j, which is sum of Negative subset\\n                 N = dp[i][j]!=0 ? Math.max(N,j) : N;\\n             }          \\n         }\\n\\n\\n         return N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719748,
                "title": "full-proof-of-why-the-dp-solution-gives-the-correct-answer",
                "content": "There are ```n!``` ways of smashing stones but only ```2^n``` ways of constructing a set with DP. Even then, it is not immediately clear that with any given set selected, we can actually reaching the final state. So I decided to show that it is indeed possible.\\n\\nNotations: uppercase letters are for sets and lowercase letters are for elements. Enclosing an element with ```{}```  makes a set with the given elements. ```+``` and ```-``` between sets means combining two sets and removing a subset to form a new set.\\n\\nDefine W(S) as a function that gives the total weight of a set of stones S. Let sets P and Q satisfy:\\n(1) ```W(P) \\u2264 W(Q)```,\\n(2) If ```W(P) < W(Q)```, there do not exist any subset P_S of P and any subset Q_S of Q, such that ```W(P) < W(P - P_S + Q_S) \\u2264 W(Q - Q_S + P_S) < W(Q)```. (In plain language, we can swap some elements in P with some elements in Q, so that we increase the total weight of P and decrease the total weight of Q, while maintaining condition (1).)\\n\\t\\t\\nOnce P and Q are selected correctly (preferrably through dynamic programming), the following pseudocode demonstrates that for any given P and Q, we can, step by step, reach the result where there is no more than one stone left in the end and the weight of that stone is the desired answer.\\n``` \\n while P is not empty:\\n     p = P.pop()\\n\\t q = Q.pop()\\n\\t if W({p}) > W({q}):\\n\\t     P.push(create_stone_with_weight(W({p})-W({q})))\\n     else if W({p}) < W({q}):\\n\\t     Q.push(create_stone_with_weight(W({q})-W({p})))\\nreturn W(Q)\\n```\\n\\t \\nFirst, we prove that the two conditions are maintained after a loop:\\n\\n(1) The first condition is maintained because the weight of two sets goes down by the same amount.\\n\\n(2) The second condition is obviously maintained if ```W({p})=W({q})``` since there is no new stone being created. Without losing generality, suppose ```W({p})>W({q})``` so that we have a new stone ```r``` in ```P``` and that there exist ```P_S``` and ```Q_S``` such that and \\n```W(P) < W(P - (P_S + {r}) + Q_S) \\u2264 W(Q - Q_S + (P_S + {r})) < W(Q)```, \\nthen we must also have \\n```W(P) < W(P - (P_S + {p}) + (Q_S + {q})) \\u2264 W(Q - (Q_S + {q}) + (P_S + {p})) < W(Q)```, \\nwhich contradicts the statement that there do not exist subsets ```P_S + {p}``` and ```Q_S + {q}``` that break the second condition before the loop.\\n\\nNotice that whichever element returned by ```pop()``` doesn\\'t matter. Firstly, it\\'s not used in the previous proof. Secondly, it always decrement the total number of stones by at least 1 so eventually the loop will exit. Therefore, at least with this pseudocode, that\\'s where the number of possibilities gets reduced from ```n!``` to ```2^n```.\\n\\nSecondly, we prove that we can safely exit the loop.\\n\\n(1) Since ```W(P)\\u2264W(Q)``` always holds throughtout the loops, Q is never empty when P is not empty and P always can be emptied, so we can\\'t get stuck in the loop.\\n\\n(2) If there exist at least two elements ```q1``` and ```q2``` in ```Q``` when the loop exits, then without losing generality, supposedly ```W({q1}) \\u2264 W({q2})```, the empty set as a subset of the empty set ```P``` and ```{q1}``` as a subset of ```Q```, break condition (2). This contradicts the statement that condition (2) is satisfied before the loops and is maintained throughout the loops.\\n\\nQ.E.D.",
                "solutionTags": [],
                "code": "```n!```\n```2^n```\n```{}```\n```+```\n```-```\n```W(P) \\u2264 W(Q)```\n```W(P) < W(Q)```\n```W(P) < W(P - P_S + Q_S) \\u2264 W(Q - Q_S + P_S) < W(Q)```\n``` \\n while P is not empty:\\n     p = P.pop()\\n\\t q = Q.pop()\\n\\t if W({p}) > W({q}):\\n\\t     P.push(create_stone_with_weight(W({p})-W({q})))\\n     else if W({p}) < W({q}):\\n\\t     Q.push(create_stone_with_weight(W({q})-W({p})))\\nreturn W(Q)\\n```\n```W({p})=W({q})```\n```W({p})>W({q})```\n```r```\n```P```\n```P_S```\n```Q_S```\n```W(P) < W(P - (P_S + {r}) + Q_S) \\u2264 W(Q - Q_S + (P_S + {r})) < W(Q)```\n```W(P) < W(P - (P_S + {p}) + (Q_S + {q})) \\u2264 W(Q - (Q_S + {q}) + (P_S + {p})) < W(Q)```\n```P_S + {p}```\n```Q_S + {q}```\n```pop()```\n```n!```\n```2^n```\n```W(P)\\u2264W(Q)```\n```q1```\n```q2```\n```Q```\n```W({q1}) \\u2264 W({q2})```\n```P```\n```{q1}```\n```Q```",
                "codeTag": "Unknown"
            },
            {
                "id": 670062,
                "title": "straightforward-c-solved-with-knapsack-algorithm",
                "content": "Based on the explanation from https://leetcode.com/problems/last-stone-weight-ii/discuss/298664/How-is-it-a-Knapsack-problem\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0, n = stones.size();\\n        for (auto s : stones) sum += s;\\n        int target = sum / 2;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (stones[i - 1] <= j)\\n                    dp[i][j] = max(dp[i - 1][j - stones[i - 1]] + stones[i - 1], dp[i - 1][j]);\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n        return sum - dp[n][target] - dp[n][target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0, n = stones.size();\\n        for (auto s : stones) sum += s;\\n        int target = sum / 2;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (stones[i - 1] <= j)\\n                    dp[i][j] = max(dp[i - 1][j - stones[i - 1]] + stones[i - 1], dp[i - 1][j]);\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n        return sum - dp[n][target] - dp[n][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667324,
                "title": "python-2-approaches-dp-and-backtracking-detailed-explanation-and-thought-process",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 416 Partition Equal Subset Sum ##\\n        \\n        ## LOGIC ##\\n        ## 1. On broader scope you have to find the combination where some stones are assigned + symbols and some stones are assigned - symbols and calculate total.\\n        ## 2. say you have 4 numbers, a,b,c,d lets say our correct answer is (a-d) - (b-c) implies ==> (a+c) - (b+d) ==> which we can put is as difference of 2 subsets in the array such that the difference is lowest possible(minimum)\\n        ## 3. Problem is now reduced to splitting of 2 groups whose difference is minimum.\\n        ## 4. For now let us assume we can equally divide into 2 subsets, so difference will be obvisouly 0. ( this can be solved by Leetcode 416.)\\n        ## 5. If we cannot divide it equally, then what is the maximum value which is close to target/2 ?? for example consider [2,5,5,7,11] total = 30, sum subet sum closest to 15 (i.e 29/2) is 14. so remaining subset will be 30 - 14 i.e 16. subset1 = 14, subset2 = 16, result = 16-14 = 2.\\n        ## 6. So we can try to divide into equal partitions, if we cannot , We find the maximum value closest to target//2 and get the subset2 value as total - subset1 and return the difference.\\n        \\n        nums = stones\\n        total = sum(nums)\\n        dp = [[ False for i in range((total//2)+1) ] for j in range(len(nums))]\\n        for i in range(len(nums)):\\n            for j in range((total//2) + 1):\\n                if(j == 0):\\n                    dp[i][j] = True         \\n                elif( j < nums[i] ):          \\n                    dp[i][j] = dp[i-1][j]\\n                elif(j == nums[i]):           \\n                    dp[i][j] = True\\n                elif( dp[i-1][j] == True or dp[i-1][j-nums[i]] == True):  \\n                    dp[i][j] = True\\n        \\n        # look the last row from backwards, to find the subset1\\n        for num in range(len(dp[-1])-1,-1,-1):\\n            if dp[-1][num]:\\n                subset1 = num\\n                subset2 = total - num\\n                return abs( subset1 - subset2 )\\n        \\n        ## APPROACH : BACKTRACKING ##\\n        def dfs(curr, remain, stones):\\n            if not stones or (curr,remain) in visited:\\n                return\\n            \\n            if( curr - remain > self.ans ):\\n                return\\n            \\n            if( curr - remain >= 0):\\n                self.ans = min( self.ans, curr - remain )\\n                \\n            visited.add((curr,remain))\\n            \\n            for i in range(len(stones)):\\n                dfs( curr + stones[i], total-(curr+stones[i]), stones[:i]+stones[i+1:] )\\n        \\n        visited = set()\\n        self.ans = float(\\'inf\\')\\n        total = sum(stones)\\n        dfs(0, total, stones)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 416 Partition Equal Subset Sum ##\\n        \\n        ## LOGIC ##\\n        ## 1. On broader scope you have to find the combination where some stones are assigned + symbols and some stones are assigned - symbols and calculate total.\\n        ## 2. say you have 4 numbers, a,b,c,d lets say our correct answer is (a-d) - (b-c) implies ==> (a+c) - (b+d) ==> which we can put is as difference of 2 subsets in the array such that the difference is lowest possible(minimum)\\n        ## 3. Problem is now reduced to splitting of 2 groups whose difference is minimum.\\n        ## 4. For now let us assume we can equally divide into 2 subsets, so difference will be obvisouly 0. ( this can be solved by Leetcode 416.)\\n        ## 5. If we cannot divide it equally, then what is the maximum value which is close to target/2 ?? for example consider [2,5,5,7,11] total = 30, sum subet sum closest to 15 (i.e 29/2) is 14. so remaining subset will be 30 - 14 i.e 16. subset1 = 14, subset2 = 16, result = 16-14 = 2.\\n        ## 6. So we can try to divide into equal partitions, if we cannot , We find the maximum value closest to target//2 and get the subset2 value as total - subset1 and return the difference.\\n        \\n        nums = stones\\n        total = sum(nums)\\n        dp = [[ False for i in range((total//2)+1) ] for j in range(len(nums))]\\n        for i in range(len(nums)):\\n            for j in range((total//2) + 1):\\n                if(j == 0):\\n                    dp[i][j] = True         \\n                elif( j < nums[i] ):          \\n                    dp[i][j] = dp[i-1][j]\\n                elif(j == nums[i]):           \\n                    dp[i][j] = True\\n                elif( dp[i-1][j] == True or dp[i-1][j-nums[i]] == True):  \\n                    dp[i][j] = True\\n        \\n        # look the last row from backwards, to find the subset1\\n        for num in range(len(dp[-1])-1,-1,-1):\\n            if dp[-1][num]:\\n                subset1 = num\\n                subset2 = total - num\\n                return abs( subset1 - subset2 )\\n        \\n        ## APPROACH : BACKTRACKING ##\\n        def dfs(curr, remain, stones):\\n            if not stones or (curr,remain) in visited:\\n                return\\n            \\n            if( curr - remain > self.ans ):\\n                return\\n            \\n            if( curr - remain >= 0):\\n                self.ans = min( self.ans, curr - remain )\\n                \\n            visited.add((curr,remain))\\n            \\n            for i in range(len(stones)):\\n                dfs( curr + stones[i], total-(curr+stones[i]), stones[:i]+stones[i+1:] )\\n        \\n        visited = set()\\n        self.ans = float(\\'inf\\')\\n        total = sum(stones)\\n        dfs(0, total, stones)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642063,
                "title": "c-similar-to-minimum-difference-partition-of-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& a) {\\n        int s=0,i,n;\\n        for(int i:a) s+=i;\\n        n=s;\\n        s/=2;\\n        int dp[s+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n\\t    for(int i:a)\\n\\t\\t    for(int j=s;j>=i;j--) dp[j]=dp[j] or dp[j-i];\\n\\t    for(i=s;i>=0;i--)\\n            if(dp[i]) break;\\n        return n-2*i;\\n    }\\n};```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& a) {\\n        int s=0,i,n;\\n        for(int i:a) s+=i;\\n        n=s;\\n        s/=2;\\n        int dp[s+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n\\t    for(int i:a)\\n\\t\\t    for(int j=s;j>=i;j--) dp[j]=dp[j] or dp[j-i];\\n\\t    for(i=s;i>=0;i--)\\n            if(dp[i]) break;\\n        return n-2*i;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 621475,
                "title": "c-classical-0-1-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII( vector<int>& stones ) {\\n        // Get total weight of all stones\\n        int totalWt=0;\\n        for( auto stoneWt : stones ) totalWt += stoneWt;\\n        \\n        // Divide all numbers into two groups,\\n        // minimum difference between the sum of two groups is the result\\n        \\n        /*\\n        0/1 Knapsack\\n        Possible items: 0,...,n-1 stones\\n        Possible Wt: 0,1,..., totalWt/2 */\\n        int n = stones.size();\\n        vector<vector<int>> dp( n+1, vector<int>( totalWt/2 + 1, 0 ) );\\n        for( int i=1; i<=n; i++ ) { // all items that can be picked\\n            for( int j=1; j <=totalWt/2; j++ ) {\\n                if( stones[i-1] > j ) // can\\'t pick this stone as wt > j\\n                    dp[i][j] = dp[i-1][j];\\n                else\\n                    dp[i][j] = max( dp[i-1][j], stones[i-1] + dp[i-1][j - stones[i-1]] );\\n            }\\n        }\\n        \\n        /* check the max possible wt */\\n        int maxWt = 0;\\n        for( int i=1; i<=n; i++ )\\n            if( dp[i][totalWt/2] > maxWt )\\n                maxWt = dp[i][totalWt/2];\\n        \\n        return totalWt - 2*maxWt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII( vector<int>& stones ) {\\n        // Get total weight of all stones\\n        int totalWt=0;\\n        for( auto stoneWt : stones ) totalWt += stoneWt;\\n        \\n        // Divide all numbers into two groups,\\n        // minimum difference between the sum of two groups is the result\\n        \\n        /*\\n        0/1 Knapsack\\n        Possible items: 0,...,n-1 stones\\n        Possible Wt: 0,1,..., totalWt/2 */\\n        int n = stones.size();\\n        vector<vector<int>> dp( n+1, vector<int>( totalWt/2 + 1, 0 ) );\\n        for( int i=1; i<=n; i++ ) { // all items that can be picked\\n            for( int j=1; j <=totalWt/2; j++ ) {\\n                if( stones[i-1] > j ) // can\\'t pick this stone as wt > j\\n                    dp[i][j] = dp[i-1][j];\\n                else\\n                    dp[i][j] = max( dp[i-1][j], stones[i-1] + dp[i-1][j - stones[i-1]] );\\n            }\\n        }\\n        \\n        /* check the max possible wt */\\n        int maxWt = 0;\\n        for( int i=1; i<=n; i++ )\\n            if( dp[i][totalWt/2] > maxWt )\\n                maxWt = dp[i][totalWt/2];\\n        \\n        return totalWt - 2*maxWt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619619,
                "title": "python-12ms-100-ile",
                "content": "The code is at the end; this problem confused me for an embarrassingly long time, so I want to talk about the \"trick\" first.\\n\\nAFAICT, this problem is very hard to solve if one approaches it on its own terms.  The \"trick\" to solving it is to realize that it\\'s really the optimization version of the [partition problem](https://en.wikipedia.org/wiki/Partition_problem) in disguise.  The final stone\\'s weight will always look something like w[0]+w[1]-w[2]+w[3]-w[4]...+w[n-1], where w[0],w[1],...,w[n-1] are the weights given in the problem.  This can be rearranged into a subtraction of one set of stones from their complement; minimizing this difference is a matter of making the two sets of stones as nearly equal in weight as possible.\\n\\nIt\\'s pretty clear that the answer to the problem can be no lower than such a minimized difference, but can such a minimized difference always be achieved?  Yes; the algorithm to do so is to order each set of stones by weight, and to smash the two lightest stones from each set together, replacing the heavier of the two stones with the product.\\n\\nThe optimization form of the parition problem is NP-hard, but the problem given is limited in size.  (In particular, there are at most 1500 sums of any interest.)  It\\'s amenable to either DP or recursion-with-memoization (brute-force is a little too slow), but I found the fastest approach was simple enumeration with a short-circuit:\\n\\n```\\ndef h7(a, g):\\n    available = set([0]); rv = 0\\n    for v in a:\\n        t = set(v+e for e in available if v+e <= g)\\n        if t: rv = max(rv, max(t))\\n        if rv == g: return rv\\n        available |= t\\n    return rv\\n```\\n\\nThe driver to use this is pretty simple:\\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        t = sum(stones)\\n        m0 = h7(stones, t//2)\\n        return t-2*m0\\n```",
                "solutionTags": [],
                "code": "```\\ndef h7(a, g):\\n    available = set([0]); rv = 0\\n    for v in a:\\n        t = set(v+e for e in available if v+e <= g)\\n        if t: rv = max(rv, max(t))\\n        if rv == g: return rv\\n        available |= t\\n    return rv\\n```\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        t = sum(stones)\\n        m0 = h7(stones, t//2)\\n        return t-2*m0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561732,
                "title": "very-easy-to-understand-top-down-dp",
                "content": "The idea is to realize that regardless of the order of rock \"match\", we will always end up with some sum = ra + rb + rc ... - rd - re - rf.....\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int: \\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(ind, curr):\\n            if ind==len(stones):\\n                return abs(curr)\\n            \\n            return min(helper(ind+1, curr+stones[ind]), helper(ind+1, curr-stones[ind]))\\n        \\n        return helper(0, 0)\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "The idea is to realize that regardless of the order of rock \"match\", we will always end up with some sum = ra + rb + rc ... - rd - re - rf.....\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int: \\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(ind, curr):\\n            if ind==len(stones):\\n                return abs(curr)\\n            \\n            return min(helper(ind+1, curr+stones[ind]), helper(ind+1, curr-stones[ind]))\\n        \\n        return helper(0, 0)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 515364,
                "title": "python-solution-dp",
                "content": "the goal is to check if partial sums can be reached range from [min(stones), sum(stones)//2]\\n\\nthen to find the last possible partial sums and return abs(2*psum - total_sum)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        start = min(stones)\\n        dp = [False] * (total//2 + 1)\\n        dp[0] = True\\n        for s in stones:\\n            for i in range(total//2, start-1, -1):\\n                if s<=i and dp[i-s]:\\n                    dp[i] = True\\n        # print(dp)\\n        for i in range(len(dp)-1, -1, -1):\\n            if dp[i]:\\n                return abs(2*i-total)\\n\\t",
                "solutionTags": [],
                "code": "the goal is to check if partial sums can be reached range from [min(stones), sum(stones)//2]\\n\\nthen to find the last possible partial sums and return abs(2*psum - total_sum)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        start = min(stones)\\n        dp = [False] * (total//2 + 1)\\n        dp[0] = True\\n        for s in stones:\\n            for i in range(total//2, start-1, -1):\\n                if s<=i and dp[i-s]:\\n                    dp[i] = True\\n        # print(dp)\\n        for i in range(len(dp)-1, -1, -1):\\n            if dp[i]:\\n                return abs(2*i-total)\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 501310,
                "title": "clean-and-fast-python-with-explanation",
                "content": "The problem is the same as dividing the stones into two groups and make the group weight as equal as possible.\\nFind all possible weights that achievable from any combination of stones. \\nAll the possible weights are within [1, sum(stones)], inclusive.\\nUse a set to store achievable weights.\\nIterate stone s in stones and previous achievable weights pre, add pre + s to achievable set.\\nreturn min(abs(total -a*2) for a in achievable) as result.\\nThis is bottom up DP.\\nTime complexity: O(N*S), S is sum(stones)\\nSpace complexity: O(S)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        achievable = {0}\\n        for n in stones:\\n            new = set()\\n            for pre in achievable:\\n                new.add(n+pre)\\n            achievable |= new\\n        return min(abs(total -a*2) for a in achievable)\\n```\\n\\nA top down DP\\nDP[i,w] = True means from stones[0:i] we can get a sum of w.\\nDP[i, w] = DP[i-1, w] or DP[i-1, w-stone[i-1]]\\nLet target = sum(stones)//2, find DP[len(stones), target] == True or False.\\nIf True, return abs(sums(stones) - 2*target).\\nIf False, decrease target by one. and then find DP[len(stones), target].\\nTry the best case first, so if we got a True, we can return.\\nUse memorization to avoid repeat calculation.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        target = total//2\\n        mem = {(0,0):True}\\n        while target > 0:\\n            if self.DP(target, len(stones), stones, mem):\\n                return abs(total -2*target)\\n            target -= 1\\n        return total\\n    \\n    def DP(self, target, idx, stones, mem):\\n        if (idx, target) in mem:\\n            return mem[(idx, target)]\\n        good = False\\n        if idx > 0:\\n            good = self.DP(target, idx-1, stones, mem)\\n            if target >= stones[idx-1]:\\n                good = good or self.DP(target-stones[idx-1], idx-1, stones, mem)\\n        mem[(idx, target)] = good\\n        return good\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        achievable = {0}\\n        for n in stones:\\n            new = set()\\n            for pre in achievable:\\n                new.add(n+pre)\\n            achievable |= new\\n        return min(abs(total -a*2) for a in achievable)\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        target = total//2\\n        mem = {(0,0):True}\\n        while target > 0:\\n            if self.DP(target, len(stones), stones, mem):\\n                return abs(total -2*target)\\n            target -= 1\\n        return total\\n    \\n    def DP(self, target, idx, stones, mem):\\n        if (idx, target) in mem:\\n            return mem[(idx, target)]\\n        good = False\\n        if idx > 0:\\n            good = self.DP(target, idx-1, stones, mem)\\n            if target >= stones[idx-1]:\\n                good = good or self.DP(target-stones[idx-1], idx-1, stones, mem)\\n        mem[(idx, target)] = good\\n        return good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477560,
                "title": "simple-explanation-of-converting-problem-to-knapsack-problem",
                "content": "The problem boils down to: \\n\\n* How do you partition the elements into two sets to minimise the absolute difference\\n\\nWhich can be stated as a knapsack problem:\\n\\n* Given a collection of elements, for each element, select either {**e**,**-e**} in order to minimise the sum of the new collection.\\n\\nWe don\\'t care about properties of a reachable sum, just whether it\\'s reachable, so we can use a HashSet\\n\\n```csharp\\npublic int LastStoneWeightII(int[] stones) \\n{\\n\\tHashSet<int> a = new HashSet<int>(new[] { 0 });\\n\\tforeach(var num in stones)\\n\\t{\\n\\t\\tvar next = new HashSet<int>();\\n\\n\\t\\tforeach(var k in a.ToList())\\n\\t\\t{\\n\\t\\t\\tnext.Add(k - num);\\n\\t\\t\\tnext.Add(k + num);\\n\\t\\t}\\n\\t\\ta = next;\\n\\t}\\n\\treturn a.Select(Math.Abs).Min();\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```csharp\\npublic int LastStoneWeightII(int[] stones) \\n{\\n\\tHashSet<int> a = new HashSet<int>(new[] { 0 });\\n\\tforeach(var num in stones)\\n\\t{\\n\\t\\tvar next = new HashSet<int>();\\n\\n\\t\\tforeach(var k in a.ToList())\\n\\t\\t{\\n\\t\\t\\tnext.Add(k - num);\\n\\t\\t\\tnext.Add(k + num);\\n\\t\\t}\\n\\t\\ta = next;\\n\\t}\\n\\treturn a.Select(Math.Abs).Min();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397862,
                "title": "java-top-down-dp-easy-to-undestand-3-ms",
                "content": "There are other posts that which explain why this becomes a knapsack problem which is about dividing the stones into 2 groups which have the minimum amount of difference between them.\\nI couldn\\'t find any top down dp solutions so here it is. I think personally top down is much more intuitive.\\n```\\nclass Solution {\\n    int total;\\n    Integer[][] memo;\\n    Deque<Integer> stoneDeq;\\n    public int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length == 0) return 0;\\n        total = 0;\\n        stoneDeq = new ArrayDeque<>(stones.length);\\n        for (int stone : stones) {\\n            total += stone;\\n            stoneDeq.add(stone);\\n        }\\n        memo = new Integer[total + 1][stones.length + 1];\\n        return topDown(0);\\n    }\\n    private int topDown(int sum) {\\n        if (stoneDeq.size() == 0) return Math.abs(sum - (total - sum));\\n        if (memo[sum][stoneDeq.size()] != null) return memo[sum][stoneDeq.size()];\\n\\n        int curVal = stoneDeq.pop(); // process from head\\n\\n        int mergeCurSum = topDown(sum + curVal);\\n        int dontMergeCurSum = topDown(sum);\\n        int minSum = Math.min(mergeCurSum, dontMergeCurSum);\\n\\n        // doesn\\'t matter whether we put back to head or tail but tail seems to run faster\\n        // not sure why if any can explain would really appreciate\\n        stoneDeq.add(curVal);\\n\\n        return memo[sum][stoneDeq.size()] = minSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int total;\\n    Integer[][] memo;\\n    Deque<Integer> stoneDeq;\\n    public int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length == 0) return 0;\\n        total = 0;\\n        stoneDeq = new ArrayDeque<>(stones.length);\\n        for (int stone : stones) {\\n            total += stone;\\n            stoneDeq.add(stone);\\n        }\\n        memo = new Integer[total + 1][stones.length + 1];\\n        return topDown(0);\\n    }\\n    private int topDown(int sum) {\\n        if (stoneDeq.size() == 0) return Math.abs(sum - (total - sum));\\n        if (memo[sum][stoneDeq.size()] != null) return memo[sum][stoneDeq.size()];\\n\\n        int curVal = stoneDeq.pop(); // process from head\\n\\n        int mergeCurSum = topDown(sum + curVal);\\n        int dontMergeCurSum = topDown(sum);\\n        int minSum = Math.min(mergeCurSum, dontMergeCurSum);\\n\\n        // doesn\\'t matter whether we put back to head or tail but tail seems to run faster\\n        // not sure why if any can explain would really appreciate\\n        stoneDeq.add(curVal);\\n\\n        return memo[sum][stoneDeq.size()] = minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375492,
                "title": "ruby-dp-solution",
                "content": "```Ruby\\n# @param {Integer[]} stones\\n# @return {Integer}\\ndef last_stone_weight_ii(stones)\\n  stones_sum = stones.reduce(:+)\\n  target_sum = stones_sum / 2\\n  dp = Array.new(target_sum + 1, 0)\\n  stones.each do |stone|\\n    target_sum.step(stone, -1).each do |i|\\n      dp[i] = [dp[i], dp[i - stone] + stone].max\\n    end\\n  end\\n  stones_sum - dp[target_sum] * 2\\nend\\n```",
                "solutionTags": [],
                "code": "```Ruby\\n# @param {Integer[]} stones\\n# @return {Integer}\\ndef last_stone_weight_ii(stones)\\n  stones_sum = stones.reduce(:+)\\n  target_sum = stones_sum / 2\\n  dp = Array.new(target_sum + 1, 0)\\n  stones.each do |stone|\\n    target_sum.step(stone, -1).each do |i|\\n      dp[i] = [dp[i], dp[i - stone] + stone].max\\n    end\\n  end\\n  stones_sum - dp[target_sum] * 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 331803,
                "title": "c-100-runtime-memory-dp-solution",
                "content": "The idea is to partition the array into two parts with sum of each subsets as close to totalSum/2 to minimize the difference. Also we need to only go till sum/2 as the sum of the other subset will be totalSum - sum of subset1. Then we just see which is the closest sum possible of subset1 and return totalSum-2*possibleSum\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int sum = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n            sum += stones[i];\\n        }\\n        bool dp[31][3100];\\n        for (int i = 0; i < stones.size(); i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i < sum/2; i++) {\\n            dp[0][i] = false;\\n        }\\n        \\n        for (int i = 1; i < stones.size()+1; i++) {\\n            for (int j = 1; j <= sum/2; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (stones[i-1] <= j) {\\n                    dp[i][j] |= dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int j = sum/2; j >=0; j--) {\\n            if (dp[stones.size()][j]) {\\n                ans = (sum - 2*j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int sum = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n            sum += stones[i];\\n        }\\n        bool dp[31][3100];\\n        for (int i = 0; i < stones.size(); i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i < sum/2; i++) {\\n            dp[0][i] = false;\\n        }\\n        \\n        for (int i = 1; i < stones.size()+1; i++) {\\n            for (int j = 1; j <= sum/2; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (stones[i-1] <= j) {\\n                    dp[i][j] |= dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int j = sum/2; j >=0; j--) {\\n            if (dp[stones.size()][j]) {\\n                ans = (sum - 2*j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310915,
                "title": "very-simple-to-understand-solution",
                "content": "The following solution is very simple to understand but it will fail because we do a lot of re-computations:\\n1. When you visit a number, you have two options. You can either add a +ve sign to it or a -ve sign to it.\\n2. The decision is based on whichever gives you a value that is closer to 0.\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        return Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n    }\\n}\\n```\\n\\nThe following solution does exactly the things described above but adds memoization on top of it so that we can avoid the re-computations.\\n```\\nclass Solution {\\n    Map<Integer, Map<Integer,Integer>> map = new HashMap<Integer, Map<Integer,Integer>>();\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        if(map.containsKey(i) && map.get(i).containsKey(sum)) return map.get(i).get(sum);\\n        \\n        int val = Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n        Map<Integer, Integer> subMap = map.getOrDefault(i, new HashMap<Integer, Integer>());\\n        subMap.put(sum, val);\\n        map.put(i, subMap);\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        return Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, Map<Integer,Integer>> map = new HashMap<Integer, Map<Integer,Integer>>();\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        if(map.containsKey(i) && map.get(i).containsKey(sum)) return map.get(i).get(sum);\\n        \\n        int val = Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n        Map<Integer, Integer> subMap = map.getOrDefault(i, new HashMap<Integer, Integer>());\\n        subMap.put(sum, val);\\n        map.put(i, subMap);\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306815,
                "title": "python-knapsack-simple-solution-using-recursion-memoization",
                "content": "```\\ndef lastStoneWeightII(self, stones):        \\n\\tdef maximize(i, space_left):\\n\\t\\tif (i, space_left) in memory:\\n\\t\\t\\treturn memory[i, space_left]\\n\\t\\telif i == len(stones) or space_left == 0:\\n\\t\\t\\treturn 0\\n\\t\\telif space_left < stones[i]:\\n\\t\\t\\treturn maximize(i+1, space_left)\\n\\t\\telse:\\n\\t\\t\\ttake_stone_i = stones[i] + maximize(i+1, space_left-stones[i])\\n\\t\\t\\tnot_take_stone_i = maximize(i+1, space_left)\\n\\t\\t\\tmax_sum_i = max(take_stone_i, not_take_stone_i)\\n\\t\\t\\tmemory[i, space_left] = max_sum_i\\n\\t\\t\\treturn max_sum_i\\n\\tmemory = {}\\n\\t# Fill up the knapsack of size floor(sum(stones)/2) as fully as possible\\n\\tmax_sum = maximize(0, sum(stones) / 2)\\n\\treturn sum(stones)-2*max_sum\\n```",
                "solutionTags": [],
                "code": "```\\ndef lastStoneWeightII(self, stones):        \\n\\tdef maximize(i, space_left):\\n\\t\\tif (i, space_left) in memory:\\n\\t\\t\\treturn memory[i, space_left]\\n\\t\\telif i == len(stones) or space_left == 0:\\n\\t\\t\\treturn 0\\n\\t\\telif space_left < stones[i]:\\n\\t\\t\\treturn maximize(i+1, space_left)\\n\\t\\telse:\\n\\t\\t\\ttake_stone_i = stones[i] + maximize(i+1, space_left-stones[i])\\n\\t\\t\\tnot_take_stone_i = maximize(i+1, space_left)\\n\\t\\t\\tmax_sum_i = max(take_stone_i, not_take_stone_i)\\n\\t\\t\\tmemory[i, space_left] = max_sum_i\\n\\t\\t\\treturn max_sum_i\\n\\tmemory = {}\\n\\t# Fill up the knapsack of size floor(sum(stones)/2) as fully as possible\\n\\tmax_sum = maximize(0, sum(stones) / 2)\\n\\treturn sum(stones)-2*max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295743,
                "title": "c-dp-solution-based-on-hints",
                "content": "```\\npublic int LastStoneWeightII(int[] stones) {\\n        var sums = new HashSet<int>();\\n\\t\\tsums.Add(0);\\n\\t\\t\\n\\t\\tforeach (var stone in stones) {\\n\\t\\t\\tvar nextSums = new HashSet<int>();\\t\\t\\t\\n\\t\\t\\tforeach (var s in sums) {\\n\\t\\t\\t\\tif (!nextSums.Contains(s+stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s+stone);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!nextSums.Contains(s-stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s-stone);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tsums = nextSums;\\n\\t\\t}\\t\\t\\n\\t\\t\\n\\t\\treturn sums.Where(s => s>=0).Min();\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int LastStoneWeightII(int[] stones) {\\n        var sums = new HashSet<int>();\\n\\t\\tsums.Add(0);\\n\\t\\t\\n\\t\\tforeach (var stone in stones) {\\n\\t\\t\\tvar nextSums = new HashSet<int>();\\t\\t\\t\\n\\t\\t\\tforeach (var s in sums) {\\n\\t\\t\\t\\tif (!nextSums.Contains(s+stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s+stone);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!nextSums.Contains(s-stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s-stone);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tsums = nextSums;\\n\\t\\t}\\t\\t\\n\\t\\t\\n\\t\\treturn sums.Where(s => s>=0).Min();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295621,
                "title": "c-dp-balanced-partition-problem-beats-100",
                "content": "Problem can be modified into another problem: **Partition the weights into 2 subsets such that the sum of the 2 subsets are as close to each other as possible**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        if (stones.empty())\\n            return 0;\\n        \\n        int sum = 0;\\n        for (int n : stones) sum += n;\\n        int target = sum / 2;\\n        bool dp[target + 1] = {false};\\n        dp[0] = true;\\n        for (int n : stones) {\\n            for (int j = target; j >= n; j--)\\n                dp[j] = dp[j] || dp[j - n];\\n        }\\n        for (int i = target; i > 0; i--) {\\n            if (dp[i])\\n                return abs(sum - 2*i);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Complexity:** `O(nS)` time, `O(S)` space (`S` = sum of all weights)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        if (stones.empty())\\n            return 0;\\n        \\n        int sum = 0;\\n        for (int n : stones) sum += n;\\n        int target = sum / 2;\\n        bool dp[target + 1] = {false};\\n        dp[0] = true;\\n        for (int n : stones) {\\n            for (int j = target; j >= n; j--)\\n                dp[j] = dp[j] || dp[j - n];\\n        }\\n        for (int i = target; i > 0; i--) {\\n            if (dp[i])\\n                return abs(sum - 2*i);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294999,
                "title": "c-convert-to-assignment",
                "content": "Change the problem to be +/- (coin change) problem.\\nTop down with memoization.\\nSince we want to get the final min residue (non-negative), we just take the min of abs() on each recursion returns.\\n\\n```\\nclass Solution {\\n  vector<unordered_map<int, int>> memo_;\\n  \\npublic:\\n  int lastStoneWeightII(vector<int>& stones) {\\n    memo_.resize(50);\\n    return doDFS(stones, 0, 0);\\n  }\\n  \\n  int doDFS(vector<int>& stones, int idx, int curSum) {\\n    if(idx == stones.size()) return curSum;\\n    if(memo_[idx].count(curSum)) return memo_[idx][curSum];\\n    \\n    return memo_[idx][curSum] =  min(abs(doDFS(stones, idx+1, curSum+stones[idx])), \\n                                     abs(doDFS(stones, idx+1, curSum-stones[idx])));\\n  }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  vector<unordered_map<int, int>> memo_;\\n  \\npublic:\\n  int lastStoneWeightII(vector<int>& stones) {\\n    memo_.resize(50);\\n    return doDFS(stones, 0, 0);\\n  }\\n  \\n  int doDFS(vector<int>& stones, int idx, int curSum) {\\n    if(idx == stones.size()) return curSum;\\n    if(memo_[idx].count(curSum)) return memo_[idx][curSum];\\n    \\n    return memo_[idx][curSum] =  min(abs(doDFS(stones, idx+1, curSum+stones[idx])), \\n                                     abs(doDFS(stones, idx+1, curSum-stones[idx])));\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294979,
                "title": "based-on-question-40",
                "content": "This question can be intepreted as the follwoing: Take any two rocks x and y, chang their values to 0 and ```y-x```. What is the smallest possible remaining non-zero value? \\nObviously this is asking us to split the list into two, with sum of each sublists as close as possible. \\nSo we calculate the sum, and get half of it, let ```half``` be either sum/2 or (sum-1)/2.\\nReduce  ```half``` from its original value down to 1. During this process, if we find a possible way get ```half``` from these stones, we easily know it\\'s possible to divide all stones into two sublists with sum of the first list = ```half``` and sum of the second one = ```sum - half```. Then the difference becomes ```sum - half - half```. \\n\\n// Note I have to modify my solution for Q40 a little bit to avoid TLE. Q40 wants ALL possible ways to get to target number. And here I want to return as soon as I find ONE way to get to target number ```half```\\n\\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length < 1) return 0;\\n        int sum = 0;\\n        for(int i : stones)\\n            sum += i;\\n        Arrays.sort(stones);\\n        \\n        int half = 0;\\n        if (sum % 2 == 0) {\\n            half = sum / 2;\\n        } else {\\n            half = (sum - 1) / 2;\\n        }\\n        for (int test = half; test > 0; test--) {\\n            if (findSum(stones, test)) {\\n                return sum - 2 * test;\\n            } else {\\n                \\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private boolean findSum(int[] stones, int target) {\\n        List<List<Integer>> result = combinationSum2(stones, target);\\n        if (result.size() > 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    // See Q40\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        // if (candidates == null || candidates.length == 0)\\n        //     return result;\\n        \\n        // Arrays.sort(candidates);\\n        int len = candidates.length;\\n        if (target < candidates[0]) // all positive\\n            return result;\\n        \\n        List<Integer> tuple = new ArrayList<>();\\n        int startIndex = 0;\\n        backtrack(result, tuple, candidates, startIndex, 0, target);\\n        \\n        return result;\\n    }\\n    \\n    boolean backtrack(List<List<Integer>> res, List<Integer> tuple, int[] cand, int index, int sum, int target) {\\n        if (sum == target) {\\n            List<Integer> temp = new ArrayList<>(tuple);\\n            res.add(temp);\\n            return true;\\n        } else if (sum > target) {\\n            // simply step back\\n            // System.out.println(\"exclude \" + tuple);\\n            return false;\\n        } else {\\n            // do normal backtracking\\n            for (int j = index; j < cand.length; j++) {\\n                \\n                // example [1,1,2,5,6,7,10], 8\\n                // 1,1,6 should be good, \\n                // first 1,2,5 is good, \\n                // second 1,2,5 is NOT good\\n                \\n                if (j != index && cand[j] == cand[j - 1])\\n                    continue; // skip duplicates\\n                \\n                tuple.add(cand[j]);\\n                \\n                if (backtrack(res, tuple, cand, j + 1, sum + cand[j], target)) {\\n                    return true;\\n                }\\n                \\n                tuple.remove(tuple.size() - 1);\\n            }\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```y-x```\n```half```\n```half```\n```half```\n```half```\n```sum - half```\n```sum - half - half```\n```half```\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length < 1) return 0;\\n        int sum = 0;\\n        for(int i : stones)\\n            sum += i;\\n        Arrays.sort(stones);\\n        \\n        int half = 0;\\n        if (sum % 2 == 0) {\\n            half = sum / 2;\\n        } else {\\n            half = (sum - 1) / 2;\\n        }\\n        for (int test = half; test > 0; test--) {\\n            if (findSum(stones, test)) {\\n                return sum - 2 * test;\\n            } else {\\n                \\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private boolean findSum(int[] stones, int target) {\\n        List<List<Integer>> result = combinationSum2(stones, target);\\n        if (result.size() > 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    // See Q40\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        // if (candidates == null || candidates.length == 0)\\n        //     return result;\\n        \\n        // Arrays.sort(candidates);\\n        int len = candidates.length;\\n        if (target < candidates[0]) // all positive\\n            return result;\\n        \\n        List<Integer> tuple = new ArrayList<>();\\n        int startIndex = 0;\\n        backtrack(result, tuple, candidates, startIndex, 0, target);\\n        \\n        return result;\\n    }\\n    \\n    boolean backtrack(List<List<Integer>> res, List<Integer> tuple, int[] cand, int index, int sum, int target) {\\n        if (sum == target) {\\n            List<Integer> temp = new ArrayList<>(tuple);\\n            res.add(temp);\\n            return true;\\n        } else if (sum > target) {\\n            // simply step back\\n            // System.out.println(\"exclude \" + tuple);\\n            return false;\\n        } else {\\n            // do normal backtracking\\n            for (int j = index; j < cand.length; j++) {\\n                \\n                // example [1,1,2,5,6,7,10], 8\\n                // 1,1,6 should be good, \\n                // first 1,2,5 is good, \\n                // second 1,2,5 is NOT good\\n                \\n                if (j != index && cand[j] == cand[j - 1])\\n                    continue; // skip duplicates\\n                \\n                tuple.add(cand[j]);\\n                \\n                if (backtrack(res, tuple, cand, j + 1, sum + cand[j], target)) {\\n                    return true;\\n                }\\n                \\n                tuple.remove(tuple.size() - 1);\\n            }\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294906,
                "title": "variant-of-956-tallest-billboard-time-o-ns-python-dp-with-explanation",
                "content": "The question is equivilant to: Divide the stoens into two groups. Calculate the total weight of each group. Try to make the two groups\\' weights as closer as possible.\\n\\nThis question is a variant of https://leetcode.com/problems/tallest-billboard/\\n\\n`dp(i, diff)` is a boolean value. It means whether using stons[0...i] (inclusive) can crash and results a remaining stone of weight `diff`. Both `i` and `diff` are non-negative numbers.\\n\\nThen search for `possible_result` from 0 increasingly. find the first `possible_result` such that `dp(n - 1, possible_result)` is true.\\n\\nThe time and space complexity are `O(NS)` where `S <= sum(stones)`\\n\\n```\\nimport functools\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def dp(i, diff):\\n            if i == 0:\\n                return diff == stones[0]\\n            return dp(i - 1, abs(diff - stones[i])) or dp(i - 1, diff + stones[i])\\n\\n        for possible_diff in range(max(stones) + 1):\\n            if dp(len(stones) - 1, possible_diff):\\n                return possible_diff\\n        assert(0)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def dp(i, diff):\\n            if i == 0:\\n                return diff == stones[0]\\n            return dp(i - 1, abs(diff - stones[i])) or dp(i - 1, diff + stones[i])\\n\\n        for possible_diff in range(max(stones) + 1):\\n            if dp(len(stones) - 1, possible_diff):\\n                return possible_diff\\n        assert(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800369,
                "title": "how-i-approched-3d-dp-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormally just make two variables s1 and s2 two store sum of individual subsets. \\nDo a proper knapsack by taking an element and by not taking it.\\nIt will give you a mle.\\n\\nTo make it working switch to 2d one by eliminating the s2 variable by calculating the total sum of the array and thus using it to calculate the s2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nfor 1. \\nO(n*s*s)\\nFor 2.\\nO(n*s)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(int i, int s1, int s2, vector<int>& nums,vector<vector<vector<int>>>&dp){\\n    if(i==nums.size()) return abs(s1-s2);\\n    if(dp[i][s1][s2]!=-1) return dp[i][s1][s2];\\n\\n    int take=solve(i+1, s1+nums[i], s2,nums, dp);\\n    int nottake=solve(i+1, s1, s2+nums[i], nums,dp);\\n    return dp[i][s1][s2]=min(take,nottake);\\n}\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n= stones.size();\\n       int sum= accumulate(stones.begin(), stones.end(), 0);\\n        //memset(dp,-1, sizeof(dp));\\n        vector<vector<vector<int>>>dp(n+1, vector<vector<int>>(sum+1,vector<int>(sum+1,-1)));\\n        return solve(0,0,0, stones,dp);\\n    }\\n};\\nWORKING SOLUTION\\n---------------------------------------------------------------------\\nclass Solution {\\npublic:\\nint dp[31][3001];\\nint mini(vector<int>&nums,int i,int n, int subsetsum, int sum){\\n      if(i==n) return abs(sum-2*subsetsum);\\n      if(dp[i][subsetsum]!=-1) return dp[i][subsetsum];\\n      int ans=0;\\n      ans=min(mini(nums,i+1,n, subsetsum+nums[i],sum),mini(nums,i+1,n,subsetsum,sum));\\n      return dp[i][subsetsum]=ans;\\n  }\\n    int lastStoneWeightII(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum=0;\\n        for(int x: nums){\\n            sum+=x;\\n        }\\n        int n=nums.size();\\n        return mini(nums,0,n,0,sum);\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(int i, int s1, int s2, vector<int>& nums,vector<vector<vector<int>>>&dp){\\n    if(i==nums.size()) return abs(s1-s2);\\n    if(dp[i][s1][s2]!=-1) return dp[i][s1][s2];\\n\\n    int take=solve(i+1, s1+nums[i], s2,nums, dp);\\n    int nottake=solve(i+1, s1, s2+nums[i], nums,dp);\\n    return dp[i][s1][s2]=min(take,nottake);\\n}\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n= stones.size();\\n       int sum= accumulate(stones.begin(), stones.end(), 0);\\n        //memset(dp,-1, sizeof(dp));\\n        vector<vector<vector<int>>>dp(n+1, vector<vector<int>>(sum+1,vector<int>(sum+1,-1)));\\n        return solve(0,0,0, stones,dp);\\n    }\\n};\\nWORKING SOLUTION\\n---------------------------------------------------------------------\\nclass Solution {\\npublic:\\nint dp[31][3001];\\nint mini(vector<int>&nums,int i,int n, int subsetsum, int sum){\\n      if(i==n) return abs(sum-2*subsetsum);\\n      if(dp[i][subsetsum]!=-1) return dp[i][subsetsum];\\n      int ans=0;\\n      ans=min(mini(nums,i+1,n, subsetsum+nums[i],sum),mini(nums,i+1,n,subsetsum,sum));\\n      return dp[i][subsetsum]=ans;\\n  }\\n    int lastStoneWeightII(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum=0;\\n        for(int x: nums){\\n            sum+=x;\\n        }\\n        int n=nums.size();\\n        return mini(nums,0,n,0,sum);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550854,
                "title": "c-unique-solution-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    unordered_set<int> helper(vector<int>& stones,int i,int j){\\n        if(j>i){\\n            if(j==i+1){\\n                return {abs(stones[j]-stones[i]),stones[j]+stones[i]};\\n            }\\n            int mid=(i+j)/2;\\n            unordered_set<int> p1=helper(stones,i,mid);\\n            unordered_set<int> p2=helper(stones,mid+1,j);\\n            unordered_set<int> ans;\\n            int maxi=0;\\n            for(int num1:p1){\\n                for(int num2:p2){\\n                    ans.insert(num1+num2);\\n                    ans.insert(abs(num1-num2));\\n                }\\n            }\\n            return ans;\\n        }\\n        return {stones[i]};\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> ans=helper(stones,0,stones.size()-1);\\n        int sol=INT_MAX;\\n        for(int num:ans)sol=min(sol,num);\\n        return sol;\\n    }\\n};\\n// [89,23,100,93,82,98,91,85,33,95,72,98,63,46,17,91,92,72,77,79,99,96,55,72,24,98,79,93,88,92]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> helper(vector<int>& stones,int i,int j){\\n        if(j>i){\\n            if(j==i+1){\\n                return {abs(stones[j]-stones[i]),stones[j]+stones[i]};\\n            }\\n            int mid=(i+j)/2;\\n            unordered_set<int> p1=helper(stones,i,mid);\\n            unordered_set<int> p2=helper(stones,mid+1,j);\\n            unordered_set<int> ans;\\n            int maxi=0;\\n            for(int num1:p1){\\n                for(int num2:p2){\\n                    ans.insert(num1+num2);\\n                    ans.insert(abs(num1-num2));\\n                }\\n            }\\n            return ans;\\n        }\\n        return {stones[i]};\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> ans=helper(stones,0,stones.size()-1);\\n        int sol=INT_MAX;\\n        for(int num:ans)sol=min(sol,num);\\n        return sol;\\n    }\\n};\\n// [89,23,100,93,82,98,91,85,33,95,72,98,63,46,17,91,92,72,77,79,99,96,55,72,24,98,79,93,88,92]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146270,
                "title": "knapsack-bottom-up-dp-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int knapsack(vector<int> &wt, int w, int n)\\n    {\\n        int dp[n+1][w+1];\\n        for (int i=0; i<=n; i++)\\n        {\\n            for (int j=0; j<=w; j++)\\n            {\\n                if(i==0 || j==0) dp[i][j]=0;\\n                else if (wt[i - 1] <= j)\\n                {\\n                    int val1=wt[i-1]+dp[i-1][j-wt[i-1]];\\n                    int val2=dp[i-1][j];\\n                    dp[i][j]=max(val1,val2);\\n                }\\n                else if(wt[i-1]>j) dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][w];\\n    }\\n    int lastStoneWeightII(vector<int> &stones)\\n    {\\n        int sum = 0, n=stones.size();\\n        for (auto stone : stones) sum += stone;\\n        return sum-2*knapsack(stones,sum/2,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int knapsack(vector<int> &wt, int w, int n)\\n    {\\n        int dp[n+1][w+1];\\n        for (int i=0; i<=n; i++)\\n        {\\n            for (int j=0; j<=w; j++)\\n            {\\n                if(i==0 || j==0) dp[i][j]=0;\\n                else if (wt[i - 1] <= j)\\n                {\\n                    int val1=wt[i-1]+dp[i-1][j-wt[i-1]];\\n                    int val2=dp[i-1][j];\\n                    dp[i][j]=max(val1,val2);\\n                }\\n                else if(wt[i-1]>j) dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][w];\\n    }\\n    int lastStoneWeightII(vector<int> &stones)\\n    {\\n        int sum = 0, n=stones.size();\\n        for (auto stone : stones) sum += stone;\\n        return sum-2*knapsack(stones,sum/2,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444405,
                "title": "easy-c-solution",
                "content": "[![image](https://assets.leetcode.com/users/images/032dafef-ee91-467f-b2d9-8eedfc7d1380_1660825349.0208166.jpeg)\\n![image](https://assets.leetcode.com/users/images/a8102f3b-2fc7-4b68-aabe-1c87849ecfa8_1660825372.8207896.jpeg)\\n\\nFor the Detailed explanation of the code see the video of \"minimum subset sum difference\" problem.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(auto i:stones) s+=i;\\n        bool dp[n+1][s+1];\\n        for(int i=0;i<=s;i++) dp[0][i]=false;\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(stones[i-1]>j) dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n            }\\n        }\\n        int mi=INT_MAX;\\n        for(int i=0;i<=s;i++)\\n        {\\n            if(dp[n][i]==true)\\n            {\\n                mi=min(mi,abs(s-2*i));\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n\\n\\n````\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(auto i:stones) s+=i;\\n        bool dp[n+1][s+1];\\n        for(int i=0;i<=s;i++) dp[0][i]=false;\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(stones[i-1]>j) dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n            }\\n        }\\n        int mi=INT_MAX;\\n        for(int i=0;i<=s;i++)\\n        {\\n            if(dp[n][i]==true)\\n            {\\n                mi=min(mi,abs(s-2*i));\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424787,
                "title": "c-similar-to-equal-sum-partition",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n       \\n        int n = stones.size();\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum = sum + stones[i];\\n           \\n        }\\n         int dp[n+1][sum/2+1];\\n        dp[0][0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int j = 1;j<=sum/2+1;j++){\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=sum/2;j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(stones[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int j = sum/2;j>=0;j--){\\n            if(dp[n][j]){\\n            ans = min(ans,sum-2*j);\\n\\t\\t\\treturn ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n       \\n        int n = stones.size();\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum = sum + stones[i];\\n           \\n        }\\n         int dp[n+1][sum/2+1];\\n        dp[0][0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int j = 1;j<=sum/2+1;j++){\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=sum/2;j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(stones[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int j = sum/2;j>=0;j--){\\n            if(dp[n][j]){\\n            ans = min(ans,sum-2*j);\\n\\t\\t\\treturn ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382121,
                "title": "python-dp-solution-with-explanation-0-1-knapsack-problem",
                "content": "the problem can be transfer to spliting the ```stones``` and making difference of the two subset\\'s sum is smallest.\\n\\nex. stones =```[2,7,4,1,8,1]```\\nthere have two sets, namely addition and substraction\\n```1 = (4-2)-(8-7)-1+1```\\nit mean when two stones combine together, and if there have a remain stone after combine together, the remain stone will combine again, and we can add plus sign or minus sign to remain stone, it mean that the set where the two original stones are located is exchanged if we use minus sign\\n\\n```\\nsum(A) + sum(B) = sum(stones)\\nsum(A) - sum(B) = diff, diff >= 0\\n\\n2 * sum(B) = sum(stones) - diff\\ndiff = sum(stones) - 2 * sum(B)\\nminimize diff to 0\\nsum(stones) - 2 * sum(B) >= 0\\nsum(B) as close to the half of sum(stones) as possible \\n```\\n\\nthe problem is similar to [494. target sum solution](https://leetcode.com/problems/target-sum/discuss/2377796/python-dp-and-top-down-solution-with-explanation), it also is 0/1 Knapsack Problem\\n\\n```dp[i][j]``` means that ```stones[:i]``` can be put into a bag of size ```j```, the maximum value of the sum in the bag\\nif the stone can be put into the bag, we have two choice, one is to put it to the bag```dp[i-1][j - stones[i-1]] + stones[i-1]```, another is not```dp[i-1][j]```, choose the option with a larger value.\\n\\ntc is ```O((sum(stones) // 2) * len(stones))```, sc is the same as tc\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones) == 1: return stones[0]\\n        total = sum(stones)\\n        half, leng =  total// 2, len(stones)\\n        dp = [[0] *  (half + 1) for _ in  range(leng + 1)]\\n        \\n        for i in range(1, leng+1):\\n            for j in range(1, half+1):\\n                if j - stones[i-1] >= 0:\\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i-1]] + stones[i-1])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return total - 2 * dp[leng][half]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```stones```\n```[2,7,4,1,8,1]```\n```1 = (4-2)-(8-7)-1+1```\n```\\nsum(A) + sum(B) = sum(stones)\\nsum(A) - sum(B) = diff, diff >= 0\\n\\n2 * sum(B) = sum(stones) - diff\\ndiff = sum(stones) - 2 * sum(B)\\nminimize diff to 0\\nsum(stones) - 2 * sum(B) >= 0\\nsum(B) as close to the half of sum(stones) as possible \\n```\n```dp[i][j]```\n```stones[:i]```\n```j```\n```dp[i-1][j - stones[i-1]] + stones[i-1]```\n```dp[i-1][j]```\n```O((sum(stones) // 2) * len(stones))```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones) == 1: return stones[0]\\n        total = sum(stones)\\n        half, leng =  total// 2, len(stones)\\n        dp = [[0] *  (half + 1) for _ in  range(leng + 1)]\\n        \\n        for i in range(1, leng+1):\\n            for j in range(1, half+1):\\n                if j - stones[i-1] >= 0:\\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i-1]] + stones[i-1])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return total - 2 * dp[leng][half]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296191,
                "title": "0-1-knapsack",
                "content": "divide the sum into two half to get the min. diff.  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ks(vector<int> &w ,int c)\\n    {\\n        int n = w.size();\\n        vector<vector<int>> cache(n+1,vector<int> (c+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j = 1;j<=c;j++)\\n            {\\n                cache[i][j] = max(cache[i][j],cache[i-1][j]);\\n                if(j>=w[i-1])\\n                {\\n                    cache[i][j] = max(cache[i][j],w[i-1]+cache[i-1][j-w[i-1]]);\\n                }\\n            }\\n        }\\n        return cache[n][c];\\n            \\n    }\\n    \\n    int lastStoneWeightII(vector<int>& a) {\\n        int s  = accumulate(a.begin(),a.end(),0);\\n        int val   = s/2;\\n        int res = ks(a,val);\\n        int  resi = s-res;          \\n        return abs(resi-res);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ks(vector<int> &w ,int c)\\n    {\\n        int n = w.size();\\n        vector<vector<int>> cache(n+1,vector<int> (c+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j = 1;j<=c;j++)\\n            {\\n                cache[i][j] = max(cache[i][j],cache[i-1][j]);\\n                if(j>=w[i-1])\\n                {\\n                    cache[i][j] = max(cache[i][j],w[i-1]+cache[i-1][j-w[i-1]]);\\n                }\\n            }\\n        }\\n        return cache[n][c];\\n            \\n    }\\n    \\n    int lastStoneWeightII(vector<int>& a) {\\n        int s  = accumulate(a.begin(),a.end(),0);\\n        int val   = s/2;\\n        int res = ks(a,val);\\n        int  resi = s-res;          \\n        return abs(resi-res);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263634,
                "title": "c-min-subset-diff-dp-explained-with-intuition",
                "content": "```\\n/*\\nthis is a variation of targte sum (leetcode 494) ,\\nbecause if u\\'ll see , here one one side we are adding elemnts \\nand , on the other side we are subtracting them,\\n\\ne.g-> stones = [2,7,4,1,8,1]\\n4-2=2;\\n8-7=1;\\n2-1=1;\\n1-1=1;\\n\\n\\nnow :\\n2-1=1;\\n1-1=0;\\n\\ntherefore 1 is left., which is our answer\\n\\n\\nthis is nothing but (4+7+1) - (2+8+1) =1\\n\\ntherefore we are calculating minimum subset differnce in the array\\n*/\\nclass Solution {\\npublic:\\n    int minSubsetDiff(vector<int>& stones,int range){\\n        int n=stones.size();\\n        vector<vector<int>> t(n+1,vector<int>(range+1));\\n        vector<int> check;\\n       for(int i=0;i<n+1;i++)\\n           t[i][0]=1;\\n        \\n        for(int i=1;i<range+1;i++)\\n           t[0][i]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<range+1;j++){\\n                if(stones[i-1]<=j)\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                \\n                else\\n                     t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        for(int j=0;j<=range/2;j++){\\n            if(t[n][j])\\n                check.push_back(j);\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<check.size();i++){\\n            ans=min(ans,range-(2*check[i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n         int n=stones.size();\\n         int sum=0;\\n         for(int i=0;i<n;i++){\\n             sum+=stones[i];\\n         }\\n        \\n        return minSubsetDiff(stones,sum);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minSubsetDiff(vector<int>& stones,int range){\\n        int n=stones.size();\\n        vector<vector<int>> t(n+1,vector<int>(range+1));\\n        vector<int> check;\\n       for(int i=0;i<n+1;i++)\\n           t[i][0]=1;\\n        \\n        for(int i=1;i<range+1;i++)\\n           t[0][i]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<range+1;j++){\\n                if(stones[i-1]<=j)\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                \\n                else\\n                     t[i][j]=t[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249240,
                "title": "dp-solution-explained-with-comments-and-compared-to-minimum-subset-sum-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& arr) {\\n        //take any two group of stones , if there will be equal stones they will cancel out each other \\n        // else they will create diff, we have to find minimum possible difference \\n        //it is equivalent to minimum subset sum difference problem \\n        \\n        int n=arr.size() ;\\n        int sum = 0 ; \\n\\t    for(int i=0;i<n;i++)\\n\\t        sum+=arr[i] ;\\n\\t    \\n\\t    //now create the table for subset SUm DP  ; \\n\\t    \\n\\t    bool dp[n+1][sum+1] ;\\n\\t    \\n\\t    \\n\\t    //initialization\\n\\t    for(int j=0 ; j<sum+1 ;j++)\\n\\t        dp[0][j] = false; \\n\\t    \\n\\t    for(int i=0;i<n+1;i++)\\n\\t        dp[i][0] = true ;\\n\\t        \\n\\t\\t\\t//subset Sum code to create the DDP table\\n\\t    \\n\\t    for(int i=1 ;i<n+1;i++){\\n\\t        for(int j=1;j<sum+1;j++){\\n\\t            \\n\\t            if(arr[i-1]<=j)\\n\\t                dp[i][j] = dp[i-1][j-arr[i-1]] or dp[i-1][j] ; \\n\\t            else\\n\\t                dp[i][j] = dp[i-1][j] ; \\n\\t        }\\n\\t    }\\n\\t    \\n\\t    //initializing a variable to store minimum difference from last  row of DP to find possible sum  \\n\\t    int minima = INT_MAX ; \\n\\t    for(int j=0 ;j<= sum/2 ;j++)\\n\\t    {\\n\\t        if(dp[n][j]==true) \\n\\t            minima = min(minima , sum - 2*j) ;\\n\\t    }\\n\\t    return minima ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& arr) {\\n        //take any two group of stones , if there will be equal stones they will cancel out each other \\n        // else they will create diff, we have to find minimum possible difference \\n        //it is equivalent to minimum subset sum difference problem \\n        \\n        int n=arr.size() ;\\n        int sum = 0 ; \\n\\t    for(int i=0;i<n;i++)\\n\\t        sum+=arr[i] ;\\n\\t    \\n\\t    //now create the table for subset SUm DP  ; \\n\\t    \\n\\t    bool dp[n+1][sum+1] ;\\n\\t    \\n\\t    \\n\\t    //initialization\\n\\t    for(int j=0 ; j<sum+1 ;j++)\\n\\t        dp[0][j] = false; \\n\\t    \\n\\t    for(int i=0;i<n+1;i++)\\n\\t        dp[i][0] = true ;\\n\\t        \\n\\t\\t\\t//subset Sum code to create the DDP table\\n\\t    \\n\\t    for(int i=1 ;i<n+1;i++){\\n\\t        for(int j=1;j<sum+1;j++){\\n\\t            \\n\\t            if(arr[i-1]<=j)\\n\\t                dp[i][j] = dp[i-1][j-arr[i-1]] or dp[i-1][j] ; \\n\\t            else\\n\\t                dp[i][j] = dp[i-1][j] ; \\n\\t        }\\n\\t    }\\n\\t    \\n\\t    //initializing a variable to store minimum difference from last  row of DP to find possible sum  \\n\\t    int minima = INT_MAX ; \\n\\t    for(int j=0 ;j<= sum/2 ;j++)\\n\\t    {\\n\\t        if(dp[n][j]==true) \\n\\t            minima = min(minima , sum - 2*j) ;\\n\\t    }\\n\\t    return minima ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202929,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int s = 0;\\n        for(auto a:stones) s+=a;\\n        int ans, i, j;\\n        if(s%2==0) ans=0;\\n        else ans=1;\\n        s /= 2;\\n        vector<vector<bool>> dp(stones.size()+1, vector<bool>(s+1, false));\\n        dp[0][0] = true;\\n        sort(stones.begin(), stones.end());\\n        for(i=1; i<=stones.size(); ++i)\\n            for(j=0; j<=s; ++j){\\n                if(j==0) dp[i][j] = true;\\n                else if(j<stones[i-1]) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n             }\\n        while(!dp[i-1][s--]) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int s = 0;\\n        for(auto a:stones) s+=a;\\n        int ans, i, j;\\n        if(s%2==0) ans=0;\\n        else ans=1;\\n        s /= 2;\\n        vector<vector<bool>> dp(stones.size()+1, vector<bool>(s+1, false));\\n        dp[0][0] = true;\\n        sort(stones.begin(), stones.end());\\n        for(i=1; i<=stones.size(); ++i)\\n            for(j=0; j<=s; ++j){\\n                if(j==0) dp[i][j] = true;\\n                else if(j<stones[i-1]) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n             }\\n        while(!dp[i-1][s--]) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166581,
                "title": "simple-java-dp-solution",
                "content": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int dp[] = new int[15000];\\n        int sum = 0;\\n        for(int i=0;i<stones.length;i++){\\n            sum += stones[i];\\n        }\\n        int target = sum / 2;\\n        for(int i=0;i<stones.length;i++){\\n            for(int j=target;j>=stones[i];j--){\\n                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);\\n            }\\n        }\\n        return sum - dp[target] - dp[target];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int dp[] = new int[15000];\\n        int sum = 0;\\n        for(int i=0;i<stones.length;i++){\\n            sum += stones[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2161416,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, A):\\n        ans = _sum = sum(A)\\n        n = _sum // 2 + 1\\n        dp = [False] * n\\n        dp[0] = True\\n        for i in A:\\n            for j in range(n-1,i-1,-1):\\n                dp[j] = dp[j] | dp[j-i]\\n                if dp[j]: ans = min(ans,_sum - 2*j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, A):\\n        ans = _sum = sum(A)\\n        n = _sum // 2 + 1\\n        dp = [False] * n\\n        dp[0] = True\\n        for i in A:\\n            for j in range(n-1,i-1,-1):\\n                dp[j] = dp[j] | dp[j-i]\\n                if dp[j]: ans = min(ans,_sum - 2*j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078876,
                "title": "explanation-of-logic-why-it-can-be-treat-as-an-01-knapsack-problem",
                "content": "This is what I think to understand this problem, hope it is useful for those who can\\'t accept other explanations.\\n\\n\\nExample:\\n\\nAssume that we have 3 stones a, b, c, and the best order is a crush b then crush c\\n\\nWe have 4 possibilities\\n\\n1:  a > b and c >= a-b  => the result will be c - (a - b) = c - a + b\\n\\n2:  a < b and c >= b-a => the result will be c - (b - a) = c - b + a\\n\\n3: a > b and c < a-b => the result will be a - b - c\\n\\n4: a < b and c < b-a=> the result will be b - a - c\\n\\nFor multiple elements, they eventually can be crushed to this base case.\\n\\nIn fact, after every crush is equal to performing a \"+\" or \"-\" to the crushed stone.\\n\\n\\nSo this problem is actually asking:\\n\\n\"Put +/- between these elements such that the absolute value of the result is minimum\"\\n\\n=> make abs(s1 + s2 +... + sn - sn+1 - sn+2 -... -sm) as small as possible, and we can seperate this into 2 groups\\n\\n=> abs(sum(s1, s2, ..., sn) - sum(sn+1, sn+2, ..., sm))\\n\\nLet s1 + s2+... + sn <= sn+1 + ... + sm\\n\\n=>\\n\\nminimum diff = sn+1 + ... + sm - s1 - ... - sn = sn+1+...+sm+s1+...+sn - 2*(s1+...+sn) = sum(all stones) - 2*(s1 + ... + sn)\\n\\n\\nNow here is the conclusion,\\n\\n01 knapsack :\\n volume of bag: sum(all stones) // 2 \\n (here, we want to find s1, ..., sn, don\\'t forget that we assume the sum of this group <= another group, so this set will not be larger than sum(all stones)//2)\\n objects s1, ..., sm \\n the value is equal to the weight\\n \\n According to above, we can finally write some codes.\\n\\n\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        SUM = sum(stones)\\n        target =  SUM // 2\\n        table = [0] * (target + 1)\\n        for stone in stones:\\n            for remain_weight in range(target, stone-1, -1):\\n                table[remain_weight] = max(table[remain_weight], table[remain_weight-stone] + stone)\\n        return SUM - 2*table[target]\\n\\n\\nHope this can help you!",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is what I think to understand this problem, hope it is useful for those who can\\'t accept other explanations.\\n\\n\\nExample:\\n\\nAssume that we have 3 stones a, b, c, and the best order is a crush b then crush c\\n\\nWe have 4 possibilities\\n\\n1:  a > b and c >= a-b  => the result will be c - (a - b) = c - a + b\\n\\n2:  a < b and c >= b-a => the result will be c - (b - a) = c - b + a\\n\\n3: a > b and c < a-b => the result will be a - b - c\\n\\n4: a < b and c < b-a=> the result will be b - a - c\\n\\nFor multiple elements, they eventually can be crushed to this base case.\\n\\nIn fact, after every crush is equal to performing a \"+\" or \"-\" to the crushed stone.\\n\\n\\nSo this problem is actually asking:\\n\\n\"Put +/- between these elements such that the absolute value of the result is minimum\"\\n\\n=> make abs(s1 + s2 +... + sn - sn+1 - sn+2 -... -sm) as small as possible, and we can seperate this into 2 groups\\n\\n=> abs(sum(s1, s2, ..., sn) - sum(sn+1, sn+2, ..., sm))\\n\\nLet s1 + s2+... + sn <= sn+1 + ... + sm\\n\\n=>\\n\\nminimum diff = sn+1 + ... + sm - s1 - ... - sn = sn+1+...+sm+s1+...+sn - 2*(s1+...+sn) = sum(all stones) - 2*(s1 + ... + sn)\\n\\n\\nNow here is the conclusion,\\n\\n01 knapsack :\\n volume of bag: sum(all stones) // 2 \\n (here, we want to find s1, ..., sn, don\\'t forget that we assume the sum of this group <= another group, so this set will not be larger than sum(all stones)//2)\\n objects s1, ..., sm \\n the value is equal to the weight\\n \\n According to above, we can finally write some codes.\\n\\n\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        SUM = sum(stones)\\n        target =  SUM // 2\\n        table = [0] * (target + 1)\\n        for stone in stones:\\n            for remain_weight in range(target, stone-1, -1):\\n                table[remain_weight] = max(table[remain_weight], table[remain_weight-stone] + stone)\\n        return SUM - 2*table[target]\\n\\n\\nHope this can help you!",
                "codeTag": "Python3"
            },
            {
                "id": 2024273,
                "title": "easy-java-solution-with-few-lines-of-code-similar-to-coin-change",
                "content": "\\xB4\\xB4\\xB4\\xB4\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       int sum = 0;\\n        \\n        for(int stone : stones){\\n            sum += stone;    \\n        }\\n        \\n        int half = sum / 2;\\n        int[] dp = new int[half+1];\\n        \\n        for(int stone : stones){\\n            for(int i=half;i>=0; i--){\\n                if(i-stone >= 0){\\n                    dp[i] = Math.max(dp[i], dp[i-stone] + stone);\\n                }\\n            }\\n        }\\n        \\n        return sum- 2*dp[half];\\n    }\\n}\\n\\xB4\\xB4\\xB4\\xB4",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       int sum = 0;\\n        \\n        for(int stone : stones){\\n            sum += stone;    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2007036,
                "title": "dp-again-01-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        int target = sum >> 1;\\n        vector<int> dp(target + 1, 0);\\n        for (int stone : stones)\\n            for (int i = target; i >= stone; i--)\\n                dp[i] = max(dp[i], dp[i - stone] + stone);\\n        int res = sum - dp[target] * 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        int target = sum >> 1;\\n        vector<int> dp(target + 1, 0);\\n        for (int stone : stones)\\n            for (int i = target; i >= stone; i--)\\n                dp[i] = max(dp[i], dp[i - stone] + stone);\\n        int res = sum - dp[target] * 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976119,
                "title": "is-the-problem-description-incorrect",
                "content": "Bit confused. The problem states that `x <= y` and to destory `x` and replace `y` with `y - x`.\\n\\nCool, totally makes sense, but then why does your explanation show...\\n\\n```\\nInput: stones = [2,7,4,1,8,1]\\nOutput: 1\\nExplanation:\\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1]\\n```\\n\\nGoing by the problem description, yes we can combine 2 and 4 to get 2 BUT that would mean our resultant array should be (assuming `x` is less than `y`)...\\n\\n```\\nstones = [7,2,1,8,1]\\n```\\n\\nAm I missing something?",
                "solutionTags": [],
                "code": "```\\nInput: stones = [2,7,4,1,8,1]\\nOutput: 1\\nExplanation:\\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1]\\n```\n```\\nstones = [7,2,1,8,1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966490,
                "title": "python-knapsack",
                "content": "\\n    def lastStoneWeightII(self, stone):\\n        @lru_cache(None)\\n        def dp(index, capacity):\\n            if index == 0:\\n                return 0\\n            \\n            if capacity <= 0:\\n                return 0\\n            \\n            if capacity >= stone[index-1]:\\n                return max(dp(index-1, capacity), dp(index-1, capacity - stone[index-1]) + stone[index-1])\\n            else:\\n                return dp(index-1, capacity)\\n            \\n        return abs(sum(stone) - 2*dp(len(stone), sum(stone)//2))",
                "solutionTags": [],
                "code": "\\n    def lastStoneWeightII(self, stone):\\n        @lru_cache(None)\\n        def dp(index, capacity):\\n            if index == 0:\\n                return 0\\n            \\n            if capacity <= 0:\\n                return 0\\n            \\n            if capacity >= stone[index-1]:\\n                return max(dp(index-1, capacity), dp(index-1, capacity - stone[index-1]) + stone[index-1])\\n            else:\\n                return dp(index-1, capacity)\\n            \\n        return abs(sum(stone) - 2*dp(len(stone), sum(stone)//2))",
                "codeTag": "Python3"
            },
            {
                "id": 1959682,
                "title": "python3-converted-to-knapsack-problem",
                "content": "Essentially, this problem is to find two subsequences with minimun difference in term of sequence sum\\nFor instance, the stones array are divided into seq1 and seq2, regardless of how to pick  stones from seq1 and seq2 and smash them, finally either seq1 or seq2 is empty.\\nIf seq1 and seq2 are not empty, you can continue smash until one of them is empty.\\nSo the problem became how to make the sum of seq1 and the sum of seq2 are as close as possible. seq1 and seq2 should be close to half sum of total array.\\nThen it\\'s easy to convert it to a 0/1 knapsack problem. The volume of knapsack is sum(stones)//2\\npick a sequence whose sum is closest to the volume of the knapsack.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        total_sum =  sum(stones)\\n        V = total_sum//2\\n        @cache\\n        def knapsack(i:int, v:int) -> int:\\n            if v <= 0:\\n                return 0\\n            if i < 0:\\n                return 0\\n            if stones[i] > v:\\n                return knapsack(i-1, v)\\n            else:\\n                return max(knapsack(i-1, v), stones[i] + knapsack(i-1, v - stones[i]))\\n        return abs(total_sum - 2*knapsack(n-1, V))",
                "solutionTags": [],
                "code": "Essentially, this problem is to find two subsequences with minimun difference in term of sequence sum\\nFor instance, the stones array are divided into seq1 and seq2, regardless of how to pick  stones from seq1 and seq2 and smash them, finally either seq1 or seq2 is empty.\\nIf seq1 and seq2 are not empty, you can continue smash until one of them is empty.\\nSo the problem became how to make the sum of seq1 and the sum of seq2 are as close as possible. seq1 and seq2 should be close to half sum of total array.\\nThen it\\'s easy to convert it to a 0/1 knapsack problem. The volume of knapsack is sum(stones)//2\\npick a sequence whose sum is closest to the volume of the knapsack.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        total_sum =  sum(stones)\\n        V = total_sum//2\\n        @cache\\n        def knapsack(i:int, v:int) -> int:\\n            if v <= 0:\\n                return 0\\n            if i < 0:\\n                return 0\\n            if stones[i] > v:\\n                return knapsack(i-1, v)\\n            else:\\n                return max(knapsack(i-1, v), stones[i] + knapsack(i-1, v - stones[i]))\\n        return abs(total_sum - 2*knapsack(n-1, V))",
                "codeTag": "Java"
            },
            {
                "id": 1935289,
                "title": "dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[34][3010];\\n    int func(vector<int>&arr,int i,int sum,int mer,int n)\\n    {\\n        if(i>=n)\\n        {\\n            return abs(sum-mer);\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        int x=min(func(arr,i+1,sum,mer,n),func(arr,i+1,sum-arr[i],mer+arr[i],n));\\n        return dp[i][sum]=x;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        memset(dp,-1,sizeof dp);\\n        for(auto i : stones)\\n        {\\n            sum+=i;\\n        }\\n        \\n        return func(stones,0,sum,0,stones.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[34][3010];\\n    int func(vector<int>&arr,int i,int sum,int mer,int n)\\n    {\\n        if(i>=n)\\n        {\\n            return abs(sum-mer);\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        int x=min(func(arr,i+1,sum,mer,n),func(arr,i+1,sum-arr[i],mer+arr[i],n));\\n        return dp[i][sum]=x;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        memset(dp,-1,sizeof dp);\\n        for(auto i : stones)\\n        {\\n            sum+=i;\\n        }\\n        \\n        return func(stones,0,sum,0,stones.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929171,
                "title": "python-o-1-memory-random-search",
                "content": "Considering the small size constraint of 30, a random shuffle bruteforce passes all cases with constant space\\n```\\nimport functools as ft\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ans = 999\\n        for i in range(len(stones) * 50):\\n            random.shuffle(stones)\\n            ans = min(ans, ft.reduce(lambda a,v: v if a==0 else abs(a-v), stones))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools as ft\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ans = 999\\n        for i in range(len(stones) * 50):\\n            random.shuffle(stones)\\n            ans = min(ans, ft.reduce(lambda a,v: v if a==0 else abs(a-v), stones))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834336,
                "title": "javascript-solution-dp",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeightII = function(stones) {\\n    if (stones.length === 1) { return stones.pop(); }\\n    let sum = 0;\\n    for (let stone of stones) {\\n        sum += stone;\\n    }\\n    \\n    let candidates = [];\\n    for (let stone of stones) {\\n        let newCandidates = [];\\n        newCandidates.push(stone);\\n        \\n        candidates.forEach((n) => {\\n            if (!candidates.includes(n + stone)) {\\n                newCandidates.push(n + stone);\\n            }\\n        });\\n        \\n        candidates = [...candidates, ...newCandidates.filter((a) => a <= sum/2)];   \\n    }\\n    \\n    candidates.sort((a, b) => Number(a) - Number(b));\\n    \\n    let s = candidates.pop()\\n    return (sum - s) - s;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeightII = function(stones) {\\n    if (stones.length === 1) { return stones.pop(); }\\n    let sum = 0;\\n    for (let stone of stones) {\\n        sum += stone;\\n    }\\n    \\n    let candidates = [];\\n    for (let stone of stones) {\\n        let newCandidates = [];\\n        newCandidates.push(stone);\\n        \\n        candidates.forEach((n) => {\\n            if (!candidates.includes(n + stone)) {\\n                newCandidates.push(n + stone);\\n            }\\n        });\\n        \\n        candidates = [...candidates, ...newCandidates.filter((a) => a <= sum/2)];   \\n    }\\n    \\n    candidates.sort((a, b) => Number(a) - Number(b));\\n    \\n    let s = candidates.pop()\\n    return (sum - s) - s;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564755,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564607,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564937,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565168,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565453,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1566623,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565911,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567726,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567685,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568313,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564755,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564607,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564937,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565168,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565453,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1566623,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565911,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567726,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567685,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568313,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568257,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1568141,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1570737,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1570720,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1575053,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1574931,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1574880,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1573608,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 2056739,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1934811,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Days to Eat N Oranges",
        "question_content": "<p>There are <code>n</code> oranges in the kitchen and you decided to eat some of these oranges every day as follows:</p>\n\n<ul>\n\t<li>Eat one orange.</li>\n\t<li>If the number of remaining oranges <code>n</code> is divisible by <code>2</code> then you can eat <code>n / 2</code> oranges.</li>\n\t<li>If the number of remaining oranges <code>n</code> is divisible by <code>3</code> then you can eat <code>2 * (n / 3)</code> oranges.</li>\n</ul>\n\n<p>You can only choose one of the actions per day.</p>\n\n<p>Given the integer <code>n</code>, return <em>the minimum number of days to eat</em> <code>n</code> <em>oranges</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 794162,
                "title": "c-java-python-5-lines",
                "content": "#### Intuition\\nAs pleasant as it seems, it does not make sense to eat oranges one by one.\\n\\nSo, the choice we have is to eat `n % 2` oranges one-by-one and then swallow `n / 2`, or eat `n % 3` oranges so that we can gobble `2 * n / 3`.\\n\\nAs usual, we use DP to memoise results and avoid re-computation. Since our numbers can be large, it\\'s better to use a hash map instead of an array.\\n\\n> Why doesn\\'t make sense to eat 2 oranges first, and then do `n / 2`? Let\\'s say `k` is one of the divisors we can use. `(n - k) / k` equals `n / k - 1`. We can reach `n / k - 1` in two actions: `n / k` and `n / k - 1`, while `(n - k) / k` requires `k + 1` actions. If `k == 2`, then we have 2 vs. 3 actions, and the difference grows with `k`.\\n\\n**C++**\\nIf you want the fastest runtime (~4 ms), make `dp` global.\\n\\n```cpp\\nunordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) == 0)\\n        dp[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3));\\n    return dp[n];\\n}\\n```\\n**Java**\\n```java\\nMap<Integer, Integer> dp = new HashMap<>();\\npublic int minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (!dp.containsKey(n))\\n        dp.put(n, 1 + Math.min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3)));\\n    return dp.get(n);\\n}\\n```\\n**Python**\\n```python\\nclass Solution:\\n    @lru_cache()\\n    def minDays(self, n: int) -> int:\\n        if n <= 1:\\n            return n;\\n        return 1 + min(n % 2 + self.minDays(n // 2), n % 3 + self.minDays(n // 3));   \\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) == 0)\\n        dp[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3));\\n    return dp[n];\\n}\\n```\n```java\\nMap<Integer, Integer> dp = new HashMap<>();\\npublic int minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (!dp.containsKey(n))\\n        dp.put(n, 1 + Math.min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3)));\\n    return dp.get(n);\\n}\\n```\n```python\\nclass Solution:\\n    @lru_cache()\\n    def minDays(self, n: int) -> int:\\n        if n <= 1:\\n            return n;\\n        return 1 + min(n % 2 + self.minDays(n // 2), n % 3 + self.minDays(n // 3));   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 794088,
                "title": "python-golang-intuitive-solution-with-proof",
                "content": "**Idea**\\nThe key idea is that we should never take more than 2 consecutive `-1` operations.\\n\\n**Proof**\\nLet\\'s prove by contradiction.\\n\\nSuppose there exists some n, where we need to take 3 consecutive `-1` operations for the optimal schedule.\\nFormally, all of the following holds.\\n- `minDays(n - 3) + 3 < minDays(n - 2) + 2`, meaning taking 2 `-1` is worse than taking 3 `-1`\\n- `minDays(n - 3) + 3 < minDays(n - 1) + 1`, meaning taking 1 `-1` is worse than taking 3 `-1`\\n- `minDays(n - 3) + 3 < minDays(n )`, meaning taking 0 `-1` is worse than taking 3 `-1`\\n\\n- if the first operation we take for `n - 3` is `/2`, then we ends in `(n - 3) / 2 = (n - 1) / 2 - 1`\\n\\t- we can easily tell minDays((n - 3) / 2) can be achieved by `-1, /2 - 1` instead of `-1, -1, -1, /2`. Thus taking 3 `-1` is not optimal\\n- if the first operation we take for `n - 3` is `/3`, then we ends in `(n - 3) / 3 = n / 3 - 1`\\n\\t- we can easily tell minDays((n - 3) / 3) can be achieved by `-1, /3` instead of `-1, -1, -1, /3`. Thus taking 3 `-1` is not optimal\\n\\nThis process can be extended to taking n consecutive `-1` cases (n >= 3)\\n\\nThus, the conclusion is that we should always only take 2 consecutive `-1` at most.\\n\\nThanks for reading my post. If you find it helpful, please upvote. Your upvote means a lot to me.\\n\\n**Complexity**\\n- Time & Space: `O(log^2(n))`, explained by [@coder206](https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794847/Polylogarithmic-solution)\\n\\n**Golang**\\n```\\n/* dp */\\nvar memo = make(map[int]int)\\n\\nfunc minDays(n int) int {\\n    if n < 3 { return n }\\n    if _, ok := memo[n]; !ok {\\n        memo[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3))\\n    }\\n    return memo[n]\\n    // AC: 0 ms, beats 100.00%, 2.6 MB, beats 86.49%\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\\n\\n**Python**\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def helper(n):\\n            if n < 3:\\n                return n\\n            return 1 + min(n % 2 + helper(n // 2), n % 3 + helper(n // 3))\\n        \\n        return helper(n)\\n        # AC: 44 ms, beats 100.00%, 14.3 MB, beats 75.00%\\n```",
                "solutionTags": [],
                "code": "```\\n/* dp */\\nvar memo = make(map[int]int)\\n\\nfunc minDays(n int) int {\\n    if n < 3 { return n }\\n    if _, ok := memo[n]; !ok {\\n        memo[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3))\\n    }\\n    return memo[n]\\n    // AC: 0 ms, beats 100.00%, 2.6 MB, beats 86.49%\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def helper(n):\\n            if n < 3:\\n                return n\\n            return 1 + min(n % 2 + helper(n // 2), n % 3 + helper(n // 3))\\n        \\n        return helper(n)\\n        # AC: 44 ms, beats 100.00%, 14.3 MB, beats 75.00%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794072,
                "title": "java-easy-understanding-bfs",
                "content": "Starting from n\\n1. if it is divisable by 3, add n / 3\\n1. if it is divisable by 2, add n / 2\\n1. always add n - 1\\n\\nSince as n goes up, it might be MLE, I added a set to remember whether this number was going through, if it has been visited, just continue to work on the remaining value in queue.\\n\\nPs: I think it is a little bit easy for this BFS for the fourth question, usually I expect dp for the fourth question.\\n\\n```\\nclass Solution {\\n    public int minDays(int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(n);\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while(!q.isEmpty()){\\n            res++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int cur = q.poll();\\n                if(cur == 0){\\n                    return res - 1;\\n                }\\n                if(set.contains(cur)){\\n                    continue;\\n                }\\n                else{\\n                    set.add(cur);\\n                }\\n                if(cur % 3 == 0){\\n                    q.offer(cur / 3);\\n                }\\n                if(cur % 2 == 0){\\n                    q.offer(cur / 2);\\n                }\\n                q.offer(cur - 1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(n);\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while(!q.isEmpty()){\\n            res++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int cur = q.poll();\\n                if(cur == 0){\\n                    return res - 1;\\n                }\\n                if(set.contains(cur)){\\n                    continue;\\n                }\\n                else{\\n                    set.add(cur);\\n                }\\n                if(cur % 3 == 0){\\n                    q.offer(cur / 3);\\n                }\\n                if(cur % 2 == 0){\\n                    q.offer(cur / 2);\\n                }\\n                q.offer(cur - 1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794075,
                "title": "c-java-dp-understandable-code-with-comments-and-key-idea",
                "content": "**Key Idea**\\nBasic idea is that you should always try both routes -> n/2 and n/3 and find the minimum. This way the final answer will be minimum without a doubt.\\n\\nWhat to do when `n` is not divisible by `3`?\\nIn that case, find the nearest number that will be divisible by `3`.\\n\\nWhat to do when `n` is not divisible by `2`?\\nIn that case, find the nearest number that will be divisible by `2`.\\n\\nVerbose as well as a bit concise codes can be found below.\\n\\n**Thanks**\\nPlease upvote if you find this helpful. It certainly encourages me write more.\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> dp;\\npublic:\\n    int minDays(int n) {\\n        dp[0] = 0;\\n        return solve(n);\\n    }\\n    \\n    int solve(int n) {\\n        if (dp.find(n) != dp.end()) {\\n            return dp[n];\\n        }\\n        int ans = INT_MAX;\\n        if (n%3 == 0 && n%2 == 0) {         // Divisible by both -\\n            ans = min(ans, 1 + solve(n/3)); // So find whichever yields minimum among\\n            ans = min(ans, 1 + solve(n/2)); // n/2 and n/3.\\n            \\n        } else if (n%3 == 0) {              // Only divisible by 3, but not 2\\n                                            // which means this is an odd number.\\n            ans = min(ans, 1 + solve(n/3)); // Try n/3.\\n            ans = min(ans, 1 + solve(n-1)); // Or it may happen that going to the nearest \\n                                            // even number i.e. (n-1) might yield better\\n                                            // answer (which can take n/2 route). So try that.\\n            \\n        } else if (n%2 == 0) {                  // Only divisible by 2, but not 3.\\n            ans = min(ans, 1 + solve(n/2));     // Try n/2.\\n                    \\n            // Similar to previous case, now find nearest number divisible by 3.\\n            if ((n-1)%3 == 0) {                 \\n                ans = min(ans, 1 + solve(n-1));\\n            } else {\\n                ans = min(ans, 2 + solve(n-2));\\n            }\\n            \\n        } else {                            // Not divisible by 3 and 2. Which means an odd number.\\n            ans = min(ans, 1+solve(n-1));   // (n-1) must be even, which will try n/2 route.\\n            if ((n-2)%3 == 0) {             // if n-2 is divisible by 3, then solve that which will\\n                                            // take n/3 route.\\n                ans = min(ans, 2 + solve(n-2));\\n            }\\n        }\\n        dp[n] = ans;                        // Very important - MEMOIZE.\\n        return dp[n];       // YAY, congratulations. Found the answer.\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<>();\\n    \\n    public int minDays(int n) {\\n        dp.put(0, 0);\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n) {\\n        if(dp.containsKey(n)) {\\n            return dp.get(n);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if (n%3 == 0 && n%2 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/3));\\n            ans = Math.min(ans, 1 + solve(n/2));\\n        } else if (n%3 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/3));\\n            ans = Math.min(ans, 1 + solve(n-1));\\n        } else if (n%2 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/2));\\n            if ((n-1)%3 == 0) {\\n                ans = Math.min(ans, 1 + solve(n-1));\\n            } else {\\n                ans = Math.min(ans, 2 + solve(n-2));\\n            }\\n        } else {\\n            ans = Math.min(ans, 1+solve(n-1));\\n            if ((n-2)%3 == 0) {\\n                ans = Math.min(ans, 2 + solve(n-2));\\n            }\\n        }\\n        dp.put(n, ans);\\n        return dp.get(n);\\n    }\\n}\\n```\\n\\n**Java** (A bit more concise)\\n```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<>();\\n    \\n    public int minDays(int n) {\\n        dp.put(0, 0);\\n        dp.put(1, 1);\\n        dp.put(2, 2);\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n) {\\n        if(dp.containsKey(n)) {\\n            return dp.get(n);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if(n % 2 == 0 && n % 3 == 0) {\\n            ans = Math.min(ans, 1 + Math.min(solve(n / 2), solve(n / 3)));\\n        } else if(n % 3 == 0) {\\n            ans = Math.min(ans, 1 + Math.min(solve(n - 1), solve(n / 3)));\\n        } else if(n % 2 == 0) {\\n            if((n - 1) % 3 == 0) {\\n                ans = Math.min(ans, 1 + Math.min(solve(n / 2), solve(n - 1)));    \\n            } else {\\n                ans = Math.min(ans, Math.min(1 + solve(n / 2), 2 + solve(n - 2)));    \\n            }\\n        } else {\\n            ans = Math.min(ans, 1 + solve(n - 1));\\n            if ((n - 2) % 3 == 0) {\\n                ans = Math.min(ans, 2 + solve(n - 2));\\n            }\\n        }\\n        dp.put(n, ans);\\n        return dp.get(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> dp;\\npublic:\\n    int minDays(int n) {\\n        dp[0] = 0;\\n        return solve(n);\\n    }\\n    \\n    int solve(int n) {\\n        if (dp.find(n) != dp.end()) {\\n            return dp[n];\\n        }\\n        int ans = INT_MAX;\\n        if (n%3 == 0 && n%2 == 0) {         // Divisible by both -\\n            ans = min(ans, 1 + solve(n/3)); // So find whichever yields minimum among\\n            ans = min(ans, 1 + solve(n/2)); // n/2 and n/3.\\n            \\n        } else if (n%3 == 0) {              // Only divisible by 3, but not 2\\n                                            // which means this is an odd number.\\n            ans = min(ans, 1 + solve(n/3)); // Try n/3.\\n            ans = min(ans, 1 + solve(n-1)); // Or it may happen that going to the nearest \\n                                            // even number i.e. (n-1) might yield better\\n                                            // answer (which can take n/2 route). So try that.\\n            \\n        } else if (n%2 == 0) {                  // Only divisible by 2, but not 3.\\n            ans = min(ans, 1 + solve(n/2));     // Try n/2.\\n                    \\n            // Similar to previous case, now find nearest number divisible by 3.\\n            if ((n-1)%3 == 0) {                 \\n                ans = min(ans, 1 + solve(n-1));\\n            } else {\\n                ans = min(ans, 2 + solve(n-2));\\n            }\\n            \\n        } else {                            // Not divisible by 3 and 2. Which means an odd number.\\n            ans = min(ans, 1+solve(n-1));   // (n-1) must be even, which will try n/2 route.\\n            if ((n-2)%3 == 0) {             // if n-2 is divisible by 3, then solve that which will\\n                                            // take n/3 route.\\n                ans = min(ans, 2 + solve(n-2));\\n            }\\n        }\\n        dp[n] = ans;                        // Very important - MEMOIZE.\\n        return dp[n];       // YAY, congratulations. Found the answer.\\n    }\\n};\\n```\n```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<>();\\n    \\n    public int minDays(int n) {\\n        dp.put(0, 0);\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n) {\\n        if(dp.containsKey(n)) {\\n            return dp.get(n);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if (n%3 == 0 && n%2 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/3));\\n            ans = Math.min(ans, 1 + solve(n/2));\\n        } else if (n%3 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/3));\\n            ans = Math.min(ans, 1 + solve(n-1));\\n        } else if (n%2 == 0) {\\n            ans = Math.min(ans, 1 + solve(n/2));\\n            if ((n-1)%3 == 0) {\\n                ans = Math.min(ans, 1 + solve(n-1));\\n            } else {\\n                ans = Math.min(ans, 2 + solve(n-2));\\n            }\\n        } else {\\n            ans = Math.min(ans, 1+solve(n-1));\\n            if ((n-2)%3 == 0) {\\n                ans = Math.min(ans, 2 + solve(n-2));\\n            }\\n        }\\n        dp.put(n, ans);\\n        return dp.get(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<>();\\n    \\n    public int minDays(int n) {\\n        dp.put(0, 0);\\n        dp.put(1, 1);\\n        dp.put(2, 2);\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n) {\\n        if(dp.containsKey(n)) {\\n            return dp.get(n);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if(n % 2 == 0 && n % 3 == 0) {\\n            ans = Math.min(ans, 1 + Math.min(solve(n / 2), solve(n / 3)));\\n        } else if(n % 3 == 0) {\\n            ans = Math.min(ans, 1 + Math.min(solve(n - 1), solve(n / 3)));\\n        } else if(n % 2 == 0) {\\n            if((n - 1) % 3 == 0) {\\n                ans = Math.min(ans, 1 + Math.min(solve(n / 2), solve(n - 1)));    \\n            } else {\\n                ans = Math.min(ans, Math.min(1 + solve(n / 2), 2 + solve(n - 2)));    \\n            }\\n        } else {\\n            ans = Math.min(ans, 1 + solve(n - 1));\\n            if ((n - 2) % 3 == 0) {\\n                ans = Math.min(ans, 2 + solve(n - 2));\\n            }\\n        }\\n        dp.put(n, ans);\\n        return dp.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794351,
                "title": "java-o-log-2n-beats-100-time-with-explanation",
                "content": "There are 3 options for each vaue of N. If we solve it as a classic DP problem, trying out all 3 options and taking the best of them, it would lead to a complexity of O(N) {Since one of the options reduces n by 1 in each step, it would go to O(N) if we evaluate this option}. Instead what we can do is we can evaluate the other two options and we would get a complexity of O(log<sup>2</sup> N). \\n\\nLogic for doing  1+ min( (n%2) + f(n/2), (n%3) + f(n/3) ) : \\nSince we need to eliminate evaluation of f(n-1), What we do is we only evaluate for  n, when n % 2 = 0  or n % 3 = 0.  If it is not the case, we simple assume that we took a number of steps, where we ate 1 orange each day. \\n\\nConsider a case where n = 2m + 1, \\nif we choose to eat 1 orange today, we have even number of oranges left for tomorrow. So we are adding n % 2 for today, when we ate 1 orange.\\n\\nOn a similar ground we are adding n % 3  to the other option and evaluating only cases when n % 2 =0 or n % 3 = 0. \\n\\nAnother **important** thing to note is that we are not using an array of size n (or n +1) as in a classic DP problem. This is because we would be storing f(x) only for some values of x, not all. So our array would be sparse and there would be wastage of space (leading to MLE). Instead we can use a map and reduce the amount of space required.\\n\\n**JAVA CODE**\\n\\n```\\nclass Solution {\\n    private HashMap<Integer,Integer> mp = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(mp.containsKey(n))\\n            return mp.get(n);\\n        \\n        mp.put(n, 1 + Math.min(n % 2 + minDays(n/2), n % 3 + minDays(n/3)));\\n        return mp.get(n);\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private HashMap<Integer,Integer> mp = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(mp.containsKey(n))\\n            return mp.get(n);\\n        \\n        mp.put(n, 1 + Math.min(n % 2 + minDays(n/2), n % 3 + minDays(n/3)));\\n        return mp.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794275,
                "title": "python3-bfs",
                "content": "Think of this problem as a tree in which we start from the root `n`. At any node, it connects to up to 3 childrens `n-1`, `n//2` if `n%2 == 0`, `n//3` if `n%3 == 0`. Then we can level order traverse the tree and find the first occurrence of `0` and return its level. \\n\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        ans = 0\\n        queue = [n]\\n        seen = set()\\n        while queue: #bfs \\n            newq = []\\n            for x in queue: \\n                if x == 0: return ans \\n                seen.add(x)\\n                if x-1 not in seen: newq.append(x-1)\\n                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)\\n                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)\\n            ans += 1\\n            queue = newq \\n```\\n\\t\\nEdit: It turns out that dp also works for this problem per this [post](https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794162/C%2B%2BJavaPython-5-lines). \\n\\t\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(n):\\n            if n <= 1: return n\\n            return 1 + min(n%2 + fn(n//2), n%3 + fn(n//3))\\n        \\n        return fn(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        ans = 0\\n        queue = [n]\\n        seen = set()\\n        while queue: #bfs \\n            newq = []\\n            for x in queue: \\n                if x == 0: return ans \\n                seen.add(x)\\n                if x-1 not in seen: newq.append(x-1)\\n                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)\\n                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)\\n            ans += 1\\n            queue = newq \\n```\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(n):\\n            if n <= 1: return n\\n            return 1 + min(n%2 + fn(n//2), n%3 + fn(n//3))\\n        \\n        return fn(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794172,
                "title": "bfs-with-explanation",
                "content": "If you are thinking of a dp solution then check the constraints again you cant\\'t initialize a dp array of size 10^9.\\nSo, best way of solving this question is using bfs.\\nVisualize the problem as  a graph with the first node being n and its adjecent node will be the numbers we can reach from this current number (i.e n//2,n//3,n-1) so find the minimum path from n to 0 using bfs.\\n```\\nclass Solution(object):\\n    def minDays(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque()\\n        q.append(n)\\n        steps=0\\n        visited=set()\\n        \\n        while(len(q)):\\n            l=len(q)\\n            steps+=1\\n            for _ in range(l):\\n                x=q.popleft()\\n                if x%3==0 and x//3 not in visited:\\n                    q.append(x//3)\\n                    visited.add(x//3)\\n                if x%2==0 and x//2 not in visited:\\n                    visited.add(x//2)\\n                    q.append(x//2)\\n                if x-1 not in visited:\\n                    visited.add(x-1)\\n                    q.append(x-1)\\n                if x-1==0:\\n                    return steps\\n        \\n                \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "If you are thinking of a dp solution then check the constraints again you cant\\'t initialize a dp array of size 10^9.\\nSo, best way of solving this question is using bfs.\\nVisualize the problem as  a graph with the first node being n and its adjecent node will be the numbers we can reach from this current number (i.e n//2,n//3,n-1) so find the minimum path from n to 0 using bfs.\\n```\\nclass Solution(object):\\n    def minDays(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque()\\n        q.append(n)\\n        steps=0\\n        visited=set()\\n        \\n        while(len(q)):\\n            l=len(q)\\n            steps+=1\\n            for _ in range(l):\\n                x=q.popleft()\\n                if x%3==0 and x//3 not in visited:\\n                    q.append(x//3)\\n                    visited.add(x//3)\\n                if x%2==0 and x//2 not in visited:\\n                    visited.add(x//2)\\n                    q.append(x//2)\\n                if x-1 not in visited:\\n                    visited.add(x-1)\\n                    q.append(x-1)\\n                if x-1==0:\\n                    return steps\\n        \\n                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 794069,
                "title": "c-dp-solution-brief-explanation",
                "content": "If we don\\'t do pruning then we will get TLE.\\nwe found that if `(n - 1) % 2== 0` or `(n - 1) % 3 == 0` then we can try dfs(n - 1), otherwise we can\\'t get the optimal answer and we don\\'t need to try `dfs(n-1)`. also same for `if (n-2) % 3 == 0`\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> dp;\\n    int minDays(int n) {\\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(dp.count(n)) return dp[n];\\n        int res = INT_MAX;\\n        if(n % 2 == 0)\\n            res = min(res, 1 + dfs(n / 2));\\n        if(n % 3 == 0)\\n            res = min(res, 1 + dfs(n / 3));\\n        if((n - 1) % 2 == 0 || (n - 1 )% 3 == 0)\\n            res = min(res, 1 + dfs(n - 1));\\n        if((n - 2) % 3 == 0)\\n            res = min(res, 2 + dfs(n - 2));\\n        return dp[n] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> dp;\\n    int minDays(int n) {\\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(dp.count(n)) return dp[n];\\n        int res = INT_MAX;\\n        if(n % 2 == 0)\\n            res = min(res, 1 + dfs(n / 2));\\n        if(n % 3 == 0)\\n            res = min(res, 1 + dfs(n / 3));\\n        if((n - 1) % 2 == 0 || (n - 1 )% 3 == 0)\\n            res = min(res, 1 + dfs(n - 1));\\n        if((n - 2) % 3 == 0)\\n            res = min(res, 2 + dfs(n - 2));\\n        return dp[n] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794847,
                "title": "polylogarithmic-solution",
                "content": "We have three operations: decrement by 1, divide by 2 and divide by 3. Decrement operation should only be used to get a number that is a multiple of 2 or 3. This allows us to use two operations: integer division by 2 and integer division by 3 with the cost (number of days) of n % 2 (for decrement) + 1 (for division) and n % 3 + 1 respectively. Note that 1 (and 2 for division by 3) is changed to 0 by additional division of 0 and total cost is greater by 1 than the number of days from the problem statement.\\n\\nSolution is similar to other recursive solutions with memoization. In k-th iteration of the outer loop it calculates numbers and minimum cost to get these numbers by k consecutive operations of any type. The order of operations only affects the cost. The number obtained from n by `i` divisions by 3 and `k-i` divisions by 2 is stored to `numbers[i]` and the minimum cost to get this number is stored to `operations[i]`. Minimum costs to get 0 are collected from all iterations to get final result.\\n\\nNumber of iterations of the outer loop is limited by `log_2(n)`, size of the `numbers` and `operations` (and number of iterations of inner loops) is limited by `log_(3/2)(n)`.\\n\\nTime complexity: O(log^2(n))\\nSpace complexity: O(log(n))\\n\\n```\\nint minDays(int n)\\n{\\n\\tint days = INT_MAX;\\n\\n\\tvector<int> numbers, operations;\\n\\tnumbers.push_back(n);\\n\\toperations.push_back(0);\\n\\n\\twhile (true) {\\n\\t\\twhile (numbers.size() > 0 && numbers.back() == 0) {\\n\\t\\t\\tdays = min(days, operations.back());\\n\\t\\t\\tnumbers.pop_back();\\n\\t\\t\\toperations.pop_back();\\n\\t\\t}\\n\\t\\tif (numbers.empty()) break;\\n\\n\\t\\tint num = numbers[0] / 2;\\n\\t\\tint op = INT_MAX;\\n\\t\\tfor (int i = 0; i < numbers.size(); i++) {\\n\\t\\t\\tswap(numbers[i], num);\\n\\t\\t\\tswap(operations[i], op);\\n\\t\\t\\toperations[i] = min(operations[i], op + num % 2 + 1);\\n\\t\\t\\top += num % 3 + 1;\\n\\t\\t\\tnum /= 3;\\n\\t\\t}\\n\\t\\tnumbers.push_back(num);\\n\\t\\toperations.push_back(op);\\n\\t}\\n\\n\\treturn days - 1;\\n}\\n```\\n\\nNOTE: Recursive memoization based solutions calculate the costs for the same numbers. Their time and space complexity is O(total size of `numbers` for all iterations) = O(log^2(n)). It looks like the number of different values in `numbers` is \\u0398(log^2(n)). Below you can find a plot of `minDay` values (red line), a plot of the number of different values in `numbers` (yellow line) and a plot of the function `3.1 * log_10^2(n)` (blue line). \\n![image](https://assets.leetcode.com/users/images/83757945-401a-46e4-bb04-9228e48e6d8d_1597573627.435893.png)\\n\\n**UPDATE:** Horizontal axis is marked incorrectly. It is size in digits (log_10).\\n\\n**UPDATE 2:** Why do we see this parabola? The number of different values in `numbers` is the size of the set S = { n // (2^k * 3^m) : k >= 0, m >= 0 }, here \"//\" is used to represent integer division. Let us consider its subset S\\' for 0 <= k <= 1/4 * log_2(n / 2) and 0 <= m <= 1/4 * log_3(n / 2). This limits implies that 1 <= 2^k * 3^m <= fourth_root(n / 2) * fourth_root(n / 2) = sqrt(n / 2). Can two different pairs (k1, m1) and (k2, m2) give the same quotient? The answer is no.\\n\\nSuppose that n // (2^k1 * 3^m1) = n // (2^k2 * 3^m2) = q. We can write these integer divisions as n = (2^k1 * 3^m1) * q + r1 and n = (2^k2 * 3^m2) * q + r2 for some remainders r1 and r2. For remainders we have r1 < 2^k1 * 3^m1 <= sqrt(n / 2) and r2 < 2^k2 * 3^m2 <= sqrt(n / 2). If q < sqrt(n / 2) then n = (2^k1 * 3^m1) * q + r1 < sqrt(n / 2) * sqrt(n / 2) + sqrt(n / 2) <= n. This contradiction implies q >= sqrt(n / 2). Now we divide both sides of the equality (2^k1 * 3^m1) * q + r1 = (2^k2 * 3^m2) * q + r2 by q and get (2^k1 * 3^m1) + r1 / q = (2^k2 * 3^m2) + r2 / q. As r1 / q < 1 and r2 / q < 1 integer parts of both sides (floor) are equal to 2^k1 * 3^m1 and 2^k2 * 3^m2 and must be the same. Thus, pairs (k1, m1) and (k2, m2) are the same.\\n\\nThe size of the set S\\' is the number of pairs (k, m) and is equal to (1 + floor(1/4 * log_2(n / 2))) * (1 + floor(1/4 * log_3(n / 2))). Thus, |S| = \\u03A9(log^2(n)). Combining this equality with the upper bound we get |S| = \\u0398(log^2(n)).",
                "solutionTags": [],
                "code": "```\\nint minDays(int n)\\n{\\n\\tint days = INT_MAX;\\n\\n\\tvector<int> numbers, operations;\\n\\tnumbers.push_back(n);\\n\\toperations.push_back(0);\\n\\n\\twhile (true) {\\n\\t\\twhile (numbers.size() > 0 && numbers.back() == 0) {\\n\\t\\t\\tdays = min(days, operations.back());\\n\\t\\t\\tnumbers.pop_back();\\n\\t\\t\\toperations.pop_back();\\n\\t\\t}\\n\\t\\tif (numbers.empty()) break;\\n\\n\\t\\tint num = numbers[0] / 2;\\n\\t\\tint op = INT_MAX;\\n\\t\\tfor (int i = 0; i < numbers.size(); i++) {\\n\\t\\t\\tswap(numbers[i], num);\\n\\t\\t\\tswap(operations[i], op);\\n\\t\\t\\toperations[i] = min(operations[i], op + num % 2 + 1);\\n\\t\\t\\top += num % 3 + 1;\\n\\t\\t\\tnum /= 3;\\n\\t\\t}\\n\\t\\tnumbers.push_back(num);\\n\\t\\toperations.push_back(op);\\n\\t}\\n\\n\\treturn days - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002051,
                "title": "the-reason-hashmap-works-but-array-does-not-work-in-dp-memory-exceed",
                "content": "You may wonder why using dp[] may lead MLE? Here is my experiement \\n\\n```\\n   public static void main(String[] args) throws InterruptedException, ExecutionException {\\n        int n = (int)Math.pow(10, 9);\\n\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(minDays(n));\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n\\n\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(minDays2(n));\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(\"Total elements not in map: \" + (n - dp2.size()));\\n\\n    }\\n\\n    static int[] dp;\\n    public static int minDays(int n) {\\n        dp = new int[n + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        return helper(n);\\n    }\\n\\n    private static int helper(int n) {\\n        if (dp[n] != -1 ) return dp[n];\\n        int a = helper(n / 2) + n % 2;\\n        int b =  helper(n / 3) + n % 3;\\n        dp[n] = Math.min(a, b) + 1;\\n        return dp[n];\\n    }\\n\\n    static Map<Integer, Integer> dp2 = new HashMap();\\n     public static int minDays2(int n) {\\n         dp2.put(0, 0);\\n         dp2.put(1, 1);\\n         if (dp2.containsKey(n)) return dp2.get(n);\\n\\n         dp2.put(n, Math.min(minDays2(n / 2) + n % 2, minDays2(n / 3) + n % 3) + 1) ;\\n\\n         return dp2.get(n);\\n     }\\n```\\n\\nOutput:\\n```\\n**** using map***\\nMB: 2.0\\n31\\nMB: 2.282012939453125\\nTotal elements not in map: 999999758\\n**** using array****\\nMB: 2.0\\n31\\nMB: 3818.3191452026367\\n```\\n\\nYou see that. the map only uses 242 elements out of 10^9 and it usues 2.2 MB memory. In contrast, array uses 10^9 elements as you have to preallocate the heap space for the whole array and it usues a whooping 3818 MB memory\\nThis is because you are not  gonna reduce 10^9 to every number smaller than it. for example, you are not reducing 999 to 998 because 999 % 3 ==0 and you will never use 998\\n\\nupvote if you like this.\\n",
                "solutionTags": [],
                "code": "```\\n   public static void main(String[] args) throws InterruptedException, ExecutionException {\\n        int n = (int)Math.pow(10, 9);\\n\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(minDays(n));\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n\\n\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(minDays2(n));\\n        System.out.println(\"MB: \" + (double) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024));\\n        System.out.println(\"Total elements not in map: \" + (n - dp2.size()));\\n\\n    }\\n\\n    static int[] dp;\\n    public static int minDays(int n) {\\n        dp = new int[n + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        return helper(n);\\n    }\\n\\n    private static int helper(int n) {\\n        if (dp[n] != -1 ) return dp[n];\\n        int a = helper(n / 2) + n % 2;\\n        int b =  helper(n / 3) + n % 3;\\n        dp[n] = Math.min(a, b) + 1;\\n        return dp[n];\\n    }\\n\\n    static Map<Integer, Integer> dp2 = new HashMap();\\n     public static int minDays2(int n) {\\n         dp2.put(0, 0);\\n         dp2.put(1, 1);\\n         if (dp2.containsKey(n)) return dp2.get(n);\\n\\n         dp2.put(n, Math.min(minDays2(n / 2) + n % 2, minDays2(n / 3) + n % 3) + 1) ;\\n\\n         return dp2.get(n);\\n     }\\n```\n```\\n**** using map***\\nMB: 2.0\\n31\\nMB: 2.282012939453125\\nTotal elements not in map: 999999758\\n**** using array****\\nMB: 2.0\\n31\\nMB: 3818.3191452026367\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794092,
                "title": "c-dp",
                "content": "```\\npublic class Solution\\n{\\n    public int MinDays(int n)\\n    {\\n        return DFS(n, new Dictionary<int, int>());\\n    }\\n\\n    private int DFS(int n, Dictionary<int,int> memo)\\n    {\\n        if (n < 3)\\n            return n;\\n        if (memo.ContainsKey(n))\\n            return memo[n];\\n        memo[n] = Math.Min(DFS(n / 2, memo) + DFS(n % 2, memo), DFS(n / 3, memo) + DFS(n % 3, memo)) + 1;\\n        return memo[n];\\n    }\\n}\\n```\\n\\n//Can be simplified\\n```\\npublic class Solution\\n{\\n    Dictionary<int, int> memo = new Dictionary<int, int>();\\n    public int MinDays(int n)\\n    {\\n        if(n < 3) return n;\\n        if(memo.ContainsKey(n)) return memo[n];\\n        return memo[n] = Math.Min(MinDays(n/2) + MinDays(n%2), MinDays(n/3) + MinDays(n%3)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinDays(int n)\\n    {\\n        return DFS(n, new Dictionary<int, int>());\\n    }\\n\\n    private int DFS(int n, Dictionary<int,int> memo)\\n    {\\n        if (n < 3)\\n            return n;\\n        if (memo.ContainsKey(n))\\n            return memo[n];\\n        memo[n] = Math.Min(DFS(n / 2, memo) + DFS(n % 2, memo), DFS(n / 3, memo) + DFS(n % 3, memo)) + 1;\\n        return memo[n];\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    Dictionary<int, int> memo = new Dictionary<int, int>();\\n    public int MinDays(int n)\\n    {\\n        if(n < 3) return n;\\n        if(memo.ContainsKey(n)) return memo[n];\\n        return memo[n] = Math.Min(MinDays(n/2) + MinDays(n%2), MinDays(n/3) + MinDays(n%3)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848529,
                "title": "recursion-cost-and-tle-in-1553",
                "content": "All of this has been discussed in previous messages (shoutout to Votrubac). \\n\\nThrowing my 2 cents in. This is what I did first. There are three recursive calls to minDays().\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        if (n < 2) return n;\\n        if (m[n]) return m[n];\\n        int a = minDays(n - 1);\\n        int b = !(n%2) ? minDays(n/2) : INT_MAX;\\n        int c = !(n%3) ? minDays(n/3) : INT_MAX;\\n        return m[n] = 1 + min(a, min(b, c));\\n    }\\n};\\n```\\nThere is a hint in the problem that gives away the solution:\\n\\n\"In each step, choose between 2 options: minOranges = 1 + min( (n%2) + f(n/2), (n%3) + f(n/3) ) where f(n) is the minimum number of days to eat n oranges.\"\\n\\nIt clearly indicates two f(n) at every step. So, doing something (above) where we recur a \"after eating a single orange\" ends in TLE due to two many branches of recursion. \\n\\nSo, the logic should be:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        /*\\n         * If I have a single orange, one day it is \\n         * If I have no oranges, 0 days\\n         */\\n        if (n < 2) return n;\\n        \\n        /* Return from memo */\\n        if (m[n]) return m[n];\\n        \\n        /* \\n         * If I have any other number of oranges, I can try\\n         * to check two things and decide which is smaller.\\n         *\\n         * 1. To eat 1 (\"extra day\") so that the number becomes \\n         *    even and then eat n/2 on one day. If even, then just\\n         *    eat n/2 on one day - no extra days. Leave n/2 for \\n         *    next day.\\n         *\\n         * 2. To eat 1 or 2 (\"extra day\") so that the number \\n         *    becomes multiple of 3 and then eat 2*(n/3) on one day. If\\n         *    multiple of 3, then just eat 2*(n/3) on one day - no \\n         *    extra days. Leave n/3 for next day.\\n         */\\n        int two   = n % 2 /* extra day */ + 1 /* one day to eat n/2     */ + minDays(n/2);\\n        int three = n % 3 /* extra day */ + 1 /* one day to eat 2*(n/3) */ + minDays(n/3);\\n        \\n        return m[n] = min(two, three);\\n    }\\n};\\n```\\nWhich can be written in just one line:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        return n < 2 ? n : ((m[n]) ? m[n] : m[n] = 1 + min(n % 2 + minDays(n/2), n % 3 + minDays(n/3)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        if (n < 2) return n;\\n        if (m[n]) return m[n];\\n        int a = minDays(n - 1);\\n        int b = !(n%2) ? minDays(n/2) : INT_MAX;\\n        int c = !(n%3) ? minDays(n/3) : INT_MAX;\\n        return m[n] = 1 + min(a, min(b, c));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        /*\\n         * If I have a single orange, one day it is \\n         * If I have no oranges, 0 days\\n         */\\n        if (n < 2) return n;\\n        \\n        /* Return from memo */\\n        if (m[n]) return m[n];\\n        \\n        /* \\n         * If I have any other number of oranges, I can try\\n         * to check two things and decide which is smaller.\\n         *\\n         * 1. To eat 1 (\"extra day\") so that the number becomes \\n         *    even and then eat n/2 on one day. If even, then just\\n         *    eat n/2 on one day - no extra days. Leave n/2 for \\n         *    next day.\\n         *\\n         * 2. To eat 1 or 2 (\"extra day\") so that the number \\n         *    becomes multiple of 3 and then eat 2*(n/3) on one day. If\\n         *    multiple of 3, then just eat 2*(n/3) on one day - no \\n         *    extra days. Leave n/3 for next day.\\n         */\\n        int two   = n % 2 /* extra day */ + 1 /* one day to eat n/2     */ + minDays(n/2);\\n        int three = n % 3 /* extra day */ + 1 /* one day to eat 2*(n/3) */ + minDays(n/3);\\n        \\n        return m[n] = min(two, three);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int minDays(int n) {\\n        return n < 2 ? n : ((m[n]) ? m[n] : m[n] = 1 + min(n % 2 + minDays(n/2), n % 3 + minDays(n/3)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813619,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        map.put(0, 0);\\n        map.put(1, 1);\\n        if (map.containsKey(n)) return map.get(n);\\n        int res = Math.min(minDays(n / 2) + n % 2, minDays(n / 3) + n % 3) + 1;\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        map.put(0, 0);\\n        map.put(1, 1);\\n        if (map.containsKey(n)) return map.get(n);\\n        int res = Math.min(minDays(n / 2) + n % 2, minDays(n / 3) + n % 3) + 1;\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795905,
                "title": "c-super-easy-to-understand",
                "content": "Explanation: \\nThere are three choices one can make each day depending on n.\\nWe want to minimize the days. Most of the code is straighforward\\nonly thing that need some explanation is line \\n```\\nif (n % 3 != 0 || n% 2 != 0) result = min(result, inner(n-1));\\n```\\nThis is just an optimization that avoids some calls. Rationale is really\\nsimple. If we can devide oranges with both 3 and 2 then any of the\\ntwo calls above will reduce number of oranges more than 1.\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    int inner(int n) {\\n        if (dp.find(n) != dp.end()) {\\n            return dp[n];\\n        }\\n        int result = INT_MAX;\\n\\t\\t// from large partitions to small\\n        if (n % 3 == 0) result = min(result, inner(n/3));\\n        if (n % 2 == 0) result = min(result, inner(n/2));\\n\\t\\t// we don\\'t want to do this step as this is the most expensive \\n\\t\\t// we don\\'t need to do this if number was divisible by both\\n        if (n % 3 != 0 || n% 2 != 0) result = min(result, inner(n-1));\\n        dp[n] = result + 1;\\n        return dp[n];\\n    }\\npublic: \\n    unordered_map<int, int> dp;\\n    int minDays(int n) {\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        return inner(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif (n % 3 != 0 || n% 2 != 0) result = min(result, inner(n-1));\\n```\n```\\nclass Solution {\\nprivate:\\n    int inner(int n) {\\n        if (dp.find(n) != dp.end()) {\\n            return dp[n];\\n        }\\n        int result = INT_MAX;\\n\\t\\t// from large partitions to small\\n        if (n % 3 == 0) result = min(result, inner(n/3));\\n        if (n % 2 == 0) result = min(result, inner(n/2));\\n\\t\\t// we don\\'t want to do this step as this is the most expensive \\n\\t\\t// we don\\'t need to do this if number was divisible by both\\n        if (n % 3 != 0 || n% 2 != 0) result = min(result, inner(n-1));\\n        dp[n] = result + 1;\\n        return dp[n];\\n    }\\npublic: \\n    unordered_map<int, int> dp;\\n    int minDays(int n) {\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        return inner(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794086,
                "title": "easy-peasy-3-liner-python",
                "content": "Basic requirement is to travel and find minimum of three conditions given.\\nThe TLE causing condition is traveling to (n - 1)th day give that N can be beyond limits.\\n\\nWorst case iterations since we exclude each day traversal is log<sup>2</sup>(N), given that we have 2 options of travelling to n/2 or n/3rd day.\\n\\nThanks for @coder206 for his post in comments regarding time complexity analysis.\\nN = 10^9,  Result = 31, Time = 52ms\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def minDays(self, n: int) -> int:\\n        if n <= 1:\\n            return n\\n        return 1 + min(n%3 + self.minDays(n//3), n%2 + self.minDays(n//2))\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Basic requirement is to travel and find minimum of three conditions given.\\nThe TLE causing condition is traveling to (n - 1)th day give that N can be beyond limits.\\n\\nWorst case iterations since we exclude each day traversal is log<sup>2</sup>(N), given that we have 2 options of travelling to n/2 or n/3rd day.\\n\\nThanks for @coder206 for his post in comments regarding time complexity analysis.\\nN = 10^9,  Result = 31, Time = 52ms\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def minDays(self, n: int) -> int:\\n        if n <= 1:\\n            return n\\n        return 1 + min(n%3 + self.minDays(n//3), n%2 + self.minDays(n//2))\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 794203,
                "title": "java-bfs-short-solution-with-set",
                "content": "Simple BFS where *Set* holds available fruits at day x\\n\\nThe size of the set on each level is relatively small. At most at each level we increase set\\'s size <= set * 3 (for each case). \\n\\nLet\\'s see how many level we might have. Assuming we have odd number N. So we can spend 1 day to convert it to even number n - 1 and then 1 day to get n = (n - 1) / 2. Overall we should have something like `2 * log2(n)` levels. We multiply by 2 to take into account possible convertion from odd to even\\n\\nExample: assume n = 11\\n```\\nday 0: [11]\\nday 1: [10]\\nday 2: [5, 9]\\nday 3: [3, 4, 8]\\nday 4: [1, 2, 3, 4, 7]\\nday 5: [0, 1, 2, 3, 6] // so we managed to eat all fruits at day 5\\n```\\n\\n```java\\nSet<Integer> set = new HashSet<>();\\nset.add(n);\\n\\n// lvl keeps track of the depth and represents current day\\nint lvl = 0; \\n\\nwhile(true) {\\n\\tSet<Integer> next = new HashSet<>();\\n\\n\\t// For each  possible number of fruits we reached at day lvl, figure out number we can get at day lvl + 1. \\n\\tfor (int i : set) {\\n\\t\\tif (i == 0) return lvl;\\n\\t\\t// consider all three cases from the problems statement\\n\\t\\tnext.add(i - 1); \\n\\t\\tif (i % 2 == 0) next.add(i / 2);  \\n\\t\\tif (i % 3 == 0) next.add(i / 3);\\n\\t}\\n\\tset = next; //set get replaced by next each time all elements in set gets used\\n\\n\\tlvl++;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nday 0: [11]\\nday 1: [10]\\nday 2: [5, 9]\\nday 3: [3, 4, 8]\\nday 4: [1, 2, 3, 4, 7]\\nday 5: [0, 1, 2, 3, 6] // so we managed to eat all fruits at day 5\\n```\n```java\\nSet<Integer> set = new HashSet<>();\\nset.add(n);\\n\\n// lvl keeps track of the depth and represents current day\\nint lvl = 0; \\n\\nwhile(true) {\\n\\tSet<Integer> next = new HashSet<>();\\n\\n\\t// For each  possible number of fruits we reached at day lvl, figure out number we can get at day lvl + 1. \\n\\tfor (int i : set) {\\n\\t\\tif (i == 0) return lvl;\\n\\t\\t// consider all three cases from the problems statement\\n\\t\\tnext.add(i - 1); \\n\\t\\tif (i % 2 == 0) next.add(i / 2);  \\n\\t\\tif (i % 3 == 0) next.add(i / 3);\\n\\t}\\n\\tset = next; //set get replaced by next each time all elements in set gets used\\n\\n\\tlvl++;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800506,
                "title": "java-solution-beating-100-using-dp-memo-in-o-n",
                "content": "```\\nclass Solution {\\n    static HashMap<Integer,Integer> has=new HashMap<>();\\n    static int maxx(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(has.get(n)!=null){return has.get(n);}\\n        if(n%2==0 && n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n/2)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%2==0){\\n            int aa=Math.min(maxx(n/2)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else{\\n            int aa=maxx(n-1)+1;\\n            has.put(n,aa);\\n            return aa;\\n        }\\n    }\\n    public int minDays(int n) {\\n        return maxx(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static HashMap<Integer,Integer> has=new HashMap<>();\\n    static int maxx(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(has.get(n)!=null){return has.get(n);}\\n        if(n%2==0 && n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n/2)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%2==0){\\n            int aa=Math.min(maxx(n/2)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else{\\n            int aa=maxx(n-1)+1;\\n            has.put(n,aa);\\n            return aa;\\n        }\\n    }\\n    public int minDays(int n) {\\n        return maxx(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794332,
                "title": "easy-to-understand-python-solution-dp-32ms-100-time-100-memory",
                "content": "This problem can be solved easily using DP and recursion. At every value of n, have to choose between 2 cases - \\n1) reduce n till n%2==0 and then n/=2 :- count = 1 + n%2 + f(n//2), or \\n2) reduce n till n%3==0 and then n/=3 :- count = 1 + n%3 + f(n//3). \\n\\nwhich results in - count = 1 + min(n%2 + f(n//2), n%3 + f(n//3))\\n\\nhere, f(n) is the minimum days required to eat n oranges. Keep storing the calculated results in a dict for fast access in case of repeating subproblems. \\n\\nBottom up DP is an obvious first thought to solve this, but it is too wasteful in most of the cases, as very few subproblems are repeated. In some cases it will lead to TLE as well. \\n\\n```\\nclass Solution(object):\\n    def minDays(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0]=0\\n        dp[1]=1\\n        \\n        def count(n):\\n            \\n            if n in dp:\\n                return dp[n]\\n            dp[n] = 1 + min(n%2 + count(n//2), n%3 + count(n//3))\\n            return dp[n]\\n        \\n        ans = count(n)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDays(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0]=0\\n        dp[1]=1\\n        \\n        def count(n):\\n            \\n            if n in dp:\\n                return dp[n]\\n            dp[n] = 1 + min(n%2 + count(n//2), n%3 + count(n//3))\\n            return dp[n]\\n        \\n        ans = count(n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794081,
                "title": "java-bfs-cut-saved-options",
                "content": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int minDays(int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(n);\\n        q.offer(Integer.MAX_VALUE);\\n        int days = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int tmp = q.poll();\\n            if(tmp == 0){\\n                return days;\\n            }\\n            if(tmp == Integer.MAX_VALUE){\\n                days++;\\n                if(q.peek() != Integer.MAX_VALUE){\\n                    q.offer(Integer.MAX_VALUE);\\n                    }\\n            }else{\\n                if(!set.contains(tmp-1)){\\n                        q.offer(tmp-1);\\n                        set.add(tmp-1);\\n                    }\\n                if(tmp % 2 == 0){\\n                    if(!set.contains(tmp/2)){\\n                        q.offer(tmp/2);\\n                        set.add(tmp/2);\\n                    }\\n                }\\n                if(tmp % 3 == 0){\\n                    if(!set.contains(tmp/3)){\\n                        q.offer(tmp/3);\\n                        set.add(tmp/3);\\n                    }\\n                }\\n            }\\n        }\\n        return days;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int minDays(int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(n);\\n        q.offer(Integer.MAX_VALUE);\\n        int days = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int tmp = q.poll();\\n            if(tmp == 0){\\n                return days;\\n            }\\n            if(tmp == Integer.MAX_VALUE){\\n                days++;\\n                if(q.peek() != Integer.MAX_VALUE){\\n                    q.offer(Integer.MAX_VALUE);\\n                    }\\n            }else{\\n                if(!set.contains(tmp-1)){\\n                        q.offer(tmp-1);\\n                        set.add(tmp-1);\\n                    }\\n                if(tmp % 2 == 0){\\n                    if(!set.contains(tmp/2)){\\n                        q.offer(tmp/2);\\n                        set.add(tmp/2);\\n                    }\\n                }\\n                if(tmp % 3 == 0){\\n                    if(!set.contains(tmp/3)){\\n                        q.offer(tmp/3);\\n                        set.add(tmp/3);\\n                    }\\n                }\\n            }\\n        }\\n        return days;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221374,
                "title": "98-faster-recursive-memo-solution",
                "content": "Explanation: \\nit does not make sense to eat oranges one by one.\\nSo, the choice we have is to eat n % 2 oranges one-by-one and then swallow n / 2, or eat n % 3 oranges so that we can gobble 2 * n / 3.\\njava code is:\\n# \\n```\\nclass Solution {\\n    Map<Integer,Integer>dp;\\n    int find(int n){\\n        if(n<=1)return n;\\n        if(dp.containsKey(n))return dp.get(n); \\n        dp.put(n,1+Math.min(n%2+find(n/2),n%3+find(n/3)));\\n        return dp.get(n);\\n    }\\n    public int minDays(int n) {\\n        dp=new HashMap<>();\\n        return find(n);\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer>dp;\\n    int find(int n){\\n        if(n<=1)return n;\\n        if(dp.containsKey(n))return dp.get(n); \\n        dp.put(n,1+Math.min(n%2+find(n/2),n%3+find(n/3)));\\n        return dp.get(n);\\n    }\\n    public int minDays(int n) {\\n        dp=new HashMap<>();\\n        return find(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796104,
                "title": "python-two-solutions-dp-and-bfs-detailed-explanations",
                "content": "**Method 1: DP (TOP DOWN)**\\nFirst of all, we only choose 1 out of 3 choices at a time. So the question is how do we choose? If you are familiar with DP idea, you can easily come up with the dp solution by comparing all of three choices and pick the minimum of it. However, the upper bound for this questions is `10^9`, which is to large to build a dp array to store all the overlapping solutions. And it takes very long time to iterate this number.\\n\\n**Analysis:**\\nWhat about top down approach? One obvervation is that we always want to choose the option of either `n/2` oranges or `2n/3` oranges. by doing so, we can have as minimum as possible steps to exhaust all orianges. \\nIf we have `n `oranges,  we can either choose `n/2` oranges or `n/3` oranges. By either option, the size n is reduced by 2 or by 3! This is crucial because the subproblem size is reduced by half or third. \\n`if n =10^9, n/2 = (10^8)*5, further divided by 2, n = (10^7)*5*5.`\\nThe exponential is reduced quickly. After 8 times, n becomes 10 * (5^8), which is 3906250, which is far less than 10^9\\n**If we divide n by 3, we can reduce problem space even faster.**\\nTherefore, the top down recursion approach would work here. Now question is how do we design the recusion? What is the base case?\\n```\\nBase case:\\nn = 0, f(n) = 0.  If we have 0 orange, we can\\'t eat. 0 day taken.\\nn = 1, f(n) = 1.  If we have 1 orange,  Option 1: eat 1 orange. 1 day taken.\\n```\\nIf n >= 2, we don\\'t consider the option 1: eat one orange. As we discussed above, we choose as many as possible each time. So we compare choosing either option 2: eat half oranges or option 3: eat 2/3 oranges.\\n**n = 2:**\\n`option 2: 2%2 = 0, Eat 2//2=1 orange. Left orange: 2 - 1 = 1. f(1) = 1.  Total: 0 + 1 = 1.`\\n`option 3: Reduce oranges by n % 3.` \\nsince 2 % 3 != 0, we cannot eat 2/3 oranges. What we can do is to first use option 1 to reduce n until n is divisble by 3 \\nHow to get this value? Use **modulo operation**. \\n`2 % 3 == 2. we eat 1 orange two times. Left: 2-2=0. f(0) = 0. Total: 2 + 0 = 2`\\n\\nChoose the minimum cost:\\n`option2: 1`  \\n`option3: 2`   \\n`cost = min(option1, option2), which is 1`. \\n**Since the current n requires 1 day, the final cost is: `1 + min(option2, option3)`**  **ans = 2**\\n\\n**n = 3:**\\n`option 2: Reduce oranges by n % 2.`\\nsince 3 % 2 != 0, we cannot eat 1/2 oranges. Reduce n until we can use this option. 3 % 2 = 1. We eat 1 orange one time. `Left: 3 - 1 = 2. Eat 2//2=1 oranges, Left 2-1 = 1. f(1) = 1.  Total: 1+1= 2`\\n\\n`option 3: 3 % 3 = 0, 2*(3/3) = 2, we left 3 - 2 = 1 orange, f(1) = 1. Total: 0 + 1 = 1.`\\n\\nChoose the minimum cost:\\n`option2: 2`  \\n`option3: 1`   \\n`cost = min(option1, option2), which is 1`. \\n**Since the current n requires 1 day, the final cost is: `1 + min(option2, option3)`**  **ans = 2**\\n\\n**Optimal Substructure:**\\n```\\nc1 = f(n//2) if n%2 == 0 else n%2 + f(n//2)\\nc2 = f(n//3) if n%3 == 0 else n%3 + f(n//3)\\nf(n) = 1 + min(c1, c2)\\n```\\nMore concise and clean way:\\n```1 + min((n%2)+search(n//2), (n%3)+search(n//3))```\\n\\nGeneral Version:\\n```\\n        @lru_cache(None)\\n        def f(n):\\n            if n == 0: return 0\\n            if n ==1: return 1           \\n            c1 = f(n//2) if n%2 == 0 else n%2 + f(n//2)\\n            c2 = f(n//3) if n%3 == 0 else n%3 + f(n//3)\\n            return 1 + min(c1, c2)\\n\\n        return f(n)\\n```\\nConcise Version:\\n```\\n        @lru_cache(None)\\n        def f(n):\\n            if n == 0: return 0\\n            if n ==1: return 1\\n\\t\\t\\treturn 1 + min((n%2) + f(n//2), (n%3) + f(n//3))\\n        return f(n)\\n```\\n\\nTime: O(log_base2 n + log_base3 n)\\nSpace: O(log_base2 n + log_base3 n)\\n\\n\\n**Method 2: BFS.** \\nIdea is to think of it as tree searching problem with branching factor of 3. After each operation, we either have `n-1`, `n//2`, or `n//3` remaining oranges. BFS is intuitive to shortest path search. We iterate level by level until we fist see the n is reduced to 1.\\nBFS took more time than the dp method. The reason is that as we search deeply in the children nodes, the tree will have exponential increase in children nodes, `(3^n)`. It increases the time complexity dramatically.\\n\\nCode:\\n```\\n        # bfs. fins shortest path level by level\\n        q = collections.deque([n])\\n        seen = set()\\n        step = 1\\n        while q:\\n            # level matters\\n            for _ in range(len(q)):\\n                val = q.popleft()\\n                if val == 1:\\n                    return step\\n                seen.add(val)\\n                if val - 1 not in seen:\\n                    q.append(val-1)\\n                if val % 2 == 0 and val//2 not in seen:\\n                    q.append(val//2)\\n                if val % 3 == 0 and val//3 not in seen:\\n                    # took (2n/3), left n/3\\n                    q.append(val//3)\\n                    \\n            step += 1\\n\\n```\\n \\nTime: O(3^n)\\nSpace: O(3^n)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nBase case:\\nn = 0, f(n) = 0.  If we have 0 orange, we can\\'t eat. 0 day taken.\\nn = 1, f(n) = 1.  If we have 1 orange,  Option 1: eat 1 orange. 1 day taken.\\n```\n```\\nc1 = f(n//2) if n%2 == 0 else n%2 + f(n//2)\\nc2 = f(n//3) if n%3 == 0 else n%3 + f(n//3)\\nf(n) = 1 + min(c1, c2)\\n```\n```1 + min((n%2)+search(n//2), (n%3)+search(n//3))```\n```\\n        @lru_cache(None)\\n        def f(n):\\n            if n == 0: return 0\\n            if n ==1: return 1           \\n            c1 = f(n//2) if n%2 == 0 else n%2 + f(n//2)\\n            c2 = f(n//3) if n%3 == 0 else n%3 + f(n//3)\\n            return 1 + min(c1, c2)\\n\\n        return f(n)\\n```\n```\\n        @lru_cache(None)\\n        def f(n):\\n            if n == 0: return 0\\n            if n ==1: return 1\\n\\t\\t\\treturn 1 + min((n%2) + f(n//2), (n%3) + f(n//3))\\n        return f(n)\\n```\n```\\n        # bfs. fins shortest path level by level\\n        q = collections.deque([n])\\n        seen = set()\\n        step = 1\\n        while q:\\n            # level matters\\n            for _ in range(len(q)):\\n                val = q.popleft()\\n                if val == 1:\\n                    return step\\n                seen.add(val)\\n                if val - 1 not in seen:\\n                    q.append(val-1)\\n                if val % 2 == 0 and val//2 not in seen:\\n                    q.append(val//2)\\n                if val % 3 == 0 and val//3 not in seen:\\n                    # took (2n/3), left n/3\\n                    q.append(val//3)\\n                    \\n            step += 1\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 794302,
                "title": "explanation-implementation-top-down-approach-c",
                "content": "In each step its optimal to reduce the oranges by half or 2/3 \\nBut what if the remining ones aren\\'t divisible by 2 or 3\\nSimple ,reduce 1 from them & make the ramaining orange divisible by 2 or 3 \\n\\nBut what should we make it divisible by 2 or 3 ?\\nWell You cant just know without trying every possible case \\nAs in some case eaing half oranges then 2/3 maybe beneficial \\ni.e   16 - > 8 (eaten half)  -> 4 (eaten half) -> 2 (eaten half) -> 1 (eaten 1)-> 0 (eaten half)\\n       16 -> 15 (eaten 1) -> 5 ( eaten 2/3)  -> 4 (eaten 1 )  -> 2 (eaten half) -> 1 (eaten half) -> 0\\n\\t  \\nSo in each step try eating half & 2/3 whichever leads to minimum steps is your answer \\n\\nNow few key things : eating 2/3 means the remaining oranges are 1/3   \\n                                  eating half means the remaining oranges are 1\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\tAlso we need to use DP to remember the steps already calculated to avoid TLE\\n\\tState of the DP will be the remaing orange ( dont worry it wont be 10^9 states it will be only Log(10e9) states . \\n\\tBase case : when we reach 0 or 1 there is 0 & 1 step remaining respectively \\n\\tAnd we are done , see the code for better understanding \\n```\\nclass Solution {\\npublic:\\n    map<int,int>dp;   // as state can be huge so cant use array\\n    int make(int left)\\n    {\\n        if(left==0)  // base case\\n            return 0;\\n        if(left==1)\\n            return 1;\\n        if(dp[left]!=0)   // if left is not 0 than the steps required to make it 0 cant be 0 ( uff what a line) \\n            return dp[left];      // not 0 means this left is made 0 prevously so answer from memory\\n        int p=99999999,q=99999999;\\n        p=left%2+make(left/2);  // eat half , there is left%2 step to make it divisible by 2\\n        q=left%3+make(left/3); // eat 2/3 , there is left%3 step to make it divisible by 3\\n        return dp[left]=1+min(p,q);  // +1 is for eating half or 2/3\\n    }\\n    int minDays(int n) {\\n        return make(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>dp;   // as state can be huge so cant use array\\n    int make(int left)\\n    {\\n        if(left==0)  // base case\\n            return 0;\\n        if(left==1)\\n            return 1;\\n        if(dp[left]!=0)   // if left is not 0 than the steps required to make it 0 cant be 0 ( uff what a line) \\n            return dp[left];      // not 0 means this left is made 0 prevously so answer from memory\\n        int p=99999999,q=99999999;\\n        p=left%2+make(left/2);  // eat half , there is left%2 step to make it divisible by 2\\n        q=left%3+make(left/3); // eat 2/3 , there is left%3 step to make it divisible by 3\\n        return dp[left]=1+min(p,q);  // +1 is for eating half or 2/3\\n    }\\n    int minDays(int n) {\\n        return make(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794218,
                "title": "java-dfs-with-memory",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(1, 1);\\n        map.put(2, 2);\\n        map.put(3, 2);\\n        return helper(n, map);\\n    }\\n    \\n    private int helper(int n, Map<Integer, Integer> map) {\\n        if(map.containsKey(n)) return map.get(n);\\n        int a = n;\\n        if(n % 2 == 0) {\\n            a = Math.min(a, 1 + helper(n / 2, map));\\n        } else {\\n            a = Math.min(a, 1 + helper(n - 1, map));\\n        }\\n        if(n % 3 == 0) {\\n            a = Math.min(a, 1 + helper(n / 3, map));\\n        } else if(n % 3 == 1) {\\n            a = Math.min(a, 1 + helper(n - 1, map));\\n        } else {\\n            a = Math.min(a, 2 + helper(n - 2, map));\\n        }\\n        map.put(n, a);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(1, 1);\\n        map.put(2, 2);\\n        map.put(3, 2);\\n        return helper(n, map);\\n    }\\n    \\n    private int helper(int n, Map<Integer, Integer> map) {\\n        if(map.containsKey(n)) return map.get(n);\\n        int a = n;\\n        if(n % 2 == 0) {\\n            a = Math.min(a, 1 + helper(n / 2, map));\\n        } else {\\n            a = Math.min(a, 1 + helper(n - 1, map));\\n        }\\n        if(n % 3 == 0) {\\n            a = Math.min(a, 1 + helper(n / 3, map));\\n        } else if(n % 3 == 1) {\\n            a = Math.min(a, 1 + helper(n - 1, map));\\n        } else {\\n            a = Math.min(a, 2 + helper(n - 2, map));\\n        }\\n        map.put(n, a);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794085,
                "title": "python-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        def eat1(n):\\n            return n-1\\n        \\n        \\n        def eat2(n):\\n            if not n % 2:\\n                return n/2\\n            return None\\n        \\n        \\n        def eat3(n):\\n            if not n % 3:\\n                return n/3\\n            return None\\n        \\n        memo = {}\\n        memo[0] = 0\\n        def eat(n):\\n            nonlocal memo\\n            if n in memo:\\n                return memo[n]\\n            if eat2(n):\\n                if eat3(n):\\n                    memo[n] = 1 + min(eat(eat2(n)), eat(eat3(n)))\\n                    return memo[n]\\n                memo[n] = 1+ min(eat(eat1(n)), eat(eat2(n)))\\n                return memo[n]\\n            if eat3(n):\\n                memo[n] = 1 + min(eat(eat1(n)), eat(eat3(n)))\\n                return memo[n]\\n            return 1 + eat(eat1(n))\\n                    \\n        return eat(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        def eat1(n):\\n            return n-1\\n        \\n        \\n        def eat2(n):\\n            if not n % 2:\\n                return n/2\\n            return None\\n        \\n        \\n        def eat3(n):\\n            if not n % 3:\\n                return n/3\\n            return None\\n        \\n        memo = {}\\n        memo[0] = 0\\n        def eat(n):\\n            nonlocal memo\\n            if n in memo:\\n                return memo[n]\\n            if eat2(n):\\n                if eat3(n):\\n                    memo[n] = 1 + min(eat(eat2(n)), eat(eat3(n)))\\n                    return memo[n]\\n                memo[n] = 1+ min(eat(eat1(n)), eat(eat2(n)))\\n                return memo[n]\\n            if eat3(n):\\n                memo[n] = 1 + min(eat(eat1(n)), eat(eat3(n)))\\n                return memo[n]\\n            return 1 + eat(eat1(n))\\n                    \\n        return eat(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159591,
                "title": "c-3-line-of-code-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<long long,int>dp;\\n    int minDays(int n) {\\n        if(n<=1) return n;\\n        if(dp.count(n)) return dp[n];\\n        else\\n            return dp[n]=1+min(n%2+minDays(n/2),n%3+minDays(n/3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<long long,int>dp;\\n    int minDays(int n) {\\n        if(n<=1) return n;\\n        if(dp.count(n)) return dp[n];\\n        else\\n            return dp[n]=1+min(n%2+minDays(n/2),n%3+minDays(n/3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119441,
                "title": "python-dfs-memorization-4-lines-99-faster",
                "content": "Nothing here is particularly new, I\\'m mostly just happy with how simple and clean my code is. That being said, the basic idea is that eating one orange at a time all the way to the end will always be the slowest option. So, if we consider the problem on the nth day, we\\'ll need 1 day for the nth day itself, and then we\\'ll either want to eat one orange per day for n%3 days and then eat 2n/3 oranges, or we want to eat one orange per day for n%2 days and then eat n/2 oranges (whichever gives use the better solution). This means that the the recursive calls generally skip forward a few days instead of just a single day, but that\\'s ok because the recursive problem depends on the number of oranges left, not the number of days which have already passed.\\n\\nSide Note: I always enjoy when I can call the function definition they give us recursively, which was really the main motivation behind why I structured my code the way I did.\\n\\nBest Performance: 28 ms/14.7 MB : 99%/41%\\n\\'\\'\\'\\nclass Solution: \\n\\n    #A Cache of Known Solutions (Recursive Base Cases)\\n\\tcache = {0:0, 1:1, 2:2}\\n    \\n    #Solve the Puzzle (Top-Down Recursive Search)\\n    def minDays(self, n: int) -> int:\\n        #Check if the Result is in the Cache\\n        if n not in self.cache:\\n            #Compute the Result\\n\\t\\t\\tself.cache[n] = 1 + min(self.minDays(n//3) + n%3, self.minDays(n//2) + n%2)\\n        \\n        #Return the Result from the Cache\\n        return self.cache[n]\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution: \\n\\n    #A Cache of Known Solutions (Recursive Base Cases)\\n\\tcache = {0:0, 1:1, 2:2}",
                "codeTag": "Java"
            },
            {
                "id": 795752,
                "title": "time-complexity-is-o-log-n-here-is-the-analysis",
                "content": "Please see the memo solution for this problem. It has the recurrence of the form\\n```\\nT(n) = T(n/3) + T(n/2) + Theta(C) <= 2T(n/2) + Theta(C)\\n\\n\\t==>                               C\\n                                    /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t   C/2        C/2\\n\\t\\t\\t\\t\\t\\t     /     \\\\     /     \\\\\\n\\t\\t\\t\\t\\t\\tC/4       C/4  C/4      C/4\\n\\nThe height of this tree is log base 2 tall. Each level costs C. So the total cost is  sum from 0 to logN of C. This is O(C log N) ==> O(log N)\\n```",
                "solutionTags": [],
                "code": "```\\nT(n) = T(n/3) + T(n/2) + Theta(C) <= 2T(n/2) + Theta(C)\\n\\n\\t==>                               C\\n                                    /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t   C/2        C/2\\n\\t\\t\\t\\t\\t\\t     /     \\\\     /     \\\\\\n\\t\\t\\t\\t\\t\\tC/4       C/4  C/4      C/4\\n\\nThe height of this tree is log base 2 tall. Each level costs C. So the total cost is  sum from 0 to logN of C. This is O(C log N) ==> O(log N)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795186,
                "title": "python-simple-solution-fully-explained-code-video",
                "content": "[](https://www.youtube.com/watch?v=la0H_s1rNcc)\\nhttps://www.youtube.com/watch?v=la0H_s1rNcc\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        q = deque([n])\\n        days = 0\\n        visited = set()\\n        \\n        while q:\\n            days += 1\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                if node == 1:\\n                    print(visited)\\n                    return days\\n                if node % 3 == 0 and node % 3 not in visited:\\n                    q.append(node // 3)\\n                    visited.add(node // 3)\\n                if node % 2 == 0 and node % 2 not in visited:\\n                    q.append(node // 2)\\n                    visited.add(node // 2)\\n                if node - 1 not in visited:\\n                    q.append(node - 1)\\n                    visited.add(node - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        q = deque([n])\\n        days = 0\\n        visited = set()\\n        \\n        while q:\\n            days += 1\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                if node == 1:\\n                    print(visited)\\n                    return days\\n                if node % 3 == 0 and node % 3 not in visited:\\n                    q.append(node // 3)\\n                    visited.add(node // 3)\\n                if node % 2 == 0 and node % 2 not in visited:\\n                    q.append(node // 2)\\n                    visited.add(node // 2)\\n                if node - 1 not in visited:\\n                    q.append(node - 1)\\n                    visited.add(node - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794174,
                "title": "java-bfs-solution-with-hashset",
                "content": "The first intution that comes to mind while solving problem is to try DP a solution but due to the very large input size, it can throw memory limit error. To bypass this, we can use solve the problem with BFS as shown below:\\n\\nclass Solution {\\n    public int minDays(int n) {\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        int ans = 0;\\n        queue.add(n);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size>0){\\n                int cur = queue.poll();\\n                if(visited.contains(cur)){\\n                    --size;\\n                    continue;\\n                }else{\\n                    visited.add(cur);\\n                }\\n                if(cur==1){\\n                    return ans + 1;\\n                }\\n                if(cur%3==0){\\n                    queue.add(cur/3);\\n                }\\n                if(cur%2==0){\\n                    queue.add(cur/2);\\n                }\\n                queue.add(cur-1);\\n                --size;\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int minDays(int n) {\\n        \\n        if(n<3){\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 794128,
                "title": "python-solution-easy-peasy-orange-squeezy",
                "content": "Very straightforward DP problem. \\n\\nThe key insight is that we do not want to recursively eat 1 orange as that can take too much time, so we can calculate how many \"1 steps\" we have to take in order to eat `n/2` or `2n/3` oranges.\\n\\n```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        self.cache = {}\\n        return self.dfs(n)\\n        \\n    def dfs(self, n):\\n        if n in self.cache:\\n            return self.cache[n]\\n        if n <= 2:\\n            return n\\n        \\n        ans = min(n%3 + self.dfs(n//3), n%2 + self.dfs(n//2)) + 1\\n        self.cache[n] = ans\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        self.cache = {}\\n        return self.dfs(n)\\n        \\n    def dfs(self, n):\\n        if n in self.cache:\\n            return self.cache[n]\\n        if n <= 2:\\n            return n\\n        \\n        ans = min(n%3 + self.dfs(n//3), n%2 + self.dfs(n//2)) + 1\\n        self.cache[n] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802592,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  unordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) == 0)\\n        dp[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3));\\n    return dp[n];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  unordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) == 0)\\n        dp[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3));\\n    return dp[n];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453282,
                "title": "c-bfs-simple-solution-map-for-checking-number-is-already-pushed",
                "content": "```\\nint minDays(int n) {\\n        \\n        //Apply BFS , Lets see what happens \\n        \\n        queue<int> q;\\n        \\n        int ans=0;\\n        \\n        q.push(n);\\n        \\n        map<int , int> mp; // mark for the that number is already visited \\n        \\n        // Dont push same number twice in the queue , that\\'s why it can give TLE\\n        \\n        // Reason behind using map .\\n        \\n        mp[n]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            \\n            while(sz--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                \\n                if(x==1)\\n                {\\n                    return ans+1;\\n                }\\n                \\n                if(x%3==0 && mp.find(x/3)==mp.end())\\n                {\\n                    mp[x/3]=1;\\n                    q.push(x/3);\\n                }\\n                \\n                 if(x%2==0 && mp.find(x/2)==mp.end())\\n                {\\n                    mp[x/2]=1;// Mark it as visited \\n                    q.push(x/2);\\n                    \\n                }\\n                \\n                if(mp.find(x-1)==mp.end())\\n                {\\n                    mp[x-1]=1;\\n                    q.push(x-1);\\n                }\\n                \\n               \\n                \\n                // x-(2*(x/3))=x/3 finally \\n                \\n               \\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint minDays(int n) {\\n        \\n        //Apply BFS , Lets see what happens \\n        \\n        queue<int> q;\\n        \\n        int ans=0;\\n        \\n        q.push(n);\\n        \\n        map<int , int> mp; // mark for the that number is already visited \\n        \\n        // Dont push same number twice in the queue , that\\'s why it can give TLE\\n        \\n        // Reason behind using map .\\n        \\n        mp[n]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            \\n            while(sz--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                \\n                if(x==1)\\n                {\\n                    return ans+1;\\n                }\\n                \\n                if(x%3==0 && mp.find(x/3)==mp.end())\\n                {\\n                    mp[x/3]=1;\\n                    q.push(x/3);\\n                }\\n                \\n                 if(x%2==0 && mp.find(x/2)==mp.end())\\n                {\\n                    mp[x/2]=1;// Mark it as visited \\n                    q.push(x/2);\\n                    \\n                }\\n                \\n                if(mp.find(x-1)==mp.end())\\n                {\\n                    mp[x-1]=1;\\n                    q.push(x-1);\\n                }\\n                \\n               \\n                \\n                // x-(2*(x/3))=x/3 finally \\n                \\n               \\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372965,
                "title": "minimum-number-of-days-to-eat-n-oranges",
                "content": "Please tell Why is this code showing error AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==30==ERROR: AddressSanitizer: stack-overflow on address 0x7ffceac96ff8 (pc 0x000000343de4 bp 0x7ffceac97000 sp 0x7ffceac97000 T0)\\n==30==ABORTING??\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, int> dp;\\n    \\n    int minDaysUtil(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp.find(n) != dp.end())\\n            return dp[n];\\n        \\n        int x= INT_MAX, y= INT_MAX, z= INT_MAX;      //or initialize with INT_MAX\\n        \\n        if(n%2)\\n        x= 1+ minDaysUtil(n/2);\\n        \\n        if(n%3)\\n        y= 1+ minDaysUtil(n- 2*(n/3));\\n        \\n        z= 1+ minDaysUtil(n-1);\\n        \\n        return dp[n]= min(x, min(y, z));\\n    }\\n    \\n    int minDays(int n) {\\n        \\n        return minDaysUtil(n);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, int> dp;\\n    \\n    int minDaysUtil(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp.find(n) != dp.end())\\n            return dp[n];\\n        \\n        int x= INT_MAX, y= INT_MAX, z= INT_MAX;      //or initialize with INT_MAX\\n        \\n        if(n%2)\\n        x= 1+ minDaysUtil(n/2);\\n        \\n        if(n%3)\\n        y= 1+ minDaysUtil(n- 2*(n/3));\\n        \\n        z= 1+ minDaysUtil(n-1);\\n        \\n        return dp[n]= min(x, min(y, z));\\n    }\\n    \\n    int minDays(int n) {\\n        \\n        return minDaysUtil(n);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2279469,
                "title": "python3-o-logn-2-with-explaination",
                "content": "First we might consider using DP, but `1 <= n <= 2 ** 109` n could be too large to be hold by a dp array.\\nTop down dp or recursion might do the trick\\nThere are three pathes to choose for each recursion: \\nminDays(i) = min(1+minDays(i-1), 1+minDay(i//2), 1 + minDay(i//3)), minDay(i-1) is too slow as only eat 1 orange per day. we need to be greedy to fininsh the orange in minimum days, so we only choose i//2 or i//3 path. \\nnow we have: minDays(i) = min(1+ i%2 + minDay(i//2), 1 + i%2 + minDay(i//3))\\n1. path /2: 1 day to eat half of the orange, and the left `i//2` oranges need  `minDay(i//2) ` days to finish, plus in order to be able to get to path /2, we need i%2 days to reach that path\\n2. path /3: 1 day to eat 2*(i//3) of the oranges, and the left `i//3` oranges need  `minDay(i//2) ` days to finish, plus in order to be able to get to path /3, we need i%3 days to reach that path\\n\\nSomehow, using a hashmap as  cache will get TLE, only with @lru_cache() beat 90% of submissions.\\n\\nTime Complexity: logN^2, logN is the height of the recursion tree\\n```\\n@lru_cache()\\ndef minDays(self, n: int) -> int:\\n\\tif n==1: return 1\\n\\tif n==2: return 2\\n\\tif n==3: return 2\\n\\treturn min(1 + n%2 + self.minDays(n//2), 1+n%3 + self.minDays(n//3))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n@lru_cache()\\ndef minDays(self, n: int) -> int:\\n\\tif n==1: return 1\\n\\tif n==2: return 2\\n\\tif n==3: return 2\\n\\treturn min(1 + n%2 + self.minDays(n//2), 1+n%3 + self.minDays(n//3))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1731354,
                "title": "c-dynamic-programming-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    int minDays(int n) {\\n        if(n<=1)\\n            return n;\\n        if(m[n]>0) // if calculation for nth number is done before we just return.\\n            return m[n];\\n        int a=INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(n%2==0) // if number is divisible by 2 \\n            a=1+minDays(n/2);\\n        if(n%3==0)  // if number is divisible by 3\\n            b=1+minDays(n/3);\\n        if((n%2)!=0 || (n%3)!=0) // if number either not divisible by 2 and 3 . so we have to check for both of these.\\n            c=1+minDays(n-1);\\n        m[n]=min(a,min(b,c));\\n        return m[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    int minDays(int n) {\\n        if(n<=1)\\n            return n;\\n        if(m[n]>0) // if calculation for nth number is done before we just return.\\n            return m[n];\\n        int a=INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(n%2==0) // if number is divisible by 2 \\n            a=1+minDays(n/2);\\n        if(n%3==0)  // if number is divisible by 3\\n            b=1+minDays(n/3);\\n        if((n%2)!=0 || (n%3)!=0) // if number either not divisible by 2 and 3 . so we have to check for both of these.\\n            c=1+minDays(n-1);\\n        m[n]=min(a,min(b,c));\\n        return m[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457555,
                "title": "c-top-down-dp-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int minDaysToEatOranges(int n, unordered_map<int, int> &memo){\\n        // no more oranges to eat, thus takes 0 days to eat\\n        if(n <= 0) return 0;\\n        \\n        // takes one day to eat one orange\\n        if(n == 1) return 1;\\n        \\n        if(memo.find(n) != memo.end()) return memo.at(n);\\n        \\n        int option_one = 1 + (n % 2) + minDaysToEatOranges(n / 2, memo);\\n        int option_two = 1 + (n % 3) + minDaysToEatOranges(n / 3, memo);\\n        \\n        return memo[n] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int minDays(int n) {\\n        // key   == day i in range [1, n]\\n        // value == which ever option we take to eat our oranges, the minimum of the options \\n        // denotes the least number of days taken to eat our oranges\\n        unordered_map<int, int> memo;\\n        \\n        return minDaysToEatOranges(n, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int minDaysToEatOranges(int n, unordered_map<int, int> &memo){\\n        // no more oranges to eat, thus takes 0 days to eat\\n        if(n <= 0) return 0;\\n        \\n        // takes one day to eat one orange\\n        if(n == 1) return 1;\\n        \\n        if(memo.find(n) != memo.end()) return memo.at(n);\\n        \\n        int option_one = 1 + (n % 2) + minDaysToEatOranges(n / 2, memo);\\n        int option_two = 1 + (n % 3) + minDaysToEatOranges(n / 3, memo);\\n        \\n        return memo[n] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int minDays(int n) {\\n        // key   == day i in range [1, n]\\n        // value == which ever option we take to eat our oranges, the minimum of the options \\n        // denotes the least number of days taken to eat our oranges\\n        unordered_map<int, int> memo;\\n        \\n        return minDaysToEatOranges(n, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268396,
                "title": "python3-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        if not n:\\n            return 0\\n        \\n        Q = deque([(n, 0)])\\n        visited = set()\\n        \\n        while(Q):\\n            fruits, days = Q.popleft()\\n            \\n            if fruits in visited:\\n                continue\\n            \\n            visited.add(fruits)\\n            \\n            if fruits == 0:\\n                return days\\n            \\n            remaining = [-1,-1,-1]\\n            \\n            if fruits % 2 == 0:\\n                remaining[0] = fruits//2\\n            if  fruits % 3 == 0:\\n                remaining[1] = fruits - ((2*fruits)//3)\\n            if fruits > 0:\\n                remaining[2] =  fruits - 1\\n            \\n            for fruit in remaining:\\n                Q.append((fruit, days+1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        if not n:\\n            return 0\\n        \\n        Q = deque([(n, 0)])\\n        visited = set()\\n        \\n        while(Q):\\n            fruits, days = Q.popleft()\\n            \\n            if fruits in visited:\\n                continue\\n            \\n            visited.add(fruits)\\n            \\n            if fruits == 0:\\n                return days\\n            \\n            remaining = [-1,-1,-1]\\n            \\n            if fruits % 2 == 0:\\n                remaining[0] = fruits//2\\n            if  fruits % 3 == 0:\\n                remaining[1] = fruits - ((2*fruits)//3)\\n            if fruits > 0:\\n                remaining[2] =  fruits - 1\\n            \\n            for fruit in remaining:\\n                Q.append((fruit, days+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209170,
                "title": "smallest-c-solution",
                "content": "\\nint minDays(int n) {\\n        \\n\\t\\tint count=0;\\n        if(n<=1)\\n            return 1;\\n        \\n        count=1+min((n%2)+minDays(n/2),(n%3)+minDays(n/3));\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\nint minDays(int n) {\\n        \\n\\t\\tint count=0;\\n        if(n<=1)\\n            return 1;\\n        \\n        count=1+min((n%2)+minDays(n/2),(n%3)+minDays(n/3));\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1165619,
                "title": "java-bfs-solution",
                "content": "I figured that a lot of counting problems (level by level) can be solved using BFS. \\nI have the bucket initialized, which contains each level\\'s numbers that are to be traversed. Since the dataset is very larget, I have to use a memo to store all the visited nodes (it caused me TLE without using it) \\nReturn the count inside BFS if we reach the number 0. \\n```\\nclass Solution {\\n    public int minDays(int n) {\\n        \\n        if (n == 1)\\n            return 1;\\n        \\n        List<Integer> bucket = new ArrayList<Integer>();\\n        \\n        bucket.add(n);\\n        \\n        int count = 0;\\n        \\n        Set<Integer> memo = new HashSet<Integer>();\\n        \\n        while (!bucket.isEmpty()) {\\n            \\n            int len = bucket.size();\\n            \\n            for (int i = 0; i < len; ++i) {\\n                \\n                int num = bucket.remove(0);\\n                \\n                if (memo.contains(num))\\n                    continue;\\n                \\n                memo.add(num);\\n                \\n                if (num == 0)\\n                    return count;\\n                \\n                bucket.add(num - 1);\\n                \\n                if (num >= 2 && num % 2 == 0)\\n                    bucket.add(num / 2);\\n                \\n                if (num >= 3 && num % 3 == 0)\\n                    bucket.add(num / 3);\\n            }\\n            count += 1;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        \\n        if (n == 1)\\n            return 1;\\n        \\n        List<Integer> bucket = new ArrayList<Integer>();\\n        \\n        bucket.add(n);\\n        \\n        int count = 0;\\n        \\n        Set<Integer> memo = new HashSet<Integer>();\\n        \\n        while (!bucket.isEmpty()) {\\n            \\n            int len = bucket.size();\\n            \\n            for (int i = 0; i < len; ++i) {\\n                \\n                int num = bucket.remove(0);\\n                \\n                if (memo.contains(num))\\n                    continue;\\n                \\n                memo.add(num);\\n                \\n                if (num == 0)\\n                    return count;\\n                \\n                bucket.add(num - 1);\\n                \\n                if (num >= 2 && num % 2 == 0)\\n                    bucket.add(num / 2);\\n                \\n                if (num >= 3 && num % 3 == 0)\\n                    bucket.add(num / 3);\\n            }\\n            count += 1;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813122,
                "title": "c-top-down-dynamic-programming",
                "content": "```\\n\\tunordered_map<int,int> hash;\\n    int dfs(int n){\\n        return hash.count(n)?hash[n]:hash[n]=1+min(n%2+dfs(n/2),n%3+dfs(n/3));\\n    }\\n    int minDays(int n) {\\n        hash[0]=0;\\n        hash[1]=1;\\n        return dfs(n);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tunordered_map<int,int> hash;\\n    int dfs(int n){\\n        return hash.count(n)?hash[n]:hash[n]=1+min(n%2+dfs(n/2),n%3+dfs(n/3));\\n    }\\n    int minDays(int n) {\\n        hash[0]=0;\\n        hash[1]=1;\\n        return dfs(n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812262,
                "title": "python-easy",
                "content": "```\\n@lru_cache(None)\\ndef f(n):\\n    if n==0:return 0\\n    if n==1:return 1\\n    if n<0:return inf\\n    ans=inf\\n    if n%3==0:\\n        ans=min(1+f(n//3),ans)\\n    if n%2==0:\\n        ans= min(1+f(n//2),ans)\\n    if (n-1)%3==0 or (n-1)%2==0:\\n        ans=min(1+f(n-1),ans)\\n    if (n-2)%3==0:\\n        ans=min(2+f(n-2),ans)\\n    return ans\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        return f(n)\\n```",
                "solutionTags": [],
                "code": "```\\n@lru_cache(None)\\ndef f(n):\\n    if n==0:return 0\\n    if n==1:return 1\\n    if n<0:return inf\\n    ans=inf\\n    if n%3==0:\\n        ans=min(1+f(n//3),ans)\\n    if n%2==0:\\n        ans= min(1+f(n//2),ans)\\n    if (n-1)%3==0 or (n-1)%2==0:\\n        ans=min(1+f(n-1),ans)\\n    if (n-2)%3==0:\\n        ans=min(2+f(n-2),ans)\\n    return ans\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        return f(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803228,
                "title": "easy-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\t    # Use a queue for our BFS.\\n        q = collections.deque([])\\n\\t\\t# Append the initial number of oranges starting at 0 days.\\n        q.append((n, 0))\\n        seen = set()\\n        while q:\\n            oranges, days = q.popleft()\\n\\t\\t\\t# First to hit 0 will be our shortest path, return the days it took.\\n            if oranges <= 3:\\n\\t\\t\\t    # We know the min from 3 is either 2 or 1.\\n                return days + min(2, oranges)\\n\\t\\t\\t# If true and not used add to the q.\\n            if oranges % 2 == 0:\\n                if oranges/2 not in seen:\\n                    q.append((oranges/2, days+1))\\n                    seen.add(oranges/2)\\n\\t\\t\\t# If true and not used add to the q.\\n            if oranges % 3 == 0:\\n                if oranges-(2*(oranges/3)) not in seen:\\n                    q.append((oranges-(2*(oranges/3)), days+1))\\n                    seen.add(oranges-(2*(oranges/3)))\\n            # If not used add to the q.\\n            if oranges-1 not in seen:\\n                q.append((oranges-1, days+1))\\n                seen.add(oranges-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\t    # Use a queue for our BFS.\\n        q = collections.deque([])\\n\\t\\t# Append the initial number of oranges starting at 0 days.\\n        q.append((n, 0))\\n        seen = set()\\n        while q:\\n            oranges, days = q.popleft()\\n\\t\\t\\t# First to hit 0 will be our shortest path, return the days it took.\\n            if oranges <= 3:\\n\\t\\t\\t    # We know the min from 3 is either 2 or 1.\\n                return days + min(2, oranges)\\n\\t\\t\\t# If true and not used add to the q.\\n            if oranges % 2 == 0:\\n                if oranges/2 not in seen:\\n                    q.append((oranges/2, days+1))\\n                    seen.add(oranges/2)\\n\\t\\t\\t# If true and not used add to the q.\\n            if oranges % 3 == 0:\\n                if oranges-(2*(oranges/3)) not in seen:\\n                    q.append((oranges-(2*(oranges/3)), days+1))\\n                    seen.add(oranges-(2*(oranges/3)))\\n            # If not used add to the q.\\n            if oranges-1 not in seen:\\n                q.append((oranges-1, days+1))\\n                seen.add(oranges-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796232,
                "title": "python3-noobest-top-down-solution",
                "content": "The way to solve this question is to list out all possible paths, and then compare them to find the least cost one!\\n```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        memo = {}\\n        def dfs(num):\\n            if num <= 1: return num\\n            if num in memo: return memo[num]\\n            res = float(\\'inf\\')\\n            if num % 2 == 0:\\n                res = min(res, 1 + dfs(num // 2))\\n            if num % 2 == 1:\\n                res = min(res, 2 + dfs(num // 2))\\n            if num % 3 == 0:\\n                res = min(res, 1 + dfs(num // 3))\\n            if num % 3 == 1:\\n                res = min(res, 2 + dfs(num // 3))\\n            if num % 3 == 2:\\n                res = min(res, 3 + dfs(num // 3))\\n            memo[num] = res \\n            return res\\n        return dfs(n)\\n```\\nI appreciate it if u can upvote!\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        memo = {}\\n        def dfs(num):\\n            if num <= 1: return num\\n            if num in memo: return memo[num]\\n            res = float(\\'inf\\')\\n            if num % 2 == 0:\\n                res = min(res, 1 + dfs(num // 2))\\n            if num % 2 == 1:\\n                res = min(res, 2 + dfs(num // 2))\\n            if num % 3 == 0:\\n                res = min(res, 1 + dfs(num // 3))\\n            if num % 3 == 1:\\n                res = min(res, 2 + dfs(num // 3))\\n            if num % 3 == 2:\\n                res = min(res, 3 + dfs(num // 3))\\n            memo[num] = res \\n            return res\\n        return dfs(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795921,
                "title": "c-fast-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp(int n,map<int,int> &m){\\n        \\n        if( n==1 )\\n            return 1;\\n        else if( n<=3 )\\n            return 2;\\n        if( m.find(n)!=m.end() )\\n            return m[n];\\n        int x = n%2 + dp(n/2,m);  // cases for all divisible by 2\\n        int y = n%3 + dp(n/3,m);  // case for all divisible by 3\\n        m.insert({n,1+min(x,y)});  // plus 1 because n/2 or n/3 is also an operation\\n        return m[n];                // memoization is important because subproblems were calculated multiple times\\n    }\\n    int minDays(int n) {\\n        // idea behind the solution is any number on divided by two can have max\\n\\t\\t//remainder of 1 similiarly any number on divisible by 3 can have maximum\\n\\t\\t//remainder 2 . It might seem obvious to you that exponentially dividing is\\n\\t\\t//better than substracting by one more than n%2 times or n%3 times hence at\\n\\t\\t//each step count for n/2 and n/3\\n        map<int,int> m;\\n        return dp(n,m);\\n        \\n\\t\\t//time complexity = number of subproblems = O(log n )\\n\\t\\t// Reason : number of subproblems will be less thn n/2 becoz n/3 < n/2\\n\\t\\t// correct me if am wrong\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int n,map<int,int> &m){\\n        \\n        if( n==1 )\\n            return 1;\\n        else if( n<=3 )\\n            return 2;\\n        if( m.find(n)!=m.end() )\\n            return m[n];\\n        int x = n%2 + dp(n/2,m);  // cases for all divisible by 2\\n        int y = n%3 + dp(n/3,m);  // case for all divisible by 3\\n        m.insert({n,1+min(x,y)});  // plus 1 because n/2 or n/3 is also an operation\\n        return m[n];                // memoization is important because subproblems were calculated multiple times\\n    }\\n    int minDays(int n) {\\n        // idea behind the solution is any number on divided by two can have max\\n\\t\\t//remainder of 1 similiarly any number on divisible by 3 can have maximum\\n\\t\\t//remainder 2 . It might seem obvious to you that exponentially dividing is\\n\\t\\t//better than substracting by one more than n%2 times or n%3 times hence at\\n\\t\\t//each step count for n/2 and n/3\\n        map<int,int> m;\\n        return dp(n,m);\\n        \\n\\t\\t//time complexity = number of subproblems = O(log n )\\n\\t\\t// Reason : number of subproblems will be less thn n/2 becoz n/3 < n/2\\n\\t\\t// correct me if am wrong\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795665,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int,bool> vis;\\n        queue<pair<int,int> > q;\\n        q.push({n,0});\\n        int ans = 0; // dummy variable otherwise compiler shows error at last line\\n        while(!q.empty())\\n        {\\n            ans++;\\n            pair<int,int> x = q.front();\\n            q.pop();\\n            int num = x.first;\\n            int days = x.second;\\n            if (num == 0)\\n                return days;\\n            if (vis.find(num-1) == vis.end())\\n                q.push({num-1,days+1}), vis[num-1] = true;\\n            if (num % 2 == 0)\\n                q.push({num/2,days+1}), vis[num/2] = true;\\n            if (num % 3 == 0)\\n                q.push({num-(2*(num/3)),days+1}), vis[num-(2*(num/3))] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int,bool> vis;\\n        queue<pair<int,int> > q;\\n        q.push({n,0});\\n        int ans = 0; // dummy variable otherwise compiler shows error at last line\\n        while(!q.empty())\\n        {\\n            ans++;\\n            pair<int,int> x = q.front();\\n            q.pop();\\n            int num = x.first;\\n            int days = x.second;\\n            if (num == 0)\\n                return days;\\n            if (vis.find(num-1) == vis.end())\\n                q.push({num-1,days+1}), vis[num-1] = true;\\n            if (num % 2 == 0)\\n                q.push({num/2,days+1}), vis[num/2] = true;\\n            if (num % 3 == 0)\\n                q.push({num-(2*(num/3)),days+1}), vis[num-(2*(num/3))] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795597,
                "title": "java-intuitive-recursion-with-memorization",
                "content": "This is actually the first time that I felt the Problem 4 is easier than Problem 3 in a contest:)\\n\\nThe idea is simple, at each step, since we only get three options:\\n1. eat n / 2 oranges,\\n2. eat n * 2/ 3 oranges,\\n3. eat 1 oranges\\n\\nWe can try expore them all and find the smallest one. And we could use memorization to reduce duplicate calculation. However, since the input n could be huge, if we try exploring eating 1 orange at each recursion call, we will get a TLE. \\n\\nMy idea is that when n is divisible by both 2 and 3, we won\\'t need to explore the option 3 (eat 1 orange), since option 1 or option 2 must be the optimal. Therefore, we will only explore the option 3 if n is not divisible by both 2 and 3.\\n\\n```\\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n == 1)return 1;\\n        if(map.containsKey(n))return map.get(n);\\n        int option1 =  Integer.MAX_VALUE;\\n        int option2 =  Integer.MAX_VALUE;\\n        int option3 =  Integer.MAX_VALUE;\\n        if(n % 2 == 0){\\n            option2 = minDays(n / 2) + 1;\\n        }\\n        if(n % 3 == 0){\\n            option3 = minDays(n / 3) + 1;\\n        }\\n        if(!(n % 2 == 0 && n % 3 == 0)){\\n            option1 = minDays(n - 1) + 1;\\n        }\\n        int temp = Math.min(option1, Math.min(option2, option3));\\n        map.putIfAbsent(n, temp);\\n        return temp;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int res = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n == 1)return 1;\\n        if(map.containsKey(n))return map.get(n);\\n        int option1 =  Integer.MAX_VALUE;\\n        int option2 =  Integer.MAX_VALUE;\\n        int option3 =  Integer.MAX_VALUE;\\n        if(n % 2 == 0){\\n            option2 = minDays(n / 2) + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 794737,
                "title": "optimised-dp-explained-along-with-tle-solutions",
                "content": "The idea is to avoid eating 1 orange per day when you can go for n//2 and n//3 in 1 day.\\nBecause of the constraints (2*10**9) we are supposed to optimise it in this way.\\nSo,basically we just consume  n//2 and eat the rest i.e n%2 one by one\\nAnd the same goes with consuming 2n/3 => remaining are n/3. we consume n%3 one by one.\\n\\n```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        @functools.lru_cache(None)\\n        def dp(n):\\n            if n<=1:\\n                return n\\n            return min(\\n            dp(n//2 ) + 1 + n%2,\\n            dp(n//3 ) + 1 + n%3,\\n            )\\n        return dp(n)\\n```\\n\\n**My first solutions that got TLE {for study purpose}**\\n**Minimum Number of Days to Eat N Oranges**\\nBottom-up DP\\n```python\\n        INF = float(\\'inf\\')\\n        NINF = float(\\'-inf\\')\\n        dp = [INF]*(n+1)\\n        for i in range(n+1):\\n            if i<2:\\n                dp[i] = i\\n                continue\\n            mx = NINF\\n            if i%2 == 0:\\n                dp[i] = min(dp[i],1 + dp[i-i//2])\\n            if i%3 == 0:\\n                dp[i] = min(dp[i],1 + dp[i-(2*i//3)])\\n            dp[i] = min(dp[i],1+dp[i-1])\\n\\n        return dp[n]\\n```\\n\\nTop-Down DP\\n```python\\n        INF = float(\\'inf\\')\\n        @functools.lru_cache(None)\\n        def dp(rem):\\n            if rem<=0:\\n                return 0\\n            cand1,cand2 = INF,INF\\n            cand3 = 1 + dp(rem-1)\\n            if rem%2 == 0:\\n                cand1 = 1 + dp( rem - rem//2 )\\n            if rem%3 == 0:\\n                cand2 = 1  + dp( rem - 2*(rem//3) )\\n            return min(cand1,cand2,cand3)\\n        \\n        return dp(n)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        @functools.lru_cache(None)\\n        def dp(n):\\n            if n<=1:\\n                return n\\n            return min(\\n            dp(n//2 ) + 1 + n%2,\\n            dp(n//3 ) + 1 + n%3,\\n            )\\n        return dp(n)\\n```\n```python\\n        INF = float(\\'inf\\')\\n        NINF = float(\\'-inf\\')\\n        dp = [INF]*(n+1)\\n        for i in range(n+1):\\n            if i<2:\\n                dp[i] = i\\n                continue\\n            mx = NINF\\n            if i%2 == 0:\\n                dp[i] = min(dp[i],1 + dp[i-i//2])\\n            if i%3 == 0:\\n                dp[i] = min(dp[i],1 + dp[i-(2*i//3)])\\n            dp[i] = min(dp[i],1+dp[i-1])\\n\\n        return dp[n]\\n```\n```python\\n        INF = float(\\'inf\\')\\n        @functools.lru_cache(None)\\n        def dp(rem):\\n            if rem<=0:\\n                return 0\\n            cand1,cand2 = INF,INF\\n            cand3 = 1 + dp(rem-1)\\n            if rem%2 == 0:\\n                cand1 = 1 + dp( rem - rem//2 )\\n            if rem%3 == 0:\\n                cand2 = 1  + dp( rem - 2*(rem//3) )\\n            return min(cand1,cand2,cand3)\\n        \\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794702,
                "title": "need-help-the-hardest-part-of-this-problem-is-how-to-calculate-the-complexity",
                "content": "The recuisive relation is: T(n) = T(n/2) + T(n/3) + O(1)\\n\\nBased on [Master Theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)), we know\\n\\n```\\nT(n) = T(n/2) + T(n/3) + O(1) < 2*T(n/2) + O(1) = O(n)\\n```\\n\\nO(n) is an easy to get but too loose upper limit. I write a program to count the number of subproblems by n (chosen by random).\\nFrom my statistics, the upper limit looks like ~~O(sqrt(n))~~. \\n**The right answer is O(log^2(n)). See [this post](https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794847/Polylogarithmic-solution)**\\n\\n```\\npackage main\\n\\nimport \"fmt\"\\nimport \"math\"\\nimport \"math/rand\"\\n\\nvar M map[int]int\\nvar callCnt int\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc minDays(n int) int {\\n    if v, exist := M[n]; exist {\\n        return v\\n    }\\n    \\n    M[n] = 1 + min(minDays(n/3) + n%3, minDays(n/2) + n%2)\\n    callCnt++\\n    return M[n]\\n}\\n\\nfunc main() {\\n    var totalN int64\\n    for i := 0; i < 10000; i++ {\\n        M = map[int]int{\\n            0:0,\\n            1:1,\\n        }\\n        n := rand.Intn(math.MaxInt32)\\n        totalN += int64(n)\\n        minDays(n)\\n    }\\n\\n    fmt.Println(\"totalN\", totalN)\\n    fmt.Println(\"callCnt\", callCnt)\\n}\\n\\n/* output: \\ntotalN 10682882233172\\ncallCnt 2369370\\n*/\\n```\\n\\nCould anyone figure the right upper limit out ?",
                "solutionTags": [],
                "code": "```\\nT(n) = T(n/2) + T(n/3) + O(1) < 2*T(n/2) + O(1) = O(n)\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\nimport \"math\"\\nimport \"math/rand\"\\n\\nvar M map[int]int\\nvar callCnt int\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc minDays(n int) int {\\n    if v, exist := M[n]; exist {\\n        return v\\n    }\\n    \\n    M[n] = 1 + min(minDays(n/3) + n%3, minDays(n/2) + n%2)\\n    callCnt++\\n    return M[n]\\n}\\n\\nfunc main() {\\n    var totalN int64\\n    for i := 0; i < 10000; i++ {\\n        M = map[int]int{\\n            0:0,\\n            1:1,\\n        }\\n        n := rand.Intn(math.MaxInt32)\\n        totalN += int64(n)\\n        minDays(n)\\n    }\\n\\n    fmt.Println(\"totalN\", totalN)\\n    fmt.Println(\"callCnt\", callCnt)\\n}\\n\\n/* output: \\ntotalN 10682882233172\\ncallCnt 2369370\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 794224,
                "title": "very-easy-i-got-a-tinder-date-with-this-solution-to-understand-c-code",
                "content": "We cannot subtraact 1 for more than twice in a row. The idea is to make number either divisible by 2 or 3 at each point and take the minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    map<int, int> mp;\\n    int solve(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(mp.find(n) != mp.end())\\n            return mp[n];\\n        return mp[n] = min( 1 + (n%2) + solve(n/2), 1 + (n%3) + solve(n/3));\\n    }\\n    int minDays(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> mp;\\n    int solve(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(mp.find(n) != mp.end())\\n            return mp[n];\\n        return mp[n] = min( 1 + (n%2) + solve(n/2), 1 + (n%3) + solve(n/3));\\n    }\\n    int minDays(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892952,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int minDays(int n)\\n{\\n    unordered_map<int, int> mp;\\n    queue<int> q;\\n    q.push(n);\\n    int count = 0;\\n\\n    while (!q.empty())\\n    {\\n        int sz = q.size();\\n\\n        while (sz--)\\n        {\\n            int org = q.front();\\n            q.pop();\\n            if (org == 0)\\n            {\\n                return count;\\n            }\\n\\n            if (org % 3 == 0 and mp.find(org / 3) == mp.end())\\n            {\\n                q.push(org / 3);\\n                mp[org / 3]++;\\n            }\\n\\n            if (org % 2 == 0 and mp.find(org / 2) == mp.end())\\n            {\\n                q.push(org / 2);\\n                mp[org / 2]++;\\n            }\\n\\n            if (mp.find(org - 1) == mp.end())\\n            {\\n                q.push(org - 1);\\n                mp[org - 1]++;\\n            }\\n        }\\n        count++;\\n    }\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minDays(int n)\\n{\\n    unordered_map<int, int> mp;\\n    queue<int> q;\\n    q.push(n);\\n    int count = 0;\\n\\n    while (!q.empty())\\n    {\\n        int sz = q.size();\\n\\n        while (sz--)\\n        {\\n            int org = q.front();\\n            q.pop();\\n            if (org == 0)\\n            {\\n                return count;\\n            }\\n\\n            if (org % 3 == 0 and mp.find(org / 3) == mp.end())\\n            {\\n                q.push(org / 3);\\n                mp[org / 3]++;\\n            }\\n\\n            if (org % 2 == 0 and mp.find(org / 2) == mp.end())\\n            {\\n                q.push(org / 2);\\n                mp[org / 2]++;\\n            }\\n\\n            if (mp.find(org - 1) == mp.end())\\n            {\\n                q.push(org - 1);\\n                mp[org - 1]++;\\n            }\\n        }\\n        count++;\\n    }\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592335,
                "title": "dijkstra-solution-with-commented-hint",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        // Edge : N -> N/2 (Cost = 1 + (N%2))  and  N -> N/3 (Cost = 1 + (N%3))\\n\\n        multiset<pair<int,int>>s;\\n        set<int>visited;\\n        unordered_map<int,int>dp;\\n        dp[n] = 0;\\n        s.insert({0, n});\\n        \\n        while((int)s.size() > 0){\\n            auto it = s.begin();\\n\\n            pair<int,int> p = *it;\\n            s.erase(s.begin());\\n            int x = p.second;\\n            n = x;\\n            if(visited.find(x)!=visited.end()) continue;\\n            visited.insert(x);\\n            // n/2 , n/3\\n            int weigh = (n%2);\\n            if(dp.find(n/2) == dp.end()) dp[n/2] = INT_MAX;\\n            if(dp[n/2] > ((n/2)>0?1:0) + dp[x] + weigh){\\n                dp[n/2] = ((n/2)>0?1:0) +  dp[x] + weigh;\\n                s.insert({dp[n/2], n/2});\\n            }\\n            weigh = (n%3);\\n            if(dp.find(n/3) == dp.end()) dp[n/3] = INT_MAX;\\n            if(dp[n/3] > ((n/3)>0?1:0) + dp[x] + weigh){\\n                dp[n/3] = ((n/3)>0?1:0) + dp[x] + weigh;\\n                s.insert({dp[n/3], n/3});\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        // Edge : N -> N/2 (Cost = 1 + (N%2))  and  N -> N/3 (Cost = 1 + (N%3))\\n\\n        multiset<pair<int,int>>s;\\n        set<int>visited;\\n        unordered_map<int,int>dp;\\n        dp[n] = 0;\\n        s.insert({0, n});\\n        \\n        while((int)s.size() > 0){\\n            auto it = s.begin();\\n\\n            pair<int,int> p = *it;\\n            s.erase(s.begin());\\n            int x = p.second;\\n            n = x;\\n            if(visited.find(x)!=visited.end()) continue;\\n            visited.insert(x);\\n            // n/2 , n/3\\n            int weigh = (n%2);\\n            if(dp.find(n/2) == dp.end()) dp[n/2] = INT_MAX;\\n            if(dp[n/2] > ((n/2)>0?1:0) + dp[x] + weigh){\\n                dp[n/2] = ((n/2)>0?1:0) +  dp[x] + weigh;\\n                s.insert({dp[n/2], n/2});\\n            }\\n            weigh = (n%3);\\n            if(dp.find(n/3) == dp.end()) dp[n/3] = INT_MAX;\\n            if(dp[n/3] > ((n/3)>0?1:0) + dp[x] + weigh){\\n                dp[n/3] = ((n/3)>0?1:0) + dp[x] + weigh;\\n                s.insert({dp[n/3], n/3});\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084756,
                "title": "one-line-solution",
                "content": "# Intuition\\nIt is almost oneliner without memoization and base case.\\n\\n# Approach\\nSolution is to take MIN of eating n%2 oranges one per day + minDays(n/2) AND eating n%3 oranges one per day + minDays(n/3). Added memoization to avoid repetitions.\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, int> memo = {{0, 1}, {1,1}}; // default values\\n    int minDays(int n) {\\n        if (memo.find(n) != memo.end())\\n            return memo[n];\\n\\n        return memo[n] = 1 + min(n%2 + minDays(n/2), n%3 + minDays(n/3));\\n        // Below is the detailed code for above one liner\\n        // int path2, path3;\\n        // if (n % 2 == 0)\\n        //     path2 = 1 + minDays(n/2);\\n        // else\\n        //     path2 = 2 + minDays(n/2);\\n        \\n        // if (n % 3 == 0)\\n        //     path3 = 1 + minDays(n/3);\\n        // else if (n % 3 == 1)\\n        //     path3 = 2 + minDays(n/3);\\n        // else\\n        //     path3 = 3 + minDays(n/3);\\n        // return memo[n] = min(path2, path3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> memo = {{0, 1}, {1,1}}; // default values\\n    int minDays(int n) {\\n        if (memo.find(n) != memo.end())\\n            return memo[n];\\n\\n        return memo[n] = 1 + min(n%2 + minDays(n/2), n%3 + minDays(n/3));\\n        // Below is the detailed code for above one liner\\n        // int path2, path3;\\n        // if (n % 2 == 0)\\n        //     path2 = 1 + minDays(n/2);\\n        // else\\n        //     path2 = 2 + minDays(n/2);\\n        \\n        // if (n % 3 == 0)\\n        //     path3 = 1 + minDays(n/3);\\n        // else if (n % 3 == 1)\\n        //     path3 = 2 + minDays(n/3);\\n        // else\\n        //     path3 = 3 + minDays(n/3);\\n        // return memo[n] = min(path2, path3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002377,
                "title": "simple-solution-using-hashmap-dfs",
                "content": "# Intuition\\nThe basic intution here is that we can do this in dynamic programming by calculating how much time it will take to eat 1,2,3,...n oranges one by one. It will take O(n) time and O(n) memory.\\n\\nInstead of finding time to eat for all n oranges, we can just find the time to eat only those number of oranges that will be enough to calculate the query.\\n\\nSo we have to calculate time to eat n/3 oranges and n/2 oranges separetely for each n considering we may need to subract 1 orange whenever the number is not exactly divisible by 2 or 3. Then we have to take the minimum of these two as our answer. This have time complexity of O(log2 n)\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer,Integer> map;\\n    public int minDays(int n) {\\n        map=new HashMap<>();\\n        map.put(0,0);\\n        map.put(1,1);\\n        return dfs(n);\\n    }\\n    public int dfs(int n){\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int a=dfs(n/2)+n%2+1;\\n        int b=dfs(n/3)+n%3+1;\\n        map.put(n,Math.min(a,b));\\n        return map.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map;\\n    public int minDays(int n) {\\n        map=new HashMap<>();\\n        map.put(0,0);\\n        map.put(1,1);\\n        return dfs(n);\\n    }\\n    public int dfs(int n){\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int a=dfs(n/2)+n%2+1;\\n        int b=dfs(n/3)+n%3+1;\\n        map.put(n,Math.min(a,b));\\n        return map.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374959,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // approach: BFS\\n    int minDays(int n) {\\n        int cnt=0;\\n        queue<int>q;\\n        q.push(n);\\n        unordered_set<int>s;\\n        s.insert(n);\\n        while(!q.empty()){\\n            int l=q.size();\\n            while(l--){\\n                int a=q.front();\\n                q.pop();\\n                if(a==0)\\n                    break;\\n                if(s.find(a-1)==s.end()){ \\n                    q.push(a-1);\\n                    s.insert(a-1);\\n                }  \\n                if(!(a&1) && s.find(a>>1)==s.end()){   // if divisible by 2 and a/2 not present in set\\n                    q.push(a>>1);\\n                    s.insert(a>>1);\\n                }\\n                if(a%3==0 && s.find(a/3)==s.end()){  // if divisible by 3 and a/3 not present in set\\n                    q.push(a/3);\\n                    s.insert(a/3);\\n                }\\n            }\\n            cnt++;\\n            if(s.find(0)!=s.end())\\n                break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // approach: BFS\\n    int minDays(int n) {\\n        int cnt=0;\\n        queue<int>q;\\n        q.push(n);\\n        unordered_set<int>s;\\n        s.insert(n);\\n        while(!q.empty()){\\n            int l=q.size();\\n            while(l--){\\n                int a=q.front();\\n                q.pop();\\n                if(a==0)\\n                    break;\\n                if(s.find(a-1)==s.end()){ \\n                    q.push(a-1);\\n                    s.insert(a-1);\\n                }  \\n                if(!(a&1) && s.find(a>>1)==s.end()){   // if divisible by 2 and a/2 not present in set\\n                    q.push(a>>1);\\n                    s.insert(a>>1);\\n                }\\n                if(a%3==0 && s.find(a/3)==s.end()){  // if divisible by 3 and a/3 not present in set\\n                    q.push(a/3);\\n                    s.insert(a/3);\\n                }\\n            }\\n            cnt++;\\n            if(s.find(0)!=s.end())\\n                break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329308,
                "title": "intuition",
                "content": "Here is a simple explanation:\\n```\\nattempt 1:    1 +  Math.min ( minDays(n-1) ,   Math.min ( n % 3 == 0 ? minDays( n  / 3) : Integer.MAX, \\n                                                             n % 2  == 0 ? minDays( n /2 ) : Integer.MAX)  \\n                             );\\n```                             \\nThis would result in too many states. Its never profitable to eat 1 apple a day for more than 2 days at a time.\\nA greedy approach is needed.  We need to greedily either eat n % 2 or n % 3 apple at a time so that we can make the number of remaining apples divisible by 2 or 3.  \\n               \\n```               \\nattempt 2:  1 +  Math.min ( n % 3 == 0 ? minDays( n / 3) : n % 3  + minDays( n - n % 3)  ,      \\n                                 n % 2 == 0 ? minDays( n  / 2) : n % 2  + minDays( n - n % 2) );\\n                           \\n           same as:                                  \\n           1 +  Math.min ( n % 3 == 0 ? minDays( n  / 3) : n % 3  + minDays( n/3)  ,      \\n                                           n % 2 == 0 ? minDays( n  / 2) : n % 2  + minDays( n /2) );\\n                                           \\n           same as:                                  \\n           1 +  Math.min ( n % 3  + minDays( n/3)  ,  n % 2  + minDays( n /2) )\\n```",
                "solutionTags": [],
                "code": "```\\nattempt 1:    1 +  Math.min ( minDays(n-1) ,   Math.min ( n % 3 == 0 ? minDays( n  / 3) : Integer.MAX, \\n                                                             n % 2  == 0 ? minDays( n /2 ) : Integer.MAX)  \\n                             );\\n```\n```               \\nattempt 2:  1 +  Math.min ( n % 3 == 0 ? minDays( n / 3) : n % 3  + minDays( n - n % 3)  ,      \\n                                 n % 2 == 0 ? minDays( n  / 2) : n % 2  + minDays( n - n % 2) );\\n                           \\n           same as:                                  \\n           1 +  Math.min ( n % 3 == 0 ? minDays( n  / 3) : n % 3  + minDays( n/3)  ,      \\n                                           n % 2 == 0 ? minDays( n  / 2) : n % 2  + minDays( n /2) );\\n                                           \\n           same as:                                  \\n           1 +  Math.min ( n % 3  + minDays( n/3)  ,  n % 2  + minDays( n /2) )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178224,
                "title": "c-bfs-easy-to-understand-no-fancy-stuff",
                "content": "#### class Solution {\\n##### public:\\n    map<int,int> m;\\n    int minDays(int n) {\\n        queue<int> q;\\n        int ans=0;\\n        q.push(n);\\n        m[n]=1;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0; i<s; i++){\\n                int a=q.front();\\n                q.pop();\\n                if(a==0)\\n                    return ans;\\n                if(a%2==0 && !m.count(a/2)){\\n                    q.push(a/2); m[a/2]=1;\\n                }\\n                if(a%3==0 && !m.count(a/3)){\\n                    q.push(a/3); m[a/3]=1;\\n                }\\n                if(!m.count(a-1)){\\n                    q.push(a-1); m[a-1]=1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n##### public:\\n    map<int,int> m;\\n    int minDays(int n) {\\n        queue<int> q;\\n        int ans=0;\\n        q.push(n);\\n        m[n]=1;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0; i<s; i++){\\n                int a=q.front();\\n                q.pop();\\n                if(a==0)\\n                    return ans;\\n                if(a%2==0 && !m.count(a/2)){\\n                    q.push(a/2); m[a/2]=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2108133,
                "title": "c-solution-using-bfs",
                "content": "```\\nint minDays(int n)\\n{\\n  queue<int> q;\\n  q.push(n);\\n  map<int, int> mp;\\n  int ans = 0;\\n  while (!q.empty())\\n  {\\n    int p = q.size();\\n    for (int i = 0; i < p; i++)\\n    {\\n      int x = q.front();\\n      q.pop();\\n      if (x == 0)\\n        return ans;\\n      if (mp.find(x - 1) == mp.end())\\n      {\\n        q.push(x - 1);\\n        mp[x - 1]++;\\n      }\\n      if (x % 2 == 0)\\n      {\\n        if (mp.find(x / 2) == mp.end())\\n        {\\n          q.push(x / 2);\\n          mp[x / 2]++;\\n        }\\n      }\\n      if (x % 3 == 0)\\n      {\\n        if (mp.find(x / 3) == mp.end())\\n        {\\n          q.push(x / 3);\\n          mp[x / 3]++;\\n        }\\n      }\\n    }\\n    ans++;\\n  }\\n  return -1;\\n}",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minDays(int n)\\n{\\n  queue<int> q;\\n  q.push(n);\\n  map<int, int> mp;\\n  int ans = 0;\\n  while (!q.empty())\\n  {\\n    int p = q.size();\\n    for (int i = 0; i < p; i++)\\n    {\\n      int x = q.front();\\n      q.pop();\\n      if (x == 0)\\n        return ans;\\n      if (mp.find(x - 1) == mp.end())\\n      {\\n        q.push(x - 1);\\n        mp[x - 1]++;\\n      }\\n      if (x % 2 == 0)\\n      {\\n        if (mp.find(x / 2) == mp.end())\\n        {\\n          q.push(x / 2);\\n          mp[x / 2]++;\\n        }\\n      }\\n      if (x % 3 == 0)\\n      {\\n        if (mp.find(x / 3) == mp.end())\\n        {\\n          q.push(x / 3);\\n          mp[x / 3]++;\\n        }\\n      }\\n    }\\n    ans++;\\n  }\\n  return -1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2100965,
                "title": "java-solution-using-hash-maps",
                "content": "```\\nclass Solution {\\n    Map<Integer ,Integer>dp = new HashMap<>();\\n    public int minDays(int n)\\n    {\\n        if(n<=1)\\n            return n;\\n        if(!dp.containsKey(n))\\n            dp.put(n,1+Math.min(n%2+minDays(n/2),n%3+minDays(n/3)));\\n        return dp.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer ,Integer>dp = new HashMap<>();\\n    public int minDays(int n)\\n    {\\n        if(n<=1)\\n            return n;\\n        if(!dp.containsKey(n))\\n            dp.put(n,1+Math.min(n%2+minDays(n/2),n%3+minDays(n/3)));\\n        return dp.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092578,
                "title": "c-dp-3-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int minDays(int n) {\\n        if(n<=1)return 1;\\n        if(mp.count(n))return mp[n];\\n        return mp[n]=1+min(n%2+minDays(n/2),n%3+minDays(n/3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int minDays(int n) {\\n        if(n<=1)return 1;\\n        if(mp.count(n))return mp[n];\\n        return mp[n]=1+min(n%2+minDays(n/2),n%3+minDays(n/3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801774,
                "title": "java-simple-bfs",
                "content": "````\\nclass Solution {\\n    int count =0;\\n    public int minDays(int n) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.add(n);\\n        Set<Integer> set = new HashSet<>();\\n        set.add(n);\\n        int steps =0;\\n        while(!queue.isEmpty() && !set.contains(0)){\\n            int l = queue.size();\\n            steps++;\\n            while(l>0){\\n                int val = queue.poll();\\n                if(val%3==0 && !set.contains(val/3)){\\n                    queue.add(val/3);\\n                    set.add(val/3);\\n                }\\n                if(val%2==0 && !set.contains(val/2)){\\n                    queue.add(val/2);\\n                    set.add(val/2);\\n                }\\n                if(!set.contains(val-1)){\\n                    queue.add(val-1);\\n                    set.add(val-1);\\n                }\\n                \\n                l--;\\n            }  \\n        }\\n       return steps; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int count =0;\\n    public int minDays(int n) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.add(n);\\n        Set<Integer> set = new HashSet<>();\\n        set.add(n);\\n        int steps =0;\\n        while(!queue.isEmpty() && !set.contains(0)){\\n            int l = queue.size();\\n            steps++;\\n            while(l>0){\\n                int val = queue.poll();\\n                if(val%3==0 && !set.contains(val/3)){\\n                    queue.add(val/3);\\n                    set.add(val/3);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1730598,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        ans = 0\\n        q = [n]\\n        visit = set()\\n        visit.add(n)\\n        while q:\\n            for i in range(len(q)):\\n                num = q.pop(0)\\n                if num == 0:\\n                    return ans\\n                if num and (num-1) not in visit:\\n                    visit.add(num-1)\\n                    q.append(num-1)\\n                if num % 2 == 0 and num-(num//2) not in visit:\\n                    visit.add(num-(num//2))\\n                    q.append(num-(num//2))\\n                if num % 3 == 0 and num-2*(num//3) not in visit:\\n                    visit.add(num-2*(num//3))\\n                    q.append(num-2*(num//3))\\n            ans += 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        ans = 0\\n        q = [n]\\n        visit = set()\\n        visit.add(n)\\n        while q:\\n            for i in range(len(q)):\\n                num = q.pop(0)\\n                if num == 0:\\n                    return ans\\n                if num and (num-1) not in visit:\\n                    visit.add(num-1)\\n                    q.append(num-1)\\n                if num % 2 == 0 and num-(num//2) not in visit:\\n                    visit.add(num-(num//2))\\n                    q.append(num-(num//2))\\n                if num % 3 == 0 and num-2*(num//3) not in visit:\\n                    visit.add(num-2*(num//3))\\n                    q.append(num-2*(num//3))\\n            ans += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1593936,
                "title": "python-king-level-o-log-n-dp-solution",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        @cache\\n        def eat(n):\\n            if n <= 1:\\n                return 1\\n            \\n            return min(n % 2 + eat(n//2), n % 3 + eat(n//3)) + 1\\n        \\n        return eat(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        @cache\\n        def eat(n):\\n            if n <= 1:\\n                return 1\\n            \\n            return min(n % 2 + eat(n//2), n % 3 + eat(n//3)) + 1\\n        \\n        return eat(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438081,
                "title": "tricky-c",
                "content": "```\\nclass Solution {\\npublic:\\n   unordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) != 0) return dp[n];\\n    \\n      int a=INT_MAX;\\n      int b=INT_MAX;\\n      int c=INT_MAX;\\n    \\n  \\n         if(n%2==0) b=1 +minDays(n/2);\\n         if(n%3==0) c=1 +minDays(n/3);\\n\\t\\t \\n\\t\\t /*This is tricky*/\\n    \\n    if((n%2!=0)||(n%3!=0)) a=1+minDays(n-1); \\n         \\n    return dp[n]=  min(min(b,c),a)  ;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_map<int, int> dp;\\nint minDays(int n) {\\n    if (n <= 1)\\n        return n;\\n    if (dp.count(n) != 0) return dp[n];\\n    \\n      int a=INT_MAX;\\n      int b=INT_MAX;\\n      int c=INT_MAX;\\n    \\n  \\n         if(n%2==0) b=1 +minDays(n/2);\\n         if(n%3==0) c=1 +minDays(n/3);\\n\\t\\t \\n\\t\\t /*This is tricky*/\\n    \\n    if((n%2!=0)||(n%3!=0)) a=1+minDays(n-1); \\n         \\n    return dp[n]=  min(min(b,c),a)  ;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429917,
                "title": "logic-matters",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int minDays(int n) {\\n       return solve(n);  \\n    }\\n    int solve(int n){\\n      if(n == 1)\\n      return 1;\\n      if(n == 2)\\n      return 2;\\n      if(n == 3)\\n      return 3;\\n      if(um.find(n)!=um.end())\\n      return um[n];\\n      int ans = 1+(n%2)+solve((n-(n%2))/2);\\n      ans = min(ans,1+(n%3)+solve((n-(n%3))/3));\\n      return um[n] = ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int minDays(int n) {\\n       return solve(n);  \\n    }\\n    int solve(int n){\\n      if(n == 1)\\n      return 1;\\n      if(n == 2)\\n      return 2;\\n      if(n == 3)\\n      return 3;\\n      if(um.find(n)!=um.end())\\n      return um[n];\\n      int ans = 1+(n%2)+solve((n-(n%2))/2);\\n      ans = min(ans,1+(n%3)+solve((n-(n%3))/3));\\n      return um[n] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362886,
                "title": "c-dp-memoization-method",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1000] = {0};   \\n    map<int , int> mp;\\n    int idx = 1;  \\n    \\n    int minDays(int n) \\n    { return recur(n); }  \\n    \\n    int recur(int n)\\n    {    \\n        if(n==0) return 0;\\n        \\n        if(mp[n]==0)\\n        { mp[n] = idx; idx++; }\\n        \\n        int m = mp[n];\\n      \\n        if(dp[m]!=0) return dp[m];\\n        \\n        if(n%2!=0 && n%3!=0) return dp[m]= 1 + recur(n-1);\\n        \\n        else if(n%2==0 || n%3==0)\\n        {\\n             if(n%2==0 && n%3==0)\\n                 return dp[m] = 1 + min(recur(n/2) , recur(n/3));\\n             else if(n%2==0)\\n                 return dp[m]= 1 + min(recur(n-1) , recur(n/2));\\n             else\\n                 return dp[m] = 1 + min(recur(n-1) , recur(n/3));             \\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\nplease upvote if it helps ,\\nthanks !\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1000] = {0};   \\n    map<int , int> mp;\\n    int idx = 1;  \\n    \\n    int minDays(int n) \\n    { return recur(n); }  \\n    \\n    int recur(int n)\\n    {    \\n        if(n==0) return 0;\\n        \\n        if(mp[n]==0)\\n        { mp[n] = idx; idx++; }\\n        \\n        int m = mp[n];\\n      \\n        if(dp[m]!=0) return dp[m];\\n        \\n        if(n%2!=0 && n%3!=0) return dp[m]= 1 + recur(n-1);\\n        \\n        else if(n%2==0 || n%3==0)\\n        {\\n             if(n%2==0 && n%3==0)\\n                 return dp[m] = 1 + min(recur(n/2) , recur(n/3));\\n             else if(n%2==0)\\n                 return dp[m]= 1 + min(recur(n-1) , recur(n/2));\\n             else\\n                 return dp[m] = 1 + min(recur(n-1) , recur(n/3));             \\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\nplease upvote if it helps ,\\nthanks !\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241274,
                "title": "5-lines-of-code-easy-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        int a1 = 1 + n%2 +minDays(n/2);\\n        int a2 = 1 + n%3+ minDays(n/3);\\n        return min(a1, a2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        int a1 = 1 + n%2 +minDays(n/2);\\n        int a2 = 1 + n%3+ minDays(n/3);\\n        return min(a1, a2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237240,
                "title": "java-naive-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offerLast(n);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        int day = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int curr = queue.pollFirst();\\n\\t\\t\\t\\t\\n                if (!visited.add(curr)) continue;\\n                if (curr == 0) return day;\\n                \\n                if (curr % 3 == 0) queue.offerLast(curr / 3);\\n                if (curr % 2 == 0) queue.offerLast(curr / 2);\\n                queue.offerLast(curr - 1);\\n            }\\n            day++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offerLast(n);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        int day = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int curr = queue.pollFirst();\\n\\t\\t\\t\\t\\n                if (!visited.add(curr)) continue;\\n                if (curr == 0) return day;\\n                \\n                if (curr % 3 == 0) queue.offerLast(curr / 3);\\n                if (curr % 2 == 0) queue.offerLast(curr / 2);\\n                queue.offerLast(curr - 1);\\n            }\\n            day++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203990,
                "title": "java-simple-dfs-according-to-the-hint-given",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> dp;\\n    public int minDays(int n) {\\n        dp = new HashMap();\\n        return minD(n);\\n    }\\n    \\n    public int minD(int n) {\\n        if(n == 0) return -1;\\n        \\n        if(dp.get(n) != null) return dp.get(n);\\n        \\n\\t\\t// n%2 gives us the number of days we can just eat 1 orange and then get to a point where the number of oranges is divisible by 2. \\n\\t\\t//So we then add that with n/2 to get total days. Same goes for 3.\\n\\t\\t// Example for 17 we can remove 1 once (17%2 = 1) to get 16 then we call f(16/2)\\n\\t\\t// Or we can remove 1 twice (17%3 = 2) to get 15 then we call f(15/3)\\n\\t\\t// If on the other hand the number is already divisible by 2 or 3, n%2 or n%3 will just give 0\\n\\t\\t// Finally we take the min of those two steps plus with the one step that we are taking\\n\\t\\t\\n        int two = n%2 + minD(n/2);\\n        int three = n%3 + minD(n/3);\\n        dp.put(n, 1 + Math.min(two, three));\\n        return dp.get(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> dp;\\n    public int minDays(int n) {\\n        dp = new HashMap();\\n        return minD(n);\\n    }\\n    \\n    public int minD(int n) {\\n        if(n == 0) return -1;\\n        \\n        if(dp.get(n) != null) return dp.get(n);\\n        \\n\\t\\t// n%2 gives us the number of days we can just eat 1 orange and then get to a point where the number of oranges is divisible by 2. \\n\\t\\t//So we then add that with n/2 to get total days. Same goes for 3.\\n\\t\\t// Example for 17 we can remove 1 once (17%2 = 1) to get 16 then we call f(16/2)\\n\\t\\t// Or we can remove 1 twice (17%3 = 2) to get 15 then we call f(15/3)\\n\\t\\t// If on the other hand the number is already divisible by 2 or 3, n%2 or n%3 will just give 0\\n\\t\\t// Finally we take the min of those two steps plus with the one step that we are taking\\n\\t\\t\\n        int two = n%2 + minD(n/2);\\n        int three = n%3 + minD(n/3);\\n        dp.put(n, 1 + Math.min(two, three));\\n        return dp.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119549,
                "title": "why-is-my-code-memory-limite-exceeded",
                "content": "What\\'s the difference with using a Hashmap which contains n key-values? The Hashmap solution is acceptable.\\n```Java\\nclass Solution {\\n    public int minDays(int n) {\\n\\t\\tint[] memo = new int[n+1];\\n        return dfs(n, memo);\\n    }\\n    \\n    private int dfs(int n, int[] memo) {\\n        // terminator\\n        if (n <= 1) {\\n           memo[n] = n;\\n            return memo[n];\\n        }\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        memo[n] = Math.min(n%2 + dfs(n/2, memo), n%3 + dfs(n/3, memo)) + 1;\\n        return memo[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int minDays(int n) {\\n\\t\\tint[] memo = new int[n+1];\\n        return dfs(n, memo);\\n    }\\n    \\n    private int dfs(int n, int[] memo) {\\n        // terminator\\n        if (n <= 1) {\\n           memo[n] = n;\\n            return memo[n];\\n        }\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        memo[n] = Math.min(n%2 + dfs(n/2, memo), n%3 + dfs(n/3, memo)) + 1;\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084776,
                "title": "c-fastest-bfs-solution",
                "content": "class Solution {\\npublic:\\n\\n\\n    int minDays(int n) {\\n        unordered_set<int>s;\\n        if(n==0)\\n            return 0;\\n        s.insert(n);\\n        s.insert(-1);\\n        queue<int>q;\\n        q.push(n);\\n        int c=0,k=0;\\n        while(q.size())\\n        {\\n            if(k)\\n                break;\\n            c++;\\n            int y=q.size();\\n            while(y--)\\n            {\\n                if(k)\\n                    break;\\n                int d=q.front();\\n                q.pop();\\n                vector<int>v(3,-1);\\n                v[0]=d-1;\\n                if(!(d%2))\\n                    v[1]=d-(d/2);\\n                if(!(d%3))\\n                    v[2]=d-((d/3)*2);\\n                for(int i=0;i<3;i++)\\n                {\\n                    if(!s.count(v[i]))\\n                    {\\n                        s.insert(v[i]);\\n                        if(v[i]==0)\\n                        {\\n                            k=1;\\n                            break;\\n                        }\\n                        q.push(v[i]);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int minDays(int n) {\\n        unordered_set<int>s;\\n        if(n==0)\\n            return 0;\\n        s.insert(n);\\n        s.insert(-1);\\n        queue<int>q;\\n        q.push(n);\\n        int c=0,k=0;\\n        while(q.size())\\n        {\\n            if(k)\\n                break;\\n            c++;\\n            int y=q.size();\\n            while(y--)\\n            {\\n                if(k)\\n                    break;\\n                int d=q.front();\\n                q.pop();\\n                vector<int>v(3,-1);\\n                v[0]=d-1;\\n                if(!(d%2))\\n                    v[1]=d-(d/2);\\n                if(!(d%3))\\n                    v[2]=d-((d/3)*2);\\n                for(int i=0;i<3;i++)\\n                {\\n                    if(!s.count(v[i]))\\n                    {\\n                        s.insert(v[i]);\\n                        if(v[i]==0)\\n                        {\\n                            k=1;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1042531,
                "title": "short-and-simple-faster-than-95-less-memory-than-88",
                "content": "The main idea is that at each step you are either waiting* until `n%2 is 0` or `n%3 is 0`, and from there you are eating 1/2 or 2/3 of the oranges. The minimum number of days is then the number of days spent waiting, plus the minimum number of days for the remaining oranges. We use memoization to get rid of repeat work.\\n\\n```\\nclass Solution:\\n    def min_days(self, n: int) -> int:\\n        if n not in self.mem:\\n            days_til_two = n % 2\\n            days_til_three = n % 3\\n            self.mem[n] = 1 + min(self.min_days((n - days_til_two)/2) + days_til_two,\\n                self.min_days((n - days_til_three)/3) + days_til_three)\\n        return self.mem[n]\\n    \\n    def minDays(self, n: int) -> int:\\n        self.mem = dict()\\n        self.mem[0] = 0\\n        self.mem[1] = 1\\n        return int(self.min_days(n))\\n```\\n            \\n\\t\\t\\t\\n\\\\* By waiting, I mean eating 1 orange per day\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def min_days(self, n: int) -> int:\\n        if n not in self.mem:\\n            days_til_two = n % 2\\n            days_til_three = n % 3\\n            self.mem[n] = 1 + min(self.min_days((n - days_til_two)/2) + days_til_two,\\n                self.min_days((n - days_til_three)/3) + days_til_three)\\n        return self.mem[n]\\n    \\n    def minDays(self, n: int) -> int:\\n        self.mem = dict()\\n        self.mem[0] = 0\\n        self.mem[1] = 1\\n        return int(self.min_days(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936846,
                "title": "straightforward-java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Set<Integer> set = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        set.add(n);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (node == 0) {\\n                    return steps;\\n                }\\n                if (!set.contains(node - 1)) {\\n                    queue.offer(node - 1);\\n                    set.add(node - 1);\\n                } \\n                if (node % 2 == 0 && !set.contains(node / 2)) {\\n                    queue.offer(node / 2);\\n                    set.add(node / 2);\\n                }\\n                if (node % 3 == 0 && !set.contains(node / 3)) {\\n                    queue.offer(node / 3);\\n                    set.add(node / 3);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Set<Integer> set = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        set.add(n);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (node == 0) {\\n                    return steps;\\n                }\\n                if (!set.contains(node - 1)) {\\n                    queue.offer(node - 1);\\n                    set.add(node - 1);\\n                } \\n                if (node % 2 == 0 && !set.contains(node / 2)) {\\n                    queue.offer(node / 2);\\n                    set.add(node / 2);\\n                }\\n                if (node % 3 == 0 && !set.contains(node / 3)) {\\n                    queue.offer(node / 3);\\n                    set.add(node / 3);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872159,
                "title": "python-recursion-with-memorization-dp-with-explanation",
                "content": "Explore dp(n-1) will give TLE\\nWe would want to explore n/2 and n/3 as much as possible\\nOnly in case n is not divisible by 2 or 3 we would consider n-1\\nwe add n%2  and  n%3 to the steps\\nhence n%2 + dp(n//2) and n%3 + dp(n//3)\\n\\n\\'\\'\\'\\n\\n\\tclass Solution(object):\\n\\t\\tdef minDays(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmemo = {} \\n\\t\\t\\tdef dp(n):\\n\\t\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\t\\treturn n\\n\\t\\t\\t\\tif n not in memo:\\n\\t\\t\\t\\t\\tmemo[n] = 1 + min(n%2 + dp(n//2), n%3 + dp(n//3))\\n\\t\\t\\t\\treturn memo[n]\\n\\n\\t\\t\\treturn dp(n)\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef minDays(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmemo = {}",
                "codeTag": "Java"
            },
            {
                "id": 852632,
                "title": "c-iterative-top-down-o-log-2-n-time-o-logn-space-no-recursion-no-dynamic-containers",
                "content": "Imagine a matrix of divisors:\\n```\\n(2^0 * 3^0)     (2^0 * 3^1)     (2^0 * 3^2)     (2^0 * 3^3)    .....\\n(2^1 * 3^0)     (2^1 * 3^1)     (2^1 * 3^2)     (2^1 * 3^3)    .....\\n(2^2 * 3^0)     (2^2 * 3^1)     (2^2 * 3^2)     (2^2 * 3^3)    .....\\n(2^3 * 3^0)     (2^3 * 3^1)     (2^3 * 3^2)     (2^3 * 3^3)    .....\\n    ...             ...             ...             ...\\n```\\nWe always start the iteration with the original value ```n```, which means the divisor is ```1```. That is we start at the top left corner of the matrix. Then, on each step we can divide the current value of ```n``` either by ```2``` (thus adding another power of 2 to the accumulated divisor, i.e. moving one cell down) or by ```3``` (thus adding another power of ```3``` to the accumulated divisor, i.e. moving one cell right).\\n\\nThis might look like every step doubles the number of posible ```n``` values for the next step. But looking at the matrix you can see it\\'s not so bad. Every step increases the set of divisors by one, instead of doubling it:\\n```\\nstep 0    step 1    step 2    step 3    ...\\nstep 1    step 2    step 3    step 4    ...\\nstep 2    step 3    step 4    step 5    ...\\nstep 3    step 4    step 5    step 6    ...\\n  ...       ...       ...       ...\\n```\\n\\nSo it\\'s possible to use a statically allocated sliding \\'window\\' for memorizing the results for the current divisor diagonal and for the next diagonal. And then push that sliding memo down step by step, accumulating the number of odd oranges we have to eat to make the division possible.\\n\\nThe code:\\n```\\nclass Solution\\n{\\npublic:\\n    int minDays(int n)\\n    {\\n        Progress*   current = buffer[0];\\n        Progress*   next = buffer[1];\\n\\n        // First value: n/(2^0 * 3^0)\\n        current[0] = Progress{unsigned(n), 0};\\n        unsigned    count = 1;\\n        unsigned    maxSteps = UINT_MAX;\\n        unsigned    bestSteps = maxSteps;\\n\\n        for (unsigned repeat = 2; repeat > 1;)\\n        {\\n            // current values:  n/(2^(count-1) * 3^0,  n/(2^(count-2) * 3^1),  n/(2^(count-3) * 3^2), ....\\n            // next values:     n/(2^(count+0) * 3^0,  n/(2^(count-1) * 3^1),  n/(2^(count-2) * 3^2), ....\\n            repeat = 0;\\n            next[0] = Progress{0, maxSteps};\\n            for (unsigned i = 0; i < count; ++i)\\n            {\\n                Progress    now = current[i];\\n                repeat |= now.value;\\n                if (now.value == 1)\\n                    bestSteps = min(bestSteps, now.steps + 1);\\n\\n                next[i  ] = Progress{now.value / 2, min(next[i].steps, now.steps + (now.value % 2) + 1)};\\n                next[i+1] = Progress{now.value / 3,                    now.steps + (now.value % 3) + 1 };\\n            }\\n            ++count;\\n            swap(current, next);\\n        }\\n        \\n        return bestSteps;\\n    }\\n\\nprivate:\\n    struct Progress\\n    {\\n        unsigned    value;\\n        unsigned    steps;\\n    };\\n    \\n    constexpr static const unsigned     maxBits = 32;\\n    Progress        buffer[2][maxBits];\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n(2^0 * 3^0)     (2^0 * 3^1)     (2^0 * 3^2)     (2^0 * 3^3)    .....\\n(2^1 * 3^0)     (2^1 * 3^1)     (2^1 * 3^2)     (2^1 * 3^3)    .....\\n(2^2 * 3^0)     (2^2 * 3^1)     (2^2 * 3^2)     (2^2 * 3^3)    .....\\n(2^3 * 3^0)     (2^3 * 3^1)     (2^3 * 3^2)     (2^3 * 3^3)    .....\\n    ...             ...             ...             ...\\n```\n```n```\n```1```\n```n```\n```2```\n```3```\n```3```\n```n```\n```\\nstep 0    step 1    step 2    step 3    ...\\nstep 1    step 2    step 3    step 4    ...\\nstep 2    step 3    step 4    step 5    ...\\nstep 3    step 4    step 5    step 6    ...\\n  ...       ...       ...       ...\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minDays(int n)\\n    {\\n        Progress*   current = buffer[0];\\n        Progress*   next = buffer[1];\\n\\n        // First value: n/(2^0 * 3^0)\\n        current[0] = Progress{unsigned(n), 0};\\n        unsigned    count = 1;\\n        unsigned    maxSteps = UINT_MAX;\\n        unsigned    bestSteps = maxSteps;\\n\\n        for (unsigned repeat = 2; repeat > 1;)\\n        {\\n            // current values:  n/(2^(count-1) * 3^0,  n/(2^(count-2) * 3^1),  n/(2^(count-3) * 3^2), ....\\n            // next values:     n/(2^(count+0) * 3^0,  n/(2^(count-1) * 3^1),  n/(2^(count-2) * 3^2), ....\\n            repeat = 0;\\n            next[0] = Progress{0, maxSteps};\\n            for (unsigned i = 0; i < count; ++i)\\n            {\\n                Progress    now = current[i];\\n                repeat |= now.value;\\n                if (now.value == 1)\\n                    bestSteps = min(bestSteps, now.steps + 1);\\n\\n                next[i  ] = Progress{now.value / 2, min(next[i].steps, now.steps + (now.value % 2) + 1)};\\n                next[i+1] = Progress{now.value / 3,                    now.steps + (now.value % 3) + 1 };\\n            }\\n            ++count;\\n            swap(current, next);\\n        }\\n        \\n        return bestSteps;\\n    }\\n\\nprivate:\\n    struct Progress\\n    {\\n        unsigned    value;\\n        unsigned    steps;\\n    };\\n    \\n    constexpr static const unsigned     maxBits = 32;\\n    Progress        buffer[2][maxBits];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804738,
                "title": "python-3-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \"\"\"\\n        Given n oranges and three options for eating oranges\\n        each day, this program uses dynamic programming to determine\\n        the minimum number of days needed to eat the oranges.\\n        The three options are:\\n            - eat one orange\\n            - eat n/2 oranges if n is even multiple of 2\\n            - eat 2n/3 oranges if n is even multiple of 3\\n\\n        :param n: number of oranges\\n        :type n: int\\n        :return: minimum days needed to eat n oranges\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Dynamic programming (dp_dict) maps number of oranges\\n          remaining to number of days elapsed. It is implemented\\n          as a hash table to accommodate large values of n. An\\n          array of size large n causes memory limit exceeded.\\n        - The queue contains the number of oranges remaining\\n          based on dynamic programming. It is initialized to\\n          a single entry of n.\\n        \"\"\"\\n        dp_dict = {n: 0}\\n        queue = [n]\\n\\n        \"\"\"\\n        Dynamic Programming\\n        - Eat one orange per day until remaining oranges are\\n          a multiple of 2, then eat 1/2 of the oranges.\\n        - Eat one orange per day until remaining oranges are\\n          a multiple of 3, then eat 2/3 of the oranges.\\n        \"\"\"\\n        while queue:\\n            num = queue.pop( 0 )\\n            new_num = num // 2\\n            if new_num:\\n                new_dp = dp_dict[num] + 1 + num % 2\\n            else:\\n                new_dp = dp_dict[num] + num % 2\\n            if new_num not in dp_dict or new_dp < dp_dict[new_num]:\\n                dp_dict[new_num] = new_dp\\n                if new_num and new_num not in queue:\\n                    queue.append( new_num )\\n            new_num = num // 3\\n            if new_num:\\n                new_dp = dp_dict[num] + 1 + num % 3\\n            else:\\n                new_dp = dp_dict[num] + num % 3\\n            if new_num not in dp_dict or new_dp < dp_dict[new_num]:\\n                dp_dict[new_num] = new_dp\\n                if new_num and new_num not in queue:\\n                    queue.append( new_num )\\n        return dp_dict[0]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \"\"\"\\n        Given n oranges and three options for eating oranges\\n        each day, this program uses dynamic programming to determine\\n        the minimum number of days needed to eat the oranges.\\n        The three options are:\\n            - eat one orange\\n            - eat n/2 oranges if n is even multiple of 2\\n            - eat 2n/3 oranges if n is even multiple of 3\\n\\n        :param n: number of oranges\\n        :type n: int\\n        :return: minimum days needed to eat n oranges\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Dynamic programming (dp_dict) maps number of oranges\\n          remaining to number of days elapsed. It is implemented\\n          as a hash table to accommodate large values of n. An\\n          array of size large n causes memory limit exceeded.\\n        - The queue contains the number of oranges remaining\\n          based on dynamic programming. It is initialized to\\n          a single entry of n.\\n        \"\"\"\\n        dp_dict = {n: 0}\\n        queue = [n]\\n\\n        \"\"\"\\n        Dynamic Programming\\n        - Eat one orange per day until remaining oranges are\\n          a multiple of 2, then eat 1/2 of the oranges.\\n        - Eat one orange per day until remaining oranges are\\n          a multiple of 3, then eat 2/3 of the oranges.\\n        \"\"\"\\n        while queue:\\n            num = queue.pop( 0 )\\n            new_num = num // 2\\n            if new_num:\\n                new_dp = dp_dict[num] + 1 + num % 2\\n            else:\\n                new_dp = dp_dict[num] + num % 2\\n            if new_num not in dp_dict or new_dp < dp_dict[new_num]:\\n                dp_dict[new_num] = new_dp\\n                if new_num and new_num not in queue:\\n                    queue.append( new_num )\\n            new_num = num // 3\\n            if new_num:\\n                new_dp = dp_dict[num] + 1 + num % 3\\n            else:\\n                new_dp = dp_dict[num] + num % 3\\n            if new_num not in dp_dict or new_dp < dp_dict[new_num]:\\n                dp_dict[new_num] = new_dp\\n                if new_num and new_num not in queue:\\n                    queue.append( new_num )\\n        return dp_dict[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804111,
                "title": "java-dp-top-down",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, 0);\\n        hm.put(1, 1);\\n        hm.put(2, 2);\\n        return dfs(n, hm);\\n    }\\n    \\n    public int dfs(int n, HashMap<Integer, Integer> map) {\\n        if(n <= 1) {\\n            return n;\\n        }\\n        \\n        if(map.containsKey(n)) {\\n            return map.get(n);\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        if(n % 2 == 0) {\\n            res = Math.min(res, 1+dfs(n/2, map));\\n        }\\n        \\n        if(n % 3 == 0) {\\n            res = Math.min(res, 1+dfs(n/3, map));\\n        }\\n        if((n - 1) % 2 == 0 || (n-1) % 3 == 0) {\\n            res = Math.min(res, 1+dfs(n-1, map));\\n        } else if( (n-2) % 3 == 0) {\\n            res = Math.min(res, 2+dfs(n-2, map));\\n        }\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        hm.put(0, 0);\\n        hm.put(1, 1);\\n        hm.put(2, 2);\\n        return dfs(n, hm);\\n    }\\n    \\n    public int dfs(int n, HashMap<Integer, Integer> map) {\\n        if(n <= 1) {\\n            return n;\\n        }\\n        \\n        if(map.containsKey(n)) {\\n            return map.get(n);\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        if(n % 2 == 0) {\\n            res = Math.min(res, 1+dfs(n/2, map));\\n        }\\n        \\n        if(n % 3 == 0) {\\n            res = Math.min(res, 1+dfs(n/3, map));\\n        }\\n        if((n - 1) % 2 == 0 || (n-1) % 3 == 0) {\\n            res = Math.min(res, 1+dfs(n-1, map));\\n        } else if( (n-2) % 3 == 0) {\\n            res = Math.min(res, 2+dfs(n-2, map));\\n        }\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799322,
                "title": "c-memotization-simple-dp",
                "content": "#define ll long long int\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    long long int ansit(long long int n){\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(mp.count(n)>0){\\n            return mp[n];\\n        }\\n      // cout<<n<<endl;\\n        ll a2=INT_MAX;\\n       \\n            a2=1+(n%3)+ansit(n/3);\\n        \\n            ll a1=1+(n%2)+ansit(n/2);\\n        return mp[n]=min(a1,a2);\\n        \\n        \\n    }\\n    int minDays(int n) {\\n        return ansit(n);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    long long int ansit(long long int n){\\n        if(n<=0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 796319,
                "title": "python-easy-understand",
                "content": "\"\"\"\\n\\n\\t\\tif n == 0:\\n\\t\\t\\treturn 0\\n        \\n        current = set([n])\\n        level = 0 \\n        while True:\\n            level += 1 \\n            temp = set()\\n            for num in current:\\n                if num == 1:\\n                    return level \\n                if num % 2 == 0:\\n                    temp.add(num//2)\\n                if num % 3 == 0:\\n                    temp.add(num//3)\\n                temp.add(num-1)\\n                \\n            current = temp \\n\\t\\t\\t\"\"\"\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "\"\"\"\\n\\n\\t\\tif n == 0:\\n\\t\\t\\treturn 0\\n        \\n        current = set([n])\\n        level = 0 \\n        while True:\\n            level += 1 \\n            temp = set()\\n            for num in current:\\n                if num == 1:\\n                    return level \\n                if num % 2 == 0:\\n                    temp.add(num//2)\\n                if num % 3 == 0:\\n                    temp.add(num//3)\\n                temp.add(num-1)\\n                \\n            current = temp \\n\\t\\t\\t\"\"\"\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 795971,
                "title": "python-recursion-with-memory-100-and-100-no-lru-cache",
                "content": "The intuitive idea and proof of the algorithm is clearly explained in [this post](https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794088/PythonGolang-Intuitive-solution-with-Proof). \\nWithout using lru_cache(maybe you want to or interviewer may ask you to), here is the BFS-like implementation. It is not exactly BFS because not every step requires one day, instead it may requires orange%2+1 or orange%3+1 days. So we could not stop when we traverse to the end for the first time. \\n\\nThe visited dictionary is the key to reduce time complexity. Whenever the days required for this path to have i orange left is larger than or equal to the previous path, it could early stop, since the optimal solution would not consist this path. \\n\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        # bfs like. \\n        queue = collections.deque([(n,0)])\\n        visited = collections.defaultdict(lambda:float(\"inf\"))\\n        res = n\\n        \\n        while(queue):\\n            orange,day = queue.popleft()\\n            if(visited[orange]<=day):\\n                continue\\n            visited[orange] = day\\n            if(orange<3):\\n                res = min(res,day+orange)\\n                continue\\n            # reduce to even, then action 2\\n            temp = orange%2\\n            queue.append(((orange-temp)//2,1+temp+day))\\n            # reduce to multiple of 3, then action 3\\n            temp = orange%3\\n            queue.append(((orange-temp)//3,1+temp+day))\\n            \\n                         \\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        # bfs like. \\n        queue = collections.deque([(n,0)])\\n        visited = collections.defaultdict(lambda:float(\"inf\"))\\n        res = n\\n        \\n        while(queue):\\n            orange,day = queue.popleft()\\n            if(visited[orange]<=day):\\n                continue\\n            visited[orange] = day\\n            if(orange<3):\\n                res = min(res,day+orange)\\n                continue\\n            # reduce to even, then action 2\\n            temp = orange%2\\n            queue.append(((orange-temp)//2,1+temp+day))\\n            # reduce to multiple of 3, then action 3\\n            temp = orange%3\\n            queue.append(((orange-temp)//3,1+temp+day))\\n            \\n                         \\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795672,
                "title": "java-solution-using-bfs",
                "content": "Since we need to find the min number of days to eat N oranges, we can use BFS to store the number of oranges left to eat. As soon as number of oranges reaches 0, we return the number of days it took to eat all the oranges. We also use a set to keep track of already seen numbers so that we don\\'t process them again.\\n\\nSince we want to look at all possible combinations in order to find the min number of days, we enqueue all 3 possibilities:\\n- `n - 2n/3`\\n- `n - n/2`\\n- `n - 1`\\n```\\nclass Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offerLast(n);\\n        int steps = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            steps++;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int num = q.pollFirst();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if num is already seen, continue to next iteration\\n                if (seen.contains(num)) {\\n                    continue;\\n                }\\n                seen.add(num);\\n                \\n\\t\\t\\t\\t// if number of remaining oranges has reached 0\\n                if (num - 1 == 0) {\\n                    return steps;\\n                }\\n                \\n\\t\\t\\t\\t// if num is divisible by 3\\n                if ((num % 3) == 0) {\\n                    q.offerLast(num / 3);\\n                }\\n                \\n\\t\\t\\t\\t// if num is divisible by 2\\n                if ((num % 2) == 0) {\\n                    q.offerLast(num / 2);\\n                }\\n                \\n\\t\\t\\t\\t// if only 1 orange is eaten\\n                q.offerLast(num - 1);\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offerLast(n);\\n        int steps = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            steps++;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int num = q.pollFirst();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if num is already seen, continue to next iteration\\n                if (seen.contains(num)) {\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 794743,
                "title": "java-simple-dfs-with-dp-100-time-complexity-passed",
                "content": "```\\nclass Solution {\\n    static HashMap<Integer,Integer> has=new HashMap<>();\\n    static int maxx(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(has.get(n)!=null){return has.get(n);}\\n        if(n%2==0 && n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n/2)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%2==0){\\n            int aa=Math.min(maxx(n/2)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else{\\n            int aa=maxx(n-1)+1;\\n            has.put(n,aa);\\n            return aa;\\n        }\\n    }\\n    public int minDays(int n) {\\n        return maxx(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static HashMap<Integer,Integer> has=new HashMap<>();\\n    static int maxx(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(has.get(n)!=null){return has.get(n);}\\n        if(n%2==0 && n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n/2)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%2==0){\\n            int aa=Math.min(maxx(n/2)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else if(n%3==0){\\n            int aa=Math.min(maxx(n/3)+1,maxx(n-1)+1);\\n            has.put(n,aa);\\n            return aa;\\n        }else{\\n            int aa=maxx(n-1)+1;\\n            has.put(n,aa);\\n            return aa;\\n        }\\n    }\\n    public int minDays(int n) {\\n        return maxx(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794457,
                "title": "getting-runtime-error-please-help",
                "content": "```\\nclass Solution {\\npublic:\\n    int go(int curr,unordered_map<int,int>& dp){\\n        if(curr==0)\\n            return dp[curr]=0;\\n        if(dp.find(curr)!=dp.end())\\n            return dp[curr];\\n        int ans=INT_MAX;\\n        if(curr%2==0)\\n            ans=min(ans,1+go(curr/2,dp));\\n        if(curr%3==0)\\n            ans=min(ans,1+go(curr/3,dp));\\n        ans=min(ans,1+go(curr-1,dp));\\n        return dp[curr]=ans;\\n    }\\n    int minDays(int n) {\\n        unordered_map<int,int>dp;\\n        return go(n,dp);\\n    }\\n};\\n\\n```\\n\\nActual solution\\n```\\n\\nclass Solution {\\npublic:\\nint go(int curr,unordered_map<int,int>& dp, int d){\\nif(d > 100)\\nreturn INT_MAX-1000;\\nif(curr==0)\\nreturn dp[curr]=0;\\nif(dp.find(curr)!=dp.end())\\nreturn dp[curr];\\nint ans=INT_MAX;\\nif(curr%3==0)\\nans=min(ans,1+go(curr/3,dp, d+1));\\nif(curr%2==0)\\nans=min(ans,1+go(curr/2,dp, d+1));\\nans=min(ans,1+go(curr-1,dp, d+1));\\nreturn dp[curr]=ans;\\n}\\nint minDays(int n) {\\nunordered_map<int,int>dp;\\nreturn go(n,dp, 0);\\n}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int go(int curr,unordered_map<int,int>& dp){\\n        if(curr==0)\\n            return dp[curr]=0;\\n        if(dp.find(curr)!=dp.end())\\n            return dp[curr];\\n        int ans=INT_MAX;\\n        if(curr%2==0)\\n            ans=min(ans,1+go(curr/2,dp));\\n        if(curr%3==0)\\n            ans=min(ans,1+go(curr/3,dp));\\n        ans=min(ans,1+go(curr-1,dp));\\n        return dp[curr]=ans;\\n    }\\n    int minDays(int n) {\\n        unordered_map<int,int>dp;\\n        return go(n,dp);\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\nint go(int curr,unordered_map<int,int>& dp, int d){\\nif(d > 100)\\nreturn INT_MAX-1000;\\nif(curr==0)\\nreturn dp[curr]=0;\\nif(dp.find(curr)!=dp.end())\\nreturn dp[curr];\\nint ans=INT_MAX;\\nif(curr%3==0)\\nans=min(ans,1+go(curr/3,dp, d+1));\\nif(curr%2==0)\\nans=min(ans,1+go(curr/2,dp, d+1));\\nans=min(ans,1+go(curr-1,dp, d+1));\\nreturn dp[curr]=ans;\\n}\\nint minDays(int n) {\\nunordered_map<int,int>dp;\\nreturn go(n,dp, 0);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794396,
                "title": "why-does-a-bfs-from-0-to-n-not-work",
                "content": "I saw several ppl posting BFS solutions searching from n to 0. Just want to know why going the opposite direction gets TLE.\\n\\t\\n\\tpublic int minDays(int n) {\\n\\t\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\t\\tqueue.offer(0);\\n\\t\\t\\tHashSet<Integer> visited = new HashSet<>();\\n\\t\\t\\tvisited.add(0);\\n\\t\\t\\tint res = 1;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tint count = queue.size();\\n\\t\\t\\t\\tfor (int k = 0; k < count; k++) {\\n\\t\\t\\t\\t\\tint cur = queue.poll();\\n\\t\\t\\t\\t\\tint a = cur * 3;\\n\\t\\t\\t\\t\\tif (a <= n && visited.add(a)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(a);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint b = cur * 2;\\n\\t\\t\\t\\t\\tif (b <= n && visited.add(b)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(b);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint c = cur + 1;\\n\\t\\t\\t\\t\\tif (c <= n && visited.add(c)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (a == n || b == n || c == n) return res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "I saw several ppl posting BFS solutions searching from n to 0. Just want to know why going the opposite direction gets TLE.\\n\\t\\n\\tpublic int minDays(int n) {\\n\\t\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\t\\tqueue.offer(0);\\n\\t\\t\\tHashSet<Integer> visited = new HashSet<>();\\n\\t\\t\\tvisited.add(0);\\n\\t\\t\\tint res = 1;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tint count = queue.size();\\n\\t\\t\\t\\tfor (int k = 0; k < count; k++) {\\n\\t\\t\\t\\t\\tint cur = queue.poll();\\n\\t\\t\\t\\t\\tint a = cur * 3;\\n\\t\\t\\t\\t\\tif (a <= n && visited.add(a)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(a);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint b = cur * 2;\\n\\t\\t\\t\\t\\tif (b <= n && visited.add(b)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(b);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint c = cur + 1;\\n\\t\\t\\t\\t\\tif (c <= n && visited.add(c)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (a == n || b == n || c == n) return res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 794382,
                "title": "c-dynamic-programming-solution",
                "content": "```csharp\\npublic int MinDays(int n)\\n{\\n\\tDictionary<int, int> cache = new Dictionary<int, int>();\\n\\tint days = helper(n, cache);\\n\\treturn days;\\n}\\n\\nprivate int helper(int n, Dictionary<int, int> cache)\\n{\\n\\tif (n < 3)\\n\\t{\\n\\t\\treturn n;\\n\\t}\\n\\n\\tif (cache.ContainsKey(n))\\n\\t{\\n\\t\\treturn cache[n];\\n\\t}\\n\\n\\tint days2 = int.MaxValue;\\n\\tint days3 = int.MaxValue;\\n\\n\\tif (n % 2 == 0)\\n\\t{\\n\\t\\tdays2 = 1 + helper(n / 2, cache);\\n\\t}\\n\\n\\tif (n % 3 == 0)\\n\\t{\\n\\t\\tdays3 = 1 + helper(n - 2 * (n / 3), cache);\\n\\t}\\n\\n\\tint min = Math.Min(days2, days3);\\n\\tif ((n - 1) % 2 == 0 || (n - 1) % 3 == 0 || (n - 2) % 3 == 0)\\n\\t{\\n\\t\\tmin = Math.Min(min, 1 + helper(n - 1, cache));\\n\\t}\\n\\n\\tcache.Add(n, min);\\n\\treturn min;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinDays(int n)\\n{\\n\\tDictionary<int, int> cache = new Dictionary<int, int>();\\n\\tint days = helper(n, cache);\\n\\treturn days;\\n}\\n\\nprivate int helper(int n, Dictionary<int, int> cache)\\n{\\n\\tif (n < 3)\\n\\t{\\n\\t\\treturn n;\\n\\t}\\n\\n\\tif (cache.ContainsKey(n))\\n\\t{\\n\\t\\treturn cache[n];\\n\\t}\\n\\n\\tint days2 = int.MaxValue;\\n\\tint days3 = int.MaxValue;\\n\\n\\tif (n % 2 == 0)\\n\\t{\\n\\t\\tdays2 = 1 + helper(n / 2, cache);\\n\\t}\\n\\n\\tif (n % 3 == 0)\\n\\t{\\n\\t\\tdays3 = 1 + helper(n - 2 * (n / 3), cache);\\n\\t}\\n\\n\\tint min = Math.Min(days2, days3);\\n\\tif ((n - 1) % 2 == 0 || (n - 1) % 3 == 0 || (n - 2) % 3 == 0)\\n\\t{\\n\\t\\tmin = Math.Min(min, 1 + helper(n - 1, cache));\\n\\t}\\n\\n\\tcache.Add(n, min);\\n\\treturn min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794378,
                "title": "clean-c-code-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>mp;\\n    long solve(int n)\\n    {\\n        if(n<=2)\\n            return n;\\n        if(mp.find(n)!=mp.end())\\n            return mp[n];\\n        \\n        mp[n] = 1 + min(n%2 + solve(n/2), n%3 + solve(n/3));\\n        return mp[n];\\n\\n    }\\n    int minDays(int n) { \\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>mp;\\n    long solve(int n)\\n    {\\n        if(n<=2)\\n            return n;\\n        if(mp.find(n)!=mp.end())\\n            return mp[n];\\n        \\n        mp[n] = 1 + min(n%2 + solve(n/2), n%3 + solve(n/3));\\n        return mp[n];\\n\\n    }\\n    int minDays(int n) { \\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794356,
                "title": "rust-recursive-with-memoization",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        fn helper(n: i32, dp: &mut std::collections::HashMap<i32,i32>) -> i32 {\\n            if n <= 1 { return n; } \\n            if dp.contains_key(&n) { return dp[&n]; }\\n            let res = 1 + std::cmp::min(n%2 + helper(n/2, dp), n%3 + helper(n/3, dp));\\n            dp.insert(n, res);\\n            res\\n        }\\n        helper(n, &mut std::collections::HashMap::new())\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        fn helper(n: i32, dp: &mut std::collections::HashMap<i32,i32>) -> i32 {\\n            if n <= 1 { return n; } \\n            if dp.contains_key(&n) { return dp[&n]; }\\n            let res = 1 + std::cmp::min(n%2 + helper(n/2, dp), n%3 + helper(n/3, dp));\\n            dp.insert(n, res);\\n            res\\n        }\\n        helper(n, &mut std::collections::HashMap::new())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794320,
                "title": "java-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        return helper(map, n);\\n    }\\n    \\n    int helper(HashMap<Integer, Integer> map, int n){\\n        \\n        if(n <= 1) return n;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int minOperations = n;\\n        // n is either divisible by or not so call for n/2 and n-1         \\n        if(n % 2 == 0)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n / 2));\\n        else\\n            minOperations = Math.min(minOperations, 1 + helper(map, n-1));\\n        \\n        // If a number is divided by 3 then remainder is (0, 1, 2) so we\\'ll try to make a number divisible by 3 with minimum opertions\\n        // For remainder 0 directly call for n/3\\n        if(n % 3 == 0)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n / 3));\\n        // For remainder 1 call for n-1\\n        else if(n % 3 == 1)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n-1));\\n        // else call for n-2\\n        else\\n            minOperations = Math.min(minOperations, 2 + helper(map, n-2));\\n        \\n        map.put(n, minOperations);\\n        return minOperations;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        return helper(map, n);\\n    }\\n    \\n    int helper(HashMap<Integer, Integer> map, int n){\\n        \\n        if(n <= 1) return n;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int minOperations = n;\\n        // n is either divisible by or not so call for n/2 and n-1         \\n        if(n % 2 == 0)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n / 2));\\n        else\\n            minOperations = Math.min(minOperations, 1 + helper(map, n-1));\\n        \\n        // If a number is divided by 3 then remainder is (0, 1, 2) so we\\'ll try to make a number divisible by 3 with minimum opertions\\n        // For remainder 0 directly call for n/3\\n        if(n % 3 == 0)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n / 3));\\n        // For remainder 1 call for n-1\\n        else if(n % 3 == 1)\\n            minOperations = Math.min(minOperations, 1 + helper(map, n-1));\\n        // else call for n-2\\n        else\\n            minOperations = Math.min(minOperations, 2 + helper(map, n-2));\\n        \\n        map.put(n, minOperations);\\n        return minOperations;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794278,
                "title": "c-dp-with-map-easy-to-code-with-explanation",
                "content": "x = {2, 3}\\nIf the number can be divided by x, move to n/x, else move to the nearest number divisible by x.\\nTake the best of those options ;)\\n\\n```\\nclass Solution {\\n    map<int, int> dp;\\npublic:\\n    int minDays(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2 || n == 3) return 2;\\n        if(dp.count(n))\\n            return dp[n];\\n        int op1 = (n%2==0 ? minDays(n/2) + 1 : minDays(n - n%2)) + n%2;\\n        int op2 = (n%3==0 ? minDays(n/3) + 1 : minDays(n - n%3) + n%3);\\n        return dp[n] = min(op1, op2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<int, int> dp;\\npublic:\\n    int minDays(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2 || n == 3) return 2;\\n        if(dp.count(n))\\n            return dp[n];\\n        int op1 = (n%2==0 ? minDays(n/2) + 1 : minDays(n - n%2)) + n%2;\\n        int op2 = (n%3==0 ? minDays(n/3) + 1 : minDays(n - n%3) + n%3);\\n        return dp[n] = min(op1, op2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794263,
                "title": "python3-bfs-solution",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dic = {}\\n        bfs_queue = deque([[n, 0]])\\n        while bfs_queue:\\n            # print(bfs_queue)\\n            # print(dic)\\n            pair = bfs_queue.popleft()\\n            number = pair[0]\\n            times = pair[1]\\n            # found\\n            if number == 1:\\n                return times + 1\\n            if number not in dic:\\n                dic[number] = times\\n                times += 1\\n                if number % 3 == 0:\\n                    bfs_queue.append([number // 3, times])\\n                if number % 2 == 0:\\n                    bfs_queue.append([number // 2, times])\\n                bfs_queue.append([number - 1, times])\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dic = {}\\n        bfs_queue = deque([[n, 0]])\\n        while bfs_queue:\\n            # print(bfs_queue)\\n            # print(dic)\\n            pair = bfs_queue.popleft()\\n            number = pair[0]\\n            times = pair[1]\\n            # found\\n            if number == 1:\\n                return times + 1\\n            if number not in dic:\\n                dic[number] = times\\n                times += 1\\n                if number % 3 == 0:\\n                    bfs_queue.append([number // 3, times])\\n                if number % 2 == 0:\\n                    bfs_queue.append([number // 2, times])\\n                bfs_queue.append([number - 1, times])\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794250,
                "title": "c-bfs-with-priority-queue-unordered-map",
                "content": "Priority queue used to process first the elements with minimum steps.\\nunordered_map used to keep the best answer for a number n and insert it in the pq only if improves the result\\n\\n```\\n    int minDays(int n) {\\n        priority_queue<vector<int>> p;\\n        p.push({0, n});\\n        unordered_map<int, int> mp;\\n        while (!p.empty()) {\\n            vector<int> t = p.top();\\n            p.pop();\\n            \\n            if (t[1] - 1 == 0) {\\n                return (t[0] - 1) * -1;\\n            }\\n\\t\\t\\t\\n            if (mp.find(t[1] / 3) == mp.end() || mp[t[1] / 3] < t[0] - (t[1] % 3) - 1) {\\n                p.push({t[0] - (t[1] % 3) - 1, t[1] / 3});\\n                mp[t[1] / 3] = t[0] - (t[1] % 3) - 1;\\n            }\\n            if (mp.find(t[1] / 2) == mp.end() || mp[t[1] / 2] < t[0] - (t[1] % 2) - 1) {\\n                p.push({t[0] - (t[1] % 2) - 1, t[1] / 2});\\n                mp[t[1] / 2] = t[0] - (t[1] % 2) - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minDays(int n) {\\n        priority_queue<vector<int>> p;\\n        p.push({0, n});\\n        unordered_map<int, int> mp;\\n        while (!p.empty()) {\\n            vector<int> t = p.top();\\n            p.pop();\\n            \\n            if (t[1] - 1 == 0) {\\n                return (t[0] - 1) * -1;\\n            }\\n\\t\\t\\t\\n            if (mp.find(t[1] / 3) == mp.end() || mp[t[1] / 3] < t[0] - (t[1] % 3) - 1) {\\n                p.push({t[0] - (t[1] % 3) - 1, t[1] / 3});\\n                mp[t[1] / 3] = t[0] - (t[1] % 3) - 1;\\n            }\\n            if (mp.find(t[1] / 2) == mp.end() || mp[t[1] / 2] < t[0] - (t[1] % 2) - 1) {\\n                p.push({t[0] - (t[1] % 2) - 1, t[1] / 2});\\n                mp[t[1] / 2] = t[0] - (t[1] % 2) - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794221,
                "title": "bfs-will-be-better-than-dp",
                "content": "Refer to this discussion https://leetcode.com/discuss/interview-question/538568/Google-or-Onsite-or-Min-operations-to-reduce-number-to-1,\\nBFS will expand smaller search space than DP does.\\n```\\nimport collections\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        queue = collections.deque([n])\\n        days = 1\\n        visited = set()\\n        while queue:\\n            for _ in range(len(queue)):\\n                oranges = queue.popleft()\\n                if oranges == 1: return days\\n                if oranges in visited: continue\\n                visited.add(oranges)\\n                candidate = []\\n                if oranges % 3 == 0:\\n                    candidate.append(oranges // 3)\\n                if oranges % 2 == 0:\\n                    candidate.append(oranges // 2)\\n                candidate.append(oranges - 1)\\n                queue += candidate\\n            days += 1\\n        return days\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        queue = collections.deque([n])\\n        days = 1\\n        visited = set()\\n        while queue:\\n            for _ in range(len(queue)):\\n                oranges = queue.popleft()\\n                if oranges == 1: return days\\n                if oranges in visited: continue\\n                visited.add(oranges)\\n                candidate = []\\n                if oranges % 3 == 0:\\n                    candidate.append(oranges // 3)\\n                if oranges % 2 == 0:\\n                    candidate.append(oranges // 2)\\n                candidate.append(oranges - 1)\\n                queue += candidate\\n            days += 1\\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794161,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n == 1){\\n            return 1;\\n        }else if(n <= 3){\\n            return 2;\\n        }else if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int res = 0;\\n        if(n % 6 == 0){\\n            res = 1 + Math.min(minDays(n / 2) , minDays(n - (2 * (n / 3))));\\n        }else if(n % 3 == 0){\\n            res = 1 + Math.min(minDays(n - (2 * (n / 3))), minDays(n - 1));\\n        }else if(n % 2 == 0){\\n            res =  1 + Math.min(minDays(n / 2), minDays(n - 1));\\n        }else{\\n            res =  1 + minDays(n - 1);\\n        }\\n        map.put(n, res);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n == 1){\\n            return 1;\\n        }else if(n <= 3){\\n            return 2;\\n        }else if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int res = 0;\\n        if(n % 6 == 0){\\n            res = 1 + Math.min(minDays(n / 2) , minDays(n - (2 * (n / 3))));\\n        }else if(n % 3 == 0){\\n            res = 1 + Math.min(minDays(n - (2 * (n / 3))), minDays(n - 1));\\n        }else if(n % 2 == 0){\\n            res =  1 + Math.min(minDays(n / 2), minDays(n - 1));\\n        }else{\\n            res =  1 + minDays(n - 1);\\n        }\\n        map.put(n, res);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794157,
                "title": "faced-memory-limit-exceeded-with-the-below-because-of-10-9",
                "content": "\\tpublic int minDays(int n) {\\n     int dp[] = new int[n + 1];\\n\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] =0;\\n        dp[1] = 1;\\n        if(n == 1) {\\n            return 1;\\n        }\\n        for(int i = 2; i<=n; i++) {\\n            if(i%2 ==0 ) {\\n                dp[i] = Math.min(dp[i/2] + 1, dp[i-1] + 1);\\n            }\\n           if (i % 3 == 0) {\\n                    dp[i] = Math.min(dp[i - ( 2 * (i) / 3)] + 1, dp[i - 1] + 1);\\n                } \\n            \\n            dp[i] = Math.min(dp[i], dp[i-1] + 1);\\n        }\\n        return dp[n];\\n\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int minDays(int n) {\\n     int dp[] = new int[n + 1];\\n\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] =0;\\n        dp[1] = 1;\\n        if(n == 1) {\\n            return 1;\\n        }\\n        for(int i = 2; i<=n; i++) {\\n            if(i%2 ==0 ) {\\n                dp[i] = Math.min(dp[i/2] + 1, dp[i-1] + 1);\\n            }\\n           if (i % 3 == 0) {\\n                    dp[i] = Math.min(dp[i - ( 2 * (i) / 3)] + 1, dp[i - 1] + 1);\\n                } \\n            \\n            dp[i] = Math.min(dp[i], dp[i-1] + 1);\\n        }\\n        return dp[n];\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 794146,
                "title": "the-key-is-when-to-check-n-1",
                "content": "only when (n-1) could improve, otherwise don\\'t bother.\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        all[1] = 1;\\n        all[2] = 2;\\n        all[3] = 2;\\n        return get(n);\\n    }\\n    \\n    int get(int n ) {\\n    //    cout<<n<<endl;\\n        if(all.count(n))\\n            return all[n];\\n        \\n        int res = n;\\n        \\n        if(n%3 == 0) {\\n            res = min(res, 1 + get(n/3));\\n        }  \\n        \\n        if (n%2 == 0) {\\n            res = min(res, 1 + get(n/2));\\n        }\\n        \\n        if(n%2 || n%3)\\n            res = min(res, 1 + get(n-1));\\n        return all[n] = res;\\n    }\\n    \\n    unordered_map<int, int> all;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        all[1] = 1;\\n        all[2] = 2;\\n        all[3] = 2;\\n        return get(n);\\n    }\\n    \\n    int get(int n ) {\\n    //    cout<<n<<endl;\\n        if(all.count(n))\\n            return all[n];\\n        \\n        int res = n;\\n        \\n        if(n%3 == 0) {\\n            res = min(res, 1 + get(n/3));\\n        }  \\n        \\n        if (n%2 == 0) {\\n            res = min(res, 1 + get(n/2));\\n        }\\n        \\n        if(n%2 || n%3)\\n            res = min(res, 1 + get(n-1));\\n        return all[n] = res;\\n    }\\n    \\n    unordered_map<int, int> all;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 794145,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        queue.add(n);\\n        Set<Integer> visited = new HashSet<>();\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int a = queue.remove();\\n                if(a == 0) return level;\\n                if(!visited.contains(a-1)){\\n                    queue.addLast(a-1);\\n                    visited.add(a-1);\\n                }\\n                if(a%2 == 0 && !visited.contains(a/2)){\\n                    int s = a- a/2;\\n                    queue.addLast(s);\\n                    visited.add(s);\\n                }\\n                if(a%3 == 0){\\n                    int s = a - 2*(a/3);\\n                    if(!visited.contains(s)){\\n                        queue.addLast(s);\\n                        visited.add(s);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        queue.add(n);\\n        Set<Integer> visited = new HashSet<>();\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                int a = queue.remove();\\n                if(a == 0) return level;\\n                if(!visited.contains(a-1)){\\n                    queue.addLast(a-1);\\n                    visited.add(a-1);\\n                }\\n                if(a%2 == 0 && !visited.contains(a/2)){\\n                    int s = a- a/2;\\n                    queue.addLast(s);\\n                    visited.add(s);\\n                }\\n                if(a%3 == 0){\\n                    int s = a - 2*(a/3);\\n                    if(!visited.contains(s)){\\n                        queue.addLast(s);\\n                        visited.add(s);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794114,
                "title": "java-easy-bfs-solution-with-explanation",
                "content": "```\\n/*\\nEasy BFS Solution: \\nAvoid DFS, it might result in Stack Overflow Error.\\n*/\\nclass Solution {\\n    public int minDays(int n) {\\n        Queue<Long> q=new LinkedList<>();\\n        q.add((long)n);        \\n        long step=0l,ll,size;        \\n        HashSet<Long>hset=new HashSet<>();// to keep track of the elements already added.\\n        while(q.size()>0){\\n            \\n            size=q.size(); \\n            \\n            // inside the following loop every number is reached in the same number of steps.\\n            while(size-->0){\\n                ll=q.poll();\\n                \\n                // if(ll==0)\\n                //     return (int)step; // no more step is required.\\n                \\n                if(ll==1)\\n                    return (int)(step+1l); // one more step is required.\\n                                \\n                if(ll%3==0&&!hset.contains(ll/3l)){// ll is divisible by 3, and ll/3 is not previously added, then we add ll/3.\\n                    hset.add(ll/3l);\\n                    q.offer(ll/3l);\\n                }\\n                \\n                if(ll%2==0&&!hset.contains(ll/2l)){// ll is divisible by 2, and ll/2 is not previously added, then we add ll/2.\\n                    hset.add(ll/2l);\\n                    q.offer(ll/2l);\\n                }\\n                \\n                if(!hset.contains(ll-1l)){ // ll-1 is not previously added, then we add ll-1.\\n                    hset.add(ll-1l);\\n                    q.offer(ll-1l);\\n                }\\n                \\n            }\\n            \\n            step++; // increment step for next iteration of the entire loop.\\n        }\\n        return (int)step;\\n    }\\n}\\n```\\nThanks for reading. Please share and upvote.",
                "solutionTags": [],
                "code": "```\\n/*\\nEasy BFS Solution: \\nAvoid DFS, it might result in Stack Overflow Error.\\n*/\\nclass Solution {\\n    public int minDays(int n) {\\n        Queue<Long> q=new LinkedList<>();\\n        q.add((long)n);        \\n        long step=0l,ll,size;        \\n        HashSet<Long>hset=new HashSet<>();// to keep track of the elements already added.\\n        while(q.size()>0){\\n            \\n            size=q.size(); \\n            \\n            // inside the following loop every number is reached in the same number of steps.\\n            while(size-->0){\\n                ll=q.poll();\\n                \\n                // if(ll==0)\\n                //     return (int)step; // no more step is required.\\n                \\n                if(ll==1)\\n                    return (int)(step+1l); // one more step is required.\\n                                \\n                if(ll%3==0&&!hset.contains(ll/3l)){// ll is divisible by 3, and ll/3 is not previously added, then we add ll/3.\\n                    hset.add(ll/3l);\\n                    q.offer(ll/3l);\\n                }\\n                \\n                if(ll%2==0&&!hset.contains(ll/2l)){// ll is divisible by 2, and ll/2 is not previously added, then we add ll/2.\\n                    hset.add(ll/2l);\\n                    q.offer(ll/2l);\\n                }\\n                \\n                if(!hset.contains(ll-1l)){ // ll-1 is not previously added, then we add ll-1.\\n                    hset.add(ll-1l);\\n                    q.offer(ll-1l);\\n                }\\n                \\n            }\\n            \\n            step++; // increment step for next iteration of the entire loop.\\n        }\\n        return (int)step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794074,
                "title": "avoid-stack-overflow-of-recursive-dp-use-bfs-to-find-the-shortest-path",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        queue<pair<int, int>> q;\\n        q.emplace(n, 0);\\n        unordered_set<int> set{n, -1};\\n        while (!q.empty()) {\\n            auto [num, add] = q.front();\\n            q.pop();\\n            if (num == 1) {\\n                return 1 + add;\\n            }\\n            int c1 = num - 1;\\n            if (set.count(c1) == 0) {\\n                q.emplace(c1, add + 1);\\n                set.emplace(c1);\\n            }\\n            int c2 = num % 2 ? -1 : num / 2;\\n            if (set.count(c2) == 0) {\\n                q.emplace(c2, add + 1);\\n                set.emplace(c2);\\n            }\\n            int c3 = num % 3 ? -1 : num / 3;\\n            if (set.count(c3) == 0) {\\n                q.emplace(c3, add + 1);\\n                set.emplace(c3);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        queue<pair<int, int>> q;\\n        q.emplace(n, 0);\\n        unordered_set<int> set{n, -1};\\n        while (!q.empty()) {\\n            auto [num, add] = q.front();\\n            q.pop();\\n            if (num == 1) {\\n                return 1 + add;\\n            }\\n            int c1 = num - 1;\\n            if (set.count(c1) == 0) {\\n                q.emplace(c1, add + 1);\\n                set.emplace(c1);\\n            }\\n            int c2 = num % 2 ? -1 : num / 2;\\n            if (set.count(c2) == 0) {\\n                q.emplace(c2, add + 1);\\n                set.emplace(c2);\\n            }\\n            int c3 = num % 3 ? -1 : num / 3;\\n            if (set.count(c3) == 0) {\\n                q.emplace(c3, add + 1);\\n                set.emplace(c3);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059948,
                "title": "o-logn-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe max days can be n if we eat one orange a day. \\n\\nWe will start with n oranges and eat oranges every day to reduce n to 0 or 1. For each day, we have two options/paths: eat n/2 oranges a day or n/3 oranges\\n\\nDo DFS to explore all paths and choose the best. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- create a hashmap for memoization i.e to store the min days required to eat x oranges\\nkey = oranges left\\nvalue = min days required to eat the remaining oranges\\n- add base cases to the hashmap i.e days required to eat 0 and 1 oranges\\n- define a helper function for DFS\\ndfs(oranges left)\\n    - if x is in the hashmap, we have already found the min days required to eat x oranges, return it\\n    - recursively find the days required to eat x oranges if we eat x/2 oranges a day or x/3 oranges and update the hashmap with the minimum\\n    - return the min days from the hashmap\\n- call dfs to find min days required to eat n oranges \\n\\n# Complexity\\n- Time complexity: O(dfs recursion) \\u2192 O(calls at each level ^ total levels) \\u2192 O(2$^{logn}$) \\u2192 (memoization using hashmap) \\u2192 O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(dfs recursion stack + hashmap) \\u2192 O(total levels + n) \\u2192 O(logn + n) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dp = {0: 0, 1: 1}\\n\\n        def dfs(x: int) -> int:\\n            if x in dp:\\n                return dp[x]\\n            dp[x] = 1 + min(x % 2 + dfs(x // 2), x % 3 + dfs(x // 3))\\n            return dp[x]\\n\\n        return dfs(n)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dp = {0: 0, 1: 1}\\n\\n        def dfs(x: int) -> int:\\n            if x in dp:\\n                return dp[x]\\n            dp[x] = 1 + min(x % 2 + dfs(x // 2), x % 3 + dfs(x // 3))\\n            return dp[x]\\n\\n        return dfs(n)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041865,
                "title": "python3-bfs-approach-with-visited-set-for-decision-tree-trimming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs many people know, using a __BFS__ is often used as a fastest path algorithm because we know that no matter how many paths we take, whatever node\\'s path reaches our solution first will have by definition been the fastest.\\n\\nKnowing this and having read the discussion page, I knew I had to take a look at the TLE issue, which I realized we could just make sure we prune branches we\\'ve visited before and let that path go on its own. Not exactly memoization which the problem has tagged, but it works.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarting from our \"node\" __N__, we __BFS__ and use a helper function __possibleEating__ to generate any valid values we could possibly travers from that \"location\".\\n\\nIf node is valid, add to q and visited, meaning futures visits to same node are ignored\\n# Complexity\\n- Time complexity: $$O(n^3)$$ maybe(?)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI\\'ll be honest - I\\'m a bit iffy on the time and space complexities of tree bfs like this which don\\'t contain explicit node counts -> but knowing that we have 3 options to visit each time, at worst case it seems like we visit $$O(n^3)$$ nodes.\\n- Space complexity: $$O(n^3)$$ similar to thoughts up-above\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        # bfs -> 3 choices each day -> because bfs min dist\\n        # return the min days it takes to eat all oranges\\n        \\n        # use a set to store previously visited values -> saves time pruning tree\\n        visited = set()\\n\\n        def possibleEating(num):\\n            res = [num-1]\\n            if not num % 2: res.append(num//2)\\n            if not num % 3: res.append(num - (2 * (num//3)))\\n            return res\\n\\n        q = deque([n])\\n\\n        time = 1\\n        while q:\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n\\n                for eat in possibleEating(curr):\\n                    if eat in visited: continue\\n\\n                    # found time to eat fruit\\n                    if eat == 0: return time\\n\\n                    q.append(eat)\\n                    visited.add(eat)\\n            time += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        # bfs -> 3 choices each day -> because bfs min dist\\n        # return the min days it takes to eat all oranges\\n        \\n        # use a set to store previously visited values -> saves time pruning tree\\n        visited = set()\\n\\n        def possibleEating(num):\\n            res = [num-1]\\n            if not num % 2: res.append(num//2)\\n            if not num % 3: res.append(num - (2 * (num//3)))\\n            return res\\n\\n        q = deque([n])\\n\\n        time = 1\\n        while q:\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n\\n                for eat in possibleEating(curr):\\n                    if eat in visited: continue\\n\\n                    # found time to eat fruit\\n                    if eat == 0: return time\\n\\n                    q.append(eat)\\n                    visited.add(eat)\\n            time += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037008,
                "title": "logn-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dp = {0:0,1:1}  # base case\\n\\n        def dfs(n):\\n            if n in dp:\\n                return dp[n]\\n\\n            one = 1 + (n % 2) + dfs(n // 2)\\n            two = 1 + (n % 3) + dfs(n // 3)\\n\\n            dp[n] = min(one,two)\\n            return dp[n]\\n        return dfs(n)\\n\\n# time complexity ->  O(logbase2n->log2(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        dp = {0:0,1:1}  # base case\\n\\n        def dfs(n):\\n            if n in dp:\\n                return dp[n]\\n\\n            one = 1 + (n % 2) + dfs(n // 2)\\n            two = 1 + (n % 3) + dfs(n // 3)\\n\\n            dp[n] = min(one,two)\\n            return dp[n]\\n        return dfs(n)\\n\\n# time complexity ->  O(logbase2n->log2(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034639,
                "title": "python-simple-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\n        seen = set()\\n\\n        heap = [(0,n)]\\n\\n        while heap:\\n            count, node = heapq.heappop(heap)\\n\\n            if node == 0: return count\\n\\n            if node % 2 == 0 and node - (node // 2) not in seen:\\n                heapq.heappush(heap,[count + 1, node - (node // 2)])\\n                seen.add(node - (node // 2))\\n            if node % 3 == 0 and node - (2 * (node // 3)) not in seen:\\n                heapq.heappush(heap,[count + 1, node - (2 * (node // 3))])\\n                seen.add(node - (2 * (node // 3)))\\n            if node - 1 not in seen:\\n                heapq.heappush(heap,[count + 1, node - 1])\\n                seen.add(node - 1)\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\n        seen = set()\\n\\n        heap = [(0,n)]\\n\\n        while heap:\\n            count, node = heapq.heappop(heap)\\n\\n            if node == 0: return count\\n\\n            if node % 2 == 0 and node - (node // 2) not in seen:\\n                heapq.heappush(heap,[count + 1, node - (node // 2)])\\n                seen.add(node - (node // 2))\\n            if node % 3 == 0 and node - (2 * (node // 3)) not in seen:\\n                heapq.heappush(heap,[count + 1, node - (2 * (node // 3))])\\n                seen.add(node - (2 * (node // 3)))\\n            if node - 1 not in seen:\\n                heapq.heappush(heap,[count + 1, node - 1])\\n                seen.add(node - 1)\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031737,
                "title": "python-one-line",
                "content": "# Code\\n```\\nclass Solution:\\n    @cache\\n    def minDays(self, n: int) -> int:        \\n        return n if n < 2 else 1 + min(n%2 + self.minDays(n//2), n%3 + self.minDays(n//3))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def minDays(self, n: int) -> int:        \\n        return n if n < 2 else 1 + min(n%2 + self.minDays(n//2), n%3 + self.minDays(n//3))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022404,
                "title": "java-simple-solution-recursion-to-memoization",
                "content": "# Recursion (TLE)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        int ans = function(n);\\n        return ans;\\n    }\\n\\n    public int function(int n){\\n\\n        if(n<=0) return 0;\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        eat_one = 1+ function(n-1);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2));\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3));\\n        }\\n\\n        return Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```\\n\\n# DP Memoization with Array (TLE)\\n\\n```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        Integer[] dp = new Integer[n+1];\\n        int ans = function(n,dp);\\n        return ans;\\n    }\\n\\n    public int function(int n,Integer[] dp){\\n\\n        if(n<=0) return 0;\\n\\n        if(dp[n]!=null) return dp[n];\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        if(n%2!=0 || n%3!=0)eat_one = 1+ function(n-1,dp);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2),dp);\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3),dp);\\n        }\\n\\n        return dp[n] = Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```\\n\\n\\n\\n# DP Memoization using HashMap (Accepted)\\n\\n# Intuition\\nWhen faced with this problem, the first thing that comes to mind is to break it down step-by-step. Each day, we have up to three choices:\\n\\n1. Eat one orange\\n2. If n is divisible by n/2 oranges\\n3. If n is divisible by 3, eat 2 * n/3 oranges\\n\\nGiven these choices, we can frame this problem as a decision tree, where each day we make one of the three decisions until all oranges are eaten. The goal is to find the shortest path from the root of the tree (the initial number of oranges) to a leaf (0 oranges).\\n\\nThis problem structure suggests the use of a recursive approach or dynamic programming. We can break down the problem into smaller sub-problems (i.e., how many days it would take to eat n-1 oranges, n - n/2 oranges, or n - 2 * n/3 oranges).By solving these sub-problems, we can construct the solution to our original problem.\\n\\n# Approach\\n\\n1. Memoization: To avoid redundant calculations and improve efficiency, we use a HashMap (dp in the code) to store already computed results for certain n values. This way, if we encounter the same n value again, we can directly fetch the result from the dp map instead of recalculating it.\\n\\n2. Base Condition: If n <= 0, return 0 as there are no oranges left to eat.\\n\\n3. Recursive Calls: For each choice: For each choice:\\n\\n* If n is not divisible by 2 or 3, we eat one orange\\n* If n is divisible by 2, we eat n/2 oranges.\\n* If n is divisible by 3 , we eat 2*(n/3) oranges\\n\\nFor each choice, we make a recursive call to function() to calculate the minimum days needed for the remaining oranges.\\n\\n4. Storing Results: After computing the minimum days required for a given n, we store the result in the dp map to avoid recalculations in the future.\\n\\n5. Return the Minimum: At the end of each recursive call, we return the minimum of the three choices.\\n# Complexity\\n- ***Time complexity:***\\nThe time complexity of this problem isn\\'t straightforward. At each step, we have three possible choices, but we might not always explore all three. Also, due to memoization, once we compute the result for a specific n, we won\\'t compute it again.However, in the worst case, our recursive function could be called for every number less than n, leading to a time complexity of O(n). But due to the halving (or reducing by two-thirds) operations, the recursive depth is actually much smaller than n. So, the time complexity would be closer to O(logn), but a little more because of the multiple branching choices. Therefore, an upper bound on the time complexity can be considered as O(n), but in practice, it will be much better than this.\\n\\n- ***Space complexity:***\\nThe space complexity is driven by the recursive call stack and the dp HashMap. In the worst case, the depth of the recursive call stack is  O(logn), and the dp HashMap can have up to n entries, leading to a space complexity of O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        HashMap<Integer,Integer> dp = new HashMap<>();\\n        int ans = function(n,dp);\\n        return ans;\\n    }\\n\\n    public int function(int n,HashMap<Integer,Integer> dp){\\n\\n        if(n<=0) return 0;\\n\\n        if(dp.containsKey(n)) return dp.get(n);\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        if(n%2!=0 || n%3!=0)eat_one = 1+ function(n-1,dp);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2),dp);\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3),dp);\\n        }\\n\\n        dp.put(n,Math.min(eat_one,Math.min(cond1,cond2)));\\n        return Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        int ans = function(n);\\n        return ans;\\n    }\\n\\n    public int function(int n){\\n\\n        if(n<=0) return 0;\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        eat_one = 1+ function(n-1);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2));\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3));\\n        }\\n\\n        return Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        Integer[] dp = new Integer[n+1];\\n        int ans = function(n,dp);\\n        return ans;\\n    }\\n\\n    public int function(int n,Integer[] dp){\\n\\n        if(n<=0) return 0;\\n\\n        if(dp[n]!=null) return dp[n];\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        if(n%2!=0 || n%3!=0)eat_one = 1+ function(n-1,dp);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2),dp);\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3),dp);\\n        }\\n\\n        return dp[n] = Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int minDays(int n) {\\n        HashMap<Integer,Integer> dp = new HashMap<>();\\n        int ans = function(n,dp);\\n        return ans;\\n    }\\n\\n    public int function(int n,HashMap<Integer,Integer> dp){\\n\\n        if(n<=0) return 0;\\n\\n        if(dp.containsKey(n)) return dp.get(n);\\n\\n        int eat_one = 1000;\\n        int cond1 = 1000;\\n        int cond2 = 1000;\\n\\n        if(n%2!=0 || n%3!=0)eat_one = 1+ function(n-1,dp);\\n\\n        if(n%2==0){\\n            cond1 = 1 + function(n-(n/2),dp);\\n        }\\n\\n        if(n%3==0){\\n            cond2 = 1 + function(n-2*(n/3),dp);\\n        }\\n\\n        dp.put(n,Math.min(eat_one,Math.min(cond1,cond2)));\\n        return Math.min(eat_one,Math.min(cond1,cond2));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979143,
                "title": "concise-solution-on-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        q = deque([n])\\n        s = set([n])\\n        cnt = 0\\n\\n        while q:\\n            sz = len(q)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                if cur <= 1:\\n                    return cnt + cur\\n                \\n                if cur % 3 == 0 and cur // 3 not in s:\\n                    q.append(cur // 3)\\n                    s.add(cur // 3)\\n                if cur % 2 == 0 and cur // 2 not in s:\\n                    q.append(cur // 2)\\n                    s.add(cur // 2)\\n                if cur - 1 not in s:\\n                    q.append(cur - 1)\\n                    s.add(cur - 1)\\n            cnt += 1\\n\\n        # dummy\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        q = deque([n])\\n        s = set([n])\\n        cnt = 0\\n\\n        while q:\\n            sz = len(q)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                if cur <= 1:\\n                    return cnt + cur\\n                \\n                if cur % 3 == 0 and cur // 3 not in s:\\n                    q.append(cur // 3)\\n                    s.add(cur // 3)\\n                if cur % 2 == 0 and cur // 2 not in s:\\n                    q.append(cur // 2)\\n                    s.add(cur // 2)\\n                if cur - 1 not in s:\\n                    q.append(cur - 1)\\n                    s.add(cur - 1)\\n            cnt += 1\\n\\n        # dummy\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956402,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minDays(int n) {\\n    if (n <= 1)\\n      return n;\\n    if (const auto it = dp.find(n); it != dp.cend())\\n      return it->second;\\n    return dp[n] = 1 + min(minDays(n / 3) + n % 3,  //\\n                           minDays(n / 2) + n % 2);\\n  }\\n\\n private:\\n  unordered_map<int, int> dp;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minDays(int n) {\\n    if (n <= 1)\\n      return n;\\n    if (const auto it = dp.find(n); it != dp.cend())\\n      return it->second;\\n    return dp[n] = 1 + min(minDays(n / 3) + n % 3,  //\\n                           minDays(n / 2) + n % 2);\\n  }\\n\\n private:\\n  unordered_map<int, int> dp;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924651,
                "title": "simple-bfs-approach-java-detailed-explanation",
                "content": "# Intuition\\n- Given a number n apples keep adding all possible remaining apples according to condition until you hit a 0. \\n - Use Similar approach as BFS in a Graph \\n\\n# Approach\\n - Step 1: Intitialize a Queue with given n and mark n as visited. minDays = 0\\n - Step 2: Start a loop till your queue is empty.\\n   - Pop the current element and add all possible remaining apples in queue if its not negative and not visited.\\n   - increment minDays\\n   - if any number you hit first is a zero then return minDays.\\n\\n# Complexity\\n- Time complexity:\\n   - $$O(n)$$\\n\\n- Space complexity:\\n   - $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int n) {\\n        if (n == 1)\\n            return 1;\\n        return eatingApples(n);\\n    }\\n\\n    private int eatingApples(int noOfApples) {\\n        int minDays = 0;\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(noOfApples);\\n        Set<Integer> eatenApples = new HashSet<>();\\n        eatenApples.add(noOfApples);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            minDays += 1;\\n            while (size-->0) {\\n                int apples = queue.poll();\\n                int remainingApples = apples - 1;\\n                if (remainingApples == 0)\\n                    return minDays;\\n                if (remainingApples > 0 && !eatenApples.contains(remainingApples)){\\n                    queue.add(remainingApples);\\n                    eatenApples.add(remainingApples);\\n                } if (apples % 2 == 0) {\\n                    remainingApples = apples - (apples/2);\\n                    if (remainingApples == 0)\\n                        return minDays;\\n                    if (remainingApples > 0 && !eatenApples.contains(remainingApples)) {\\n                        queue.add(remainingApples);\\n                        eatenApples.add(remainingApples);\\n                    }\\n                } if (apples % 3 == 0) {\\n                    remainingApples = apples - (2*(apples/3));\\n                    if (remainingApples == 0)\\n                        return minDays;\\n                    if (remainingApples > 0 && !eatenApples.contains(remainingApples)) {\\n                        queue.add(remainingApples);\\n                        eatenApples.add(remainingApples);\\n                    }\\n                }\\n            }\\n        }\\n        return minDays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        if (n == 1)\\n            return 1;\\n        return eatingApples(n);\\n    }\\n\\n    private int eatingApples(int noOfApples) {\\n        int minDays = 0;\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(noOfApples);\\n        Set<Integer> eatenApples = new HashSet<>();\\n        eatenApples.add(noOfApples);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            minDays += 1;\\n            while (size-->0) {\\n                int apples = queue.poll();\\n                int remainingApples = apples - 1;\\n                if (remainingApples == 0)\\n                    return minDays;\\n                if (remainingApples > 0 && !eatenApples.contains(remainingApples)){\\n                    queue.add(remainingApples);\\n                    eatenApples.add(remainingApples);\\n                } if (apples % 2 == 0) {\\n                    remainingApples = apples - (apples/2);\\n                    if (remainingApples == 0)\\n                        return minDays;\\n                    if (remainingApples > 0 && !eatenApples.contains(remainingApples)) {\\n                        queue.add(remainingApples);\\n                        eatenApples.add(remainingApples);\\n                    }\\n                } if (apples % 3 == 0) {\\n                    remainingApples = apples - (2*(apples/3));\\n                    if (remainingApples == 0)\\n                        return minDays;\\n                    if (remainingApples > 0 && !eatenApples.contains(remainingApples)) {\\n                        queue.add(remainingApples);\\n                        eatenApples.add(remainingApples);\\n                    }\\n                }\\n            }\\n        }\\n        return minDays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897550,
                "title": "easy-to-understand-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStoring every element in a map with its count initial being 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_map<int,int>mp;\\n    int minDays(int n) {\\n        if(n<=1) return n;\\n        if(mp.count(n)==0)\\n            mp[n]=1+min(n % 2+ minDays(n/2), n % 3 + minDays(n/3));\\n\\n        \\n        return mp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_map<int,int>mp;\\n    int minDays(int n) {\\n        if(n<=1) return n;\\n        if(mp.count(n)==0)\\n            mp[n]=1+min(n % 2+ minDays(n/2), n % 3 + minDays(n/3));\\n\\n        \\n        return mp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829026,
                "title": "c-clean-code-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t(int n,map<int,int>& v)\\n    {\\n        if(n<=1) return 1;\\n        if(v.count(n)) return v[n];\\n\\n        return v[n]=1+min(n%2+t(n/2,v),n%3+t(n/3,v));\\n    }\\n    int minDays(int n) {\\n        map<int,int> v;\\n        return t(1LL*n,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(int n,map<int,int>& v)\\n    {\\n        if(n<=1) return 1;\\n        if(v.count(n)) return v[n];\\n\\n        return v[n]=1+min(n%2+t(n/2,v),n%3+t(n/3,v));\\n    }\\n    int minDays(int n) {\\n        map<int,int> v;\\n        return t(1LL*n,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817403,
                "title": "my-solutions",
                "content": "**1. Use the DFS**\\n```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    unordered_map<int, int> memo;\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  int dfs(const int n, unordered_map<int, int> &memo) {\\n    if (n < 2) {\\n      return n;\\n    }\\n    \\n    auto itr = memo.find(n);\\n    if (itr != memo.end()) {\\n      return itr->second;\\n    }\\n    \\n    const int ret = 1 + min((n & 1) + dfs(n >> 1, memo), (n % 3) + dfs(n / 3, memo));\\n    memo[n] = ret;\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the Dijkstra Algorithm**\\n```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    using pq_node_t = pair<int, int>;   // {the days, the remained oranges}\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    pq.emplace(0, n);\\n    unordered_set<int> visited;\\n    while (!pq.empty()) {\\n      const auto [d, o] = pq.top();\\n      if (o < 2) {\\n        return d + o;\\n      }\\n      pq.pop();\\n      if (visited.find(o) != visited.end()) {\\n        continue;\\n      }\\n      visited.emplace(o);\\n      if (visited.find(o >> 1) == visited.end()) {\\n        pq.emplace(d + (o & 1) + 1, (o >> 1));\\n      }\\n      if (visited.find(o / 3) == visited.end()) {\\n        pq.emplace(d + (o % 3) + 1, (o / 3));\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\\n**3. Use the A-Star Algorithm**\\n```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    using pq_node_t = pair<int, int>;   // {the days, the remained oranges}\\n    auto log3 = [](const int a) -> int {\\n      return a == 0 ? 0 : static_cast<int>(log(a) / log(3));\\n    };\\n    auto compare = [&log3](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.first + log3(lhs.second) < rhs.first + log3(rhs.second));\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(0, n);\\n    unordered_map<int, int> oranges_to_days;\\n    \\n    auto get_cached_days = [&oranges_to_days](const int oranges) -> int& {\\n      auto itr = oranges_to_days.find(oranges);\\n      if (itr == oranges_to_days.end()) {\\n        itr = oranges_to_days.emplace(oranges, numeric_limits<int>::max()).first;\\n      }\\n      return itr->second;\\n    };\\n    \\n    while (!pq.empty()) {\\n      const auto [d, o] = pq.top();\\n      if (o < 2) {\\n        return d + o;\\n      }\\n      pq.pop();\\n      \\n      int &cached_days = get_cached_days(o);\\n      if (cached_days <= d) {\\n        continue;\\n      }\\n      cached_days = d;\\n\\n      if (get_cached_days(o >> 1) > d + (o & 1) + 1) {\\n        pq.emplace(d + (o & 1) + 1, (o >> 1));\\n      }\\n      if (get_cached_days(o / 3) > d + (o % 3) + 1) {\\n        pq.emplace(d + (o % 3) + 1, (o / 3));\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    unordered_map<int, int> memo;\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  int dfs(const int n, unordered_map<int, int> &memo) {\\n    if (n < 2) {\\n      return n;\\n    }\\n    \\n    auto itr = memo.find(n);\\n    if (itr != memo.end()) {\\n      return itr->second;\\n    }\\n    \\n    const int ret = 1 + min((n & 1) + dfs(n >> 1, memo), (n % 3) + dfs(n / 3, memo));\\n    memo[n] = ret;\\n    return ret;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    using pq_node_t = pair<int, int>;   // {the days, the remained oranges}\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    pq.emplace(0, n);\\n    unordered_set<int> visited;\\n    while (!pq.empty()) {\\n      const auto [d, o] = pq.top();\\n      if (o < 2) {\\n        return d + o;\\n      }\\n      pq.pop();\\n      if (visited.find(o) != visited.end()) {\\n        continue;\\n      }\\n      visited.emplace(o);\\n      if (visited.find(o >> 1) == visited.end()) {\\n        pq.emplace(d + (o & 1) + 1, (o >> 1));\\n      }\\n      if (visited.find(o / 3) == visited.end()) {\\n        pq.emplace(d + (o % 3) + 1, (o / 3));\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int minDays(const int n) {\\n    using pq_node_t = pair<int, int>;   // {the days, the remained oranges}\\n    auto log3 = [](const int a) -> int {\\n      return a == 0 ? 0 : static_cast<int>(log(a) / log(3));\\n    };\\n    auto compare = [&log3](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.first + log3(lhs.second) < rhs.first + log3(rhs.second));\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(0, n);\\n    unordered_map<int, int> oranges_to_days;\\n    \\n    auto get_cached_days = [&oranges_to_days](const int oranges) -> int& {\\n      auto itr = oranges_to_days.find(oranges);\\n      if (itr == oranges_to_days.end()) {\\n        itr = oranges_to_days.emplace(oranges, numeric_limits<int>::max()).first;\\n      }\\n      return itr->second;\\n    };\\n    \\n    while (!pq.empty()) {\\n      const auto [d, o] = pq.top();\\n      if (o < 2) {\\n        return d + o;\\n      }\\n      pq.pop();\\n      \\n      int &cached_days = get_cached_days(o);\\n      if (cached_days <= d) {\\n        continue;\\n      }\\n      cached_days = d;\\n\\n      if (get_cached_days(o >> 1) > d + (o & 1) + 1) {\\n        pq.emplace(d + (o & 1) + 1, (o >> 1));\\n      }\\n      if (get_cached_days(o / 3) > d + (o % 3) + 1) {\\n        pq.emplace(d + (o % 3) + 1, (o / 3));\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789871,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int, int> map;\\n        map[0] = 0;\\n        map[1] = 1;\\n        return dfs(n, map);\\n    }\\nprivate:\\n    int dfs(int i, unordered_map<int, int>& map) {\\n        if (map.find(i) != map.end())\\n            return map[i];\\n\\n        return map[i] = min(dfs(i / 2, map) + i % 2 + 1, dfs(i / 3, map) + i % 3 + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int, int> map;\\n        map[0] = 0;\\n        map[1] = 1;\\n        return dfs(n, map);\\n    }\\nprivate:\\n    int dfs(int i, unordered_map<int, int>& map) {\\n        if (map.find(i) != map.end())\\n            return map[i];\\n\\n        return map[i] = min(dfs(i / 2, map) + i % 2 + 1, dfs(i / 3, map) + i % 3 + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789621,
                "title": "bidirectional-bfs",
                "content": "# Code\\n```\\nimport sys\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        OPENf = {}\\n        OPENb = {}\\n        OPENf[0] =  0\\n        OPENb[n] = 0\\n        while(True):\\n            OPENf = self.getNeighborsForward(OPENf)\\n            answer = self.getAnswer(OPENf, OPENb)\\n            if ( answer != None ) :\\n                return answer\\n            OPENb = self.getNeighborsBackward(OPENb)\\n            answer = self.getAnswer(OPENf, OPENb)\\n            if ( answer != None ) :\\n                return answer\\n           \\n    def getNeighborsBackward(self, OPENb):\\n        neighbors = {}\\n        for index, (key,value) in enumerate(OPENb.items()):\\n            if (int(key)%3==0):\\n                neighbors[int(key/3)] = value+1\\n            if (int(key)%2==0):\\n                neighbors[int(key/2)] = value+1\\n            neighbors[int(key-1)] = value+1\\n        return neighbors\\n    \\n    def getNeighborsForward(self, OPENf):\\n        neighbors = {}\\n        if(0 in OPENf):\\n            neighbors[1] = 1\\n            return neighbors\\n        for index, (key, value) in enumerate(OPENf.items()):\\n            neighbors[int(key)+1] = value+1\\n            neighbors[int(key)*2] = value+1\\n            neighbors[int(key)*3] = value+1\\n        return neighbors\\n    \\n    def getAnswer(self, OPENf, OPENb):\\n        for index, (key, value) in enumerate(OPENf.items()):\\n            if (key in OPENb):\\n                return value + OPENb[key]\\n        return None\\n        \\n            \\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        OPENf = {}\\n        OPENb = {}\\n        OPENf[0] =  0\\n        OPENb[n] = 0\\n        while(True):\\n            OPENf = self.getNeighborsForward(OPENf)\\n            answer = self.getAnswer(OPENf, OPENb)\\n            if ( answer != None ) :\\n                return answer\\n            OPENb = self.getNeighborsBackward(OPENb)\\n            answer = self.getAnswer(OPENf, OPENb)\\n            if ( answer != None ) :\\n                return answer\\n           \\n    def getNeighborsBackward(self, OPENb):\\n        neighbors = {}\\n        for index, (key,value) in enumerate(OPENb.items()):\\n            if (int(key)%3==0):\\n                neighbors[int(key/3)] = value+1\\n            if (int(key)%2==0):\\n                neighbors[int(key/2)] = value+1\\n            neighbors[int(key-1)] = value+1\\n        return neighbors\\n    \\n    def getNeighborsForward(self, OPENf):\\n        neighbors = {}\\n        if(0 in OPENf):\\n            neighbors[1] = 1\\n            return neighbors\\n        for index, (key, value) in enumerate(OPENf.items()):\\n            neighbors[int(key)+1] = value+1\\n            neighbors[int(key)*2] = value+1\\n            neighbors[int(key)*3] = value+1\\n        return neighbors\\n    \\n    def getAnswer(self, OPENf, OPENb):\\n        for index, (key, value) in enumerate(OPENf.items()):\\n            if (key in OPENb):\\n                return value + OPENb[key]\\n        return None\\n        \\n            \\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783616,
                "title": "dp-using-hashmap-to-save-space-clean-and-elegant-code",
                "content": "# Complexity\\n- Time complexity: $$O(log_2(n))$$ \\n\\n- Space complexity: $$O(log_2(n))$$ \\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<int,int> dp; \\n    //we used map instead of array\\n    //because we won\\'t be visiting all the n states\\n    //due to divide and conquer approach\\n    int solve(int n, unordered_map<int,int>& dp)\\n    {\\n        if(n == 0) return 0;\\n        if(dp[n]) return dp[n];\\n\\n        int eat1 = (n % 2 == 0) ? solve(n/2,dp) : 1e5;\\n        int eat2 = (n % 3 == 0) ? solve(n/3,dp) : 1e5;\\n        int eat3 = (n%2 || n%3) ? solve(n-1,dp) : 1e5; //don\\'t try this step if both of the above two were possible\\n        return dp[n] = 1 + min({eat1,eat2,eat3});\\n    }\\npublic:\\n    int minDays(int n) {\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,int> dp; \\n    //we used map instead of array\\n    //because we won\\'t be visiting all the n states\\n    //due to divide and conquer approach\\n    int solve(int n, unordered_map<int,int>& dp)\\n    {\\n        if(n == 0) return 0;\\n        if(dp[n]) return dp[n];\\n\\n        int eat1 = (n % 2 == 0) ? solve(n/2,dp) : 1e5;\\n        int eat2 = (n % 3 == 0) ? solve(n/3,dp) : 1e5;\\n        int eat3 = (n%2 || n%3) ? solve(n-1,dp) : 1e5; //don\\'t try this step if both of the above two were possible\\n        return dp[n] = 1 + min({eat1,eat2,eat3});\\n    }\\npublic:\\n    int minDays(int n) {\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756728,
                "title": "c-solution-with-full-explanation-in-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp;\\n    int minDays(int n) {\\n        if(n<=1){\\n            return n;\\n        }\\n        int t2=500000;\\n        int t3=500000;\\n        if(dp.find(n)!=dp.end()){\\n            return dp[n];\\n        }\\n        // if we do -1 at every n then it will give tle\\n        // if it is not divisible by 2 then we had to remove remiander, for unit remainder we need unit days so we added n%2 after making it a multiple of 2 we need 1 more day to make it n/2 so added 1 more similarly for 3\\n        // question may arrise like why we are only doing n/2 and n/3 operation and -1 operation at every n , because n/2 and n/3 are always more fast to reduce the number of days \\n        // take example of 10 and 8 distance between them is two but if we divide both of them by 2 then they become 4 and 5 and distance is reduced to 1 \\n       t2=1+n%2+minDays(n/2);\\n       t3=1+n%3+minDays(n/3);\\n        return dp[n]=min(t2,t3);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp;\\n    int minDays(int n) {\\n        if(n<=1){\\n            return n;\\n        }\\n        int t2=500000;\\n        int t3=500000;\\n        if(dp.find(n)!=dp.end()){\\n            return dp[n];\\n        }\\n        // if we do -1 at every n then it will give tle\\n        // if it is not divisible by 2 then we had to remove remiander, for unit remainder we need unit days so we added n%2 after making it a multiple of 2 we need 1 more day to make it n/2 so added 1 more similarly for 3\\n        // question may arrise like why we are only doing n/2 and n/3 operation and -1 operation at every n , because n/2 and n/3 are always more fast to reduce the number of days \\n        // take example of 10 and 8 distance between them is two but if we divide both of them by 2 then they become 4 and 5 and distance is reduced to 1 \\n       t2=1+n%2+minDays(n/2);\\n       t3=1+n%3+minDays(n/3);\\n        return dp[n]=min(t2,t3);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692337,
                "title": "best-solution-using-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log2(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> dp{{0, 0}, {1, 1}};    \\n    int minDays(int n) {\\n        if(dp.find(n)!=dp.end())\\n            return dp[n];\\n        \\n        int one = 1 + (n%2) + minDays(n/2);\\n        int two = 1 + (n%3) + minDays(n/3);\\n        return dp[n] = min(one, two);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> dp{{0, 0}, {1, 1}};    \\n    int minDays(int n) {\\n        if(dp.find(n)!=dp.end())\\n            return dp[n];\\n        \\n        int one = 1 + (n%2) + minDays(n/2);\\n        int two = 1 + (n%3) + minDays(n/3);\\n        return dp[n] = min(one, two);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344061,
                "title": "c-simple-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        queue<int> q;\\n        q.push(n);\\n        set<int> visited;\\n        int ans = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i = 0; i < s; i++){\\n                int f = q.front();\\n                q.pop();\\n                if(f == 0) return ans;\\n                visited.insert(f);\\n\\n                if(!visited.count(f-1)) q.push(f-1);\\n                if(f%2 == 0 && !visited.count(f/2))q.push(f/2);\\n                if(f%3 == 0 && !visited.count(f/3))q.push(f/3);\\n            }  \\n            ans++;          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        queue<int> q;\\n        q.push(n);\\n        set<int> visited;\\n        int ans = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i = 0; i < s; i++){\\n                int f = q.front();\\n                q.pop();\\n                if(f == 0) return ans;\\n                visited.insert(f);\\n\\n                if(!visited.count(f-1)) q.push(f-1);\\n                if(f%2 == 0 && !visited.count(f/2))q.push(f/2);\\n                if(f%3 == 0 && !visited.count(f/3))q.push(f/3);\\n            }  \\n            ans++;          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229653,
                "title": "memoization-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\n    unordered_map<int,int> dp;\\n    int sol(int n){\\n        if(n <= 1) return n;\\n        if(dp.find(n) != dp.end()) return dp[n];\\n        int op1 = (n%2) + sol(n/2);\\n        int op2 = (n%3) + sol(n/3);\\n        return dp[n] = min({op1,op2}) + 1;\\n    }\\npublic:\\n    int minDays(int n){\\n        return sol(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,int> dp;\\n    int sol(int n){\\n        if(n <= 1) return n;\\n        if(dp.find(n) != dp.end()) return dp[n];\\n        int op1 = (n%2) + sol(n/2);\\n        int op2 = (n%3) + sol(n/3);\\n        return dp[n] = min({op1,op2}) + 1;\\n    }\\npublic:\\n    int minDays(int n){\\n        return sol(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222107,
                "title": "rust-dp-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        use std::collections::*;\\n        let mut dp = HashMap::new();\\n        fn dfs(n: i32, dp: &mut HashMap<i32, i32>) -> i32 {\\n            if n <= 1 {\\n                return n;\\n            }\\n            if !dp.contains_key(&n) {\\n                let mid_days_to_eat = 1 + (n % 2 + dfs(n / 2, dp)).min(n % 3 + dfs(n / 3, dp));\\n                dp.insert(n, mid_days_to_eat);\\n            }\\n            dp.get(&n).copied().unwrap()\\n        }\\n        dfs(n, &mut dp)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        use std::collections::*;\\n        let mut dp = HashMap::new();\\n        fn dfs(n: i32, dp: &mut HashMap<i32, i32>) -> i32 {\\n            if n <= 1 {\\n                return n;\\n            }\\n            if !dp.contains_key(&n) {\\n                let mid_days_to_eat = 1 + (n % 2 + dfs(n / 2, dp)).min(n % 3 + dfs(n / 3, dp));\\n                dp.insert(n, mid_days_to_eat);\\n            }\\n            dp.get(&n).copied().unwrap()\\n        }\\n        dfs(n, &mut dp)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217774,
                "title": "easy-memoization-solution-using-java-hashmap",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Idea is, when n is divisible by 2 and 3,the minimum operations can be obtained from either of the subproblems n/3 and n/2\\nWhen n is divisible by 3- answer is between the subproblems n/3,n-1\\nNOTE: n-(2*(n/3)) can be replaced by n/3\\nWhen n is divisible by 2- answer is between the subproblems n/2,n-1\\nWhen n is divisible by 3- answer is between the subproblems n/3,n-1\\nIf none of the above cases are true ony possibilty is n-1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck all the possibilities and memoize the repeating subproblems using a HashMap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# > O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) and auxiliary stack space\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer,Integer> dp;\\n    public int minDays(int n) {\\n        dp = new HashMap<>();\\n        return helper(n);\\n    }\\n    public int helper(int n){\\n        if(n==0) return 0; // Base Case\\n        if(dp.containsKey(n)) return dp.get(n); // Cache\\n        int temp = Integer.MAX_VALUE; // Initializing\\n        if(n%6==0) temp = 1+ Math.min(helper(n/2),helper(n/3)); // If n is divisible by 6,minimum will be among n/2,n/3\\n        else if(n%3==0)temp = 1 + Math.min(helper(n/3),helper(n-1));// n-(2*(n/3)) can be considered n/3\\n        else if(n%2==0)temp = 1+ Math.min(helper(n/2),helper(n-1));\\n        else temp = 1+helper(n-1);\\n        dp.put(n,temp); // memoizing\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> dp;\\n    public int minDays(int n) {\\n        dp = new HashMap<>();\\n        return helper(n);\\n    }\\n    public int helper(int n){\\n        if(n==0) return 0; // Base Case\\n        if(dp.containsKey(n)) return dp.get(n); // Cache\\n        int temp = Integer.MAX_VALUE; // Initializing\\n        if(n%6==0) temp = 1+ Math.min(helper(n/2),helper(n/3)); // If n is divisible by 6,minimum will be among n/2,n/3\\n        else if(n%3==0)temp = 1 + Math.min(helper(n/3),helper(n-1));// n-(2*(n/3)) can be considered n/3\\n        else if(n%2==0)temp = 1+ Math.min(helper(n/2),helper(n-1));\\n        else temp = 1+helper(n-1);\\n        dp.put(n,temp); // memoizing\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171671,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minDays(n int) int {\\n\\tdp := map[int]int{\\n\\t\\t0: 0,\\n\\t\\t1: 1,\\n\\t}\\n\\n\\tvar dfs func(n int) int\\n\\tdfs = func(n int) int {\\n\\n\\t\\tif v, f := dp[n]; f {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\n\\t\\tone := 1 + (n % 2) + dfs(n/2)\\n\\t\\ttwo := 1 + (n % 3) + dfs(n/3)\\n\\t\\tdp[n] = min(one, two)\\n\\t\\treturn dp[n]\\n\\t}\\n\\n\\treturn dfs(n)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minDays(n int) int {\\n\\tdp := map[int]int{\\n\\t\\t0: 0,\\n\\t\\t1: 1,\\n\\t}\\n\\n\\tvar dfs func(n int) int\\n\\tdfs = func(n int) int {\\n\\n\\t\\tif v, f := dp[n]; f {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\n\\t\\tone := 1 + (n % 2) + dfs(n/2)\\n\\t\\ttwo := 1 + (n % 3) + dfs(n/3)\\n\\t\\tdp[n] = min(one, two)\\n\\t\\treturn dp[n]\\n\\t}\\n\\n\\treturn dfs(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171269,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn _min_days(n: i32, dp: &mut HashMap<i32, i32>) -> i32 {\\n            if n <= 1 {\\n                return n;\\n            }\\n            if !dp.contains_key(&n) {\\n                let a = n % 2 + _min_days(n / 2, dp);\\n                let b = n % 3 + _min_days(n / 3, dp);\\n                dp.insert(n, 1 + a.min(b));\\n            }\\n            *dp.get(&n).unwrap()\\n        }\\n\\n        let mut dp = HashMap::new();\\n        _min_days(n, &mut dp)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(n: i32) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn _min_days(n: i32, dp: &mut HashMap<i32, i32>) -> i32 {\\n            if n <= 1 {\\n                return n;\\n            }\\n            if !dp.contains_key(&n) {\\n                let a = n % 2 + _min_days(n / 2, dp);\\n                let b = n % 3 + _min_days(n / 3, dp);\\n                dp.insert(n, 1 + a.min(b));\\n            }\\n            *dp.get(&n).unwrap()\\n        }\\n\\n        let mut dp = HashMap::new();\\n        _min_days(n, &mut dp)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3119690,
                "title": "python-fast-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using a dynamic programming approach. The idea is to store already computed values in a memo table and recursively calculate the minimum number of days for any given value of n. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a recursive function dp(n) which returns the minimum number of days required to reduce n to 1. The function takes a number as input and returns the minimum number of days required to reduce it to 1. If n is 1, the minimum number of days is n itself. If n is not 1, we can either choose to subtract 1 from n or divide n by 2 or 3. We make use of a memo table to store the already computed values.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        memo = {}\\n        def dp(n):\\n            if n <= 1: return n\\n            if n in memo: return memo[n]\\n            memo[n] = 1 + min(n % 2 + dp(n // 2), n % 3 + dp(n // 3))\\n            return memo[n]\\n        return dp(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        memo = {}\\n        def dp(n):\\n            if n <= 1: return n\\n            if n in memo: return memo[n]\\n            memo[n] = 1 + min(n % 2 + dp(n // 2), n % 3 + dp(n // 3))\\n            return memo[n]\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119651,
                "title": "4ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is that we need to find the minimum number of days it will take for us to reduce the given number \\'n\\' to 1. We can reduce this number either by subtracting 1 from it or by dividing it by 2 or 3. We need to find the minimum number of steps to reach 1 from the given number n. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a dynamic programming approach. We can use a hashmap to store the intermediate results so that we don\\'t have to recalculate them. We can use a recursive function to calculate the minimum number of days it will take to reduce the number \\'n\\' to 1. The function will return the answer.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int, int> dp;\\n        function<int(int)> f = [&](int n) {\\n            if (n <= 1) return n;\\n            if (dp.count(n)) return dp[n];\\n            return dp[n] = 1 + min(n % 2 + f(n / 2), n % 3 + f(n / 3));\\n        };\\n        return f(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        unordered_map<int, int> dp;\\n        function<int(int)> f = [&](int n) {\\n            if (n <= 1) return n;\\n            if (dp.count(n)) return dp[n];\\n            return dp[n] = 1 + min(n % 2 + f(n / 2), n % 3 + f(n / 3));\\n        };\\n        return f(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107748,
                "title": "golang-0-ms-2-1-mb",
                "content": "```\\nconst MaxN = 2 * 1e9\\n\\nvar cache map[uint32]byte\\n\\nfunc init() {\\n\\tcache = make(map[uint32]byte)\\n\\tfor i, n := 1, 1; n <= MaxN; i, n = i+1, n<<1 {\\n\\t\\tcache[uint32(n)] = byte(i)\\n\\t}\\n\\tfor i, n := 1, 1; n <= MaxN; i, n = i+1, n*3 {\\n\\t\\tcache[uint32(n)] = byte(i)\\n\\t}\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minDays(n int) int {\\n\\tresult, exist := cache[uint32(n)]\\n\\tif !exist {\\n\\t\\tresult = byte(min(minDays(n>>1)+1+(n%2), minDays(n/3)+1+(n%3)))\\n\\t\\tcache[uint32(n)] = result\\n\\t}\\n\\treturn int(result)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst MaxN = 2 * 1e9\\n\\nvar cache map[uint32]byte\\n\\nfunc init() {\\n\\tcache = make(map[uint32]byte)\\n\\tfor i, n := 1, 1; n <= MaxN; i, n = i+1, n<<1 {\\n\\t\\tcache[uint32(n)] = byte(i)\\n\\t}\\n\\tfor i, n := 1, 1; n <= MaxN; i, n = i+1, n*3 {\\n\\t\\tcache[uint32(n)] = byte(i)\\n\\t}\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minDays(n int) int {\\n\\tresult, exist := cache[uint32(n)]\\n\\tif !exist {\\n\\t\\tresult = byte(min(minDays(n>>1)+1+(n%2), minDays(n/3)+1+(n%3)))\\n\\t\\tcache[uint32(n)] = result\\n\\t}\\n\\treturn int(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957922,
                "title": "bfs-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        deque <pair<int,int>> dq; //number left ,steps;\\n        dq.push_back({n,0});\\n        unordered_map <int,int> visited;\\n        while(!dq.empty())\\n        {\\n            int steps = dq.front().second;\\n            int left = dq.front().first;\\n            dq.pop_front();\\n            if(left==1) return steps+1;\\n            else \\n            {\\n                if(visited[left-1]==0)\\n                {\\n                    dq.push_back({left-1,steps+1});\\n                    visited[left-1]=1;\\n                }\\n            }\\n            if(left%2==0 && visited[left/2]==0)\\n            {\\n                dq.push_back({left/2,steps+1});\\n                visited[left/2]=1;\\n            }\\n            if(left%3==0 && visited[left/3]==0)\\n            {\\n                dq.push_back({left/3,steps+1});\\n                visited[left/3]=1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(int n) {\\n        deque <pair<int,int>> dq; //number left ,steps;\\n        dq.push_back({n,0});\\n        unordered_map <int,int> visited;\\n        while(!dq.empty())\\n        {\\n            int steps = dq.front().second;\\n            int left = dq.front().first;\\n            dq.pop_front();\\n            if(left==1) return steps+1;\\n            else \\n            {\\n                if(visited[left-1]==0)\\n                {\\n                    dq.push_back({left-1,steps+1});\\n                    visited[left-1]=1;\\n                }\\n            }\\n            if(left%2==0 && visited[left/2]==0)\\n            {\\n                dq.push_back({left/2,steps+1});\\n                visited[left/2]=1;\\n            }\\n            if(left%3==0 && visited[left/3]==0)\\n            {\\n                dq.push_back({left/3,steps+1});\\n                visited[left/3]=1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884439,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, n):\\n        @lru_cache(None)\\n        def dfs(n):\\n            if n<=1:\\n                return n\\n                \\n            opt1, opt2, opt3 = float(\"inf\"), float(\"inf\"), float(\"inf\")\\n\\n            if n%3 == 0:\\n                opt3 = dfs(n//3)\\n            if n%2 == 0:\\n                opt2 = dfs(n//2)\\n            if n%2 or n%3:\\n                opt1 = dfs(n-1)\\n\\n            return min(opt1,opt2,opt3) + 1\\n\\n        return dfs(n)\\n\\n        \\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, n):\\n        @lru_cache(None)\\n        def dfs(n):\\n            if n<=1:\\n                return n\\n                \\n            opt1, opt2, opt3 = float(\"inf\"), float(\"inf\"), float(\"inf\")\\n\\n            if n%3 == 0:\\n                opt3 = dfs(n//3)\\n            if n%2 == 0:\\n                opt2 = dfs(n//2)\\n            if n%2 or n%3:\\n                opt1 = dfs(n-1)\\n\\n            return min(opt1,opt2,opt3) + 1\\n\\n        return dfs(n)\\n\\n        \\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880773,
                "title": "can-someone-tell-me-why-timecomplexity-of-this-code",
                "content": "What is the time complexity?? Please explain it in detail\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n    \\n        dp={0:0,1:1}\\n        def f(n):\\n            if n in dp:\\n                return dp[n]\\n            one=1+(n%2)+f(n//2)\\n            two=1+(n%3)+f(n//3)\\n            dp[n]=min(one,two) #this helps in avoiding repetition\\n            return dp[n]    \\n        return f(n)\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def minDays(self, n: int) -> int:\\n    \\n        dp={0:0,1:1}",
                "codeTag": "Java"
            },
            {
                "id": 2873865,
                "title": "java-recursive-with-cache",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    public int minDays(int n) {\\n        if (n == 0) return 0;\\n        if (cache.containsKey(n)) return  cache.get(n);\\n        if (n %3 ==0) {\\n            if (n %2 == 0) {\\n                cache.put(n, 1 + Math.min(minDays(n - (2 *(n/3))), minDays(n - (n/2))));\\n            } else {\\n                cache.put(n, 1 + Math.min(minDays(n-1), minDays(n - (2 *(n/3)))));\\n            }\\n        } else if (n%2 == 0) {\\n            cache.put(n, 1 + Math.min(minDays(n-1), minDays(n - (n/2))));\\n        } else {\\n            cache.put(n, 1 + minDays(n-1));\\n        }\\n        return cache.get(n);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    public int minDays(int n) {\\n        if (n == 0) return 0;\\n        if (cache.containsKey(n)) return  cache.get(n);\\n        if (n %3 ==0) {\\n            if (n %2 == 0) {\\n                cache.put(n, 1 + Math.min(minDays(n - (2 *(n/3))), minDays(n - (n/2))));\\n            } else {\\n                cache.put(n, 1 + Math.min(minDays(n-1), minDays(n - (2 *(n/3)))));\\n            }\\n        } else if (n%2 == 0) {\\n            cache.put(n, 1 + Math.min(minDays(n-1), minDays(n - (n/2))));\\n        } else {\\n            cache.put(n, 1 + minDays(n-1));\\n        }\\n        return cache.get(n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805224,
                "title": "rejected-bottom-up-dp",
                "content": "isn\\'t this a bottom up DP solution starting from i = 1 up to n? o(n) runtime? why is it rejected for TLE?\\n\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\t\\n        dp = [0] * (n + 1) \\n        dp[1] = 1\\n        \\n        for i in range(2,n+1):\\n            best = dp[i-1]\\n            if i % 2 == 0:\\n                best = min(best,dp[i - i//2])\\n            if i % 3 == 0:\\n                best = min(best,dp[i - 2 * i//3])\\n                \\n            dp[i] = 1 + best\\n        \\n        \\n        return dp[n]\\n",
                "solutionTags": [],
                "code": "isn\\'t this a bottom up DP solution starting from i = 1 up to n? o(n) runtime? why is it rejected for TLE?\\n\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n\\t\\n        dp = [0] * (n + 1) \\n        dp[1] = 1\\n        \\n        for i in range(2,n+1):\\n            best = dp[i-1]\\n            if i % 2 == 0:\\n                best = min(best,dp[i - i//2])\\n            if i % 3 == 0:\\n                best = min(best,dp[i - 2 * i//3])\\n                \\n            dp[i] = 1 + best\\n        \\n        \\n        return dp[n]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2753866,
                "title": "javascript-using-greedy-dp",
                "content": "We only try eating groups of 2 & 3, and then including the remainder (how long it will take us to get to an amount of oranges divisible by 2 or 3 respectively)\\n```\\nvar minDays = function(n) {\\n    let dp = {}\\n    dp[0] = 0\\n    dp[1] = 1\\n    const helper = (i) => {\\n        if (dp[i] !== undefined) return dp[i]\\n        dp[i] = Math.min(helper(Math.floor(i/2)) + i%2, helper(Math.floor(i/3)) + i%3) + 1\\n        return dp[i]\\n    }\\n    return helper(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDays = function(n) {\\n    let dp = {}\\n    dp[0] = 0\\n    dp[1] = 1\\n    const helper = (i) => {\\n        if (dp[i] !== undefined) return dp[i]\\n        dp[i] = Math.min(helper(Math.floor(i/2)) + i%2, helper(Math.floor(i/3)) + i%3) + 1\\n        return dp[i]\\n    }\\n    return helper(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751284,
                "title": "python-several-lines-dp-solution",
                "content": "class Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        self.dp={}\\n        def dfs(n):\\n            if n==0:\\n                return 0\\n            if n in self.dp:\\n                return self.dp[n]\\n            res=0\\n            res+=min(dfs(n//2)+n%2,dfs(n//3)+n%3)+1\\n            self.dp[n]=res\\n            return res\\n        dfs(n)\\n        return self.dp[n]-1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        self.dp={}",
                "codeTag": "Java"
            },
            {
                "id": 2731412,
                "title": "lol-why-is-it-even-hard-python-dp-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    @cache\\n    def minDays(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return n\\n        return 1 + min((n % 2) + self.minDays(n // 2), (n % 3) + self.minDays(n // 3))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def minDays(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return n\\n        return 1 + min((n % 2) + self.minDays(n // 2), (n % 3) + self.minDays(n // 3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719625,
                "title": "dp-bfs-solution-explained-python",
                "content": "The key step to making DP work is to not make n-1 call,\\nbecause n <= 10^9\\nso instead of making n-1 call u jump over those steps by doing n%2 or n%3. Because n%3 is the number of times you need to subtract 1 from n to make n divisible by 3. Same logic applies for 2.\\n\\nBut if you really want to use n-1, just convert your code from dfs to bfs. This ways you will reach the answer in answer steps. \\n\\nDP\\n```\\ndef minDays(self, n: int) -> int:\\n    \\n    @lru_cache(None)\\n    def dp(n):\\n        if n == 1:\\n            return 1\\n        if n <= 3:\\n            return 2\\n        nMod3 = n%3\\n        nMod2 = n%2\\n        return 1 + min(nMod3 + dp(n//3), nMod2 + dp(n//2))\\n        \\n    return dp(n)\\n```\\nBFS\\n```\\ndef minDays(self, n: int) -> int:\\n    que = deque([n])\\n    visited = set([n])\\n    ans = 0\\n    while que:\\n        Len = len(que)\\n        for _ in range(Len):\\n            c_node = que.popleft()\\n            if c_node == 1: return ans + 1\\n            if c_node%3 == 0 and c_node//3 not in visited:\\n                visited.add(c_node//3)\\n                que.append(c_node//3)\\n            if c_node%2 == 0 and c_node//2 not in visited:\\n                visited.add(c_node//2)\\n                que.append(c_node//2)\\n            if c_node - 1 not in visited:\\n                visited.add(c_node-1)\\n                que.append(c_node-1)\\n        \\n        ans += 1\\n    return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minDays(self, n: int) -> int:\\n    \\n    @lru_cache(None)\\n    def dp(n):\\n        if n == 1:\\n            return 1\\n        if n <= 3:\\n            return 2\\n        nMod3 = n%3\\n        nMod2 = n%2\\n        return 1 + min(nMod3 + dp(n//3), nMod2 + dp(n//2))\\n        \\n    return dp(n)\\n```\n```\\ndef minDays(self, n: int) -> int:\\n    que = deque([n])\\n    visited = set([n])\\n    ans = 0\\n    while que:\\n        Len = len(que)\\n        for _ in range(Len):\\n            c_node = que.popleft()\\n            if c_node == 1: return ans + 1\\n            if c_node%3 == 0 and c_node//3 not in visited:\\n                visited.add(c_node//3)\\n                que.append(c_node//3)\\n            if c_node%2 == 0 and c_node//2 not in visited:\\n                visited.add(c_node//2)\\n                que.append(c_node//2)\\n            if c_node - 1 not in visited:\\n                visited.add(c_node-1)\\n                que.append(c_node-1)\\n        \\n        ans += 1\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2703117,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    map<int,int> dp;\\n    \\n    \\n    int help(int n)\\n    {\\n        if(dp.count(n))\\n        {\\n            return dp[n];\\n        }\\n        \\n        int res = INT_MAX;\\n        \\n        if(n % 2 == 0)\\n        {\\n            res = min(res,help(n/2));\\n        }\\n        \\n        if(n % 3 == 0)\\n        {\\n            res = min(res,help(n/3));\\n        }\\n        \\n        if(n % 2 != 0 || n % 3 != 0)\\n        {\\n            res = min(res,help(n-1));\\n        }\\n        \\n        dp[n] = res+1;\\n        \\n        return dp[n];\\n    }\\n    \\n    int minDays(int n) \\n    {\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        \\n        return  help(n);\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    map<int,int> dp;\\n    \\n    \\n    int help(int n)\\n    {\\n        if(dp.count(n))\\n        {\\n            return dp[n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2693157,
                "title": "simple-java-solution-memoization-and-dpd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer,Integer> dp = new HashMap<>();\\n    public int minDays(int n) {\\n        dp.put(1,1);\\n        dp.put(2,2);\\n        dp.put(3,2);\\n        solve(n);\\n        return dp.get(n);\\n    }\\n    public int solve(int n){\\n        if(n <= 0) {\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(dp.containsKey(n)){\\n            return dp.get(n);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        if(n % 3 == 0){\\n            res = Math.min(res, 1 + solve(n/3));\\n        }\\n        if(n % 3 == 1){\\n            res = Math.min(res, 2 + solve(n/3));\\n        }\\n        if(n % 3 == 2){\\n            res = Math.min(res, 3 + solve(n/3));\\n        }\\n        if(n % 2 == 0){\\n            res = Math.min(res, 1 + solve(n/2));\\n        }\\n        if(n % 2 == 1){\\n            res = Math.min(res, 2 + solve(n/2));\\n        }\\n        dp.put(n, res);\\n        return dp.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> dp = new HashMap<>();\\n    public int minDays(int n) {\\n        dp.put(1,1);\\n        dp.put(2,2);\\n        dp.put(3,2);\\n        solve(n);\\n        return dp.get(n);\\n    }\\n    public int solve(int n){\\n        if(n <= 0) {\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(dp.containsKey(n)){\\n            return dp.get(n);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        if(n % 3 == 0){\\n            res = Math.min(res, 1 + solve(n/3));\\n        }\\n        if(n % 3 == 1){\\n            res = Math.min(res, 2 + solve(n/3));\\n        }\\n        if(n % 3 == 2){\\n            res = Math.min(res, 3 + solve(n/3));\\n        }\\n        if(n % 2 == 0){\\n            res = Math.min(res, 1 + solve(n/2));\\n        }\\n        if(n % 2 == 1){\\n            res = Math.min(res, 2 + solve(n/2));\\n        }\\n        dp.put(n, res);\\n        return dp.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620316,
                "title": "python-dfs-with-memoization",
                "content": "\\n```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        cache = {0 : 0, 1 : 1} # Memoization with bases cases of 0 and 1 days\\n        \\n        def dfs(days):\\n            if days in cache:\\n                return cache[days]\\n            \\n            # The remainder days % 2 will be 1 when the number\\n            # of days is odd. This accounts for the extra\\n            # day required in consuming an orange before we can\\n            # apply the \"even\" rule.\\n            # And similarly for days % 3.\\n            #\\n            # Further, the \"1 + \" accounts for the day\\n            # taken to consume either n / 2 or 2n / 3 oranges.\\n            even_path = 1 + (days % 2) + dfs(days // 2)\\n            otherwise = 1 + (days % 3) + dfs(days // 3)\\n            \\n            cache[days] = min(even_path, otherwise)\\n            \\n            return cache[days]\\n            \\n        return dfs(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        cache = {0 : 0, 1 : 1} # Memoization with bases cases of 0 and 1 days\\n        \\n        def dfs(days):\\n            if days in cache:\\n                return cache[days]\\n            \\n            # The remainder days % 2 will be 1 when the number\\n            # of days is odd. This accounts for the extra\\n            # day required in consuming an orange before we can\\n            # apply the \"even\" rule.\\n            # And similarly for days % 3.\\n            #\\n            # Further, the \"1 + \" accounts for the day\\n            # taken to consume either n / 2 or 2n / 3 oranges.\\n            even_path = 1 + (days % 2) + dfs(days // 2)\\n            otherwise = 1 + (days % 3) + dfs(days // 3)\\n            \\n            cache[days] = min(even_path, otherwise)\\n            \\n            return cache[days]\\n            \\n        return dfs(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610730,
                "title": "python-simple-queue-solution",
                "content": "Start with n oranges, from here you can have 3 possibilities i.e., n-1, n/2, or n/3 based on the conditions\\nOn every day include all the possibilities in the queue for BFS, process the oranges in queue in level order.\\n\\n```\\ndef minDays(self, n: int) -> int:\\n        queue = collections.deque([n])\\n        visited = set()\\n        day  = 0\\n        while queue:\\n            length = len(queue)\\n            day += 1\\n            for _ in range(length):\\n                o = queue.popleft()\\n                if o in visited:\\n                    continue\\n                    \\n                visited.add(o)\\n                if o == 1:\\n                    return day\\n                \\n                if o%3 == 0:\\n                    queue.append(o/3)\\n                if o%2 == 0:\\n                    queue.append(o/2)\\n                queue.append(o-1)\\n        return day\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minDays(self, n: int) -> int:\\n        queue = collections.deque([n])\\n        visited = set()\\n        day  = 0\\n        while queue:\\n            length = len(queue)\\n            day += 1\\n            for _ in range(length):\\n                o = queue.popleft()\\n                if o in visited:\\n                    continue\\n                    \\n                visited.add(o)\\n                if o == 1:\\n                    return day\\n                \\n                if o%3 == 0:\\n                    queue.append(o/3)\\n                if o%2 == 0:\\n                    queue.append(o/2)\\n                queue.append(o-1)\\n        return day\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2607615,
                "title": "python-simple-bfs",
                "content": "\\n    def minDays(self, n):\\n        stack, total, visited = [n], 0, set()\\n        \\n        while stack:\\n            total += 1\\n            \\n            for _ in range(len(stack)):\\n                node = stack.pop(0)\\n                \\n                if node == 1:\\n                    return total\\n                \\n                if node%3 == 0 and node%3 not in visited:\\n                    stack.append(node//3)\\n                    visited.add(node//3)\\n                    \\n                if node%2 == 0 and node%2 not in visited:\\n                    stack.append(node//2)\\n                    visited.add(node//2)\\n                    \\n                if node - 1 not in visited:\\n                    stack.append(node-1)\\n                    visited.add(node-1)",
                "solutionTags": [],
                "code": "\\n    def minDays(self, n):\\n        stack, total, visited = [n], 0, set()\\n        \\n        while stack:\\n            total += 1\\n            \\n            for _ in range(len(stack)):\\n                node = stack.pop(0)\\n                \\n                if node == 1:\\n                    return total\\n                \\n                if node%3 == 0 and node%3 not in visited:\\n                    stack.append(node//3)\\n                    visited.add(node//3)\\n                    \\n                if node%2 == 0 and node%2 not in visited:\\n                    stack.append(node//2)\\n                    visited.add(node//2)\\n                    \\n                if node - 1 not in visited:\\n                    stack.append(node-1)\\n                    visited.add(node-1)",
                "codeTag": "Python3"
            },
            {
                "id": 2578896,
                "title": "most-optimal-c-easy-aproach-memoization",
                "content": "```\\nclass Solution {\\n    int minDayz(int n, unordered_map<int, int>& map){\\n        /// Base cases...\\n        if(n < 3) return n;\\n        ////   Previous calculation checking...!\\n        if(map.find(n) != map.end())\\n            return map[n];\\n        \\n        ///   answer by eating (2*n)/3 oranges..\\n        int div3 = minDayz(n/3, map) + 1;\\n        div3 += n%3;  ///  eating one oranges if n is not div by 3.... \\n        \\n        ///   answer by eating n/2 oranges...\\n        int div2 = minDayz(n/2, map) + 1;\\n        div2 += n&1; ///   if n is not odd.. we\\'ve to eat one orange today...!\\n        ///   final ans\\n        return map[n] = min(div3, div2);\\n        \\n    }\\npublic:\\n    int minDays(int n) {\\n        //  Memoization...!!   using map for a little space optimization..:)\\n        unordered_map<int, int> map;\\n        return minDayz(n, map);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int minDayz(int n, unordered_map<int, int>& map){\\n        /// Base cases...\\n        if(n < 3) return n;\\n        ////   Previous calculation checking...!\\n        if(map.find(n) != map.end())\\n            return map[n];\\n        \\n        ///   answer by eating (2*n)/3 oranges..\\n        int div3 = minDayz(n/3, map) + 1;\\n        div3 += n%3;  ///  eating one oranges if n is not div by 3.... \\n        \\n        ///   answer by eating n/2 oranges...\\n        int div2 = minDayz(n/2, map) + 1;\\n        div2 += n&1; ///   if n is not odd.. we\\'ve to eat one orange today...!\\n        ///   final ans\\n        return map[n] = min(div3, div2);\\n        \\n    }\\npublic:\\n    int minDays(int n) {\\n        //  Memoization...!!   using map for a little space optimization..:)\\n        unordered_map<int, int> map;\\n        return minDayz(n, map);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568645,
                "title": "java-bfs",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minDays(int n) {\\n\\t\\t\\tQueue<Integer> queue = new ArrayDeque<>();\\n\\t\\t\\tqueue.offer(n);\\n\\t\\t\\tint dist = 0;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tseen.add(n);\\n\\t\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\t\\tint cur = queue.poll();\\n\\t\\t\\t\\t\\tif (!seen.contains(cur - 1)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(cur - 1);\\n\\t\\t\\t\\t\\t\\tseen.add(cur - 1);\\n\\t\\t\\t\\t\\t\\tif (cur - 1 == 0) {\\n\\t\\t\\t\\t\\t\\t\\treturn dist;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (cur % 2 == 0 && !seen.contains(cur / 2)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(cur / 2);\\n\\t\\t\\t\\t\\t\\tseen.add(cur / 2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (cur % 3 == 0 && !seen.contains(cur / 3)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(cur / 3);\\n\\t\\t\\t\\t\\t\\tseen.add(cur / 3);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minDays(int n) {\\n\\t\\t\\tQueue<Integer> queue = new ArrayDeque<>();\\n\\t\\t\\tqueue.offer(n);\\n\\t\\t\\tint dist = 0;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tseen.add(n);\\n\\t\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\t\\tint cur = queue.poll();\\n\\t\\t\\t\\t\\tif (!seen.contains(cur - 1)) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(cur - 1);\\n\\t\\t\\t\\t\\t\\tseen.add(cur - 1);\\n\\t\\t\\t\\t\\t\\tif (cur - 1 == 0) {\\n\\t\\t\\t\\t\\t\\t\\treturn dist;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2536738,
                "title": "c-dfs-with-memoization",
                "content": "```csharp\\npublic int MinDays(int n) {\\n\\tDictionary<int, int> memo = new();\\n\\treturn dfs(n);\\n\\n\\tint dfs(int cur) {\\n\\t\\tif (cur == 0) return 0;\\n\\t\\tif (cur == 1) return 1;\\n\\t\\tif (memo.TryGetValue(cur, out int memoVal)) return memoVal;\\n\\n\\t\\t// n == 5 => (5 % 3) + dfs(5/3) => 2 + dfs(3) => 2 + 1;\\n\\t\\tint div3 = (cur % 3) + dfs(cur/3); // (n%3) - it means how many time we should eat one, to get number divisible by 3\\n\\t\\tint div2 = (cur % 2) + dfs(cur/2);\\n\\t\\tmemo[cur] = 1 + Math.Min(div2, div3);\\n\\t\\treturn memo[cur];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```csharp\\npublic int MinDays(int n) {\\n\\tDictionary<int, int> memo = new();\\n\\treturn dfs(n);\\n\\n\\tint dfs(int cur) {\\n\\t\\tif (cur == 0) return 0;\\n\\t\\tif (cur == 1) return 1;\\n\\t\\tif (memo.TryGetValue(cur, out int memoVal)) return memoVal;\\n\\n\\t\\t// n == 5 => (5 % 3) + dfs(5/3) => 2 + dfs(3) => 2 + 1;\\n\\t\\tint div3 = (cur % 3) + dfs(cur/3); // (n%3) - it means how many time we should eat one, to get number divisible by 3\\n\\t\\tint div2 = (cur % 2) + dfs(cur/2);\\n\\t\\tmemo[cur] = 1 + Math.Min(div2, div3);\\n\\t\\treturn memo[cur];\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2535828,
                "title": "c-recursion-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> numToDays;\\n\\npublic:\\n    int minDays(int n) {\\n        if (n == 0 || n == 1)\\n            return n;\\n        if (numToDays.find(n) != numToDays.end()) {\\n            return numToDays[n];\\n        }\\n\\n        int count1 = 1;\\n        int delta = n % 2;\\n        int leftDays = n - n / 2 - delta;\\n        count1 += delta + minDays(leftDays);\\n\\n        int count2 = 1;\\n        delta = n % 3;\\n        leftDays = n - 2 * (n / 3) - delta;\\n        count2 += delta + minDays(leftDays);\\n\\n        numToDays[n] = min(count1, count2);\\n\\n        return numToDays[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> numToDays;\\n\\npublic:\\n    int minDays(int n) {\\n        if (n == 0 || n == 1)\\n            return n;\\n        if (numToDays.find(n) != numToDays.end()) {\\n            return numToDays[n];\\n        }\\n\\n        int count1 = 1;\\n        int delta = n % 2;\\n        int leftDays = n - n / 2 - delta;\\n        count1 += delta + minDays(leftDays);\\n\\n        int count2 = 1;\\n        delta = n % 3;\\n        leftDays = n - 2 * (n / 3) - delta;\\n        count2 += delta + minDays(leftDays);\\n\\n        numToDays[n] = min(count1, count2);\\n\\n        return numToDays[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463187,
                "title": "c-memoized-o-log-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> min_day;\\n    int minDays(int n) {\\n        if(n <= 1)\\n        {\\n            return n;\\n        }\\n        if(min_day.count(n)>0)\\n        {\\n            return min_day[n];\\n        }\\n        else\\n        {\\n            min_day[n] =  1 + min((n%2) + minDays(n/2),(n%3) + minDays(n/3));\\n            return min_day[n];\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    map<int,int> min_day;\\n    int minDays(int n) {\\n        if(n <= 1)\\n        {\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2428211,
                "title": "c-dp-solution-beats-75-47",
                "content": "```\\nclass Solution {\\n    vector<int> dp; // To handle base cases when n is very small\\n    unordered_map<int, int> mp; // main memo table to store ans\\n    \\npublic:\\n    int getmp(int n){\\n        if(n<dp.size())\\n            return dp[n];\\n        if(mp[n]!=0)\\n            return mp[n];\\n        \\n        int ans1 = getmp(n/2)+1, ans2=0;\\n        if(n%2==1)\\n            ans1++;\\n        \\n        if(n%3==0)\\n            ans2 = getmp(n/3)+1;\\n        else\\n            ans2 = getmp(n-1)+1;\\n        \\n        return mp[n] = min(ans1, ans2);\\n    }\\n    \\n    int minDays(int n) {\\n        int ans=0;\\n        dp.resize(3, 1);\\n        for(int i=2; i<dp.size(); i++){\\n            if(i%6==0)\\n                dp[i] = min(dp[i-1], min(dp[i/2], dp[i/3]))+1;\\n            else if(i%2==0)\\n                dp[i] = min(dp[i-1], dp[i/2])+1;\\n            else if(i%3==0)\\n                dp[i] = min(dp[i-1], dp[i/3])+1;\\n            else \\n                dp[i] = dp[i-1]+1;\\n        }\\n        \\n        ans = getmp(n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dp; // To handle base cases when n is very small\\n    unordered_map<int, int> mp; // main memo table to store ans\\n    \\npublic:\\n    int getmp(int n){\\n        if(n<dp.size())\\n            return dp[n];\\n        if(mp[n]!=0)\\n            return mp[n];\\n        \\n        int ans1 = getmp(n/2)+1, ans2=0;\\n        if(n%2==1)\\n            ans1++;\\n        \\n        if(n%3==0)\\n            ans2 = getmp(n/3)+1;\\n        else\\n            ans2 = getmp(n-1)+1;\\n        \\n        return mp[n] = min(ans1, ans2);\\n    }\\n    \\n    int minDays(int n) {\\n        int ans=0;\\n        dp.resize(3, 1);\\n        for(int i=2; i<dp.size(); i++){\\n            if(i%6==0)\\n                dp[i] = min(dp[i-1], min(dp[i/2], dp[i/3]))+1;\\n            else if(i%2==0)\\n                dp[i] = min(dp[i-1], dp[i/2])+1;\\n            else if(i%3==0)\\n                dp[i] = min(dp[i-1], dp[i/3])+1;\\n            else \\n                dp[i] = dp[i-1]+1;\\n        }\\n        \\n        ans = getmp(n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400487,
                "title": "95-fast-and-easy-code-explained",
                "content": "```\\nunordered_map<int,int> t;\\n    int solve(int n)\\n    {\\n\\t// base case\\n        if(n==0 || n==1)\\n            return n;\\n\\t\\t\\t// if you already had saved result for the value of n\\n        if(t.find(n)!=t.end())  return t[n];\\n        int x,y;\\n\\t\\t// if n is divisble by 6 then dont need to check for 2 or 3 becuause it if a number id divisble by 6 then it will return <= the answer for 2 and 3 divisibility\\n        if(n%6==0)\\n            return t[n] = 1 + solve(n/3);\\n\\t\\t\\t// check for 2 and 3 \\n\\t\\t\\t// if number os ot divisble then simply add the left remainder\\n        y = (n%2) + solve(n/2);\\n        x = (n%3) + solve(n/3);\\n        return t[n] = 1 + min(x,y);\\n    }\\n    int minDays(int n) {\\n        return solve(n);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nunordered_map<int,int> t;\\n    int solve(int n)\\n    {\\n\\t// base case\\n        if(n==0 || n==1)\\n            return n;\\n\\t\\t\\t// if you already had saved result for the value of n\\n        if(t.find(n)!=t.end())  return t[n];\\n        int x,y;\\n\\t\\t// if n is divisble by 6 then dont need to check for 2 or 3 becuause it if a number id divisble by 6 then it will return <= the answer for 2 and 3 divisibility\\n        if(n%6==0)\\n            return t[n] = 1 + solve(n/3);\\n\\t\\t\\t// check for 2 and 3 \\n\\t\\t\\t// if number os ot divisble then simply add the left remainder\\n        y = (n%2) + solve(n/2);\\n        x = (n%3) + solve(n/3);\\n        return t[n] = 1 + min(x,y);\\n    }\\n    int minDays(int n) {\\n        return solve(n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2331841,
                "title": "runtime-6-ms-faster-than-82-40-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Integer>map;\\n    public int minDays(int n) {\\n        map = new HashMap<>();\\n        map.put(0,0);\\n        map.put(1,1);\\n        return dp(n);\\n    }\\n    public int dp(int n){\\n        if(map.get(n)!=null)\\n            return map.get(n);\\n         int one = 1+(n%2)+dp(n/2);\\n         int two = 1+(n%3)+dp(n/3);\\n        map.put(n,Math.min(one,two));\\n        return map.get(n);\\n} \\n    }\\n        // int one = 1+(n%2)+cache(n/2);\\n        // int two = 1+(n%3)+cache(n/3);\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer>map;\\n    public int minDays(int n) {\\n        map = new HashMap<>();\\n        map.put(0,0);\\n        map.put(1,1);\\n        return dp(n);\\n    }\\n    public int dp(int n){\\n        if(map.get(n)!=null)\\n            return map.get(n);\\n         int one = 1+(n%2)+dp(n/2);\\n         int two = 1+(n%3)+dp(n/3);\\n        map.put(n,Math.min(one,two));\\n        return map.get(n);\\n} \\n    }\\n        // int one = 1+(n%2)+cache(n/2);\\n        // int two = 1+(n%3)+cache(n/3);\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273735,
                "title": "c-3-lines",
                "content": "```\\n\\n\\n    class Solution\\n{\\npublic:\\nunordered_map<int,int> dp;\\n   \\n    int minDays(int n)\\n    {\\n       \\n        if (n <= 0 || n==1)\\n            return n;\\n\\n        if(dp.count(n))\\n            return dp[n];\\n\\n\\n        return dp[n]= min(1 + (n % 2) + minDays(n / 2), 1 + (n % 3) + minDays(n / 3));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n    class Solution\\n{\\npublic:\\nunordered_map<int,int> dp;\\n   \\n    int minDays(int n)\\n    {\\n       \\n        if (n <= 0 || n==1)\\n            return n;\\n\\n        if(dp.count(n))\\n            return dp[n];\\n\\n\\n        return dp[n]= min(1 + (n % 2) + minDays(n / 2), 1 + (n % 3) + minDays(n / 3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269441,
                "title": "python-logn-cache",
                "content": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @cache\\n        def dfs(n):\\n            if n == 0:\\n                return 0\\n            if n == 1:\\n                return 1\\n            \\n            return min(1 + n % 2 + dfs(n // 2), 1 + n % 3 + dfs(n // 3))\\n        \\n        return dfs(n)",
                "solutionTags": [],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n        \\n        @cache\\n        def dfs(n):\\n            if n == 0:\\n                return 0\\n            if n == 1:\\n                return 1\\n            \\n            return min(1 + n % 2 + dfs(n // 2), 1 + n % 3 + dfs(n // 3))\\n        \\n        return dfs(n)",
                "codeTag": "Java"
            },
            {
                "id": 2192745,
                "title": "a-search",
                "content": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n    \\n        def herustic(i):\\n            return n-i\\n        \\n        q=[]\\n        heappush(q,(herustic(0),n,0))\\n        #bfs or A* or djikstra,number of oranges, step\\n        visited={(n,0)}\\n        while q:\\n            weight,remain,step=heappop(q)\\n            if remain==0:\\n                return step\\n            # 3 choices\\n            if (remain-1,step+1) not in visited:\\n                visited.add((remain-1,step+1))\\n                heappush(q,(herustic(1)+step+1,remain-1,step+1))\\n            if remain%2==0 and (remain-remain//2,step+1) not in visited:\\n                visited.add((remain-remain//2,step+1))\\n                heappush(q,(herustic(remain//2)+step+1,remain-remain//2,step+1))\\n            if remain%3==0 and (remain-2*(remain//3),step+1) not in visited:\\n                visited.add((remain-2*(remain//3),step+1))\\n                heappush(q,(herustic(2*(remain//3))+step+1,remain-2*(remain//3),step+1))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def minDays(self, n: int) -> int:\\n    \\n        def herustic(i):\\n            return n-i\\n        \\n        q=[]\\n        heappush(q,(herustic(0),n,0))\\n        #bfs or A* or djikstra,number of oranges, step\\n        visited={(n,0)}\\n        while q:\\n            weight,remain,step=heappop(q)\\n            if remain==0:\\n                return step\\n            # 3 choices\\n            if (remain-1,step+1) not in visited:\\n                visited.add((remain-1,step+1))\\n                heappush(q,(herustic(1)+step+1,remain-1,step+1))\\n            if remain%2==0 and (remain-remain//2,step+1) not in visited:\\n                visited.add((remain-remain//2,step+1))\\n                heappush(q,(herustic(remain//2)+step+1,remain-remain//2,step+1))\\n            if remain%3==0 and (remain-2*(remain//3),step+1) not in visited:\\n                visited.add((remain-2*(remain//3),step+1))\\n                heappush(q,(herustic(2*(remain//3))+step+1,remain-2*(remain//3),step+1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120418,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        // 0. corner cases\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        // 1. init\\n        Map<Integer, Integer> distances = new HashMap<>();\\n        distances.put(n, 0);\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(n);\\n        \\n        // 2. BFS \\n        while (!queue.isEmpty()) {\\n            int cur = queue.poll();\\n            int days = distances.get(cur);\\n            \\n            for (int remaining : getOptions(cur)) {\\n                if (distances.containsKey(remaining)) {\\n                    continue;\\n                }\\n                if (remaining == 0) {\\n                    return days + 1;\\n                }\\n                if (remaining == 1) {\\n                    return days + 2;\\n                }\\n                distances.put(remaining, days + 1);\\n                queue.add(remaining);\\n            }\\n        }\\n        \\n        return -1; // impossible\\n    }\\n    \\n    List<Integer> getOptions(int n){\\n        List<Integer> options = new ArrayList<>();\\n        options.add(n - 1);\\n        if (n % 2 == 0){\\n            options.add(n / 2);\\n        }\\n        if (n % 3 == 0){\\n            options.add(n / 3);\\n        }\\n        \\n        return options;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int n) {\\n        // 0. corner cases\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        // 1. init\\n        Map<Integer, Integer> distances = new HashMap<>();\\n        distances.put(n, 0);\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(n);\\n        \\n        // 2. BFS \\n        while (!queue.isEmpty()) {\\n            int cur = queue.poll();\\n            int days = distances.get(cur);\\n            \\n            for (int remaining : getOptions(cur)) {\\n                if (distances.containsKey(remaining)) {\\n                    continue;\\n                }\\n                if (remaining == 0) {\\n                    return days + 1;\\n                }\\n                if (remaining == 1) {\\n                    return days + 2;\\n                }\\n                distances.put(remaining, days + 1);\\n                queue.add(remaining);\\n            }\\n        }\\n        \\n        return -1; // impossible\\n    }\\n    \\n    List<Integer> getOptions(int n){\\n        List<Integer> options = new ArrayList<>();\\n        options.add(n - 1);\\n        if (n % 2 == 0){\\n            options.add(n / 2);\\n        }\\n        if (n % 3 == 0){\\n            options.add(n / 3);\\n        }\\n        \\n        return options;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107308,
                "title": "actual-readable-javascript-solution-using-a-queue",
                "content": "// Didn\\'t see any JS solutions for this one, so here\\'s mine. Hope this helps someone.\\n```\\nvar minDays = function(n) {\\n    const queue = [ [n,0] ];\\n    const visited = new Set();\\n    \\n    while (queue.length > 0) {\\n        const [ orangesLeft, days ] = queue.shift();\\n        \\n        if (visited.has(orangesLeft)) continue;\\n        if (orangesLeft === 0) return days;\\n        \\n        visited.add(orangesLeft);\\n        queue.push([orangesLeft - 1, days + 1]);\\n        \\n        if (orangesLeft % 2 === 0) {\\n            queue.push([orangesLeft - orangesLeft / 2, days + 1]);\\n        }\\n        \\n        if (orangesLeft % 3 === 0) {\\n            queue.push([orangesLeft - 2 * (orangesLeft / 3), days + 1])\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDays = function(n) {\\n    const queue = [ [n,0] ];\\n    const visited = new Set();\\n    \\n    while (queue.length > 0) {\\n        const [ orangesLeft, days ] = queue.shift();\\n        \\n        if (visited.has(orangesLeft)) continue;\\n        if (orangesLeft === 0) return days;\\n        \\n        visited.add(orangesLeft);\\n        queue.push([orangesLeft - 1, days + 1]);\\n        \\n        if (orangesLeft % 2 === 0) {\\n            queue.push([orangesLeft - orangesLeft / 2, days + 1]);\\n        }\\n        \\n        if (orangesLeft % 3 === 0) {\\n            queue.push([orangesLeft - 2 * (orangesLeft / 3), days + 1])\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1896049,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 1950215,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 2056681,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 2018564,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 1993255,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 1945190,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            },
            {
                "id": 1903341,
                "content": [
                    {
                        "username": "daniellin110",
                        "content": "The hint basically gives the solution away"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Agreed, I love a good hint but this hint just tells you the answer in pretty explicit terms."
                    },
                    {
                        "username": "_BackTracker_",
                        "content": "TLE in 116th case!"
                    },
                    {
                        "username": "PeterMoraStevens",
                        "content": "Idk if I just got lucky, but to avoid TLE with a bfs solution, I used a visited set to prune my decision tree, helps reduce repeated work."
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Think of n as root node and each possible remaining apples according to conditions as neighboring nodes. Start BFS from n and you\\'ll get the shortest path from n to 0, which will be your minDays."
                    },
                    {
                        "username": "NickParzival",
                        "content": "i too tried the same idea but got a tle"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Difficulty is medium at best"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 130th testcase"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Someone please explain me time complexity of DP solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "How many times do we (integer) divide a number by 2 before it becomes 1? How many times do we (integer) divide a number by 3 before it becomes 1? Which one takes more divisions and therefore more time? That is your answer. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Flips to Make the Binary String Alternating",
        "question_content": "<p>You are given a binary string <code>s</code>. You are allowed to perform two types of operations on the string in any sequence:</p>\n\n<ul>\n\t<li><strong>Type-1: Remove</strong> the character at the start of the string <code>s</code> and <strong>append</strong> it to the end of the string.</li>\n\t<li><strong>Type-2: Pick</strong> any character in <code>s</code> and <strong>flip</strong> its value, i.e., if its value is <code>&#39;0&#39;</code> it becomes <code>&#39;1&#39;</code> and vice-versa.</li>\n</ul>\n\n<p>Return <em>the <strong>minimum</strong> number of <strong>type-2</strong> operations you need to perform</em> <em>such that </em><code>s</code> <em>becomes <strong>alternating</strong>.</em></p>\n\n<p>The string is called <strong>alternating</strong> if no two adjacent characters are equal.</p>\n\n<ul>\n\t<li>For example, the strings <code>&quot;010&quot;</code> and <code>&quot;1010&quot;</code> are alternating, while the string <code>&quot;0100&quot;</code> is not.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;111000&quot;\n<strong>Output:</strong> 2\n<strong>Explanation</strong>: Use the first operation two times to make s = &quot;100011&quot;.\nThen, use the second operation on the third and sixth elements to make s = &quot;10<u>1</u>01<u>0</u>&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;010&quot;\n<strong>Output:</strong> 0\n<strong>Explanation</strong>: The string is already alternating.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1110&quot;\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: Use the second operation on the second element to make s = &quot;1<u>0</u>10&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1253874,
                "title": "c-solution-sliding-window-o-n-time-o-1-space",
                "content": "\\n### Idea\\n- For the 1st operation, we can simply do `s += s` to append the whole string to the end. \\n- then we make two different string with the same length by `01` and `10` alternative. for example: s = `11100`\\n    - `do s += s`:  s = `1110011100`\\n    - `goal 1`:  s1= `1010101010`\\n    - `goal 2`:  s2= `0101010101`\\n- finally, use sliding window\\uFF08size n\\uFF09to compare s to both s1 and s2.\\n- why we can double s to fullfil the first operation, let\\'s look at the same example  s = `11100`:`\\n\\t- double s: `1110011100`\\n\\t- size n window: |11100|11100 ==>  1|11001|1100 ==> 11|10011|100 and so on, when we move one step of the sliding window, it is the same to append 1 more element from beginning.\\n### Time complexity\\n- Time O(N)\\n- Space O(N) ==> O(1)\\n\\n### Solution\\n\\n- C++, O(N) space is easier to understand.\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        string s1, s2;\\n        \\n        for(int i = 0; i < s.size(); i++) {\\n            s1 += i % 2 ? \\'0\\' : \\'1\\';\\n            s2 += i % 2 ? \\'1\\' : \\'0\\';\\n        }\\n        int ans1 = 0, ans2 = 0, ans = INT_MAX;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s1[i] != s[i]) ++ans1;\\n            if(s2[i] != s[i]) ++ans2;\\n            if(i >= n) { //the most left element is outside of sliding window, we need to subtract the ans if we did `flip` before.\\n                if(s1[i - n] != s[i - n]) --ans1;\\n                if(s2[i - n] != s[i - n]) --ans2;\\n            }\\n            if(i >= n - 1)\\n                ans = min({ans1, ans2, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n- base on above solution, we can come up with O(1) space solution.\\n```\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans1 = 0, ans2 = 0, ans = INT_MAX;\\n        for(int i = 0; i < 2 * n; i++) {\\n            if(i < n) s[i] -= \\'0\\'; //make \\'1\\' and \\'0\\' to be integer 1 and 0.\\n            if(i % 2 != s[i % n]) ++ans1;\\n            if((i + 1) % 2 != s[i % n]) ++ans2;\\n            if(i >= n) {\\n                if((i - n) % 2 != s[i - n]) --ans1;\\n                if((i - n + 1) % 2 != s[i - n]) --ans2;\\n            }\\n            if(i >= n - 1)\\n                ans = min({ans1, ans2, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        string s1, s2;\\n        \\n        for(int i = 0; i < s.size(); i++) {\\n            s1 += i % 2 ? \\'0\\' : \\'1\\';\\n            s2 += i % 2 ? \\'1\\' : \\'0\\';\\n        }\\n        int ans1 = 0, ans2 = 0, ans = INT_MAX;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s1[i] != s[i]) ++ans1;\\n            if(s2[i] != s[i]) ++ans2;\\n            if(i >= n) { //the most left element is outside of sliding window, we need to subtract the ans if we did `flip` before.\\n                if(s1[i - n] != s[i - n]) --ans1;\\n                if(s2[i - n] != s[i - n]) --ans2;\\n            }\\n            if(i >= n - 1)\\n                ans = min({ans1, ans2, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans1 = 0, ans2 = 0, ans = INT_MAX;\\n        for(int i = 0; i < 2 * n; i++) {\\n            if(i < n) s[i] -= \\'0\\'; //make \\'1\\' and \\'0\\' to be integer 1 and 0.\\n            if(i % 2 != s[i % n]) ++ans1;\\n            if((i + 1) % 2 != s[i % n]) ++ans2;\\n            if(i >= n) {\\n                if((i - n) % 2 != s[i - n]) --ans1;\\n                if((i - n + 1) % 2 != s[i - n]) --ans2;\\n            }\\n            if(i >= n - 1)\\n                ans = min({ans1, ans2, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253886,
                "title": "c-o-n-time-o-1-space-concise-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        vector<vector<int> > cnt(2, vector<int>(2, 0));\\n        \\n        // cnt[0][0] = number of \\'0\\' in even positions\\n        // cnt[0][1] = number of \\'0\\' in odd  positions\\n        // cnt[1][0] = number of \\'1\\' in even positions\\n        // cnt[1][1] = number of \\'1\\' in odd  positions\\n        \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]++;\\n        }\\n        int ans=cnt[1][0]+cnt[0][1]; // cost to make all \\'0\\' in even positions and all \\'1\\' in odd positions\\n        ans=min(ans, cnt[0][0]+cnt[1][1]); // cost to make all \\'1\\' in even positions and all \\'0\\' in odd positions\\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]--;\\n            cnt[s[i]-\\'0\\'][(n+i)%2]++; // sending this character at the end of the string\\n            ans=min(ans, cnt[1][0]+cnt[0][1]);\\n            ans=min(ans, cnt[0][0]+cnt[1][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        vector<vector<int> > cnt(2, vector<int>(2, 0));\\n        \\n        // cnt[0][0] = number of \\'0\\' in even positions\\n        // cnt[0][1] = number of \\'0\\' in odd  positions\\n        // cnt[1][0] = number of \\'1\\' in even positions\\n        // cnt[1][1] = number of \\'1\\' in odd  positions\\n        \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]++;\\n        }\\n        int ans=cnt[1][0]+cnt[0][1]; // cost to make all \\'0\\' in even positions and all \\'1\\' in odd positions\\n        ans=min(ans, cnt[0][0]+cnt[1][1]); // cost to make all \\'1\\' in even positions and all \\'0\\' in odd positions\\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]--;\\n            cnt[s[i]-\\'0\\'][(n+i)%2]++; // sending this character at the end of the string\\n            ans=min(ans, cnt[1][0]+cnt[0][1]);\\n            ans=min(ans, cnt[0][0]+cnt[1][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254148,
                "title": "sliding-window",
                "content": "The alternating string can start with \\'0\\' or \\'1\\'. We count how many replancements we need for these two cases in `s0` and `s1`.\\n\\nBut do not stop there. Since we can rotate our string, keep going and counting. However, this time we need to discard (subtract) missmatches that occurred before the rotated string. This can be done using the sliding window approach.\\n\\n**C++**\\n```cpp\\nint minFlips(string s) {\\n    int res = INT_MAX, s0 = 0, s1 = 0, sz = s.size();\\n    for (int i = 0; i < 2 * sz; ++i) {\\n        s0 += s[i % sz] != \\'0\\' + i % 2;\\n        s1 += s[i % sz] != \\'0\\' + (1 - i % 2);\\n        if (i >= sz - 1) {\\n            if (i >= sz) {\\n                s0 -= s[i - sz] != \\'0\\' + (i - sz) % 2;\\n                s1 -= s[i - sz] != \\'0\\' + (1 - (i - sz) % 2);\\n            }\\n            res = min(res, min(s0, s1));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minFlips(string s) {\\n    int res = INT_MAX, s0 = 0, s1 = 0, sz = s.size();\\n    for (int i = 0; i < 2 * sz; ++i) {\\n        s0 += s[i % sz] != \\'0\\' + i % 2;\\n        s1 += s[i % sz] != \\'0\\' + (1 - i % 2);\\n        if (i >= sz - 1) {\\n            if (i >= sz) {\\n                s0 -= s[i - sz] != \\'0\\' + (i - sz) % 2;\\n                s1 -= s[i - sz] != \\'0\\' + (1 - (i - sz) % 2);\\n            }\\n            res = min(res, min(s0, s1));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613715,
                "title": "python-fixed-size-sliding-window-explained",
                "content": "For me it was quite a tricky question to understand but thanks to some help from Leetcode Discussion and YouTube, I got the main idea of this problem. And Now I feel too dumb to not get it myself xD\\n\\nAnyways, here is an explanation of what we have to do. \\n\\nWe are given a binary string and we want to make it alternating. Alternating means each 0 after each 1 and 1 after each 0. e.g. for a binary string of length = 3, we have two valid alternating string -> 101 and 010. In fact, for every length, there are only two valid alternting strings which is obvious because there are only two types of numbers in a binary string - 1 and 0.\\n\\nFor a moment, forget that type-1 operation exists. Just think that we are given a string and we can flip a bit. We want to find minimum number of flips we can do so that this string is alternating. How will you do it? Will you take each bit, flip it and check if that makes string alternating? Ofcourse not. \\n\\nBecause we know that for any length, there are only two valid alternating strings, we can simply compare each position with each valid string. And if the number at that position differs, we need to flip. In other words -\\n\\n\\t\\tMinimum Number of Flips = Minimum Number of differences between given string and valid strings\\n\\n\\t\\tlets say s = \"111000\"\\n\\nSince length is 6, what are the valid alternating binary strings of length 6? They are \\n\\t\\t\\n\\t\\t\\tvalid1 = \"101010\"\\n\\t\\t\\tvalid2 = \"010101\"\\n\\nSo, lets compare s with valid1 first\\n\\n\\t\\t\\ts =      \"111000\"\\n\\t\\t\\tvalid1 = \"101010\"\\n\\t\\t\\t\\n\\t\\t\\tFor each position in s, check what is the value at same position in valid1. If they are not same, we need to flip.\\n\\t\\t\\t\\n\\t\\t\\tSo we get differences = 2\\n\\t\\nNow lets compare s with valid2\\n\\t\\t\\t\\n\\t\\t\\ts =      \"111000\"\\n\\t\\t\\tvalid1 = \"010101\"\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tWe get differences = 4\\n\\t\\t\\t\\nSo that means, we can simply flip 2 bits to make the string alternating such that it starts with 1, instead of flipping 4 bits such that it starts with 0.\\n\\nNow we add in the type-1 operation. It says that we can take a character from beginning of string \"s\" and add it to the end of it in order to minimize the flips. What that means?\\n\\n\\tLets say we performed type-1 operation once on s = \"111000\"\\n\\tThen the first \"1\" will be moved to end. So string will become \"110001\"\\n\\t\\n\\tAnd now again, we have to do the same thing as above \\n\\ti.e., compare it with valid1 and valid2 to see which one results in least difference.\\n\\t\\nWhat is the maximum number of type-1 operations we can do? It is equal to length of string. Why? Because if we take the whole string and append it to itself, that means we get the same string in return.\\n\\n\\ts = \"111000\" \\n\\t1 type-1 operation, s = \"110001\"\\n\\t2 type-1 operations, s = \"100011\"\\n\\t3 type-1 operations, s = \"000111\"\\n\\t4 type-1 operations, s = \"001110\"\\n\\t5 type-1 operations, s = \"011100\"\\n\\t6 type-1 operations, s = \"111000\" => Back to original\\n\\t\\nSo it makes no sense to go above 6 in this case as we would be doing the same work again. \\n\\nSo that means, instead of manually taking each character and moving it to end, why not we double the given string \"s\" .\\n\\n\\ts = \"111000\" to s + s\\n\\tsuch that new s => \"111000111000\"\\n\\t\\n\\tAnd now, each window of size = 6 represents each type-1 operation.\\n\\t\\n\\tFirst window of size 6 -> \"111000\"\\n\\tSecond window of size 6 -> \"110001\"\\n\\tThird window of size 6 -> \"100011\"\\n\\tFourth window of size 6 -> \"000111\"\\n\\tFifth window of size 6 -> \"001110\"\\n\\tSixth window of size 6 -> \"011100\"\\n\\tSeventh window of size 6 -> \"111000\" => Back to original\\n\\t\\nSo we had to do no extra work to take each character from beginning and move it to end.\\n\\nAnd now. Just think how we were comparing the string with valid1 and valid2.\\n\\n\\t\\ts =      \"111000\"\\n\\t\\tvalid1 = \"101010\"\\n\\t\\tDifferences = 2\\n\\t\\t\\nWhen we take a character out from \"s\" and move it to end, then that means, we need to do the same with valid1 right? Because we won\\'t be recalculating the whole difference again when only one character has changed. \\n\\nIn other words, as we slide the window, all that we are doing is just check the one extra character that we added at the end and also before sliding the window remove all the calculations for that character.\\n\\t\\t\\nAnd the rest, is a general sliding window template.\\n\\nYou might be thinking does type-1 operation even helps in minimizing the flips? Because for above example, even if we don\\'t do type-1 operation, we get 2 minimum flips. And after doing as well, we get 2.  Yes, you are right. For some strings, this doubling of strings is not required at all. That\\'s the case with even number of characters in a given string. So, if length of string is even, there is no need to double the string. But  when there is an odd number, we may get a minimum value after doing type-1 operation. Try with s = \"11100\" you will understand.\\n\\nBecause in \"11100\" if we take four characters from beginning and append them to end we get \"01110\\' ANd now, all we need to do is 1 flip for the 1 at the center to make it \"01010\". So minimum Flips = 1\\n\\nBut had we not done the type-1 operation at all, then minimum flips would be 2. i.e., flipping the 2nd \"1\" and last \"0\" to get \"10101\"\\n\\n\\n```\\ndef minFlips(self, s: str) -> int:\\n        # Minimum number of flips to return\\n        minimumFlips = len(s)\\n        \\n        # Window Size\\n        k = len(s)\\n        \\n        # For strings of odd length, double them\\n        # So that we do not have to manually perform type-1 operation \\n        # that is, taking each bit and moving to end of string\\n        s = s if k % 2 == 0 else s + s\\n        \\n        # There can be only two valid alternating strings as we only have 0 and 1\\n        # One starts with 0 and other with 1\\n        # e.g. for a string of length 3 we can have either 010 or 101\\n        altArr1, altArr2 = [], []        \\n        for i in range(len(s)):\\n            altArr1.append(\"0\" if i % 2 == 0 else \"1\")\\n            altArr2.append(\"1\" if i % 2 == 0 else \"0\")\\n            \\n        alt1 = \"\".join(altArr1)\\n        alt2 = \"\".join(altArr2)\\n        \\n        \\n        # Minimum Number of operations = Minimum Difference between the string and alt2 and alt3\\n        diff1, diff2 = 0,0\\n        \\n        # Sliding Window Template Begins\\n        i,j = 0,0\\n        \\n        \\n        while j < len(s):\\n            if s[j] != alt1[j] : diff1 += 1\\n            if s[j] != alt2[j] : diff2 += 1\\n                \\n            if j - i + 1 < k: j += 1\\n            else:\\n                minimumFlips = min(minimumFlips, diff1, diff2)\\n                if s[i] != alt1[i] : diff1 -= 1\\n                if s[i] != alt2[i] : diff2 -= 1\\n                i += 1\\n                j += 1\\n        \\n        return minimumFlips\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef minFlips(self, s: str) -> int:\\n        # Minimum number of flips to return\\n        minimumFlips = len(s)\\n        \\n        # Window Size\\n        k = len(s)\\n        \\n        # For strings of odd length, double them\\n        # So that we do not have to manually perform type-1 operation \\n        # that is, taking each bit and moving to end of string\\n        s = s if k % 2 == 0 else s + s\\n        \\n        # There can be only two valid alternating strings as we only have 0 and 1\\n        # One starts with 0 and other with 1\\n        # e.g. for a string of length 3 we can have either 010 or 101\\n        altArr1, altArr2 = [], []        \\n        for i in range(len(s)):\\n            altArr1.append(\"0\" if i % 2 == 0 else \"1\")\\n            altArr2.append(\"1\" if i % 2 == 0 else \"0\")\\n            \\n        alt1 = \"\".join(altArr1)\\n        alt2 = \"\".join(altArr2)\\n        \\n        \\n        # Minimum Number of operations = Minimum Difference between the string and alt2 and alt3\\n        diff1, diff2 = 0,0\\n        \\n        # Sliding Window Template Begins\\n        i,j = 0,0\\n        \\n        \\n        while j < len(s):\\n            if s[j] != alt1[j] : diff1 += 1\\n            if s[j] != alt2[j] : diff2 += 1\\n                \\n            if j - i + 1 < k: j += 1\\n            else:\\n                minimumFlips = min(minimumFlips, diff1, diff2)\\n                if s[i] != alt1[i] : diff1 -= 1\\n                if s[i] != alt2[i] : diff2 -= 1\\n                i += 1\\n                j += 1\\n        \\n        return minimumFlips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1261056,
                "title": "java-simple-and-easy-using-sliding-window-solution-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        /*\\n        * Sliding Window Approach\\n        */\\n        \\n        \\n        int n = s.length();\\n        \\n        int mininumFlip = Integer.MAX_VALUE;\\n        \\n        int misMatchCount = 0;\\n        for(int i = 0; i < (2 * n); i++){\\n            \\n            int r = i % n;\\n            \\n            //add mis watch count in current window\\n            if((s.charAt(r) - \\'0\\') != (i % 2 == 0 ? 1 : 0)) misMatchCount++;\\n            \\n            //remove mismatch count which are not relvent for current window\\n            if(i >= n && (s.charAt(r) - \\'0\\') != (r % 2 == 0 ? 1 : 0)) misMatchCount--;\\n            \\n            \\n            //misMatchCount : when valid binary string start from 1\\n            //n - misMatchCount : when valid binary string start from 0\\n            if(i >= n - 1) mininumFlip = Math.min(mininumFlip, Math.min(misMatchCount, n - misMatchCount));\\n        }\\n        \\n        return mininumFlip;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        /*\\n        * Sliding Window Approach\\n        */\\n        \\n        \\n        int n = s.length();\\n        \\n        int mininumFlip = Integer.MAX_VALUE;\\n        \\n        int misMatchCount = 0;\\n        for(int i = 0; i < (2 * n); i++){\\n            \\n            int r = i % n;\\n            \\n            //add mis watch count in current window\\n            if((s.charAt(r) - \\'0\\') != (i % 2 == 0 ? 1 : 0)) misMatchCount++;\\n            \\n            //remove mismatch count which are not relvent for current window\\n            if(i >= n && (s.charAt(r) - \\'0\\') != (r % 2 == 0 ? 1 : 0)) misMatchCount--;\\n            \\n            \\n            //misMatchCount : when valid binary string start from 1\\n            //n - misMatchCount : when valid binary string start from 0\\n            if(i >= n - 1) mininumFlip = Math.min(mininumFlip, Math.min(misMatchCount, n - misMatchCount));\\n        }\\n        \\n        return mininumFlip;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254010,
                "title": "python-solution-count-1-on-odd-and-even-positions",
                "content": "If s has even number of digits, we don\\'t need to do the first operation at all. We simply count the number of ones on odd and even positions and derive the answer. \\n\\nIf s has odd number of digits, we may consider the first operation. We need to refresh the number of ones on odd and even positions depending on the first digit of the string. \\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n = len(s)\\n        even, odd = 0, 0\\n        for i in range(n): \\n            if i % 2 == 1 and s[i] == \\'1\\': odd += 1\\n            if i % 2 == 0 and s[i] == \\'1\\': even += 1\\n        \\n        print(n, even, odd)\\n        if n % 2 == 0: \\n            return min(even + n // 2 - odd, odd + n // 2 - even)\\n        \\n        if n % 2 == 1: \\n            result = min(even + n // 2 - odd, odd + n // 2 + 1 - even)\\n            for i in range(n): \\n                if s[i] == \\'1\\': \\n                    even, odd = odd + 1, even - 1\\n                    result = min(result, min(even + n // 2 - odd, odd + n // 2 + 1 - even))\\n                else: \\n                    even, odd = odd, even\\n                    result = min(result, min(even + n // 2 - odd, odd + n // 2 + 1 - even))\\n            return result\\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n = len(s)\\n        even, odd = 0, 0\\n        for i in range(n): \\n            if i % 2 == 1 and s[i] == \\'1\\': odd += 1\\n            if i % 2 == 0 and s[i] == \\'1\\': even += 1\\n        \\n        print(n, even, odd)\\n        if n % 2 == 0: \\n            return min(even + n // 2 - odd, odd + n // 2 - even)\\n        \\n        if n % 2 == 1: \\n            result = min(even + n // 2 - odd, odd + n // 2 + 1 - even)\\n            for i in range(n): \\n                if s[i] == \\'1\\': \\n                    even, odd = odd + 1, even - 1\\n                    result = min(result, min(even + n // 2 - odd, odd + n // 2 + 1 - even))\\n                else: \\n                    even, odd = odd, even\\n                    result = min(result, min(even + n // 2 - odd, odd + n // 2 + 1 - even))\\n            return result\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253989,
                "title": "python-concise-dp-solution-o-n-o-n",
                "content": "`dp[i][j]` means the number of flips it takes to make `s[:j+1]` an alternating sequence ending with `i`. \\n\\nCompared with the sliding window solution, the DP solution is harder to understand. Just put it here for reference.\\n\\n```Python\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[0] * n for _ in range(2)]\\n        dp[1-int(s[0])][0] = 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[1][i-1] + (s[i] == \\'1\\')\\n            dp[1][i] = dp[0][i-1] + (s[i] == \\'0\\')\\n        \\n        ans = min(dp[0][-1], dp[1][-1])\\n        for i in range(n - 1):\\n            ans = min(ans, dp[0][i] + (dp[1-i%2][-1] - dp[n%2][i]))\\n            ans = min(ans, dp[1][i] + (dp[i%2][-1] - dp[1-n%2][i]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[0] * n for _ in range(2)]\\n        dp[1-int(s[0])][0] = 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[1][i-1] + (s[i] == \\'1\\')\\n            dp[1][i] = dp[0][i-1] + (s[i] == \\'0\\')\\n        \\n        ans = min(dp[0][-1], dp[1][-1])\\n        for i in range(n - 1):\\n            ans = min(ans, dp[0][i] + (dp[1-i%2][-1] - dp[n%2][i]))\\n            ans = min(ans, dp[1][i] + (dp[i%2][-1] - dp[1-n%2][i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334901,
                "title": "python-not-sliding-window-just-odd-even-count",
                "content": "The main concept behind this solution is to store count of zeroes and ones at odd and even places, for that I have declared odd and even array of size 2 where position 0 represent the count of 0\\'s. \\nto get alternating sequence, there are two different possibilities:\\n1) Starting with 0\\n2) Starting with 1\\n\\nThe strings which start with 0 means 0\\'s are at even position and 1\\'s are at odd position that means we need to flip all the 1\\'s at even position and all the 0\\'s at odd position. If we have 3 zeroes at even position and total number of evenpositions are 5, then the required flips(1->0) are (5-3)=2 that means 2 ones are needed to be flipped. and same way the number of flips (0 -> 1) for odd position is (total_odd_position_count - odd[1])\\n\\n\\nIf the length of string is even, on every operation-1 the oddcount is changed to even and even count is changed to odd, so the ans would not change.\\nIf the length of string is odd, on every operation-1, the odd count and even count swaps and the even count of digit at starting position decreases whereas odd count increases.\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s=[int(i) for i in s] #converting every binary digit into integer\\n        odd=[0,0] #this array stores count of 0\\'s at oddposition in odd[0] and 0\\'s at evenposition at odd[1]\\n        even=[0,0] #similar to odd\\n        for i in range(len(s)):\\n            if(i%2==0):\\n                even[s[i]]+=1 #incrementing even position (0 or 1) count\\n            else:\\n                odd[s[i]]+=1 #incrementing odd position (0 or 1) count\\n        evencount=(len(s)+1)//2 #total evenposition count\\n        oddcount=len(s)//2 #total oddposition count\\n\\t\\t\\n\\t\\t#ans = minimum flips required of strings starting with 0 and strings starting with 1\\n        ans=min((evencount-even[0])+(oddcount-odd[1]),(evencount-even[1])+(oddcount-odd[0]))\\n        if(len(s)%2==0):return ans \\n        for i in range(len(s)):\\n\\t\\t\\teven[s[i]]-=1 #even count of the digit decreases\\n            odd[s[i]]+=1  #odd count of the digit increases\\n            odd,even=even,odd #odd and even gets swapped\\n            ans=min(evencount-even[0]+oddcount-odd[1],evencount-even[1]+oddcount-odd[0],ans) \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s=[int(i) for i in s] #converting every binary digit into integer\\n        odd=[0,0] #this array stores count of 0\\'s at oddposition in odd[0] and 0\\'s at evenposition at odd[1]\\n        even=[0,0] #similar to odd\\n        for i in range(len(s)):\\n            if(i%2==0):\\n                even[s[i]]+=1 #incrementing even position (0 or 1) count\\n            else:\\n                odd[s[i]]+=1 #incrementing odd position (0 or 1) count\\n        evencount=(len(s)+1)//2 #total evenposition count\\n        oddcount=len(s)//2 #total oddposition count\\n\\t\\t\\n\\t\\t#ans = minimum flips required of strings starting with 0 and strings starting with 1\\n        ans=min((evencount-even[0])+(oddcount-odd[1]),(evencount-even[1])+(oddcount-odd[0]))\\n        if(len(s)%2==0):return ans \\n        for i in range(len(s)):\\n\\t\\t\\teven[s[i]]-=1 #even count of the digit decreases\\n            odd[s[i]]+=1  #odd count of the digit increases\\n            odd,even=even,odd #odd and even gets swapped\\n            ans=min(evencount-even[0]+oddcount-odd[1],evencount-even[1]+oddcount-odd[0],ans) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253967,
                "title": "c-o-n-time-o-1-space-intuitive",
                "content": "fz is a 2x2 array having the following structure\\nfz[0][0] -> # of zeros in even indices\\nfz[0][1] -> # of ones in even indices\\nfz[1][0] -> # of zeros in odd indices\\nfz[1][1] -> # of ones in odd indices\\n\\nlet n = length of string\\nif n is even, type-1 operations don\\'t matter at all.\\nso we can simply return the min-flips at current stage.\\n\\nMain problem is when n is odd, all characters shift from even positions to odd positions and vice-versa, except the first, it stays in the even position only and rest are swapped\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        array<array<int, 2>, 2> fz = {};\\n    \\n        for(int i = 0; i < n; ++i) {\\n            fz[i % 2][s[i] - \\'0\\']++;\\n        }\\n        \\n        int res = INT_MAX;\\n  \\n        if(n % 2 == 0)\\n            return min(fz[0][0] + fz[1][1], fz[0][1] + fz[1][0]);\\n        \\n        for(int i = 0; i < n; ++i) {\\n            swap(fz[0][0], fz[1][0]);\\n            swap(fz[0][1], fz[1][1]);\\n            \\n            if(s[i] == \\'0\\') {\\n                fz[0][0]++;\\n                fz[1][0]--;\\n            } else {\\n                fz[0][1]++;\\n                fz[1][1]--;\\n            }\\n            \\n            res = min(res, min(fz[0][0] + fz[1][1], fz[0][1] + fz[1][0]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        array<array<int, 2>, 2> fz = {};\\n    \\n        for(int i = 0; i < n; ++i) {\\n            fz[i % 2][s[i] - \\'0\\']++;\\n        }\\n        \\n        int res = INT_MAX;\\n  \\n        if(n % 2 == 0)\\n            return min(fz[0][0] + fz[1][1], fz[0][1] + fz[1][0]);\\n        \\n        for(int i = 0; i < n; ++i) {\\n            swap(fz[0][0], fz[1][0]);\\n            swap(fz[0][1], fz[1][1]);\\n            \\n            if(s[i] == \\'0\\') {\\n                fz[0][0]++;\\n                fz[1][0]--;\\n            } else {\\n                fz[0][1]++;\\n                fz[1][1]--;\\n            }\\n            \\n            res = min(res, min(fz[0][0] + fz[1][1], fz[0][1] + fz[1][0]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823006,
                "title": "java-sliding-window-video-solution",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        StringBuilder sb = new StringBuilder(s).append(s);\\n\\n        StringBuilder alt1 = new StringBuilder();\\n        StringBuilder alt2 = new StringBuilder();\\n\\n        for (int i = 0; i < sb.length(); i++) {\\n            if (i % 2 == 0) {\\n                alt1.append(0);\\n                alt2.append(1);\\n            }\\n            else {\\n                alt1.append(1);\\n                alt2.append(0);\\n            }\\n        }\\n\\n        int diff1 = 0, diff2 = 0;\\n        int l = 0;\\n\\n        int res = sb.length();\\n\\n        for (int r = 0; r < sb.length(); r++) {\\n            if (alt1.charAt(r) != sb.charAt(r)) diff1++;\\n            if (alt2.charAt(r) != sb.charAt(r)) diff2++;\\n\\n            if (r - l + 1 > s.length()) {\\n                if (alt1.charAt(l) != sb.charAt(l)) diff1--;\\n                if (alt2.charAt(l) != sb.charAt(l)) diff2--;\\n                l++;\\n            }\\n\\n            if (r - l + 1 == s.length()) {\\n                res = Math.min(res, Math.min(diff1, diff2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n[Watch this video to understand the approach](https://www.youtube.com/watch?v=MOeuK6gaC2A)",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        StringBuilder sb = new StringBuilder(s).append(s);\\n\\n        StringBuilder alt1 = new StringBuilder();\\n        StringBuilder alt2 = new StringBuilder();\\n\\n        for (int i = 0; i < sb.length(); i++) {\\n            if (i % 2 == 0) {\\n                alt1.append(0);\\n                alt2.append(1);\\n            }\\n            else {\\n                alt1.append(1);\\n                alt2.append(0);\\n            }\\n        }\\n\\n        int diff1 = 0, diff2 = 0;\\n        int l = 0;\\n\\n        int res = sb.length();\\n\\n        for (int r = 0; r < sb.length(); r++) {\\n            if (alt1.charAt(r) != sb.charAt(r)) diff1++;\\n            if (alt2.charAt(r) != sb.charAt(r)) diff2++;\\n\\n            if (r - l + 1 > s.length()) {\\n                if (alt1.charAt(l) != sb.charAt(l)) diff1--;\\n                if (alt2.charAt(l) != sb.charAt(l)) diff2--;\\n                l++;\\n            }\\n\\n            if (r - l + 1 == s.length()) {\\n                res = Math.min(res, Math.min(diff1, diff2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253983,
                "title": "java-o-n-using-set-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int min = Integer.MAX_VALUE;\\n        int n = s.length();\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        int expected = s.charAt(0) - \\'0\\';\\n        int expected2 = 1 - (s.charAt(0) - \\'0\\');\\n        for (int i = 0; i < 2*n; i++) {\\n            if (s.charAt(i % n) - \\'0\\' != expected) {\\n                set.add(i);\\n            }\\n            if (s.charAt(i % n) - \\'0\\' != expected2) {\\n                set2.add(i);\\n            }\\n            expected = 1 - expected;\\n            expected2 = 1 - expected2; \\n            if (i > n - 1) {\\n                set.remove(i - n);\\n                set2.remove(i - n);\\n            }\\n            if (i >= n - 1) {\\n                min = Math.min(set.size(), Math.min(set2.size(), min));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int min = Integer.MAX_VALUE;\\n        int n = s.length();\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        int expected = s.charAt(0) - \\'0\\';\\n        int expected2 = 1 - (s.charAt(0) - \\'0\\');\\n        for (int i = 0; i < 2*n; i++) {\\n            if (s.charAt(i % n) - \\'0\\' != expected) {\\n                set.add(i);\\n            }\\n            if (s.charAt(i % n) - \\'0\\' != expected2) {\\n                set2.add(i);\\n            }\\n            expected = 1 - expected;\\n            expected2 = 1 - expected2; \\n            if (i > n - 1) {\\n                set.remove(i - n);\\n                set2.remove(i - n);\\n            }\\n            if (i >= n - 1) {\\n                min = Math.min(set.size(), Math.min(set2.size(), min));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253881,
                "title": "c-simple-solution-explained",
                "content": "The idea is \\n-> Create the prefix arrays `odd` and `even` represents number of flips required to make string alternative starting with odd positions \\'1\\' and even positions \\'1\\' respectively.\\n-> After that we just need to find the min flips required, if we flip `s[0:i]` and append them at the end.\\n\\n**DO UPVOTE if you find it helpful!!**\\n\\n```\\nint minFlips(string s) {\\n        int n = s.length();\\n        int odd[n + 1];\\n        int even[n + 1];\\n        odd[0] = 0;\\n        even[0] = 0;\\n        for(int i = 0; i < n; i++){\\n            if (i % 2 != 0){\\n                odd[i + 1] = odd[i] + (s[i] == \\'1\\');\\n                even[i + 1] = even[i] +(s[i] == \\'0\\');\\n            }else{\\n                odd[i + 1] = odd[i] +(s[i] == \\'0\\' );\\n                even[i + 1] = even[i] + (s[i] == \\'1\\');\\n            }\\n        }\\n        int res = min(odd[n], even[n]);\\n        for(int i = 0; i < n; i++){\\n            if (n % 2 != 0){\\n                res = min(res,odd[n] - odd[i + 1] + even[i + 1]);\\n                res = min(res, even[n] - even[i + 1] + odd[i + 1]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint minFlips(string s) {\\n        int n = s.length();\\n        int odd[n + 1];\\n        int even[n + 1];\\n        odd[0] = 0;\\n        even[0] = 0;\\n        for(int i = 0; i < n; i++){\\n            if (i % 2 != 0){\\n                odd[i + 1] = odd[i] + (s[i] == \\'1\\');\\n                even[i + 1] = even[i] +(s[i] == \\'0\\');\\n            }else{\\n                odd[i + 1] = odd[i] +(s[i] == \\'0\\' );\\n                even[i + 1] = even[i] + (s[i] == \\'1\\');\\n            }\\n        }\\n        int res = min(odd[n], even[n]);\\n        for(int i = 0; i < n; i++){\\n            if (n % 2 != 0){\\n                res = min(res,odd[n] - odd[i + 1] + even[i + 1]);\\n                res = min(res, even[n] - even[i + 1] + odd[i + 1]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254389,
                "title": "c-sliding-window-o-n",
                "content": "```\\n int minFlips(string s) {\\n        //using sliding window technique\\n        int n = s.size(), res =INT_MAX, ans1 =0, ans2=0;\\n        string s1 , s2;\\n        s = s+s;\\n\\t\\t//create 2 string stirng  of size s+s\\n        for(int i =0;i<s.size();i++)\\n        {\\n            s1 += i%2 == 0 ? \\'0\\' :\\'1\\';   // 0101010101... \\n            s2 += i%2 == 0 ? \\'1\\' : \\'0\\';  //1010101010...\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s1[i] != s[i]) ans1++; \\n            if(s2[i] != s[i]) ans2++; \\n            \\n            if(i >= n){\\n                //decrement the prev if it was a part of res\\n                if(s1[i-n] != s[i-n]) ans1--;\\n                if(s2[i-n] != s[i-n]) ans2--;\\n            }\\n            if(i >= n-1)\\n                res = min(res, min(ans1, ans2));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minFlips(string s) {\\n        //using sliding window technique\\n        int n = s.size(), res =INT_MAX, ans1 =0, ans2=0;\\n        string s1 , s2;\\n        s = s+s;\\n\\t\\t//create 2 string stirng  of size s+s\\n        for(int i =0;i<s.size();i++)\\n        {\\n            s1 += i%2 == 0 ? \\'0\\' :\\'1\\';   // 0101010101... \\n            s2 += i%2 == 0 ? \\'1\\' : \\'0\\';  //1010101010...\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s1[i] != s[i]) ans1++; \\n            if(s2[i] != s[i]) ans2++; \\n            \\n            if(i >= n){\\n                //decrement the prev if it was a part of res\\n                if(s1[i-n] != s[i-n]) ans1--;\\n                if(s2[i-n] != s[i-n]) ans2--;\\n            }\\n            if(i >= n-1)\\n                res = min(res, min(ans1, ans2));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259837,
                "title": "python-simple-dp-beats-99-52",
                "content": "* **Type-1** operation doesn\\'t count. It will only benefit when the length of s is **odd** (will allow one-time two adjacent positions with same value, e.g. moving the first \\'1\\' of \\'110\\' to the end, it will become valid \\'101\\'.\\n* We track 4 DP variables to count the # of Type-2 operations:\\n\\t* **start_1**: final valid string starting with \\'1\\', e.g. \\'1010\\'\\n\\t* **start_0**: the final valid string starting with \\'0\\', e.g. \\'0101\\'\\n\\t* **start_1_odd**: only works when s with odd length. positions after type-1 operation are the same with start_1\\n\\t* **start_0_odd**: only works when s with odd length. positions after type-1 operation are the same with start_0\\n* **prev**: 0 or 1 (initial val as 0, used to track start_1)\\n\\t* if current **val** == **prev** (conflict with start_1): 1) flip **start_1** (+=1); 2) for odd length s: perform Type-1 operation  move current **start_1** to **start_0_odd**, flip **start_1_odd**\\n\\t* if current **val** != **prev** (conflict with start_0): 1) flip **start_0** (+=1); 2) perform Type-1 operation for odd length s, move current **start_0** to **start_1_odd**, flip **start_0_odd**\\n\\t* after each iteration, switch the value of prev, i.e. prev = 1- prev\\n* In the end, pick the smallest operations from: start_1, start_0, start_1_odd, start_0_odd\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        prev = 0\\n        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize\\n        odd = len(s)%2\\n        for val in s:\\n            val = int(val)\\n            if val == prev:\\n                if odd:\\n                    start_0_odd = min(start_0_odd, start_1)\\n                    start_1_odd += 1\\n                start_1 += 1\\n            else:\\n                if odd:\\n                    start_1_odd = min(start_1_odd, start_0)\\n                    start_0_odd += 1\\n                start_0 += 1\\n            prev = 1 - prev\\n        return min([start_1, start_0, start_1_odd, start_0_odd])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        prev = 0\\n        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize\\n        odd = len(s)%2\\n        for val in s:\\n            val = int(val)\\n            if val == prev:\\n                if odd:\\n                    start_0_odd = min(start_0_odd, start_1)\\n                    start_1_odd += 1\\n                start_1 += 1\\n            else:\\n                if odd:\\n                    start_1_odd = min(start_1_odd, start_0)\\n                    start_0_odd += 1\\n                start_0 += 1\\n            prev = 1 - prev\\n        return min([start_1, start_0, start_1_odd, start_0_odd])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254186,
                "title": "o-n-o-n-intuitive-dp-prefix-suffix-easy-proof",
                "content": "The solution for any substring without any type 1 steps is the same as its reverse. Also, we can always apply all type 1\\nbefore type 2 and get the same result. Applying a type 1 essentially rotates the string. So for `s.length == n`, we have `n` possible answers, one for each of `n` rotations. \\n\\nlet `pref0[i]` be the minimum cost to make `0..i` alternating if we set `s[0]` to `0`. \\nlet `pref1[i]` be that if `s[0]` is set to 1.\\n\\nLikewise for `suff0[i]` and `suff1[i]` except we end with `0` and `1` respectively. \\n\\nThen the cost of rotating `s` by `k` or applying `k` type1 steps and then the necessary type 2 steps is \\n`min(pref0[i] + suff1[i+1], pref1[i] + suff0[i+1])` because `s_rotated(k) = s[k...n-1] + s[0..k-1]` so the start of the prefix and the end of the suffix have to be opposite.\\n\\nWe can then just iterate over all rotations and take `O(1)` time to compute each of them, and select the maximum.\\n\\n```\\n    vector<int> solve(string s, int start) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            dp[i+1] = dp[i] + ((start + \\'0\\') == s[i]);\\n            start = (start+1) % 2;\\n        }\\n        return dp;\\n    }\\n    \\n    \\n    int minFlips(string s) {\\n        int n = s.length();\\n        auto pref0 = slv(s, 0);\\n        auto pref1 = slv(s, 1);\\n        reverse(s.begin(), s.end());\\n        auto suff0 = slv(s, 0);\\n        auto suff1 = slv(s, 1);\\n        reverse(suff0.begin(), suff0.end());\\n        reverse(suff1.begin(), suff1.end());\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, min(pref0[i] + suff1[i], pref1[i] + suff0[i]));\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> solve(string s, int start) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            dp[i+1] = dp[i] + ((start + \\'0\\') == s[i]);\\n            start = (start+1) % 2;\\n        }\\n        return dp;\\n    }\\n    \\n    \\n    int minFlips(string s) {\\n        int n = s.length();\\n        auto pref0 = slv(s, 0);\\n        auto pref1 = slv(s, 1);\\n        reverse(s.begin(), s.end());\\n        auto suff0 = slv(s, 0);\\n        auto suff1 = slv(s, 1);\\n        reverse(suff0.begin(), suff0.end());\\n        reverse(suff1.begin(), suff1.end());\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, min(pref0[i] + suff1[i], pref1[i] + suff0[i]));\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739819,
                "title": "c-well-commented-code-explaination-o-n",
                "content": "We can try all possible **rotations**, and for each rotation find **min flips**.\\n> This can be done in **O(n)** by concatenating the string to its own **end** . Every window we take in this string where **window size** is original string\\'s initial length,  is a rotation of **original** **string**.\\n\\n**Now comes the part of counting flips:**\\nfor a string of size n, we are actually trying to make\\n1010101......n\\n0101010.....n\\nIn the first one we want 1 **at odd places(1 based indexing)** and **0 at evens**, and reverse in second one.\\nIf we keep count of all  4 counts and change them during sliding , we can actually find our ans.\\nThats it is the logic , Implementations will be clearer from the code and comments.\\n\\nPlease upvote if it helps :)\\n```\\nint check(int evens[], int odds[] , int n) {\\n\\tint o, e;\\n\\tif (n % 2 == 0)\\n\\t\\to = n / 2, e = n / 2;\\n\\telse\\n\\t\\te = n / 2, o = n - e;\\n\\n\\tint moves = INT_MAX;\\n\\t//choose 1 at odds and 0 at evens\\n\\tmoves = min(moves, max(o - odds[1], 0) + max(e - evens[0], 0));\\n\\t//choose 1 at evens and 0 at odds\\n\\tmoves = min(moves, max(e - evens[1], 0) + max(o - odds[0], 0));\\n\\treturn moves;\\n}\\n\\n\\nint minFlips(string s) {\\n\\tint n = s.length();\\n\\ts += s;\\n\\n\\tint odds[2] = {0, 0}, evens[2] = {0, 0};\\n\\n\\tint i = 0;\\n\\t//i am following 1 based indexing everywhere\\n\\twhile (i < n ) {\\n\\t\\tif ((i + 1) % 2 == 0) {\\n\\t\\t\\tevens[s[i] - \\'0\\']++;\\n\\t\\t} else {\\n\\t\\t\\todds[s[i] - \\'0\\']++;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\n\\tint ans = INT_MAX;\\n\\tans = min(ans , check(evens, odds, n));\\n\\tint j = i;\\n\\ti = 0;\\n\\n\\twhile (j < s.length()) {\\n\\t\\t//shrink from back and reduce odds\\n\\t\\t//since 1 element is removed it will always be odd\\n\\t\\todds[s[i++] - \\'0\\']--;\\n\\t\\t//after shiting odds become evens and evens become odds\\n\\t\\tswap(evens[0], odds[0]);\\n\\t\\tswap(odds[1], evens[1]);\\n\\t\\t//add the new added character to appropraite position\\n\\t\\t//added characters position depends on the size of window/given string\\n\\t\\tif (n % 2 == 0) evens[s[j] - \\'0\\']++;\\n\\t\\telse odds[s[j] - \\'0\\']++;\\n\\n\\t\\tans = min(ans , check(evens, odds, n));\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint check(int evens[], int odds[] , int n) {\\n\\tint o, e;\\n\\tif (n % 2 == 0)\\n\\t\\to = n / 2, e = n / 2;\\n\\telse\\n\\t\\te = n / 2, o = n - e;\\n\\n\\tint moves = INT_MAX;\\n\\t//choose 1 at odds and 0 at evens\\n\\tmoves = min(moves, max(o - odds[1], 0) + max(e - evens[0], 0));\\n\\t//choose 1 at evens and 0 at odds\\n\\tmoves = min(moves, max(e - evens[1], 0) + max(o - odds[0], 0));\\n\\treturn moves;\\n}\\n\\n\\nint minFlips(string s) {\\n\\tint n = s.length();\\n\\ts += s;\\n\\n\\tint odds[2] = {0, 0}, evens[2] = {0, 0};\\n\\n\\tint i = 0;\\n\\t//i am following 1 based indexing everywhere\\n\\twhile (i < n ) {\\n\\t\\tif ((i + 1) % 2 == 0) {\\n\\t\\t\\tevens[s[i] - \\'0\\']++;\\n\\t\\t} else {\\n\\t\\t\\todds[s[i] - \\'0\\']++;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\n\\tint ans = INT_MAX;\\n\\tans = min(ans , check(evens, odds, n));\\n\\tint j = i;\\n\\ti = 0;\\n\\n\\twhile (j < s.length()) {\\n\\t\\t//shrink from back and reduce odds\\n\\t\\t//since 1 element is removed it will always be odd\\n\\t\\todds[s[i++] - \\'0\\']--;\\n\\t\\t//after shiting odds become evens and evens become odds\\n\\t\\tswap(evens[0], odds[0]);\\n\\t\\tswap(odds[1], evens[1]);\\n\\t\\t//add the new added character to appropraite position\\n\\t\\t//added characters position depends on the size of window/given string\\n\\t\\tif (n % 2 == 0) evens[s[j] - \\'0\\']++;\\n\\t\\telse odds[s[j] - \\'0\\']++;\\n\\n\\t\\tans = min(ans , check(evens, odds, n));\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262557,
                "title": "c-solution-a-different-approach-time-o-n-space-o-1",
                "content": "The idea is to calculate the minimum operations to convert to an alternate string for each of rotation (Type - 1 operation).\\n\\nSuppose the present string is `s1 = 1110010`\\nand we know the operation to convert it to\\n1. Alt starting with 1 (One Alt  = `1010101`) is, `one = 4`\\n2. Alt starting with 0 (Zero Alt = `0101010`) is, `zero = 3`\\n\\nNow on the next move, we convert it to -> `s2 = 110010` + `1`\\nTo calculate the `one` for this string, note that the first part of this string was already converted to one alt string while calculating `zero` for the previous string. \\n\\nSo, `one(s2) = zero(s1) + some additional cost`\\n\\nNow, to calculate this additional cost \\n* we need to **remove** 1 if the popped character (1st at `s1`) was contributing to the zero calculation of `s1`, meaning if it was `1` or `not 0` \\n* we need to **add** 1 if the added character does not match with the expected end character. This is dependent on whether the string is even or odd length. For Odd length string, One-Alt ends with 1 but Zero-Alt ends with 0.\\n\\nif `char` is the present character which is popped and added to back,\\n\\n`one(s2) = zero(s1) - (char != \\'0\\') + (char != expected end char of length n)`\\nSimilarly,\\n`zero(s2) = one(s1) - (char != \\'1\\') + (char != expected end char of length n)`\\n\\nWe can see that that for even length strings these 2 cancels each other.\\n\\nTo visualize this, we can make table which tracks the rotation and calculate the operation needed to transform to either of the alternating string (`1010101`  or `0101010`). \\n\\n\\n![image](https://assets.leetcode.com/users/images/243ceb7e-6cb5-4401-bffe-8ec7d8085122_1623310385.5569072.png)\\n\\n\\nThis shows how we can calculate the operation needed after one rotation. In practice, we won\\'t be needing this table, rather keep running variables.\\n\\n\\n```\\nint minFlips(string s) {\\n        \\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int one = 0, zero = 0;\\n        int n = s.length();\\n        // one => operation needed to convert to 101010101... \\n        // zero => operation needed to convert to 01010101...\\n        // Calculate the operation needed from current position\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(i % 2 == 0 && s[i] == \\'0\\') one++;\\n            if(i % 2 == 1 && s[i] == \\'1\\') one++;\\n            \\n            if(i % 2 == 0 && s[i] == \\'1\\') zero++;\\n            if(i % 2 == 1 && s[i] == \\'0\\') zero++;\\n        }\\n        \\n        int ans = min(one, zero);\\n        int even = (n % 2) == 0;\\n        \\n        // This part is slightly tricky\\n        // Explanation above\\n        for(int i = 1; i < n; i++)\\n        {\\n            int new_one = even ? zero : zero - (s[i-1] != \\'0\\') + (s[i-1] != \\'1\\');\\n            int new_zero = even ? one : one  - (s[i-1] != \\'1\\') + (s[i-1] != \\'0\\');\\n            one = new_one;\\n            zero = new_zero;\\n            ans = min(ans,min(one, zero));\\n            if(ans == 0) break;\\n        }\\n        return ans;\\n    }\\n```\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\nint minFlips(string s) {\\n        \\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int one = 0, zero = 0;\\n        int n = s.length();\\n        // one => operation needed to convert to 101010101... \\n        // zero => operation needed to convert to 01010101...\\n        // Calculate the operation needed from current position\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(i % 2 == 0 && s[i] == \\'0\\') one++;\\n            if(i % 2 == 1 && s[i] == \\'1\\') one++;\\n            \\n            if(i % 2 == 0 && s[i] == \\'1\\') zero++;\\n            if(i % 2 == 1 && s[i] == \\'0\\') zero++;\\n        }\\n        \\n        int ans = min(one, zero);\\n        int even = (n % 2) == 0;\\n        \\n        // This part is slightly tricky\\n        // Explanation above\\n        for(int i = 1; i < n; i++)\\n        {\\n            int new_one = even ? zero : zero - (s[i-1] != \\'0\\') + (s[i-1] != \\'1\\');\\n            int new_zero = even ? one : one  - (s[i-1] != \\'1\\') + (s[i-1] != \\'0\\');\\n            one = new_one;\\n            zero = new_zero;\\n            ans = min(ans,min(one, zero));\\n            if(ans == 0) break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254138,
                "title": "python-easy-sliding-window-based-solutiion",
                "content": "*  so first of all basic idea is that we add s at the back because for every possible s that is a n length piece\\n*   we try to see what no changes it req for that we make it 2n length now we make to dummty strings s1 and s2 as only two alternative are available .... one starts with one 10101 and another starts with 01010101 \\n* . so now start for loop with i if s1[i]!=s[i] then we want a change so we increase ans1 by + 1  now if we reach n-1 index we have a n lenrtgh string so we check with ans what if we got a min answer so ans1 ans2 and ans are compared and minimum value stored in ans\\n*  ....now we go to n th index now we remove the first index i=0 from s but we check if that index was earlier if  changed \\n* then we did ans-=1 so as to nullify its effect in ans so wo a new ans1 and ans2\\nfor this n len string from index 1 to n and so on we go to n+1 then we remove 2 nd index element ...and so on and \\n* we return ans at end which is min of all iterations\\n**if u like the explanation plz do upvote it ..**\\n\\n```py\\nclass Solution(object):\\n    def minFlips(self, s):\\n        n=len(s) # we save this length as it is length of window\\n        s+=s #we add this string because we can have any possibility like s[0]->s[n-1] or s[2]->s[n+1]meaning is that any continous variation with n length ... \\n        ans=sys.maxint #assiging the answer max possible value as want our answer to be minimum so while comparing min answer will be given \\n        ans1,ans2=0,0#two answer variables telling amount of changes we require to make it alternative\\n        s1=\"\"#dummy string like 10010101\\n        s2=\"\"#dummy string like 01010101\\n        for i in range(len(s)):\\n            if i%2==0:\\n                s1+=\"1\"\\n                s2+=\"0\"\\n            else :\\n                s1+=\"0\"\\n                s2+=\"1\"\\n        for i in range(len(s)):\\n            if s[i]!=s1[i]:#if they dont match we want a change so ++1\\n                ans1+=1\\n            if s[i]!=s2[i]:\\n                ans2+=1\\n            \\n            if i>=n:\\n                if s[i-n]!=s1[i-n]:#now we have gone ahead so removing the intial element but wait if that element needed a change we added ++ earlier but now he is not our part so why we have his ++ so to nullify its ++ we did a -- in string\\n                    ans1-=1\\n                if s[i-n]!=s2[i-n]:\\n                    ans2-=1\\n            if i>=n-1#when i reaches n-1 we have n length so we check answer first time and after that we always keep seeing if we get a less answer value and after the loop we get \\n                ans=min([ans,ans1,ans2])\\n        return ans          \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "*  so first of all basic idea is that we add s at the back because for every possible s that is a n length piece\\n*   we try to see what no changes it req for that we make it 2n length now we make to dummty strings s1 and s2 as only two alternative are available .... one starts with one 10101 and another starts with 01010101 \\n* . so now start for loop with i if s1[i]!=s[i] then we want a change so we increase ans1 by + 1  now if we reach n-1 index we have a n lenrtgh string so we check with ans what if we got a min answer so ans1 ans2 and ans are compared and minimum value stored in ans\\n*  ....now we go to n th index now we remove the first index i=0 from s but we check if that index was earlier if  changed \\n* then we did ans-=1 so as to nullify its effect in ans so wo a new ans1 and ans2\\nfor this n len string from index 1 to n and so on we go to n+1 then we remove 2 nd index element ...and so on and \\n* we return ans at end which is min of all iterations\\n**if u like the explanation plz do upvote it ..**\\n\\n```py\\nclass Solution(object):\\n    def minFlips(self, s):\\n        n=len(s) # we save this length as it is length of window\\n        s+=s #we add this string because we can have any possibility like s[0]->s[n-1] or s[2]->s[n+1]meaning is that any continous variation with n length ... \\n        ans=sys.maxint #assiging the answer max possible value as want our answer to be minimum so while comparing min answer will be given \\n        ans1,ans2=0,0#two answer variables telling amount of changes we require to make it alternative\\n        s1=\"\"#dummy string like 10010101\\n        s2=\"\"#dummy string like 01010101\\n        for i in range(len(s)):\\n            if i%2==0:\\n                s1+=\"1\"\\n                s2+=\"0\"\\n            else :\\n                s1+=\"0\"\\n                s2+=\"1\"\\n        for i in range(len(s)):\\n            if s[i]!=s1[i]:#if they dont match we want a change so ++1\\n                ans1+=1\\n            if s[i]!=s2[i]:\\n                ans2+=1\\n            \\n            if i>=n:\\n                if s[i-n]!=s1[i-n]:#now we have gone ahead so removing the intial element but wait if that element needed a change we added ++ earlier but now he is not our part so why we have his ++ so to nullify its ++ we did a -- in string\\n                    ans1-=1\\n                if s[i-n]!=s2[i-n]:\\n                    ans2-=1\\n            if i>=n-1#when i reaches n-1 we have n length so we check answer first time and after that we always keep seeing if we get a less answer value and after the loop we get \\n                ans=min([ans,ans1,ans2])\\n        return ans          \\n",
                "codeTag": "Java"
            },
            {
                "id": 1254108,
                "title": "pyhton-count-01-for-odd-and-even-indices",
                "content": "**Idea**\\n1. Count the 0s and 1s for even and odd indices respectively\\n2. Get the number Operation 2 required to make the string alternating: \\n* either all 1s for even, all 0s for odd; \\n* or all 0s for even, all 1s for odd\\n3. Get the times required for the original string\\n4. If the total length of the string is even. It is easy. No matter how many time Operation 1 happens, the counts of even and odds are reversed, while required Operation 2 times remains the same.\\n5. \\tif the length is odd, each time we move the first digit to the tail, say a \\'1\\', we have:\\n* evens[\\'1\\'] minus 1 \\n* evens and odds are reversed\\n* new evens[\\'1\\'] plus 1\\nHence we iterate all digits to move it to the tail and keep track of the min Operation 2 required.\\n\\n**Python**\\n```\\n    def minFlips(self, s: str) -> int:\\n        \\n        evens, odds = Counter(s[0::2]), Counter(s[1::2])\\n\\t\\t# get the min time of operation 2 required: \\n\\t\\t# either all 1s for even, all 0s for odd; \\n\\t\\t# or all 0s for even, all 1s for odd\\n        get_min_ops = lambda evens, odds: min(evens[\\'0\\'] + odds[\\'1\\'], evens[\\'1\\'] + odds[\\'0\\'])\\n        res = get_min_ops(evens, odds)\\n\\t\\t\\n\\t\\t# if the length is even, \\n\\t\\t# no matter how many time operation 1 happens, the counts remains the same, so res remains \\n        if len(s) % 2 == 0:\\n            return res\\n\\t\\t\\t\\n\\t\\t# if the length is odd, each time you move the first digit to the tail, say a \\'1\\'\\n\\t\\t# evens[\\'1\\'] minus 1 \\n\\t\\t# evens and odds are reversed\\n\\t\\t# new evens[\\'1\\'] plus 1\\n\\t\\t# iterate all digits and keep track of the min operation 2 required\\n        else:\\n            for char in s:\\n                evens[char] -= 1\\n                odds, evens = evens, odds\\n                evens[char] += 1\\n\\n                curr_res = get_min_ops(evens, odds)\\n                res = min(res, curr_res)\\n            return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minFlips(self, s: str) -> int:\\n        \\n        evens, odds = Counter(s[0::2]), Counter(s[1::2])\\n\\t\\t# get the min time of operation 2 required: \\n\\t\\t# either all 1s for even, all 0s for odd; \\n\\t\\t# or all 0s for even, all 1s for odd\\n        get_min_ops = lambda evens, odds: min(evens[\\'0\\'] + odds[\\'1\\'], evens[\\'1\\'] + odds[\\'0\\'])\\n        res = get_min_ops(evens, odds)\\n\\t\\t\\n\\t\\t# if the length is even, \\n\\t\\t# no matter how many time operation 1 happens, the counts remains the same, so res remains \\n        if len(s) % 2 == 0:\\n            return res\\n\\t\\t\\t\\n\\t\\t# if the length is odd, each time you move the first digit to the tail, say a \\'1\\'\\n\\t\\t# evens[\\'1\\'] minus 1 \\n\\t\\t# evens and odds are reversed\\n\\t\\t# new evens[\\'1\\'] plus 1\\n\\t\\t# iterate all digits and keep track of the min operation 2 required\\n        else:\\n            for char in s:\\n                evens[char] -= 1\\n                odds, evens = evens, odds\\n                evens[char] += 1\\n\\n                curr_res = get_min_ops(evens, odds)\\n                res = min(res, curr_res)\\n            return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3378502,
                "title": "c-solution-o-n-time-and-o-1-space",
                "content": "what is given to us are two operations\\n* **operation 1:** Remove the character at the start of the string s and append it to the end of the string.\\n* **operation 2 :** Pick any character in s and flip its value.\\n\\n**observation from operation 1 & 2:** Either we need to select a subarray that is starting from index 0, append it to the end of string OR flip the bit of any character.\\n\\n\\n![image](https://assets.leetcode.com/users/images/522d842e-53af-45b6-8486-0ead3c0c946c_1680599960.6184368.png)\\n\\nas you can see in the image, what i am going to do is to select any subarray that is starting from 0 and ending on each index i (0 to n-1) and append to to the end of string.\\n\\nSo **total cost** = cost to make **string[0,i]** in alternating order + cost to make **string[i+1,n-1]** in alternating order.\\nbut do you think it is enough \\uD83E\\uDD14?\\n.\\n.\\n.\\n.\\n.\\nNo, Let\\'s find the reason.\\nwhat if the length of the string [i+1,n-1] is **odd**\\n\\nLet\\'s take one example.\\n![image](https://assets.leetcode.com/users/images/aa7b0cf4-5d41-4f9e-81f8-9501442a2934_1680600821.4202433.png)\\n\\nIn that case if i append s1 at the end of s2 the final string will be **0 1 0 1 0 0 1 0** which is not in the alternating order.\\n\\nso what to do ??\\n.\\n.\\n.\\nwe can make a check if the s2 length is odd we need to convert s1 in  the different order.<br>\\nwhat i mean by different order is, if s2 is in the order of **0101..** then s1 will be in the order of **1010...** and vice versa also and finally take the minimum value for the answer.\\n\\nHere is the code for it\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans = n;\\n        int s01 = 0,s10 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(i%2 == (s[i]-\\'0\\')) s10++; \\n            else s01++;\\n        }\\n        /**\\n          * c01 and c10 is the cost to make string[0,i] in 0101 and 1010 order respectively.\\n          **/\\n        \\n        /**\\n          * s01 and s10 is the cost to make string[i+1,n-1] in 0101 and 1010 order respectively.\\n          **/\\n        \\n        int c01 = 0,c10 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if((n-i)%2 == 0) ans = min(ans,min(s10+c10,s01+c01));\\n            else ans = min(ans,min(s10+c01,s01+c10));\\n            if(s[i] == \\'0\\') s10--;\\n            else s01--;\\n            swap(s10,s01);\\n            \\n            if(i%2 == 0){\\n                if(s[i] == \\'0\\') c10++;\\n                else c01++;\\n            }else{\\n                if(s[i] == \\'0\\') c01++;\\n                else c10++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans = n;\\n        int s01 = 0,s10 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(i%2 == (s[i]-\\'0\\')) s10++; \\n            else s01++;\\n        }\\n        /**\\n          * c01 and c10 is the cost to make string[0,i] in 0101 and 1010 order respectively.\\n          **/\\n        \\n        /**\\n          * s01 and s10 is the cost to make string[i+1,n-1] in 0101 and 1010 order respectively.\\n          **/\\n        \\n        int c01 = 0,c10 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if((n-i)%2 == 0) ans = min(ans,min(s10+c10,s01+c01));\\n            else ans = min(ans,min(s10+c01,s01+c10));\\n            if(s[i] == \\'0\\') s10--;\\n            else s01--;\\n            swap(s10,s01);\\n            \\n            if(i%2 == 0){\\n                if(s[i] == \\'0\\') c10++;\\n                else c01++;\\n            }else{\\n                if(s[i] == \\'0\\') c01++;\\n                else c10++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925526,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s):\\n        n = len(s)\\n        e, o = (n + 1) // 2, n // 2\\n        x = s[::2].count(\\'1\\') - s[1::2].count(\\'1\\')\\n        ans = min(e - x, o + x)\\n        if n&1 == 0: return ans\\n        for i in s:\\n            x = 2 * int(i) - x\\n            ans = min(ans, e - x, o + x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s):\\n        n = len(s)\\n        e, o = (n + 1) // 2, n // 2\\n        x = s[::2].count(\\'1\\') - s[1::2].count(\\'1\\')\\n        ans = min(e - x, o + x)\\n        if n&1 == 0: return ans\\n        for i in s:\\n            x = 2 * int(i) - x\\n            ans = min(ans, e - x, o + x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950776,
                "title": "java100-faster",
                "content": "\\n\\n        int n=s.length(); \\n        s=s+s;\\n        char t[]=s.toCharArray();\\n        char  a[]=new char[n+n];\\n        char b[]=new char[n+n];\\n        for(int i=0;i<n+n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a[i]=\\'1\\';\\n                b[i]=\\'0\\';\\n            }\\n            else\\n            {\\n                a[i]=\\'0\\';\\n                b[i]=\\'1\\';\\n            }\\n        }\\n        int f=0,sec=0,ans=Integer.MAX_VALUE;\\n        for(int i=0;i<n+n;i++)\\n        {\\n            if(a[i]!=t[i])\\n                f++;\\n            if(b[i]!=t[i])\\n                sec++;\\n            if(i>=n)\\n            {\\n                if(a[i-n]!=t[i-n])\\n                    f--;\\n                if(b[i-n]!=t[i-n])\\n                    sec--;\\n            }\\n            if(i>=n-1)\\n                ans=Math.min(ans,Math.min(f,sec));\\n                \\n        }\\n        return ans;\\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "\\n\\n        int n=s.length(); \\n        s=s+s;\\n        char t[]=s.toCharArray();\\n        char  a[]=new char[n+n];\\n        char b[]=new char[n+n];\\n        for(int i=0;i<n+n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a[i]=\\'1\\';\\n                b[i]=\\'0\\';\\n            }\\n            else\\n            {\\n                a[i]=\\'0\\';\\n                b[i]=\\'1\\';\\n            }\\n        }\\n        int f=0,sec=0,ans=Integer.MAX_VALUE;\\n        for(int i=0;i<n+n;i++)\\n        {\\n            if(a[i]!=t[i])\\n                f++;\\n            if(b[i]!=t[i])\\n                sec++;\\n            if(i>=n)\\n            {\\n                if(a[i-n]!=t[i-n])\\n                    f--;\\n                if(b[i-n]!=t[i-n])\\n                    sec--;\\n            }\\n            if(i>=n-1)\\n                ans=Math.min(ans,Math.min(f,sec));\\n                \\n        }\\n        return ans;\\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1668058,
                "title": "python-solution-o-n-time-o-1-space-sliding-window-with-detailed-explanation",
                "content": "# We want to make several key observations here:\\nAssuming we do not have access to operation 1, we want to find the* \\'difference\\'* between our input string s and an alternating string. \\nWe have two alternating binary strings: either the alternating binary string that starts with 1: 10101.... or the binary string that starts with 0: 01010.....\\nLet\\'s say we are given the binary string \\n\\ns = \"111000\"\\n\\nNow let\\'s calculate the different bits from s to both alternating binary strings (s is on top and alternating binary string is on the bottom):\\n\\n**1**1**10**0**0**\\n**0**1**01**0**1**\\ndiff_0 = 4\\n\\n1**1**10**0**0\\n1**0**10**1**0\\ndiff_1 = 2\\n\\nAs we can see here, the minimum number of flips between s and the alternating binary string starting with 1 is *2 flips.*\\nAnother observation we can make here is that we only have to compute the number of flips between s and just **one** of the alternating binary strings since the other alternating binary string is the complement. Then the difference between s and the other alternating binary string that we did not keep track of is\\n\\n**len(s) - diff(alt binary str we kept track of)**\\n\\nAs we can see in the example above, diff_0 = len(s) - diff_1 ----> 4 = 6 - 2\\n\\nSo we go through the input string s once. That is O(N) time.  \\n\\n------------------\\n\\nNow what if consider operation 1??  Would that change the min number of flips?\\n\\nNotice that if N is even, then operation 1 does not change the minimum number of flips at all. For example:\\ns = 10\\nalt_b_str = 10\\n\\nnow move the first character (let\\'s call it c) to the end of s. Here c = 1:\\ns =  01\\nalt_b_str = 01\\n\\nNotice that since N is even, the bit we are comparing c to stays the same, therefore, it will always take the same number of flips no matter how many operation 1s we do.\\n\\n-------------\\n\\nNow what if N is odd?\\n\\nconsider the binary string of length 3:\\n\\ns = \"110\"\\n\\nafter we go through the first loop, the minimum number of flips is 1:\\n**1**10\\n**0**10\\n\\nNow perform operation 1:\\n101\\n10**1**\\n\\nNotice that the bit in our alternating binary string changed, and now our min number of flips became 0!\\n\\nSo if N is odd, we can decrement the num flips if the character we move to the end is the same, otherwise we increment the number of flips like normal.\\n\\nWe can do Operation 1 a maximum of N times, so for each bit we \\'move to the end\\' of the string, update the minimum number of flips if it changed.\\nBelow is each \\'window\\' that we keep track of after doing one Type-1 operation at each step\\n\\n```\\n110 # original string (min_flips: 1)\\n 101 # after first type-1 (min_flips: 0)\\n  011 # after second type-1 (min_flips: 1)\\n\\t110 # after third type-1 (min_flips: 1)\\n```\\nThis is akin to appending the input string s back onto itself and then keeping track of a window of length N at each step in our loop\\ni.e.\\n110 + 110 = 110110\\nwhere there are 4 windows to check for as shown above\\n\\nBut to simplify even further, we just have two loops where in the second loop starting from the begining of s again, we just update the minimum number of flips according to the first bit. \\n\\nSo we go through two passes of s to get a total time complexity of O(N)\\n\\n\\n\\n\\n\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        diff_first_str = 0\\n        first_str_bit = 0\\n        \\n        # go through first pass to check minimum number of operation 2 (if operation 1 was not done)\\n        for c in s:\\n            if int(c) != first_str_bit:\\n                diff_first_str += 1\\n            first_str_bit = not first_str_bit\\n        \\n        min_diff = min(diff_first_str, n - diff_first_str)\\n        \\n        # operation 1 only matters if n is odd, then use sliding window to chec\\n        if n%2 != 0:\\n            for c in s:\\n                if int(c) == first_str_bit:\\n                    diff_first_str -= 1\\n                else:\\n                    diff_first_str += 1\\n                \\n                min_diff = min(min_diff, diff_first_str, n - diff_first_str)\\n                first_str_bit = not first_str_bit\\n                \\n        return min_diff\\n",
                "solutionTags": [],
                "code": "```\\n110 # original string (min_flips: 1)\\n 101 # after first type-1 (min_flips: 0)\\n  011 # after second type-1 (min_flips: 1)\\n\\t110 # after third type-1 (min_flips: 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334840,
                "title": "java-simple-small-o-n-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minFlips(String s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\ts+=s;\\n\\t\\t\\tint minOperations=n,cnt1=0,cnt2=0;\\t\\n\\t\\t\\tfor(int i=0;i<2*n;i++){\\n\\t\\t\\t\\tif(s.charAt(i)-\\'0\\'!=i%2)    cnt1++;\\n\\t\\t\\t\\telse  cnt2++;\\n\\t\\t\\t\\tif(i>=n){\\n\\t\\t\\t\\t\\tif(s.charAt(i-n)-\\'0\\'!=(i-n)%2)    cnt1--;\\n\\t\\t\\t\\t\\telse    cnt2--;\\n\\t\\t\\t\\t\\tminOperations=Math.min(minOperations,Math.min(cnt1,cnt2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn minOperations;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minFlips(String s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\ts+=s;\\n\\t\\t\\tint minOperations=n,cnt1=0,cnt2=0;\\t\\n\\t\\t\\tfor(int i=0;i<2*n;i++){\\n\\t\\t\\t\\tif(s.charAt(i)-\\'0\\'!=i%2)    cnt1++;\\n\\t\\t\\t\\telse  cnt2++;\\n\\t\\t\\t\\tif(i>=n){\\n\\t\\t\\t\\t\\tif(s.charAt(i-n)-\\'0\\'!=(i-n)%2)    cnt1--;\\n\\t\\t\\t\\t\\telse    cnt2--;\\n\\t\\t\\t\\t\\tminOperations=Math.min(minOperations,Math.min(cnt1,cnt2));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3163749,
                "title": "90-faster-c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int ans = INT_MAX;\\n        int n = s.length(),x=0,y=0;\\n        for(int i = 0; i < n*2; i++){\\n            x += (s[i%n]-\\'0\\' != (i%2));\\n            y += (s[i%n]-\\'0\\' != (1-i%2));\\n            if(i>=n-1){\\n                if(i>=n){\\n                    x -= (s[i-n] != ((i-n)%2)+\\'0\\');\\n                    y -= (s[i-n] != (1-(i-n)%2)+\\'0\\');\\n                }\\n                ans = min({ans,x,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int ans = INT_MAX;\\n        int n = s.length(),x=0,y=0;\\n        for(int i = 0; i < n*2; i++){\\n            x += (s[i%n]-\\'0\\' != (i%2));\\n            y += (s[i%n]-\\'0\\' != (1-i%2));\\n            if(i>=n-1){\\n                if(i>=n){\\n                    x -= (s[i-n] != ((i-n)%2)+\\'0\\');\\n                    y -= (s[i-n] != (1-(i-n)%2)+\\'0\\');\\n                }\\n                ans = min({ans,x,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708493,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minFlips(string s) {\\n        int n=s.size();\\n        vector<vector<int> > cnt(2, vector<int>(2, 0));\\n        \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]++;\\n        }\\n        int ans=cnt[1][0]+cnt[0][1]; \\n        ans=min(ans, cnt[0][0]+cnt[1][1]); \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]--;\\n            cnt[s[i]-\\'0\\'][(n+i)%2]++;\\n            ans=min(ans, cnt[1][0]+cnt[0][1]);\\n            ans=min(ans, cnt[0][0]+cnt[1][1]);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minFlips(string s) {\\n        int n=s.size();\\n        vector<vector<int> > cnt(2, vector<int>(2, 0));\\n        \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]++;\\n        }\\n        int ans=cnt[1][0]+cnt[0][1]; \\n        ans=min(ans, cnt[0][0]+cnt[1][1]); \\n        for(int i=0; i<n; i++){\\n            cnt[s[i]-\\'0\\'][i%2]--;\\n            cnt[s[i]-\\'0\\'][(n+i)%2]++;\\n            ans=min(ans, cnt[1][0]+cnt[0][1]);\\n            ans=min(ans, cnt[0][0]+cnt[1][1]);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263936,
                "title": "a-few-solutions",
                "content": "Use a sliding window of length `n` to find the minimal mismatch count between case `a` and `b` as the `best` answer:\\n\\n* case `a`: target starts with `0`, ie. `010101...`, so every even digit is expected to be `0` and every odd digit is expected to be `1`\\n* case `b`: target starts with `1`, ie. `101010...`, so every even digit is expected to be `1` and every odd digit is expected to be `0`\\n\\t* ie. `b` is the opposite of `a`\\n\\nWe can append `s` onto itself to consider the wrap-around cases.\\n\\n---\\n\\n*Javascript*\\n```\\nlet minFlips = (s, cnt_a = 0, cnt_b = 0, best = Infinity) => {\\n    let ord = c => c.charCodeAt(0) - \\'0\\'.charCodeAt(0);\\n    let n = s.length;\\n    s = `${s}${s}`;\\n    for (let i = 0; i < s.length; ++i) {\\n        let x = ord(s[i]);\\n        let a = i & 1, b = a ^ 1;\\n        if (x != a) ++cnt_a;\\n        if (x != b) ++cnt_b;\\n        if (n <= i) {\\n            let y = ord(s[i - n]);\\n            a = (i - n) & 1, b = a ^ 1;\\n            if (y != a) --cnt_a;\\n            if (y != b) --cnt_b;\\n        }\\n        if (n - 1 <= i)\\n            best = Math.min(best, cnt_a, cnt_b);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minFlips(self, s: str, a = 0, b = 1, cnt_a = 0, cnt_b = 0, best = float(\\'inf\\')) -> int:\\n        n = len(s)\\n        s = f\\'{s}{s}\\'\\n        for i in range(len(s)):\\n            a = i & 1\\n            b = a ^ 1\\n            x = int(s[i])\\n            if x != a: cnt_a += 1\\n            if x != b: cnt_b += 1\\n            if n <= i:\\n                a = (i - n) & 1\\n                b = a ^ 1\\n                y = int(s[i - n])\\n                if y != a: cnt_a -= 1\\n                if y != b: cnt_b -= 1\\n            if n - 1 <= i:\\n                best = min(best, cnt_a, cnt_b)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nlet minFlips = (s, cnt_a = 0, cnt_b = 0, best = Infinity) => {\\n    let ord = c => c.charCodeAt(0) - \\'0\\'.charCodeAt(0);\\n    let n = s.length;\\n    s = `${s}${s}`;\\n    for (let i = 0; i < s.length; ++i) {\\n        let x = ord(s[i]);\\n        let a = i & 1, b = a ^ 1;\\n        if (x != a) ++cnt_a;\\n        if (x != b) ++cnt_b;\\n        if (n <= i) {\\n            let y = ord(s[i - n]);\\n            a = (i - n) & 1, b = a ^ 1;\\n            if (y != a) --cnt_a;\\n            if (y != b) --cnt_b;\\n        }\\n        if (n - 1 <= i)\\n            best = Math.min(best, cnt_a, cnt_b);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minFlips(self, s: str, a = 0, b = 1, cnt_a = 0, cnt_b = 0, best = float(\\'inf\\')) -> int:\\n        n = len(s)\\n        s = f\\'{s}{s}\\'\\n        for i in range(len(s)):\\n            a = i & 1\\n            b = a ^ 1\\n            x = int(s[i])\\n            if x != a: cnt_a += 1\\n            if x != b: cnt_b += 1\\n            if n <= i:\\n                a = (i - n) & 1\\n                b = a ^ 1\\n                y = int(s[i - n])\\n                if y != a: cnt_a -= 1\\n                if y != b: cnt_b -= 1\\n            if n - 1 <= i:\\n                best = min(best, cnt_a, cnt_b)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253911,
                "title": "python3-circular-window",
                "content": "\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s = deque(int(x) for x in s)\\n        \\n        def fn(s, val=0): \\n            \"\"\"Return min type-2 op to make s alternating.\"\"\"\\n            ans = int(s[0] != val)\\n            for i in range(1, len(s)): \\n                val ^= 1\\n                if val != s[i]: ans += 1\\n            return ans\\n        \\n        x0, x1 = fn(s, 0), fn(s, 1)\\n        ans = min(x0, x1)\\n        for _ in range(len(s)):\\n            if len(s)&1: x0, x1 = x1 + s[0] - (s[0]^1), x0 - s[0] + (s[0]^1)\\n            else: x0, x1 = x1, x0\\n            s.append(s.popleft())\\n            ans = min(ans, x0, x1)\\n        return ans \\n```\\n\\nEdited on 6/6/2021\\nA more concise circular window implementation per @votrubac\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s = [int(x) for x in s]\\n        ans = inf\\n        x01 = x10 = 0 \\n        for i in range(2*len(s)): \\n            x01 += s[i%len(s)]^i&1\\n            x10 += s[i%len(s)]^(i+1)&1\\n            if i+1 >= len(s): \\n                if i >= len(s):\\n                    x01 -= s[i-len(s)]^(i-len(s))&1\\n                    x10 -= s[i-len(s)]^(i-len(s)+1)&1\\n                ans = min(ans, x01, x10)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s = deque(int(x) for x in s)\\n        \\n        def fn(s, val=0): \\n            \"\"\"Return min type-2 op to make s alternating.\"\"\"\\n            ans = int(s[0] != val)\\n            for i in range(1, len(s)): \\n                val ^= 1\\n                if val != s[i]: ans += 1\\n            return ans\\n        \\n        x0, x1 = fn(s, 0), fn(s, 1)\\n        ans = min(x0, x1)\\n        for _ in range(len(s)):\\n            if len(s)&1: x0, x1 = x1 + s[0] - (s[0]^1), x0 - s[0] + (s[0]^1)\\n            else: x0, x1 = x1, x0\\n            s.append(s.popleft())\\n            ans = min(ans, x0, x1)\\n        return ans \\n```\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s = [int(x) for x in s]\\n        ans = inf\\n        x01 = x10 = 0 \\n        for i in range(2*len(s)): \\n            x01 += s[i%len(s)]^i&1\\n            x10 += s[i%len(s)]^(i+1)&1\\n            if i+1 >= len(s): \\n                if i >= len(s):\\n                    x01 -= s[i-len(s)]^(i-len(s))&1\\n                    x10 -= s[i-len(s)]^(i-len(s)+1)&1\\n                ans = min(ans, x01, x10)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272194,
                "title": "javascript-solution",
                "content": "# Intuition - Approach\\nIt seems a lot more complicated in the beginning, than what it actually is.\\nYou just have to realize that for any string there are only 2 scenarios you have to compare with, only 2 binary strings to compare with. \\nOne that starts with a zero and alternating bits are folowing, and another that starts with 1 and alternating bits are folowing. Both have to be of same length as the input string.\\n\\n**The Type-2 operation**:\\nWe are talking for a binary input, let\\'s consider this one `10111010` (this is of length 8).\\nSo, we need to have an alternating string of zeros and ones. As we already said, this means that our string will ether start with 0 or 1 and the rest of the bits will alternate.\\nSo we have only two strings to compare our input with.\\n\\nWe will compare every bit of our input with the corresponding bit of `01010101`(this is **even** cause it starts with 0) and `10101010` (this is **odd** cause it starts with 1).\\nThese, are both of length 8 of course, like our input.\\n\\nWe can construct our **even** and **odd** strings like this:\\n``` javascript\\nlet evenOfSameLength = \"\";\\nlet oddOfSameLength = \"\";\\n\\n//\\'^\\' represents the XOR operation\\nfor (let i = 0; i < s.length; i++) {\\n    evenOfSameLength += i % 2; // \"01...\"\\n    oddOfSameLength += i % 2 ^ 1; // \"10...\"\\n}\\n```\\nSo, according to the type-2 operation, we have to count how many flips we need to make to our input so to be identical to our **even** or **odd** alternating strings. We check bit by bit and keep track of these flips and return the result. \\nSounds easier now, but there is one more thing to bear in mind, the type-1 operation...\\n\\n**The Type-1 operation**:\\nWe might need less flips for a given string if we move it\\'s first bit to the end and compare every bit of our new string with our **even** and **odd** strings.\\n\\nLet\\'s consider an input `1101`. Moving it\\'s first bit to the end will be like `1011`(1st time we used the type-1 op), let\\'s repeat that procedure `0111`(2), `1110` (3), `1101` (4). Ok, let\\'s stop right here. \\nSo, after running our first operation for sting.length times, we ended up in the same string. \\nThere is no reason to continue using this procedure any more.\\n\\nIf we just double our string (so `1101` will become `11011101`), and compare an input.length window (so our first window would be `[1101]1101`) with our **even** and **odd** alternating strings, then we would have \"mocked\" the type-1 operation.\\nAnd this is where the Sliding Window approach comes handy.\\n\\n# Finally:\\n- We have to double our string and to compare each bit inside of a window of constant length (length of input) with our **even** and **odd** strings of same length. \\n- Our window will slide towards the end of our doubled string until we reach the last bit. \\n- We keep track of the needed flips for every window, and return the min number of flips.\\n\\n\\n---\\n\\n\\n\\n# Enhancement:\\nThere is no need to use the Type-1 operation on inputs of **even length** (if the length of the binary number is even, not the binary number itself).\\n\\nWe could do something like this:\\n`if (s.length % 2 === 1) s += s;`\\nWe double the s only if it\\'s of odd length.\\n\\n**More about this**:\\nLet\\'s consider an **even length** alternating binary num `101010`. \\nNow let\\'s apply the type-1 operation `010101` (1st time), `101010` (2)...**its the same already**...\\nEvery time it\\'s the same as one of our even and odd alternating strings.\\n> For even-length alternating bin number we just have **2 alternatives**, one that starts with `0` (even binary) and one that starts with `1` (odd binary).\\n\\nFor an **odd length** alternating binary num `1010101`, apply type-1 op `0101011` (1st time), `1010110` (2), `0101101`(3), `1011010`(4), `0110101`(5), `1101010`(6), `1010101`(7) ...**now it\\'s the same**! \\nWe had to apply the procedure string.length times to get the same binary number. \\nThis would be the case for both an odd-length **even-binary** alternating number like `0101010`(starting with zero), and also for an odd-length **odd-binary** alternating number like `1010101` (starting with 1)\\n> For odd-length bin number we ended up with **7 alternatives** (string.length alternatives)! \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n``` javascript []\\nvar minFlips = (s) => {\\n    if (!s || s.length < 1) return 0;\\n\\n    const initialLen = s.length;\\n    if (initialLen % 2 === 1) s += s;\\n\\n    let evenCmp = 0;\\n    let oddCmp = 0;\\n    let minFlips = Infinity;\\n    let end = 0;\\n    let start = 0;\\n\\n    while (end < s.length) {\\n        if (end % 2 !== Number(s[end])) evenCmp++;\\n        if ((end % 2 ^ 1) !== Number(s[end])) oddCmp++;\\n\\n        if (end >= initialLen) {\\n            if (start % 2 !== Number(s[start])) evenCmp--;\\n            if ((start % 2 ^ 1) !== Number(s[start])) oddCmp--;\\n            start++;\\n        }\\n\\n        if (end >= initialLen - 1) {\\n            minFlips = Math.min(evenCmp, oddCmp, minFlips);\\n        }\\n        end++;\\n    }\\n\\n    return minFlips;\\n};\\n\\n```\\n\\n\\n\\n# Some Explaination:\\n\\n``` javascript []\\nif (end >= initialLen) {\\n    if (start % 2 !== Number(s[start])) evenCmp--;\\n    if ((start % 2 ^ 1) !== Number(s[start])) oddCmp--;\\n    start++;\\n}\\n```\\nFor input of length 4. If end >= 4, means we slided our window. \\nSo we compare the **start** variable, and decrease our counters if we increased them before. \\n`0[1100]110` So, the first time **start** is `0` and points to the first element of our string.\\n\\nWe don\\'t consider those bits any more. We slided our window and want to know the flips needed for our current window not those old bits in the beginning.\\n\\n---\\n\\n\\n\\n``` javascript []\\nif (end >= initialLen - 1) {\\n    minFlips = Math.min(evenCmp, oddCmp, minFlips);\\n}\\n```\\nFor input on length 4. If end>=3, it means we reached the 4th bit of our window `[0110]0110`, we save the minFlips for that window and lets go for the next bit. Of course the next bit will be the end of this window `0[1100]110` so after checking this bit (which is the last one of a window) we will also have to consider updating our **minFlips** variable.\\n\\n---\\n\\n\\n``` javascript []\\n(end % 2 ^ 1)\\n```\\n\\'^\\' represents the XOR operation\\n\\nThanks for reading this.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "``` javascript\\nlet evenOfSameLength = \"\";\\nlet oddOfSameLength = \"\";\\n\\n//\\'^\\' represents the XOR operation\\nfor (let i = 0; i < s.length; i++) {\\n    evenOfSameLength += i % 2; // \"01...\"\\n    oddOfSameLength += i % 2 ^ 1; // \"10...\"\\n}\\n```\n``` javascript []\\nvar minFlips = (s) => {\\n    if (!s || s.length < 1) return 0;\\n\\n    const initialLen = s.length;\\n    if (initialLen % 2 === 1) s += s;\\n\\n    let evenCmp = 0;\\n    let oddCmp = 0;\\n    let minFlips = Infinity;\\n    let end = 0;\\n    let start = 0;\\n\\n    while (end < s.length) {\\n        if (end % 2 !== Number(s[end])) evenCmp++;\\n        if ((end % 2 ^ 1) !== Number(s[end])) oddCmp++;\\n\\n        if (end >= initialLen) {\\n            if (start % 2 !== Number(s[start])) evenCmp--;\\n            if ((start % 2 ^ 1) !== Number(s[start])) oddCmp--;\\n            start++;\\n        }\\n\\n        if (end >= initialLen - 1) {\\n            minFlips = Math.min(evenCmp, oddCmp, minFlips);\\n        }\\n        end++;\\n    }\\n\\n    return minFlips;\\n};\\n\\n```\n``` javascript []\\nif (end >= initialLen) {\\n    if (start % 2 !== Number(s[start])) evenCmp--;\\n    if ((start % 2 ^ 1) !== Number(s[start])) oddCmp--;\\n    start++;\\n}\\n```\n``` javascript []\\nif (end >= initialLen - 1) {\\n    minFlips = Math.min(evenCmp, oddCmp, minFlips);\\n}\\n```\n``` javascript []\\n(end % 2 ^ 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113960,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string str) {\\n        \\n        int n = str.size();\\n        \\n        str += str;    // concatenate the string with itself instead of moving one element from start to end\\n        \\n        string target_1 = \"\";  // it may be like \"010101010101\" alternating string\\n         \\n        string target_2 = \"\";  // it may be like \"101010101010\" alternating string\\n        \\n        // fill the target_1 and target_2\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                target_1 += \\'0\\';\\n                \\n                target_2 += \\'1\\';\\n            }\\n            else\\n            {\\n                target_1 += \\'1\\';\\n                \\n                target_2 += \\'0\\';\\n            }\\n        }\\n        \\n        int diff_1 = 0;   // will store the no of different characters in window from target_1\\n        \\n        int diff_2 = 0;   // will store the no of different characters in window from target_2\\n        \\n        int mini = INT_MAX;\\n        \\n        // apply sliding window, window length will be n\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(i < n)\\n            {\\n                if(str[i] != target_1[i])\\n                {\\n                    diff_1++;\\n                }\\n                \\n                if(str[i] != target_2[i])\\n                {\\n                    diff_2++;\\n                }\\n            }\\n            else\\n            {\\n                // update our result\\n                \\n                mini = min({mini, diff_1, diff_2});\\n                \\n                // removing one character from window from start\\n                \\n                if(str[i - n] != target_1[i - n])\\n                {\\n                    diff_1--;\\n                }\\n                \\n                if(str[i - n] != target_2[i - n])\\n                {\\n                    diff_2--;\\n                }\\n                \\n                // adding one character to window at end\\n                \\n                if(str[i] != target_1[i])\\n                {\\n                    diff_1++;\\n                }\\n                \\n                if(str[i] != target_2[i])\\n                {\\n                    diff_2++;\\n                }\\n            }\\n        }\\n        \\n        mini = min({mini, diff_1, diff_2});\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string str) {\\n        \\n        int n = str.size();\\n        \\n        str += str;    // concatenate the string with itself instead of moving one element from start to end\\n        \\n        string target_1 = \"\";  // it may be like \"010101010101\" alternating string\\n         \\n        string target_2 = \"\";  // it may be like \"101010101010\" alternating string\\n        \\n        // fill the target_1 and target_2\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                target_1 += \\'0\\';\\n                \\n                target_2 += \\'1\\';\\n            }\\n            else\\n            {\\n                target_1 += \\'1\\';\\n                \\n                target_2 += \\'0\\';\\n            }\\n        }\\n        \\n        int diff_1 = 0;   // will store the no of different characters in window from target_1\\n        \\n        int diff_2 = 0;   // will store the no of different characters in window from target_2\\n        \\n        int mini = INT_MAX;\\n        \\n        // apply sliding window, window length will be n\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(i < n)\\n            {\\n                if(str[i] != target_1[i])\\n                {\\n                    diff_1++;\\n                }\\n                \\n                if(str[i] != target_2[i])\\n                {\\n                    diff_2++;\\n                }\\n            }\\n            else\\n            {\\n                // update our result\\n                \\n                mini = min({mini, diff_1, diff_2});\\n                \\n                // removing one character from window from start\\n                \\n                if(str[i - n] != target_1[i - n])\\n                {\\n                    diff_1--;\\n                }\\n                \\n                if(str[i - n] != target_2[i - n])\\n                {\\n                    diff_2--;\\n                }\\n                \\n                // adding one character to window at end\\n                \\n                if(str[i] != target_1[i])\\n                {\\n                    diff_1++;\\n                }\\n                \\n                if(str[i] != target_2[i])\\n                {\\n                    diff_2++;\\n                }\\n            }\\n        }\\n        \\n        mini = min({mini, diff_1, diff_2});\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889831,
                "title": "python-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        diff1,diff2 = 0,0\\n        alt1,alt2 = \"\",\"\"\\n        s=s+s\\n        alt1, alt2 = \"01\" * n, \"10\" * n\\n        l=0\\n        res = len(s)\\n        for r in range(len(s)):\\n            if s[r]!=alt1[r]:\\n                diff1+=1\\n            if s[r]!=alt2[r]:\\n                diff2+=1\\n            if r>=n:\\n                if n%2!=0: # if 0th(Lth) bit are different with alt1,alt2 then n+1 bit will be same and vice versa\\n                    if s[l]!=alt1[l]:\\n                        diff1-=1\\n                    if s[l]!=alt2[l]:\\n                        diff2-=1\\n                l+=1\\n            if r >= n-1:\\n                res = min(res,diff1,diff2)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        diff1,diff2 = 0,0\\n        alt1,alt2 = \"\",\"\"\\n        s=s+s\\n        alt1, alt2 = \"01\" * n, \"10\" * n\\n        l=0\\n        res = len(s)\\n        for r in range(len(s)):\\n            if s[r]!=alt1[r]:\\n                diff1+=1\\n            if s[r]!=alt2[r]:\\n                diff2+=1\\n            if r>=n:\\n                if n%2!=0: # if 0th(Lth) bit are different with alt1,alt2 then n+1 bit will be same and vice versa\\n                    if s[l]!=alt1[l]:\\n                        diff1-=1\\n                    if s[l]!=alt2[l]:\\n                        diff2-=1\\n                l+=1\\n            if r >= n-1:\\n                res = min(res,diff1,diff2)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1728356,
                "title": "observation-based-sliding-window",
                "content": "\\n    def minFlips(self, s: str) -> int:\\n        \"\"\"\\n        111000\\n        uee the first operation two times\\n        100011\\n        use second operation on 2nd and last idx\\n        101010\\n        \\n        is it something related to count of 1\\'s and 0\\'s?\\n        \\n        there is one mindblowing solution out there in discussion forum\\n        \\n        to handle removing operation what we can do is to append \\n        curr string to same string again\\n        \\n        for eg s = 110\\n        s = 110110\\n        \\n        now take two string s1 and s2\\n        which start with 01 and 10 respectively and has alternate binary representation\\n        s =  110|110\\n        s1 = 101|010\\n        s2 = 010|101\\n        \\n        now we will keep track of changed bits in window for both s1 and s2 \\n        with s\\n        \\n        and windowsize will be of len original string\\n        \\n        count1 = positions need to flip to convert s to s1\\n        count2 = positions need to flip to convert s to s2\\n        for\\n        idx         count1          count2\\n        0             0               1\\n        1             1               1\\n        2             2               1\\n        \\n        whenever our idx goes beyound n\\n            then just validate out of boundary ele\\n            and if not same the reduce the count of flip\\n        s =  1|101|10\\n        s1 = 1|010|10\\n        s2 = 0|101|01\\n        3            2 => 3           0 => 0\\n        and so on keep track of min count among both\\n        \\n        tc = O(2n)\\n        sc = O(n)        \\n        \"\"\"\\n        oldLen = len(s)\\n        s += s\\n        s1 = \"\"\\n        s2 = \"\"\\n        newLen = len(s)\\n        for i in range(newLen):\\n            if i % 2 == 0:\\n                s1 += \"0\"\\n                s2 += \"1\"\\n            else:\\n                s1 += \"1\"\\n                s2 += \"0\"\\n    \\n        count1 = 0\\n        count2 = 0\\n        minFlips = newLen\\n        for i in range(newLen):\\n            if s[i] != s1[i]:\\n                count1 += 1\\n            if s[i] != s2[i]:\\n                count2 += 1\\n            if i >= oldLen:\\n                if s[i - oldLen] != s1[i - oldLen]:\\n                    count1 -= 1\\n                if s[i - oldLen] != s2[i - oldLen]:\\n                    count2 -= 1\\n            if i >= oldLen - 1:\\n                minFlips = min(minFlips,count1,count2)\\n        return minFlips",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Simulation"
                ],
                "code": "\\n    def minFlips(self, s: str) -> int:\\n        \"\"\"\\n        111000\\n        uee the first operation two times\\n        100011\\n        use second operation on 2nd and last idx\\n        101010\\n        \\n        is it something related to count of 1\\'s and 0\\'s?\\n        \\n        there is one mindblowing solution out there in discussion forum\\n        \\n        to handle removing operation what we can do is to append \\n        curr string to same string again\\n        \\n        for eg s = 110\\n        s = 110110\\n        \\n        now take two string s1 and s2\\n        which start with 01 and 10 respectively and has alternate binary representation\\n        s =  110|110\\n        s1 = 101|010\\n        s2 = 010|101\\n        \\n        now we will keep track of changed bits in window for both s1 and s2 \\n        with s\\n        \\n        and windowsize will be of len original string\\n        \\n        count1 = positions need to flip to convert s to s1\\n        count2 = positions need to flip to convert s to s2\\n        for\\n        idx         count1          count2\\n        0             0               1\\n        1             1               1\\n        2             2               1\\n        \\n        whenever our idx goes beyound n\\n            then just validate out of boundary ele\\n            and if not same the reduce the count of flip\\n        s =  1|101|10\\n        s1 = 1|010|10\\n        s2 = 0|101|01\\n        3            2 => 3           0 => 0\\n        and so on keep track of min count among both\\n        \\n        tc = O(2n)\\n        sc = O(n)        \\n        \"\"\"\\n        oldLen = len(s)\\n        s += s\\n        s1 = \"\"\\n        s2 = \"\"\\n        newLen = len(s)\\n        for i in range(newLen):\\n            if i % 2 == 0:\\n                s1 += \"0\"\\n                s2 += \"1\"\\n            else:\\n                s1 += \"1\"\\n                s2 += \"0\"\\n    \\n        count1 = 0\\n        count2 = 0\\n        minFlips = newLen\\n        for i in range(newLen):\\n            if s[i] != s1[i]:\\n                count1 += 1\\n            if s[i] != s2[i]:\\n                count2 += 1\\n            if i >= oldLen:\\n                if s[i - oldLen] != s1[i - oldLen]:\\n                    count1 -= 1\\n                if s[i - oldLen] != s2[i - oldLen]:\\n                    count2 -= 1\\n            if i >= oldLen - 1:\\n                minFlips = min(minFlips,count1,count2)\\n        return minFlips",
                "codeTag": "Python3"
            },
            {
                "id": 1300971,
                "title": "c-well-commented-easy-to-understand-simple-comparison",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        if (n < 2)\\n            return 0;\\n        string S = s+s;\\n        bool zero = false;\\n\\t\\t// why 2*n -> because char can be moved from starting to ending as well, \\n\\t\\t// so we need to check for all possible string rotations\\n\\t\\tvector<char> target1(2*n), target2(2*n);\\n\\t\\t\\n\\t\\t// why 2 targets -> target string can either be of the form 010101 or 101010, \\n\\t\\t// so need to check for both variations\\n        for (int i=0; i<2*n; i++) {\\n            if (zero) {\\n                target1[i] = \\'0\\';\\n                target2[i] = \\'1\\';\\n            } else {\\n                target2[i] = \\'0\\';\\n                target1[i] = \\'1\\';\\n            }\\n            zero = !zero;\\n        }\\n\\n\\t\\t// check flips required to convert without doing any rotation\\n        int a = 0, b = 0;\\n        for (int j=0; j<n; j++) {\\n            if (target1[j] != S[j])\\n                a++;\\n            if (target2[j] != S[j])\\n                b++;\\n        }\\n        int ans = min(a,b);\\n\\t\\t// sliding window part\\n        // checking each rotation one by one to minimize the answer\\n        for (int i=0; i<n; i++) {\\n            // removing the first element from the window\\n            // so need to update a & b so that they dont account\\n            // for the first element\\n            if (target1[i] != S[i])\\n                a--;\\n            if (target2[i] != S[i])\\n                b--;\\n            // adding a new element towards the end of the window\\n            // so need to recompute a & b based on this\\n            if (target1[i+n] != S[i+n])\\n                a++;\\n            if (target2[i+n] != S[i+n])\\n                b++;\\n            ans = min(ans, min(a, b));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        if (n < 2)\\n            return 0;\\n        string S = s+s;\\n        bool zero = false;\\n\\t\\t// why 2*n -> because char can be moved from starting to ending as well, \\n\\t\\t// so we need to check for all possible string rotations\\n\\t\\tvector<char> target1(2*n), target2(2*n);\\n\\t\\t\\n\\t\\t// why 2 targets -> target string can either be of the form 010101 or 101010, \\n\\t\\t// so need to check for both variations\\n        for (int i=0; i<2*n; i++) {\\n            if (zero) {\\n                target1[i] = \\'0\\';\\n                target2[i] = \\'1\\';\\n            } else {\\n                target2[i] = \\'0\\';\\n                target1[i] = \\'1\\';\\n            }\\n            zero = !zero;\\n        }\\n\\n\\t\\t// check flips required to convert without doing any rotation\\n        int a = 0, b = 0;\\n        for (int j=0; j<n; j++) {\\n            if (target1[j] != S[j])\\n                a++;\\n            if (target2[j] != S[j])\\n                b++;\\n        }\\n        int ans = min(a,b);\\n\\t\\t// sliding window part\\n        // checking each rotation one by one to minimize the answer\\n        for (int i=0; i<n; i++) {\\n            // removing the first element from the window\\n            // so need to update a & b so that they dont account\\n            // for the first element\\n            if (target1[i] != S[i])\\n                a--;\\n            if (target2[i] != S[i])\\n                b--;\\n            // adding a new element towards the end of the window\\n            // so need to recompute a & b based on this\\n            if (target1[i+n] != S[i+n])\\n                a++;\\n            if (target2[i+n] != S[i+n])\\n                b++;\\n            ans = min(ans, min(a, b));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256298,
                "title": "easy-to-understand-o-n-time-and-o-1-space-solution",
                "content": "The key is to realize alternating binary string can ONLY be either 101010... or 010101....  We can compare the string with both and calculate the number of type2 operations.  Instead of comparing one digit by one digit, count the number of ones at odd indexes and ones at even indexes, then with simple calculation we can come up with how many flips (type2 operations) needed.    \\n\\nSince type1 operation is allowed too, we can enumerate all possible number of type1 operations and count the number of types operations. The smallest count will be the answer.  The tricky part is, if the length of s is odd, when performing type1 operation, the first number moved to the end remains at even index.\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        ret = len(s)\\n        onesOdd = 0 \\n        onesEven = 0\\n        for i, digit in enumerate(s):\\n            if i % 2 == 0 and digit == \"1\":\\n                onesEven += 1\\n            elif i % 2 == 1 and digit == \"1\":\\n                onesOdd += 1\\n                    \\n        total = onesEven + onesOdd\\n        for i in range(len(s)):\\n           \\n            #target: 010101...\\n            flips = onesEven + (len(s)//2 - onesOdd)\\n            ret = min(ret, flips)\\n            \\n            #target: 101010...\\n            flips = (len(s)-len(s)//2 - onesEven) + onesOdd\\n            ret = min(ret, flips)\\n            \\n            if len(s) % 2 == 0:\\n                break  \\n            else:\\n                onesEven = onesOdd + (1 if s[i] == \"1\" else 0)\\n                onesOdd = total - onesEven\\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        ret = len(s)\\n        onesOdd = 0 \\n        onesEven = 0\\n        for i, digit in enumerate(s):\\n            if i % 2 == 0 and digit == \"1\":\\n                onesEven += 1\\n            elif i % 2 == 1 and digit == \"1\":\\n                onesOdd += 1\\n                    \\n        total = onesEven + onesOdd\\n        for i in range(len(s)):\\n           \\n            #target: 010101...\\n            flips = onesEven + (len(s)//2 - onesOdd)\\n            ret = min(ret, flips)\\n            \\n            #target: 101010...\\n            flips = (len(s)-len(s)//2 - onesEven) + onesOdd\\n            ret = min(ret, flips)\\n            \\n            if len(s) % 2 == 0:\\n                break  \\n            else:\\n                onesEven = onesOdd + (1 if s[i] == \"1\" else 0)\\n                onesOdd = total - onesEven\\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254663,
                "title": "c-sliding-window-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n     int n = s.size();\\n     string ss = s+s;\\n     string s1, s2;\\n     int ans = INT_MAX;\\n     for(int i=0; i<ss.size(); i++)\\n     {\\n         s1+=(i%2?\\'1\\':\\'0\\');\\n         s2+=(i%2?\\'0\\':\\'1\\');\\n     }\\n     int ans1 = 0, ans2 = 0;\\n     for(int i=0; i<ss.size(); i++)\\n     {\\n         if(s1[i]!=ss[i]) ans1++;\\n         if(s2[i]!=ss[i]) ans2++;\\n         if(i>=n-1)\\n         {\\n             if(i!=n-1 && s1[i-n]!=ss[i-n]) ans1--;\\n             if(i!=n-1 && s2[i-n]!=ss[i-n]) ans2--;\\n             ans = min({ans,ans1,ans2});\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n     int n = s.size();\\n     string ss = s+s;\\n     string s1, s2;\\n     int ans = INT_MAX;\\n     for(int i=0; i<ss.size(); i++)\\n     {\\n         s1+=(i%2?\\'1\\':\\'0\\');\\n         s2+=(i%2?\\'0\\':\\'1\\');\\n     }\\n     int ans1 = 0, ans2 = 0;\\n     for(int i=0; i<ss.size(); i++)\\n     {\\n         if(s1[i]!=ss[i]) ans1++;\\n         if(s2[i]!=ss[i]) ans2++;\\n         if(i>=n-1)\\n         {\\n             if(i!=n-1 && s1[i-n]!=ss[i-n]) ans1--;\\n             if(i!=n-1 && s2[i-n]!=ss[i-n]) ans2--;\\n             ans = min({ans,ans1,ans2});\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254361,
                "title": "java-sliding-window-o-n-6ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        char [] arr=s.toCharArray();\\n        int len=arr.length;\\n        char [] odd=new char[2*arr.length];\\n        int flag=0;\\n        for(int i=0;i<odd.length;i++){\\n            odd[i]=(char)(\\'0\\'+flag);\\n            flag=1-flag;\\n        }\\n        int val=0;\\n        for(int i=0;i<arr.length;i++){\\n            val+=odd[i]^arr[i];\\n        }\\n        min=Math.min(val,len-val);\\n        for(int i=len;i<2*len;i++){\\n            val=val-(arr[i-len]^odd[i-len]);\\n            val+=arr[i-len]^odd[i];\\n            min=Math.min(min,Math.min(val,len-val));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        char [] arr=s.toCharArray();\\n        int len=arr.length;\\n        char [] odd=new char[2*arr.length];\\n        int flag=0;\\n        for(int i=0;i<odd.length;i++){\\n            odd[i]=(char)(\\'0\\'+flag);\\n            flag=1-flag;\\n        }\\n        int val=0;\\n        for(int i=0;i<arr.length;i++){\\n            val+=odd[i]^arr[i];\\n        }\\n        min=Math.min(val,len-val);\\n        for(int i=len;i<2*len;i++){\\n            val=val-(arr[i-len]^odd[i-len]);\\n            val+=arr[i-len]^odd[i];\\n            min=Math.min(min,Math.min(val,len-val));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254133,
                "title": "python-2-pointer-sliding-window-o-n-time-o-1-space",
                "content": "\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        wrongBits = 0\\n        length = len(s)\\n        for i in range(length):\\n            wrongBits += (i % 2 == 0 and s[i] == \"1\") or (i % 2 == 1 and s[i] == \"0\")\\n        i = 0\\n        j = 0\\n        best = min(wrongBits, length-wrongBits)\\n        while (j < length):\\n            wrongBits -= (i % 2 == 0 and s[i] == \"1\") or (i % 2 == 1 and s[i] == \"0\")\\n            wrongBits += (j % 2 == length % 2 and s[j] == \"1\") or (j % 2 == 1 - (length % 2) and s[j] == \"0\")\\n            best = min(best, wrongBits, length-wrongBits)\\n            i += 1\\n            j += 1\\n        return best\\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        wrongBits = 0\\n        length = len(s)\\n        for i in range(length):\\n            wrongBits += (i % 2 == 0 and s[i] == \"1\") or (i % 2 == 1 and s[i] == \"0\")\\n        i = 0\\n        j = 0\\n        best = min(wrongBits, length-wrongBits)\\n        while (j < length):\\n            wrongBits -= (i % 2 == 0 and s[i] == \"1\") or (i % 2 == 1 and s[i] == \"0\")\\n            wrongBits += (j % 2 == length % 2 and s[j] == \"1\") or (j % 2 == 1 - (length % 2) and s[j] == \"0\")\\n            best = min(best, wrongBits, length-wrongBits)\\n            i += 1\\n            j += 1\\n        return best\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1254113,
                "title": "java-o-n-dynamic-programming",
                "content": "Dynamic programming, \\nlet l[i][j] is the minimum number of type 2 operation to make substring (0, i) alternating with s[i] == j (0 <= j <= 1)\\nlet [i][j] is the minimum number of type 2 operation to make substring (i, s.length() - 1) alternating with s[i] == j (0 <= j <= 1)  \\n\\nthen for each i (1 -> s.length()) ans = Math.min(ans, l[i - 1][0] + r[i][1]). See the code for more details.\\n\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        \\n        int n = s.length();\\n        int[][] l = new int[n][2];\\n        \\n        int ans = 0;\\n        \\n        l[0][0] = (s.charAt(0) == \\'0\\') ? 0 : 1;\\n        l[0][1] = (s.charAt(0) == \\'1\\') ? 0 : 1;\\n        for(int i=1; i<s.length(); i++) {\\n            l[i][0] = ((s.charAt(i) == \\'0\\') ? 0 : 1) + l[i - 1][1];\\n            l[i][1] = ((s.charAt(i) == \\'1\\') ? 0 : 1) + l[i - 1][0];\\n        }\\n        \\n        int[][] r = new int[n][2];\\n        r[n - 1][0] = (s.charAt(n - 1) == \\'0\\') ? 0 : 1;\\n        r[n - 1][1] = (s.charAt(n - 1) == \\'1\\') ? 0 : 1;\\n        for(int i=n - 2; i>=0; i--) {\\n            r[i][0] = ((s.charAt(i) == \\'0\\') ? 0 : 1) + r[i + 1][1];\\n            r[i][1] = ((s.charAt(i) == \\'1\\') ? 0 : 1) + r[i + 1][0];\\n        }\\n        \\n        ans = Math.min(l[n - 1][0], l[n - 1][1]);\\n        for(int i=1; i<n; i++) {\\n            if ((n - i) % 2 == 0) {\\n                // 0101 0101 ? 1010 1010\\n                ans = Math.min(ans, r[i][0] + ((i % 2 == 0) ? l[i - 1][1] : l[i - 1][0]));\\n                ans = Math.min(ans, r[i][1] + ((i % 2 == 0) ? l[i - 1][0] : l[i - 1][1]));\\n            } else {\\n                // 101 0101\\n                ans = Math.min(ans, r[i][0] + ((i % 2 == 0) ? l[i - 1][0] : l[i - 1][1]));\\n                ans = Math.min(ans, r[i][1] + ((i % 2 == 0) ? l[i - 1][1] : l[i - 1][0]));\\n            } \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        \\n        int n = s.length();\\n        int[][] l = new int[n][2];\\n        \\n        int ans = 0;\\n        \\n        l[0][0] = (s.charAt(0) == \\'0\\') ? 0 : 1;\\n        l[0][1] = (s.charAt(0) == \\'1\\') ? 0 : 1;\\n        for(int i=1; i<s.length(); i++) {\\n            l[i][0] = ((s.charAt(i) == \\'0\\') ? 0 : 1) + l[i - 1][1];\\n            l[i][1] = ((s.charAt(i) == \\'1\\') ? 0 : 1) + l[i - 1][0];\\n        }\\n        \\n        int[][] r = new int[n][2];\\n        r[n - 1][0] = (s.charAt(n - 1) == \\'0\\') ? 0 : 1;\\n        r[n - 1][1] = (s.charAt(n - 1) == \\'1\\') ? 0 : 1;\\n        for(int i=n - 2; i>=0; i--) {\\n            r[i][0] = ((s.charAt(i) == \\'0\\') ? 0 : 1) + r[i + 1][1];\\n            r[i][1] = ((s.charAt(i) == \\'1\\') ? 0 : 1) + r[i + 1][0];\\n        }\\n        \\n        ans = Math.min(l[n - 1][0], l[n - 1][1]);\\n        for(int i=1; i<n; i++) {\\n            if ((n - i) % 2 == 0) {\\n                // 0101 0101 ? 1010 1010\\n                ans = Math.min(ans, r[i][0] + ((i % 2 == 0) ? l[i - 1][1] : l[i - 1][0]));\\n                ans = Math.min(ans, r[i][1] + ((i % 2 == 0) ? l[i - 1][0] : l[i - 1][1]));\\n            } else {\\n                // 101 0101\\n                ans = Math.min(ans, r[i][0] + ((i % 2 == 0) ? l[i - 1][0] : l[i - 1][1]));\\n                ans = Math.min(ans, r[i][1] + ((i % 2 == 0) ? l[i - 1][1] : l[i - 1][0]));\\n            } \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254093,
                "title": "python-for-beginners",
                "content": "The idea is very simple and easy to follow.\\n1. make s double size to check Type 1 rule\\n2. create two templates, starting 1 first and 0 first\\n3. compare with s and records the difference with two templates separately\\n3. when for loop reach the end of s, check for the difference with substracting the first character\\n4. return the minum number from the two differences\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        ls = len(s)\\n        lnn = ls - 1\\n        s += s # make s double size to check the type 1\\n        ln = ls * 2\\n        a = \\'\\'\\n        b = \\'\\'\\n        ca = \\'1\\'\\n        cb = \\'0\\'\\n        adif = 0\\n        bdif = 0\\n        out =  float(\\'inf\\')\\n        for i in range(ln):\\n            a += ca\\n            b += cb\\n            ca, cb = cb, ca\\n            if a[i] != s[i]:\\n                adif += 1\\n            if b[i] != s[i]:\\n                bdif += 1\\n            if i >= lnn:\\n                if i >= ls:\\n                    if a[i-ls] != s[i-ls]:\\n                        adif -= 1\\n                    if b[i-ls] != s[i-ls]:\\n                        bdif -= 1\\n                out = min(out, adif, bdif)\\n        \\n        return out",
                "solutionTags": [],
                "code": "The idea is very simple and easy to follow.\\n1. make s double size to check Type 1 rule\\n2. create two templates, starting 1 first and 0 first\\n3. compare with s and records the difference with two templates separately\\n3. when for loop reach the end of s, check for the difference with substracting the first character\\n4. return the minum number from the two differences\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        ls = len(s)\\n        lnn = ls - 1\\n        s += s # make s double size to check the type 1\\n        ln = ls * 2\\n        a = \\'\\'\\n        b = \\'\\'\\n        ca = \\'1\\'\\n        cb = \\'0\\'\\n        adif = 0\\n        bdif = 0\\n        out =  float(\\'inf\\')\\n        for i in range(ln):\\n            a += ca\\n            b += cb\\n            ca, cb = cb, ca\\n            if a[i] != s[i]:\\n                adif += 1\\n            if b[i] != s[i]:\\n                bdif += 1\\n            if i >= lnn:\\n                if i >= ls:\\n                    if a[i-ls] != s[i-ls]:\\n                        adif -= 1\\n                    if b[i-ls] != s[i-ls]:\\n                        bdif -= 1\\n                out = min(out, adif, bdif)\\n        \\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 1253973,
                "title": "clean-python-3-dp",
                "content": "To separate `s` into `s1` + `s2`, if `s1` starts with `1`, `s2` should ends with `0`, and vice-versa\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        dp_head = [[0] * (n + 1), [0] * (n + 1)]\\n        dp_tail = [[0] * (n + 1), [0] * (n + 1)]\\n        for i in range(2):\\n            for j in range(n):\\n                dp_head[i][j] = dp_head[i][j-1]\\n                if ((j + 1) % 2) != (s[j] == str(i)):\\n                    dp_head[i][j] += 1\\n            for j in reversed(range(n)):\\n                dp_tail[i][j] = dp_tail[i][j+1]\\n                if ((n - j) % 2) != (s[j] == str(i)):\\n                    dp_tail[i][j] += 1\\n\\n        ans = min(dp_head[0][n-1], dp_head[1][n-1])\\n        for i in range(1, n):\\n            zero_x_one = dp_head[0][i-1] + dp_tail[1][i]\\n            one_x_zero = dp_head[1][i-1] + dp_tail[0][i]\\n            ans = min(ans, zero_x_one, one_x_zero)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        dp_head = [[0] * (n + 1), [0] * (n + 1)]\\n        dp_tail = [[0] * (n + 1), [0] * (n + 1)]\\n        for i in range(2):\\n            for j in range(n):\\n                dp_head[i][j] = dp_head[i][j-1]\\n                if ((j + 1) % 2) != (s[j] == str(i)):\\n                    dp_head[i][j] += 1\\n            for j in reversed(range(n)):\\n                dp_tail[i][j] = dp_tail[i][j+1]\\n                if ((n - j) % 2) != (s[j] == str(i)):\\n                    dp_tail[i][j] += 1\\n\\n        ans = min(dp_head[0][n-1], dp_head[1][n-1])\\n        for i in range(1, n):\\n            zero_x_one = dp_head[0][i-1] + dp_tail[1][i]\\n            one_x_zero = dp_head[1][i-1] + dp_tail[0][i]\\n            ans = min(ans, zero_x_one, one_x_zero)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425352,
                "title": "simple",
                "content": "**1 pass / 3 variables**\\n**time: `O(N)`; space: `O(1)`**\\n\\n**Intro:**\\n\\nThe useful observation is that the strings `\"0101010.....\"` and `\"1010101.....\"` are \"complementary\" and the number of mismatches with `\"0101010.....\"` is equal to the number of matches with `\"1010101.....\"` and vice versa. So there\\'s no point to count matches with both strings. Also the sum of matches and mismatches with either  of the strings equals the size of the input array. So you can just count the number of matches with any of two strings and derive all the other necessary values. In the presented algo I choose to count the **difference** of matches and mismatches with `\"101010...\"` though.\\n\\n![image](https://assets.leetcode.com/users/images/5d5e54de-b144-4334-9695-80283be78d96_1660499287.461111.png)\\n\\n**Algo**\\n\\n* traverse the input array, keep `d` quantity up to date and keep track of its maximum(`M`) and minimum(`m`). If `s[i]` matches with the `ith` character of `\"1010101010...\"` string then `d` gets `+1`, otherwise it gets `-1`. So basically `d` is a difference of matches of `s` with  string `\"01010101...\"` and string `\"1010101...\"`. If you know final value of `d`then it\\'s easy to get the number of matches  with the strings`\"01010101...\"` or `\"1010101...\"`: it\\'s `(size(s)-d)/2` and `(size(s)+d)/2` respectively.\\n\\n* judging by the parity of the size of the input array use one of two expressions for the `return` that involve final value of `d`,`m`,`M` and `size(s)`.\\n\\n```\\nint minFlips(string s) \\n{\\n\\tint d{}, m{INT_MAX}, M{INT_MIN}, sz(size(s));\\n\\tfor(int i{}; i<sz; ++i)\\n\\t{\\n\\t\\td += (i&1)+\\'0\\'!=s[i] ? 1 : -1; \\n\\t\\tm  = min(m, d);\\n\\t\\tM  = max(M, d);\\n\\t}  \\n\\treturn sz&1 ? min((sz-d)/2+m, (sz+d)/2-M) : min((sz-d)/2, (sz+d)/2);\\n}\\n```\\n**Notation:**\\n\\n`d` stands for **d**elta of matches of `s` with `\"01010101...\"` and `\"1010101...\"`;\\n`m` - **m**inimum of delta;\\n`M` - **m**aximum of delta;\\n`sz` - **s**i**z**e of the input array.\\n\\n**Explanation:**\\n\\nLet\\'s discuss the differences between arrays with even and odd sizes.\\nThe truth is that there\\'s absolutely no point in performing type 1 operation for even arrays. You just calculate the number of matches with strings `\"01010101...\"` and `\"1010101...\"` and return the least of them. This picture can explain why type 1 operations are useless in diminishing the number of type 2 operations.\\n\\n![image](https://assets.leetcode.com/users/images/1fdd8fda-8d3a-4a9d-809c-a4fc3c5c8aed_1660501176.4529552.png)\\n\\nOn the other hand if the input array is odd you can basically invert some number of leading array values and after that choose the minimum of matches with strings `\"01010101...\"` and `\"101010...\"`. \\n\\n![image](https://assets.leetcode.com/users/images/5c4c5a80-30bf-40a1-8983-72e10bc6c6d2_1660502014.6485038.png)\\n\\nIt turns out that you may consider inverting up to a minimum or a maximum of `d`. In the first case the maximum number of matches will be with string `\"101010...\"`, while in the second case the string `\"01010101...\"` is a better match.\\n\\n![image](https://assets.leetcode.com/users/images/aef57be7-304a-4f02-996a-d7cb06aa45c8_1660524465.1682947.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minFlips(string s) \\n{\\n\\tint d{}, m{INT_MAX}, M{INT_MIN}, sz(size(s));\\n\\tfor(int i{}; i<sz; ++i)\\n\\t{\\n\\t\\td += (i&1)+\\'0\\'!=s[i] ? 1 : -1; \\n\\t\\tm  = min(m, d);\\n\\t\\tM  = max(M, d);\\n\\t}  \\n\\treturn sz&1 ? min((sz-d)/2+m, (sz+d)/2-M) : min((sz-d)/2, (sz+d)/2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2299663,
                "title": "rust-7-ms",
                "content": "```rust\\n\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_flips(mut s: String) -> i32 {\\n        let len = s.len();\\n        let mut chars = s.chars().collect::<Vec<char>>();\\n        let ch = [\\'0\\',\\'1\\'];\\n        let mut cnt = 0;\\n        for i in 0..len {\\n            if chars[i] != ch[i%2] {\\n                cnt+=1;\\n            }\\n        }\\n        let mut ans = min(cnt,len as i32 - cnt);\\n        for i in 0..len {\\n            if chars[i] != ch[i%2] {\\n                cnt-=1;\\n            }\\n            if chars[i] != ch[(i+len)%2] {\\n                cnt+=1;\\n            }\\n            ans = ans.min(min(cnt,len as i32 - cnt));\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_flips(mut s: String) -> i32 {\\n        let len = s.len();\\n        let mut chars = s.chars().collect::<Vec<char>>();\\n        let ch = [\\'0\\',\\'1\\'];\\n        let mut cnt = 0;\\n        for i in 0..len {\\n            if chars[i] != ch[i%2] {\\n                cnt+=1;\\n            }\\n        }\\n        let mut ans = min(cnt,len as i32 - cnt);\\n        for i in 0..len {\\n            if chars[i] != ch[i%2] {\\n                cnt-=1;\\n            }\\n            if chars[i] != ch[(i+len)%2] {\\n                cnt+=1;\\n            }\\n            ans = ans.min(min(cnt,len as i32 - cnt));\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898523,
                "title": "c-sliding-window-remove-circular-property-first",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int oddzero=0;\\n        int evenzero=0;\\n        int oddone=0;\\n        int evenone=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            s+=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                if(s[i]==\\'1\\')evenone++;\\n                else evenzero++;\\n            }\\n            else{\\n                if(s[i]==\\'1\\')oddone++;\\n                else oddzero++;\\n            }\\n        }\\n        int ans=min(evenone+oddzero,evenzero+oddone);\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]==\\'1\\')evenone--;\\n            else evenzero--;\\n            int temp=evenone;\\n            evenone=oddone;\\n            oddone=temp;\\n            temp=evenzero;\\n            evenzero=oddzero;\\n            oddzero=temp;\\n            if(n%2==0){\\n                if(s[i+n-1]==\\'1\\')oddone++;\\n                else oddzero++;\\n            }\\n            else{\\n                if(s[i+n-1]==\\'1\\')evenone++;\\n                else evenzero++;\\n            }\\n            ans=min(ans,evenzero+oddone);\\n            ans=min(ans,evenone+oddzero);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minFlips(string s) {\\n        int oddzero=0;\\n        int evenzero=0;\\n        int oddone=0;\\n        int evenone=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            s+=s[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1643931,
                "title": "detail-explaination-easy-to-read-commented-c-solution-o-n-time-o-1-space",
                "content": "```\\n// Idea:\\n//   The strategy of coming up with the below solution comes from a few observation:\\n//\\n//      1. Alternating sequence comes in two forms, being 0101 sequence or 1010 sequence\\n//\\n//      2. Sum of number of bits you need to flip to satisfy 0101 seq and 1010 seq is the input size.\\n//         The reason being each bit that satisfy 0101 seq does not satisfy 1010.\\n//\\n//      3. Shifting the string can be interpreted as shifting to the alternating sequence we are\\n//         comparing the string with to the opposite direction.\\n//\\n//         Example:\\n//              before              left shift seq by 1 bit  compensate by right shifting both str and seq\\n//              str: 1 1 1 0        str: 1 1 1 0             str: 0 1 1 1\\n//              seq: 0 1 0 1 (3)    seq: 1 0 1 0 (1)         seq: 0 1 0 1 (1)\\n//              seq: 1 0 1 0 (1)    seq: 0 1 0 1 (3)         seq: 1 0 1 0 (3)\\n//\\n//         Note that the number of bits to flip is str.size() - bits to flip in 0101 sequence (refer observation 2).\\n//         So as a form of optimization, we only need to care about one of the two sequence, where I chose 0101.\\n//\\n//      4. The first obvious observation is that if the string is even, shifting will not contribute\\n//         to the reduction of bits we need to alter, because you don\\'t get less bits to alter if you\\n//         only alter the sequence.\\n//\\n//      5. By 4, the logical step is to think where we can gain less bits to flip by shifting.\\n//         The answer is when the string has odd length. Let\\'s take a look at an example.\\n//\\n//         str: 1 1 1 0 0\\n//         seq: 0 1 0 1 0 (3)\\n//\\n//         When right shift by 1 bit, observe the alternating sequence\\n//         str: 1 1 1 0 0      compensate     str: 0 1 1 1 0\\n//         seq: 1 0 1 0 0 (1)      ->         seq: 0 1 0 1 0 (1)\\n//\\n//         As you can see, we have gain two bits in this case. Why?\\n//         We can split our string into 2 parts, where the second part is the last bit.\\n//         \\n//         str (part 1): 1 1 1 0     str (part 2): 0\\n//         seq         : 0 1 0 1     seq         : 0\\n//\\n//         For part 1, a shift will simply change the number of bits to count to (str.size() - bits to flip)\\n//         For part 2, after shift, the sequence mask will still be 0. If the last bit is 0, we deduct 1 to the\\n//         part 1 result (1 less bit to flip).\\n//\\n//         Rewriting the equations with conditions:\\n//\\n//         if (part2 == 0) {\\n//             bitsToFlip = (s.size() - part1ToFlip) - 1;\\n//         }\\n//\\n//         if (part2 == 1) {\\n//             bitsToFlip = (s.size() - part1ToFlip) + 1;\\n//         }\\n//\\n// Complexity Analysis:\\n//    O(n) time, O(1) space\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int bitsToFlip = 0; // required bit change if alternating seq is 010...01\\n        int minFlip = INT_MAX, maxFlip = INT_MIN;\\n        \\n        // Get number of bits we need to flip if we comapre to 010101 alternating sequence\\n        char expectedC = \\'0\\';\\n        for (char &c : s) {\\n            if (c != expectedC) {\\n                bitsToFlip++;\\n            }\\n            expectedC = expectedC == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        // If the string has an even length, shifting does not affect the outcome\\n        if (!(s.size() & 1)) return min(bitsToFlip, (int)(s.size() - bitsToFlip));\\n        \\n        // Get Min / Max of bits to flip if string has odd length\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            if (s[i] == \\'0\\') {\\n                bitsToFlip = s.size() - bitsToFlip - 1;\\n            } else if (s[i] == \\'1\\') {\\n                bitsToFlip = s.size() - bitsToFlip + 1;\\n            }\\n            minFlip = min(minFlip, bitsToFlip);\\n            maxFlip = max(maxFlip, bitsToFlip);\\n        }\\n        \\n        return min(minFlip, (int)(s.size() - maxFlip)); // consider the 2 altering sequence\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Idea:\\n//   The strategy of coming up with the below solution comes from a few observation:\\n//\\n//      1. Alternating sequence comes in two forms, being 0101 sequence or 1010 sequence\\n//\\n//      2. Sum of number of bits you need to flip to satisfy 0101 seq and 1010 seq is the input size.\\n//         The reason being each bit that satisfy 0101 seq does not satisfy 1010.\\n//\\n//      3. Shifting the string can be interpreted as shifting to the alternating sequence we are\\n//         comparing the string with to the opposite direction.\\n//\\n//         Example:\\n//              before              left shift seq by 1 bit  compensate by right shifting both str and seq\\n//              str: 1 1 1 0        str: 1 1 1 0             str: 0 1 1 1\\n//              seq: 0 1 0 1 (3)    seq: 1 0 1 0 (1)         seq: 0 1 0 1 (1)\\n//              seq: 1 0 1 0 (1)    seq: 0 1 0 1 (3)         seq: 1 0 1 0 (3)\\n//\\n//         Note that the number of bits to flip is str.size() - bits to flip in 0101 sequence (refer observation 2).\\n//         So as a form of optimization, we only need to care about one of the two sequence, where I chose 0101.\\n//\\n//      4. The first obvious observation is that if the string is even, shifting will not contribute\\n//         to the reduction of bits we need to alter, because you don\\'t get less bits to alter if you\\n//         only alter the sequence.\\n//\\n//      5. By 4, the logical step is to think where we can gain less bits to flip by shifting.\\n//         The answer is when the string has odd length. Let\\'s take a look at an example.\\n//\\n//         str: 1 1 1 0 0\\n//         seq: 0 1 0 1 0 (3)\\n//\\n//         When right shift by 1 bit, observe the alternating sequence\\n//         str: 1 1 1 0 0      compensate     str: 0 1 1 1 0\\n//         seq: 1 0 1 0 0 (1)      ->         seq: 0 1 0 1 0 (1)\\n//\\n//         As you can see, we have gain two bits in this case. Why?\\n//         We can split our string into 2 parts, where the second part is the last bit.\\n//         \\n//         str (part 1): 1 1 1 0     str (part 2): 0\\n//         seq         : 0 1 0 1     seq         : 0\\n//\\n//         For part 1, a shift will simply change the number of bits to count to (str.size() - bits to flip)\\n//         For part 2, after shift, the sequence mask will still be 0. If the last bit is 0, we deduct 1 to the\\n//         part 1 result (1 less bit to flip).\\n//\\n//         Rewriting the equations with conditions:\\n//\\n//         if (part2 == 0) {\\n//             bitsToFlip = (s.size() - part1ToFlip) - 1;\\n//         }\\n//\\n//         if (part2 == 1) {\\n//             bitsToFlip = (s.size() - part1ToFlip) + 1;\\n//         }\\n//\\n// Complexity Analysis:\\n//    O(n) time, O(1) space\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int bitsToFlip = 0; // required bit change if alternating seq is 010...01\\n        int minFlip = INT_MAX, maxFlip = INT_MIN;\\n        \\n        // Get number of bits we need to flip if we comapre to 010101 alternating sequence\\n        char expectedC = \\'0\\';\\n        for (char &c : s) {\\n            if (c != expectedC) {\\n                bitsToFlip++;\\n            }\\n            expectedC = expectedC == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        // If the string has an even length, shifting does not affect the outcome\\n        if (!(s.size() & 1)) return min(bitsToFlip, (int)(s.size() - bitsToFlip));\\n        \\n        // Get Min / Max of bits to flip if string has odd length\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            if (s[i] == \\'0\\') {\\n                bitsToFlip = s.size() - bitsToFlip - 1;\\n            } else if (s[i] == \\'1\\') {\\n                bitsToFlip = s.size() - bitsToFlip + 1;\\n            }\\n            minFlip = min(minFlip, bitsToFlip);\\n            maxFlip = max(maxFlip, bitsToFlip);\\n        }\\n        \\n        return min(minFlip, (int)(s.size() - maxFlip)); // consider the 2 altering sequence\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445805,
                "title": "simple-o-n-time-and-o-1-space-complexity",
                "content": "class Solution {\\npublic:\\n        \\n        \\n    int minFlips(string s) {\\n            int n=s.length();\\n            s+=s;\\n            int k0=0,ki0=0,k1=1,ki1=1,kf0,kf1;\\n            int c1=0,c2=0,mn=INT_MAX;\\n            for(int i=0;i<n;i++)\\n                    {\\n                            if(s[i]!=k0+\\'0\\')\\n                                    c1++;\\n                            if(s[i]!=k1+\\'0\\')\\n                                    c2++;\\n                                k0=k0^1;\\n                                k1=k1^1;\\n                                \\n                    }\\n            mn=min(c1,c2);\\n            int lol=0;\\n            for(int i=n;i<s.length();i++)\\n                    {\\n                        if((ki0+\\'0\\')!=s[lol])\\n                                c1--;\\n                        if((ki1+\\'0\\')!=s[lol])\\n                                c2--;\\n                        if(s[i]!=k0+\\'0\\')\\n                                c1++;\\n                        if(s[i]!=k1+\\'0\\')\\n                                c2++;\\n                                k0=k0^1;\\n                                k1=k1^1;\\n                    \\n                        mn=min(mn,min(c1,c2));\\n                    ki0=ki0^1;\\n                    ki1=ki1^1;\\n                    lol++;\\n                                \\n                    }\\n\\n        return mn ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n        \\n    int minFlips(string s) {\\n            int n=s.length();\\n            s+=s;\\n            int k0=0,ki0=0,k1=1,ki1=1,kf0,kf1;\\n            int c1=0,c2=0,mn=INT_MAX;\\n            for(int i=0;i<n;i++)\\n                    {\\n                            if(s[i]!=k0+\\'0\\')\\n                                    c1++;\\n                            if(s[i]!=k1+\\'0\\')\\n                                    c2++;\\n                                k0=k0^1;\\n                                k1=k1^1;\\n                                \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1387184,
                "title": "100-solution-4ms-12ms-time-o-n-space-o-1-optimized-cpp-code",
                "content": "```\\nTime: [4ms~12ms] 100% of all C++ submission\\n      O(N)\\nSpace: O(1)\\n```\\n\\nThe solution is somehow like cyclic shift. It is a interesting journey to continuely optimize the code. It may take a while to understand the codes.\\n\\nFrom 0 to n, we count required operations in case the result begin with 0 and 1.\\nIn case it require m operations if the result begin with 1, then n-m is require to make the result begin with 0. (remove one variant).\\n\\nDue to the first kind of operation, if n is odd, we scan from 0 to n-1 for the second time. This time we count required operations of a sliding window as [i+1,n] [0, i].\\n\\nIn the following code, we use some trick to shorten codes.\\n```\\n//Trick 1#\\nfor(; i<n; ++i, b^=1) {\\n\\tm += (c[i]-\\'0\\'==b);\\n}\\n// equals to\\nfor(; i<n; ++i, b^=1) {\\n\\tif(c[i]-\\'0\\'==b)\\n\\t\\t++m;\\n}\\n```\\n\\n```\\n//Trick 2#\\nfor(i=0; i<n-1; ++i, b^=1) {\\n\\tm += 2*(c[i]-\\'0\\'==b)-1;\\n\\tans=min(ans, min(m, n-m));\\n}\\n// equals to\\nfor(i=0; i<n-1; ++i, b^=1) {\\n\\tif(c[i]-\\'0\\'==b) {\\n\\t\\t++m;\\n\\t} else {\\n\\t\\t--m;\\n\\t}\\n}\\n```\\nAnd the code submitted is as the following:\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        const char * c=s.c_str();\\n        int n=s.size(), m=0, ans, i=0, b=0;\\n        for(; i<n; ++i, b^=1) {\\n            m += (c[i]-\\'0\\'==b);\\n        }\\n        ans=min(m, n-m);\\n        if(b) {\\n            for(i=0; i<n-1; ++i, b^=1) {\\n                m += 2*(c[i]-\\'0\\'==b)-1;\\n                ans=min(ans, min(m, n-m));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime: [4ms~12ms] 100% of all C++ submission\\n      O(N)\\nSpace: O(1)\\n```\n```\\n//Trick 1#\\nfor(; i<n; ++i, b^=1) {\\n\\tm += (c[i]-\\'0\\'==b);\\n}\\n// equals to\\nfor(; i<n; ++i, b^=1) {\\n\\tif(c[i]-\\'0\\'==b)\\n\\t\\t++m;\\n}\\n```\n```\\n//Trick 2#\\nfor(i=0; i<n-1; ++i, b^=1) {\\n\\tm += 2*(c[i]-\\'0\\'==b)-1;\\n\\tans=min(ans, min(m, n-m));\\n}\\n// equals to\\nfor(i=0; i<n-1; ++i, b^=1) {\\n\\tif(c[i]-\\'0\\'==b) {\\n\\t\\t++m;\\n\\t} else {\\n\\t\\t--m;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        const char * c=s.c_str();\\n        int n=s.size(), m=0, ans, i=0, b=0;\\n        for(; i<n; ++i, b^=1) {\\n            m += (c[i]-\\'0\\'==b);\\n        }\\n        ans=min(m, n-m);\\n        if(b) {\\n            for(i=0; i<n-1; ++i, b^=1) {\\n                m += 2*(c[i]-\\'0\\'==b)-1;\\n                ans=min(ans, min(m, n-m));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361354,
                "title": "c-prefix-suffix-clean-easy-solution-o-n",
                "content": "- `even[i]`: cost of turning string `[0, i]` to binary starting with 0 (pattern: `0 1 0 1 0 ...`) - Type-2 operation\\n- `odd[i]`: cost of turning string `[0,  i]` to binary starting with 1 (pattern: `1 0 1 0 1 ..`.) - Type-2 operation\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minFlips(string s) {\\n        int n = s.length();\\n        int v[n];\\n \\n        for(int i = 0; i < n; i++) {\\n            v[i] = (s[i] - \\'0\\');\\n        }\\n \\n        int even[n], odd[n];\\n\\n        even[0] = (v[0] == 0 ? 0 : 1); // start with even 010101\\n        odd[0] = (v[0] == 0 ? 1 : 0); // start with odd 101010\\n \\n        for(int i = 1; i < n; i++) {\\n            if (i % 2 == 0) { // even\\n                even[i] = even[i-1] + (v[i] == 0 ? 0 : 1);\\n                odd[i] = odd[i-1] + (v[i] == 1 ? 0 : 1);\\n            } else {\\n                even[i] = even[i-1] + (v[i] == 1 ? 0 : 1);\\n                odd[i] = odd[i-1] + (v[i] == 0 ? 0 : 1);\\n            }\\n        }\\n \\n        int res = min(odd[n - 1], even[n - 1]); // no Type-1 operation\\n \\n        // states\\n        // even[] -> e o e o e -> 1 shift -> o e o e e -> odd[n-1] - odd[i] + even[i] \\n        // odd[] -> o e o e o -> 1 shift -> e o e o o -> even[n-1] - even[i] + odd[i]\\n        \\n        if (n % 2 != 0) {\\n            for(int i = 0; i < n; i++) {\\n                res = min(res, odd[n-1] - odd[i] + even[i]); \\n                res = min(res, even[n-1] - even[i] + odd[i]);\\n            }\\n        }\\n \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minFlips(string s) {\\n        int n = s.length();\\n        int v[n];\\n \\n        for(int i = 0; i < n; i++) {\\n            v[i] = (s[i] - \\'0\\');\\n        }\\n \\n        int even[n], odd[n];\\n\\n        even[0] = (v[0] == 0 ? 0 : 1); // start with even 010101\\n        odd[0] = (v[0] == 0 ? 1 : 0); // start with odd 101010\\n \\n        for(int i = 1; i < n; i++) {\\n            if (i % 2 == 0) { // even\\n                even[i] = even[i-1] + (v[i] == 0 ? 0 : 1);\\n                odd[i] = odd[i-1] + (v[i] == 1 ? 0 : 1);\\n            } else {\\n                even[i] = even[i-1] + (v[i] == 1 ? 0 : 1);\\n                odd[i] = odd[i-1] + (v[i] == 0 ? 0 : 1);\\n            }\\n        }\\n \\n        int res = min(odd[n - 1], even[n - 1]); // no Type-1 operation\\n \\n        // states\\n        // even[] -> e o e o e -> 1 shift -> o e o e e -> odd[n-1] - odd[i] + even[i] \\n        // odd[] -> o e o e o -> 1 shift -> e o e o o -> even[n-1] - even[i] + odd[i]\\n        \\n        if (n % 2 != 0) {\\n            for(int i = 0; i < n; i++) {\\n                res = min(res, odd[n-1] - odd[i] + even[i]); \\n                res = min(res, even[n-1] - even[i] + odd[i]);\\n            }\\n        }\\n \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346566,
                "title": "c",
                "content": "```class Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n        int zO=0,zE=0,oO=0,oE=0,n=s.length();\\n        \\n        for(int i=0; i < n;i++)\\n        {\\n            oO = (i&1) && (s[i]-\\'0\\')  ? oO+1 : oO;\\n            oE = !(i&1) && (s[i]-\\'0\\') ? oE+1 : oE;\\n            zO = (i&1) && !(s[i]-\\'0\\') ? zO+1 : zO;\\n            zE = !(i&1) && !(s[i]-\\'0\\')? zE+1 : zE;\\n        }\\n        \\n        int ans= min(zO+oE,zE+oO);\\n        \\n        if((n&1)==0)\\n            return ans; \\n        \\n        for(int i=0;i < n;i++)\\n        {\\n            swap(zO,zE);\\n            swap(oO,oE);\\n            \\n            if(s[i]-\\'0\\')\\n            {\\n                oE++;\\n                oO--;\\n            }\\n            else \\n            {\\n                zE++;\\n                zO--;\\n            }\\n            \\n            ans=min(ans,min(zO+oE,zE+oO));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n        int zO=0,zE=0,oO=0,oE=0,n=s.length();\\n        \\n        for(int i=0; i < n;i++)\\n        {\\n            oO = (i&1) && (s[i]-\\'0\\')  ? oO+1 : oO;\\n            oE = !(i&1) && (s[i]-\\'0\\') ? oE+1 : oE;\\n            zO = (i&1) && !(s[i]-\\'0\\') ? zO+1 : zO;\\n            zE = !(i&1) && !(s[i]-\\'0\\')? zE+1 : zE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1260096,
                "title": "c-o-n-with-explanation",
                "content": "case 1: there are 2*n(even) elements in string s\\nremoving the 1st char in s, and appending it to the end of s, that is same as connnecting the first element and the last element of s. AND string s become a circle. In this case, after all the operations are done, the adjacent element must be like \"010101\" or \"10101010\". \\n![image](https://assets.leetcode.com/users/images/5c6e288b-7df5-487a-93c6-11f5922f3edc_1623201871.4536755.png)\\nSo we just need to count the number of the elements in string s that differ from the results(010101... or 10101010...). And return the smaller number as the result.\\ncase 2: there are 2*n + 1(odd) elements in string s. this looks more complicated, but it is actually same as the first case. what we need to do is to add one more element into the circle.\\n![image](https://assets.leetcode.com/users/images/ab0e2d1b-c6f0-42fe-9e92-0426a531708c_1623202707.4024065.png)\\ncalculate the number of operations(flip) for each position, and return the smallest one.\\n```\\nint minFlips(string s) {\\n\\t\\tint len = s.size();\\n\\t\\tint ret = 0;\\n\\t\\tint res = 0;\\n\\t\\tif (len % 2 == 0) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char((i % 2)+48)) { res++; }\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char(((i + 1) % 2)+48) ) { ret++; }\\n\\t\\t\\t}\\n\\t\\t\\tret = ret < res ? ret : res;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tres = INT32_MAX;\\n\\t\\t\\tvector<int> sum(len);\\n\\t\\t\\tvector<int> sum1(len);\\n\\t\\t\\t// begin with 0\\n\\t\\t\\tint pin1 = 0;\\n\\t\\t\\t// begin with 1\\n\\t\\t\\tint pin2 = 0;\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char((i % 2) + 48)) {\\n\\t\\t\\t\\t\\tpin1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { \\n\\t\\t\\t\\t\\tpin2++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsum[i] = pin1;\\n\\t\\t\\t\\tsum1[i] = pin2;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tint tmp1 = (i!=0)? sum1[len - 1] - sum1[i] + sum[i - 1] : sum1[len - 1] - sum1[i];\\n\\t\\t\\t\\tint tmp2 = (i!=0)? sum[len - 1] - sum[i] + sum1[i - 1] : sum[len - 1] - sum[i];\\n\\t\\t\\t\\tres = min(min(tmp1, tmp2),res);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nint minFlips(string s) {\\n\\t\\tint len = s.size();\\n\\t\\tint ret = 0;\\n\\t\\tint res = 0;\\n\\t\\tif (len % 2 == 0) {\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char((i % 2)+48)) { res++; }\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char(((i + 1) % 2)+48) ) { ret++; }\\n\\t\\t\\t}\\n\\t\\t\\tret = ret < res ? ret : res;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tres = INT32_MAX;\\n\\t\\t\\tvector<int> sum(len);\\n\\t\\t\\tvector<int> sum1(len);\\n\\t\\t\\t// begin with 0\\n\\t\\t\\tint pin1 = 0;\\n\\t\\t\\t// begin with 1\\n\\t\\t\\tint pin2 = 0;\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tif (s[i] != char((i % 2) + 48)) {\\n\\t\\t\\t\\t\\tpin1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { \\n\\t\\t\\t\\t\\tpin2++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsum[i] = pin1;\\n\\t\\t\\t\\tsum1[i] = pin2;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\t\\tint tmp1 = (i!=0)? sum1[len - 1] - sum1[i] + sum[i - 1] : sum1[len - 1] - sum1[i];\\n\\t\\t\\t\\tint tmp2 = (i!=0)? sum[len - 1] - sum[i] + sum1[i - 1] : sum[len - 1] - sum[i];\\n\\t\\t\\t\\tres = min(min(tmp1, tmp2),res);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258225,
                "title": "simple-cpp-solution-using-sliding-window-with-explanation-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    //Function that finds differences between given string and string that starts with 01 and 10 and adds given increment.\\n    void updateDifference(string &s, int i, int &diffStartWithZero, int &diffStartWithOne, int inc)\\n    {\\n        //If we are at even index, we should have a 0 here => if string start with 0, else 1 if string start with 1.\\n        //Add increment to respective variables if this condition doesn\\'t match\\n        if(i % 2 == 0)\\n        {\\n            if(s[i] != \\'0\\')\\n                diffStartWithZero += inc;\\n            if(s[i] != \\'1\\')\\n                diffStartWithOne += inc;\\n        }\\n        //Do the same for odd index\\n        else\\n        {\\n            if(s[i] != \\'1\\')\\n                diffStartWithZero += inc;\\n            if(s[i] != \\'0\\')\\n                diffStartWithOne += inc;\\n        }\\n    }\\n    \\n    int minFlips(string s) \\n    {\\n        //Add the string to itself\\n        s += s;\\n        int len = s.size() / 2, diffStartWithZero = 0, diffStartWithOne = 0, res = INT_MAX;\\n        \\n        //iterate through the string and do sliding window approach. Window size should be len = s.size()\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            updateDifference(s, i, diffStartWithZero, diffStartWithOne, 1);\\n            \\n            //If we have exceeded window of size len, then we need to subtract previous diff if present\\n            if(i >= len)\\n                updateDifference(s, i-len, diffStartWithZero, diffStartWithOne, -1);\\n            \\n            //If we have our window size, update res.\\n            if(i >= len-1)\\n                res = min(res, min(diffStartWithZero, diffStartWithOne));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Function that finds differences between given string and string that starts with 01 and 10 and adds given increment.\\n    void updateDifference(string &s, int i, int &diffStartWithZero, int &diffStartWithOne, int inc)\\n    {\\n        //If we are at even index, we should have a 0 here => if string start with 0, else 1 if string start with 1.\\n        //Add increment to respective variables if this condition doesn\\'t match\\n        if(i % 2 == 0)\\n        {\\n            if(s[i] != \\'0\\')\\n                diffStartWithZero += inc;\\n            if(s[i] != \\'1\\')\\n                diffStartWithOne += inc;\\n        }\\n        //Do the same for odd index\\n        else\\n        {\\n            if(s[i] != \\'1\\')\\n                diffStartWithZero += inc;\\n            if(s[i] != \\'0\\')\\n                diffStartWithOne += inc;\\n        }\\n    }\\n    \\n    int minFlips(string s) \\n    {\\n        //Add the string to itself\\n        s += s;\\n        int len = s.size() / 2, diffStartWithZero = 0, diffStartWithOne = 0, res = INT_MAX;\\n        \\n        //iterate through the string and do sliding window approach. Window size should be len = s.size()\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            updateDifference(s, i, diffStartWithZero, diffStartWithOne, 1);\\n            \\n            //If we have exceeded window of size len, then we need to subtract previous diff if present\\n            if(i >= len)\\n                updateDifference(s, i-len, diffStartWithZero, diffStartWithOne, -1);\\n            \\n            //If we have our window size, update res.\\n            if(i >= len-1)\\n                res = min(res, min(diffStartWithZero, diffStartWithOne));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258013,
                "title": "java-short-o-n-time-o-1-space-sliding-window-solution-w-explaination",
                "content": "Our target is to convert the original `s` to either *010101010...* or *101010101...*. So here we can just check whether index after type-1 transformation is odd or even. \\n* Type-1 transform could be done with `i%n` or `i-n`, when our i ranged from 0 to 2\\\\*n. Here in the code, it is `s.charAt(i%n)` when `i >= n`.\\n* Type-2 transform is to compare the value of index `s[i%n]` with `i` \\'s even or odd attribute.\\n* 2 results would either be `t` or `n-t` (one is for  *010101010...*, another is for  *101010101...*). We just get Min of them.\\n\\nThere would be a sliding window, when `i < n`, we just add new number to the window, when `i >= n`, we remove the previous number we added into the window. \\n\\nAnd note that the original length of string s may be odd, so when we add new number into the sliding window, we are checking `i` itself. When removing previous number, we are checking `i%n`, since the previous number we added is `i%n`.\\n\\nJAVA code:\\n\\n```\\n    public int minFlips(String s) {\\n        int n = s.length(), res = Integer.MAX_VALUE, t = 0;        \\n        for (int i = 0; i < 2*n; i++)  {\\n            if (s.charAt(i%n) - \\'0\\' != (i % 2 != 0 ? 0 : 1) ) t++; // add is i\\n            if (i >= n && s.charAt(i%n) - \\'0\\' != (i%n % 2 != 0 ? 0 : 1)) t--; // minus is i%n\\n            if (i >= n-1)  res = Math.min(res, Math.min(t, n-t));             \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int minFlips(String s) {\\n        int n = s.length(), res = Integer.MAX_VALUE, t = 0;        \\n        for (int i = 0; i < 2*n; i++)  {\\n            if (s.charAt(i%n) - \\'0\\' != (i % 2 != 0 ? 0 : 1) ) t++; // add is i\\n            if (i >= n && s.charAt(i%n) - \\'0\\' != (i%n % 2 != 0 ? 0 : 1)) t--; // minus is i%n\\n            if (i >= n-1)  res = Math.min(res, Math.min(t, n-t));             \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1257883,
                "title": "detailed-explanation-of-algo-and-easy-to-understand-o-n-python-code-with-comments",
                "content": "This is a DP solution. O(n) time complexity (two pass solution) and O(n) space complexity.\\nthe array dp stores the number of changes you need to make in the string to get 0101... (not considering 1010... at the moment, Later! See the note below)\\nSo, if the string char doesn\\'t match with the char in 0101... we add 1 to last element of dp and insert in the dp array, else just copy the previous element of dp.\\nif given s is       11011001\\ndp will store     11112333 (though the dp array in code will actuallu look like 011112333)\\nTo make it easy to code, have added a 0 at the start of dp and removed it later. \\n**We do this for the s+s instead of s**\\nThis is because instead of the rotaton operation we can just consider it as a cyclic array.\\ne.g. \\n11011001 ---rotation--> 10110011 --rotation--> 01100111\\nInstead of doing this what we do is:\\n\\t\\ts\\t\\t+\\t\\ts\\n11011001 + 11011001 = 1101100111011001\\nIf we consider the first n elements in s+s we get the inital s obviously\\nthen we consider n elements from 1st index of s+s , we get the s after 1 rotation\\nthen we consider n elements from 2nd index of s+s, we get the s after 2 rotations... and so on, we get our n different strings after n rotations(which would repat after n rotations)\\nso now for each of these n strings we just need to check the number of flips required, but that would give an O(n^2) solution, **DP comes to rescue, the dp array is useful here**\\n\\nfor each window we subtract dp[left_index] from dp[right_index] which I do by the code \"\"\"val=dp[i]-dp[i%x]\"\"\" and that gives us the number of flips required to convert the string to 0101... \\nWe can check for 1010 easily! HOW?\\n\\nNote: If it takes \"x\" moves to convert a string of length \"n\" to 1010... then it would take \"n-x\" moves to convert it to 0101...\\nSo, you just need to chcek for one of them and you get by subtracting from the length and the min of the two is the answer.\\n\\n\"\"\"\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        \\n        n=len(s)\\n        def func(st):                                # st is s+s    e.g. if s = \"101\"  st = \"101101\" \\n            dp=[0]                                     #0 is appended at start for ease to code\\n            x=len(st)//2                             # x is length of s ( st = s + s )\\n            for i in range(len(st)):\\n                if i%2!=int(st[i]):\\n                    dp.append(dp[-1]+1)\\n                else:\\n                    dp.append(dp[-1])\\n            dp.pop(0)\\n            maxi=0\\n            mini=x+10\\n            for i in range(x,2*x):\\n                val=dp[i]-dp[i%x]\\n                mini=min(mini,val) #storing the min flips required to convert string to 0101....\\n\\t\\t\\t\\tmaxi=max(maxi,val)  #storing the max flips required to convert string to 0101...   , max steps to 0101... means min steps to 1010... so we storing it for 1010...\\n\\t\\t\\t\\t\\n            return min(mini,x-maxi)\\n            \\n            \\n        return func(s+s)\\n\"\"\"\\nNOTE: This code can be easily optimized to O(1) space once you have understood the logic, (just store the left_index value instead of keeping the whole array and keep finding right_index value as you proceed)\\n\\nFeel free to ask doubts.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "This is a DP solution. O(n) time complexity (two pass solution) and O(n) space complexity.\\nthe array dp stores the number of changes you need to make in the string to get 0101... (not considering 1010... at the moment, Later! See the note below)\\nSo, if the string char doesn\\'t match with the char in 0101... we add 1 to last element of dp and insert in the dp array, else just copy the previous element of dp.\\nif given s is       11011001\\ndp will store     11112333 (though the dp array in code will actuallu look like 011112333)\\nTo make it easy to code, have added a 0 at the start of dp and removed it later. \\n**We do this for the s+s instead of s**\\nThis is because instead of the rotaton operation we can just consider it as a cyclic array.\\ne.g. \\n11011001 ---rotation--> 10110011 --rotation--> 01100111\\nInstead of doing this what we do is:\\n\\t\\ts\\t\\t+\\t\\ts\\n11011001 + 11011001 = 1101100111011001\\nIf we consider the first n elements in s+s we get the inital s obviously\\nthen we consider n elements from 1st index of s+s , we get the s after 1 rotation\\nthen we consider n elements from 2nd index of s+s, we get the s after 2 rotations... and so on, we get our n different strings after n rotations(which would repat after n rotations)\\nso now for each of these n strings we just need to check the number of flips required, but that would give an O(n^2) solution, **DP comes to rescue, the dp array is useful here**\\n\\nfor each window we subtract dp[left_index] from dp[right_index] which I do by the code \"\"\"val=dp[i]-dp[i%x]\"\"\" and that gives us the number of flips required to convert the string to 0101... \\nWe can check for 1010 easily! HOW?\\n\\nNote: If it takes \"x\" moves to convert a string of length \"n\" to 1010... then it would take \"n-x\" moves to convert it to 0101...\\nSo, you just need to chcek for one of them and you get by subtracting from the length and the min of the two is the answer.\\n\\n\"\"\"\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        \\n        n=len(s)\\n        def func(st):                                # st is s+s    e.g. if s = \"101\"  st = \"101101\" \\n            dp=[0]                                     #0 is appended at start for ease to code\\n            x=len(st)//2                             # x is length of s ( st = s + s )\\n            for i in range(len(st)):\\n                if i%2!=int(st[i]):\\n                    dp.append(dp[-1]+1)\\n                else:\\n                    dp.append(dp[-1])\\n            dp.pop(0)\\n            maxi=0\\n            mini=x+10\\n            for i in range(x,2*x):\\n                val=dp[i]-dp[i%x]\\n                mini=min(mini,val) #storing the min flips required to convert string to 0101....\\n\\t\\t\\t\\tmaxi=max(maxi,val)  #storing the max flips required to convert string to 0101...   , max steps to 0101... means min steps to 1010... so we storing it for 1010...\\n\\t\\t\\t\\t\\n            return min(mini,x-maxi)\\n            \\n            \\n        return func(s+s)\\n\"\"\"\\nNOTE: This code can be easily optimized to O(1) space once you have understood the logic, (just store the left_index value instead of keeping the whole array and keep finding right_index value as you proceed)\\n\\nFeel free to ask doubts.",
                "codeTag": "Java"
            },
            {
                "id": 1257708,
                "title": "c-o-n-44ms",
                "content": "What basically done here is if for any i-1, i if s[i-1]==s[i], then we do something like rotation. I\\'ll take an example,\\n\\nsuppose s = 10101010011010011100\\n\\nwe see that s can be written as 1010101001 (s1) + 1010011100 (s2)\\nso if rotation is done than it will become s2+ s1 i.e., 1010011100 + 1010101001 = 101001110011010101001\\n\\nHere, \\'+\\' is the concatenation operator.\\n\\nwe did this to make the string have similar value at s[0] and s[s.length()-1].\\n\\nthis prevents the rotated \\'s\\' to have better answer in circular manner, if \\'s\\' has a good answer than we just need to scan \\'s\\' in linear fashion and not worry about it having a better answer with rotation.\\n\\nI think taking look at the code will clear the doubts.\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.length();\\n        int cnt = 0;\\n        int t = 1;\\n        int pref[n][2];\\n        for(int i=0;i<n;i++){\\n            if(t){\\n                if(s[i]==\\'0\\')\\n                    cnt++;\\n                t^=1;\\n            }\\n            else{\\n                if(s[i]==\\'1\\')\\n                    cnt++;\\n                t^=1;\\n            }\\n            pref[i][0]=i+1-cnt;\\n            pref[i][1]=cnt;\\n        }\\n        int suf[n][2];\\n        suf[0][1]=cnt;\\n        suf[0][0]=n-cnt;\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'1\\'){\\n                suf[i][0]=suf[i-1][1];\\n                suf[i][1]=suf[i-1][0]-1;\\n            }\\n            else{\\n                suf[i][1]=suf[i-1][0];\\n                suf[i][0]=suf[i-1][1]-1;\\n            }\\n            \\n        }\\n        int ans =min(pref[n-1][0],pref[n-1][1]);\\n        for(int i=1;i<n;i++){\\n            if(s[i]==s[i-1]){\\n                int len1 = i;\\n                int len2 = n-i;\\n                if((len2&1)){\\n                    ans=min(ans,suf[i][1]+pref[i-1][0]);\\n                    ans=min(ans,suf[i][0]+pref[i-1][1]);\\n                }\\n                else{\\n                    ans=min(ans,suf[i][1]+pref[i-1][1]);\\n                    ans=min(ans,suf[i][0]+pref[i-1][0]);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.length();\\n        int cnt = 0;\\n        int t = 1;\\n        int pref[n][2];\\n        for(int i=0;i<n;i++){\\n            if(t){\\n                if(s[i]==\\'0\\')\\n                    cnt++;\\n                t^=1;\\n            }\\n            else{\\n                if(s[i]==\\'1\\')\\n                    cnt++;\\n                t^=1;\\n            }\\n            pref[i][0]=i+1-cnt;\\n            pref[i][1]=cnt;\\n        }\\n        int suf[n][2];\\n        suf[0][1]=cnt;\\n        suf[0][0]=n-cnt;\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'1\\'){\\n                suf[i][0]=suf[i-1][1];\\n                suf[i][1]=suf[i-1][0]-1;\\n            }\\n            else{\\n                suf[i][1]=suf[i-1][0];\\n                suf[i][0]=suf[i-1][1]-1;\\n            }\\n            \\n        }\\n        int ans =min(pref[n-1][0],pref[n-1][1]);\\n        for(int i=1;i<n;i++){\\n            if(s[i]==s[i-1]){\\n                int len1 = i;\\n                int len2 = n-i;\\n                if((len2&1)){\\n                    ans=min(ans,suf[i][1]+pref[i-1][0]);\\n                    ans=min(ans,suf[i][0]+pref[i-1][1]);\\n                }\\n                else{\\n                    ans=min(ans,suf[i][1]+pref[i-1][1]);\\n                    ans=min(ans,suf[i][0]+pref[i-1][0]);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257289,
                "title": "simulation-presum-o-n-time-and-o-n-space",
                "content": "Calculating the flips to make s to \\'0101..\\' is enough, marked as f(0). \\nFlips to make a s to \"1010..\" will be len(s) - f(0).\\nProof is simple:\\nf(0) will get how many \"0\" and \"1\\'\"in wrong place. but if we want to make s start with 1, f(0) will be those \\'0\\' and \\'1\\' that in correct place.\\n\\n**Presum**\\nNow we only care about the target pattern \"0101..\".\\npresum[i] means for first i chars, how many flips is needed.\\n\\n**Rotation**\\nAfter rotation, ith char will be moved to head.\\nThe flips needed in substring s[i:] will be r = presum[-1] - presum[i].\\nThe value at position i will be i & 1.\\nAnd then, the value at position 0 will be start = (i & 1) ^ ((n - i) & 1), because 0th char will be placed at the tail.\\nThe substring on the left is s[:i].\\nIf start == 0, flips on the left is l = presum[i].\\nIf start == 1, flips on the left is l = i - presum[i].\\n\\nMinimum flips needed, if we rotate the string at i, is min(l + r, n - l - r)\\n\\n**Python**\\n```python\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        presum = [0]\\n        for i, c in enumerate(s):\\n            presum.append(presum[-1] + (int(c) ^ (i & 1)))\\n            \\n        res = n\\n        for i in range(n):\\n            # make ith char be i & 1, 0th char will be (i & 1) ^ ((n - i) & 1)\\n            r = presum[-1] - presum[i]\\n            start = (i & 1) ^ ((n - i) & 1)\\n            l = presum[i] if not start else i - presum[i]\\n            res = min(res, l + r, (n - l - r))\\n        return res\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int n = s.length();\\n        int[] presum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            presum[i + 1] = presum[i] + ((s.charAt(i) - \\'0\\') ^ (i & 1));\\n        }\\n        \\n        int res = n;\\n        for (int i = 0; i < n; i++) {\\n            int r = presum[n] - presum[i];\\n            int start = (i & 1) ^ ((n - i) & 1);\\n            int l = start == 0 ? presum[i] : i - presum[i];\\n            res = Math.min(res, Math.min(l + r, n - l - r));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        presum = [0]\\n        for i, c in enumerate(s):\\n            presum.append(presum[-1] + (int(c) ^ (i & 1)))\\n            \\n        res = n\\n        for i in range(n):\\n            # make ith char be i & 1, 0th char will be (i & 1) ^ ((n - i) & 1)\\n            r = presum[-1] - presum[i]\\n            start = (i & 1) ^ ((n - i) & 1)\\n            l = presum[i] if not start else i - presum[i]\\n            res = min(res, l + r, (n - l - r))\\n        return res\\n```\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int n = s.length();\\n        int[] presum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            presum[i + 1] = presum[i] + ((s.charAt(i) - \\'0\\') ^ (i & 1));\\n        }\\n        \\n        int res = n;\\n        for (int i = 0; i < n; i++) {\\n            int r = presum[n] - presum[i];\\n            int start = (i & 1) ^ ((n - i) & 1);\\n            int l = start == 0 ? presum[i] : i - presum[i];\\n            res = Math.min(res, Math.min(l + r, n - l - r));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257202,
                "title": "c-24ms-100-iterative-two-pass-only-odd-case",
                "content": "Runtime: 24 ms, faster than 100.00% of C++ online submissions for Minimum Number of Flips to Make the Binary String Alternating.\\nMemory Usage: 11.3 MB, less than 100.00% of C++ online submissions for Minimum Number of Flips to Make the Binary String Alternating.\\n**General idea : for cases with even length after counting 1 and 0 : answer = min(even1 + odd0 ,even0 + odd1). But for odd cases of length we will rotate our string (we only fetch first character and embed it in end of string and recalculate . As we have even1, odd0 ,even0, odd1 we only chainge it according to current character)**\\n**I tried to find out math solution for odd cases but I dont see any strict dependance . =(**\\n```\\nclass Solution {\\npublic:\\n  int minFlips(string s) {\\n    int odd1 = 0, odd0 = 0, even1 = 0, even0 = 0, answer, n = s.size();\\n    \\n    for(int i = 0; i < n; i += 2)\\n      s[i] == \\'1\\' ? even1++ : even0++;   //count 1 and 0 in even places    \\n    \\n    for(int i = 1; i < n; i += 2)        //count 1 and 0 in odd places \\n      s[i] == \\'1\\' ? odd1++ : odd0++;\\n    \\n    answer = min(even1 + odd0 ,even0 + odd1);     //if n is even\\n    \\n    if(n-- % 2 == 1){                             //if n is odd\\n      for(int i = 0; i != n; i++){\\n        swap(even1,odd1), swap(even0,odd0);\\n        if(s[i] == \\'0\\') odd0--, even0++;\\n        else odd1--, even1++;\\n        answer = min(answer, min(even0 + odd1 ,even1 + odd0));\\n      }\\n    }\\n    return answer;    \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minFlips(string s) {\\n    int odd1 = 0, odd0 = 0, even1 = 0, even0 = 0, answer, n = s.size();\\n    \\n    for(int i = 0; i < n; i += 2)\\n      s[i] == \\'1\\' ? even1++ : even0++;   //count 1 and 0 in even places    \\n    \\n    for(int i = 1; i < n; i += 2)        //count 1 and 0 in odd places \\n      s[i] == \\'1\\' ? odd1++ : odd0++;\\n    \\n    answer = min(even1 + odd0 ,even0 + odd1);     //if n is even\\n    \\n    if(n-- % 2 == 1){                             //if n is odd\\n      for(int i = 0; i != n; i++){\\n        swap(even1,odd1), swap(even0,odd0);\\n        if(s[i] == \\'0\\') odd0--, even0++;\\n        else odd1--, even1++;\\n        answer = min(answer, min(even0 + odd1 ,even1 + odd0));\\n      }\\n    }\\n    return answer;    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256014,
                "title": "c-o-n-time-o-1-space-by-counting-odd-position-even-positions-1-s-and-0-s",
                "content": "A little bit explanation here. Maintain two vectors odd[2], and even[2]\\nwhich respectively counts the 0s and 1s at the even and odd positions of the string. \\nodd[0]->odd position 0s count\\nodd[1]->odd position 1s count\\n...\\nTo make it alternativing, either we have all odd to be 1 && all even to be 0 || all odd to be 0 && all even to be 0. Therefore, if we **do not do any type-1 op**, the minimum number of ops is `min (odd[0] + even[1], odd[1] + even[0])`\\n\\nThen loop through s.size() cases where each time we move one starting char to the end (type-1 operation). To maintain and update the odd[] and even[] status, we can first delete the first char (assuming), and update the even[] result. Then, we swap odd[] and even[] (because after we shifting it by one). Lastly, we update odd[] or even[] by adding the last char. In the meantime, we update the minOps in each shift of starting char to the end. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        vector<int> odd(2, 0), even(2, 0); // 01 count ; \\n        for (int i = 0; i < s.size(); i++){\\n            if (i%2 == 0) even[s[i]-\\'0\\']++; \\n            else odd[s[i] -\\'0\\']++; \\n        }\\n        \\n        int minOps = min(odd[1] + even[0], odd[0]+even[1]); \\n        for (int i = 0; i < s.size(); i++){\\n\\t\\t\\t// Assuming first char is deleted \\n            char c = s[i];\\n            even[c-\\'0\\']--; \\n\\t\\t\\t\\n\\t\\t\\t// Swap even[] and odd[]\\n            auto tmp = even; \\n            even = odd; \\n            odd = tmp; \\n\\t\\t\\t\\n            // Append last one \\n            if ((s.size() - 1)%2 == 0) even[c-\\'0\\']++; \\n            else odd[c-\\'0\\']++; \\n\\t\\t\\t\\n\\t\\t\\t// Update minOps global optimum\\n            minOps = min(minOps, min(odd[1] + even[0], odd[0]+ even[1]));\\n        }\\n        \\n        return minOps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string s) {\\n        vector<int> odd(2, 0), even(2, 0); // 01 count ; \\n        for (int i = 0; i < s.size(); i++){\\n            if (i%2 == 0) even[s[i]-\\'0\\']++; \\n            else odd[s[i] -\\'0\\']++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1255338,
                "title": "python-3-counter-swap-for-odd-length-string-384ms",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        odd, even = defaultdict(int), defaultdict(int)\\n        for i in range(len(s)):\\n            if i % 2:\\n                odd[s[i]] += 1\\n            else:\\n                even[s[i]] += 1\\n\\n        ans =  min(odd[\\'1\\'] + even[\\'0\\'], odd[\\'0\\'] + even[\\'1\\'])\\n        \\n        # if even length string, odd and even position will not swap after each type-1 op\\n        if len(s) % 2 == 0: return ans\\n        \\n        # if odd length string:\\n        # 1. even and odd will swap after type-1 op\\n        # 2. index 0 will still be even after type-1 op\\n        for i in range(len(s)):\\n            even[s[i]] -= 1\\n            odd[s[i]] += 1\\n            even, odd = odd, even\\n            ans = min(ans, min(odd[\\'1\\'] + even[\\'0\\'], odd[\\'0\\'] + even[\\'1\\']))\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        odd, even = defaultdict(int), defaultdict(int)\\n        for i in range(len(s)):\\n            if i % 2:\\n                odd[s[i]] += 1\\n            else:\\n                even[s[i]] += 1\\n\\n        ans =  min(odd[\\'1\\'] + even[\\'0\\'], odd[\\'0\\'] + even[\\'1\\'])\\n        \\n        # if even length string, odd and even position will not swap after each type-1 op\\n        if len(s) % 2 == 0: return ans\\n        \\n        # if odd length string:\\n        # 1. even and odd will swap after type-1 op\\n        # 2. index 0 will still be even after type-1 op\\n        for i in range(len(s)):\\n            even[s[i]] -= 1\\n            odd[s[i]] += 1\\n            even, odd = odd, even\\n            ans = min(ans, min(odd[\\'1\\'] + even[\\'0\\'], odd[\\'0\\'] + even[\\'1\\']))\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1254784,
                "title": "1888-minimum-number-of-flips-simple-python-solution-with-comments",
                "content": "class Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n=len(s)\\n        \\n        \\'\\'\\'\\n            add string to it self so  \"010\" becomes \"010010\"\\n            this simulates Type-1: Remove in one operation\\n        \\'\\'\\'\\n        s=s+s \\n        \\n        diff1,diff2,result=0,0,0\\n        \\n        \\'\\'\\'\\n            create alternate 2 possible strings\\n            which has 0 in even place other  has 1 in even place\\n        \\'\\'\\'\\n        \\n        alt1,alt2=\"\",\"\"\\n        \\n        for i in range(len(s)):\\n            alt1+= \"0\" if i%2 else \"1\"\\n            alt2+= \"1\" if i%2  else \"0\"\\n        \\n        \\n        l=0\\n        result=n\\n        \\n        for i in range(len(s)):\\n            \\n            \\'\\'\\'\\n                1.compare with alt1,alt2 and if flip necessary increment the count\\n            \\'\\'\\'\\n            \\n            if s[i]!=alt1[i]:\\n                diff1+=1\\n            \\n            if s[i]!=alt2[i]:\\n                diff2+=1\\n            \\n            \\'\\'\\'\\n                if str len greater than n then it is necessary to increment left pointer\\n                but it removes lhs element (element before left pointer ) from consideration \\n                which effect diff1,diff2 count\\n            \\'\\'\\'\\n            if (i-l+1)>n:\\n                if s[l]!=alt1[l]:\\n                    diff1-=1\\n                    \\n                if s[l]!=alt2[l]:\\n                    diff2-=1\\n                \\n                l+=1\\n            \\n            if (i-l+1)==n:\\n                result=min(result,diff1,diff2)\\n            \\n            \\n        return result\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n=len(s)\\n        \\n        \\'\\'\\'\\n            add string to it self so  \"010\" becomes \"010010\"\\n            this simulates Type-1: Remove in one operation\\n        \\'\\'\\'\\n        s=s+s \\n        \\n        diff1,diff2,result=0,0,0\\n        \\n        \\'\\'\\'\\n            create alternate 2 possible strings\\n            which has 0 in even place other  has 1 in even place\\n        \\'\\'\\'\\n        \\n        alt1,alt2=\"\",\"\"\\n        \\n        for i in range(len(s)):\\n            alt1+= \"0\" if i%2 else \"1\"\\n            alt2+= \"1\" if i%2  else \"0\"\\n        \\n        \\n        l=0\\n        result=n\\n        \\n        for i in range(len(s)):\\n            \\n            \\'\\'\\'\\n                1.compare with alt1,alt2 and if flip necessary increment the count\\n            \\'\\'\\'\\n            \\n            if s[i]!=alt1[i]:\\n                diff1+=1\\n            \\n            if s[i]!=alt2[i]:\\n                diff2+=1\\n            \\n            \\'\\'\\'\\n                if str len greater than n then it is necessary to increment left pointer\\n                but it removes lhs element (element before left pointer ) from consideration \\n                which effect diff1,diff2 count\\n            \\'\\'\\'\\n            if (i-l+1)>n:\\n                if s[l]!=alt1[l]:\\n                    diff1-=1\\n                    \\n                if s[l]!=alt2[l]:\\n                    diff2-=1\\n                \\n                l+=1\\n            \\n            if (i-l+1)==n:\\n                result=min(result,diff1,diff2)\\n            \\n            \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 1254765,
                "title": "python-o-n-solution",
                "content": "Observation 1. Type-1 operation is just rotation, we can rotate input string as much as we like.\\nObservation 2. If the length is even, rotations don\\'t help. If the length is odd, rotation is equivalent to flipping the rotated bit.\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        N = len(s)\\n        d = [0,0]\\n        for i,v in enumerate(s):\\n            d[(i&1)^(v==\\'1\\')] += 1\\n        if not N&1:\\n            return min(d)\\n        d1 = [0,0]\\n        best = min(d)\\n        for j in range(N-1,-1,-1):\\n            d[(j&1)^(s[j]==\\'1\\')] -= 1\\n            d1[(j&1)^(s[j]==\\'0\\')] += 1\\n            best = min(best,d[0]+d1[0],d[1]+d1[1])\\n        return best\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        N = len(s)\\n        d = [0,0]\\n        for i,v in enumerate(s):\\n            d[(i&1)^(v==\\'1\\')] += 1\\n        if not N&1:\\n            return min(d)\\n        d1 = [0,0]\\n        best = min(d)\\n        for j in range(N-1,-1,-1):\\n            d[(j&1)^(s[j]==\\'1\\')] -= 1\\n            d1[(j&1)^(s[j]==\\'0\\')] += 1\\n            best = min(best,d[0]+d1[0],d[1]+d1[1])\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254706,
                "title": "doubt-on-testcase-0-1-0-0-1-0-0-1-1-0-1-how-to-solve",
                "content": "\\n# Testcase : \"0 1 0 0 1 0 0 1 1 0 1\"\\nCurrent : \"0 1 0 0 1 0 0 1 1 0 1\"\\nshifting 1 character to the end : 0 1 0 (*0*) 1 0 0 1 1 0 1 -> 0 1 0 1 0 0 1 1 0 1 0 \\nCurrent : 0 1 0 1 0 0 1 1 0 1 0  \\nshifting\\t :\\t\\t   0 1 0 1 0 (*0*) 1 1 0 1 0 -> 0 1 0 1 0  1 1 0 1 0 0\\nCurrent : 0 1 0 1 0 1 1 0 1 0 0\\nShifting : 0 1 0 1 0 1 (*1*) 0 1 0 0 -> 0 1 0 1 0 1 0 1 0 0 1\\ncurrent : 0 1 0 1 0 1 0 1 0 0 1\\nShifting : 0 1 0 1 0 1 0 1 0 (*0*) 1 -> 0 1 0 1 0 1 0 1 0 1 0 \\n\\nThe string has become alternating and total swaps are 0 \\nbut the output says its 2 \\nHow is it possible ? \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Swift",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "\\n# Testcase : \"0 1 0 0 1 0 0 1 1 0 1\"\\nCurrent : \"0 1 0 0 1 0 0 1 1 0 1\"\\nshifting 1 character to the end : 0 1 0 (*0*) 1 0 0 1 1 0 1 -> 0 1 0 1 0 0 1 1 0 1 0 \\nCurrent : 0 1 0 1 0 0 1 1 0 1 0  \\nshifting\\t :\\t\\t   0 1 0 1 0 (*0*) 1 1 0 1 0 -> 0 1 0 1 0  1 1 0 1 0 0\\nCurrent : 0 1 0 1 0 1 1 0 1 0 0\\nShifting : 0 1 0 1 0 1 (*1*) 0 1 0 0 -> 0 1 0 1 0 1 0 1 0 0 1\\ncurrent : 0 1 0 1 0 1 0 1 0 0 1\\nShifting : 0 1 0 1 0 1 0 1 0 (*0*) 1 -> 0 1 0 1 0 1 0 1 0 1 0 \\n\\nThe string has become alternating and total swaps are 0 \\nbut the output says its 2 \\nHow is it possible ? \\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1254409,
                "title": "python-easy-understanding-well-explained-sliding-window",
                "content": "if you get any doubt feel free to ask.\\n## IDEA :\\n* First make the copy of string (\"cp\" = s+s ), beacuse after performin type-1 operation maximum time we will come to end to that set of string only.\\n* after this, the question becomes sliding - window problem to check which n-length substring is having highly matchable \\'0\\' and \\'1\\' (minimum fliping required).\\n* create s1 and s2 string starting with \\'1\\' and \\'0\\' respectively with alternating position.\\n* comparing with \\'cp\\' double length string when you get different character at any position then increment their result by 1 (res1 and res2 resp.).\\n* when i of the loop get extended after n then start subtracting 1 from res1 and res2 when (i-n)th positions have different value.\\n* Now you are sliding the window by 1 to the right with comparision.\\n* In last , now u start comparing which window requires minimum flip ( res ).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n=len(s)\\n        cp=s+s\\n        s1=\"\"\\n        s2=\"\"\\n        for i in range(len(cp)):\\n            if i%2==0:\\n                s1+=\\'1\\'\\n                s2+=\\'0\\'\\n            else:\\n                s1+=\\'0\\'\\n                s2+=\\'1\\'\\n        \\n        res1=0\\n        res2=0\\n        res =10**6\\n        for i in range(len(cp)):\\n            if cp[i]!=s1[i]:\\n                res1+=1\\n                \\n            if cp[i]!=s2[i]:\\n                res2+=1\\n            \\n            if i>=n:\\n                if cp[i-n]!=s1[i-n]:\\n                    res1-=1\\n                if cp[i-n]!=s2[i-n]:\\n                    res2-=1\\n            if i>=n-1:\\n                res=min(res,res1,res2)\\n        \\n        return res\\n            \\nThank You !! \\uD83E\\uDD17\\nIf you got help then **Do Upvote** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "if you get any doubt feel free to ask.\\n## IDEA :\\n* First make the copy of string (\"cp\" = s+s ), beacuse after performin type-1 operation maximum time we will come to end to that set of string only.\\n* after this, the question becomes sliding - window problem to check which n-length substring is having highly matchable \\'0\\' and \\'1\\' (minimum fliping required).\\n* create s1 and s2 string starting with \\'1\\' and \\'0\\' respectively with alternating position.\\n* comparing with \\'cp\\' double length string when you get different character at any position then increment their result by 1 (res1 and res2 resp.).\\n* when i of the loop get extended after n then start subtracting 1 from res1 and res2 when (i-n)th positions have different value.\\n* Now you are sliding the window by 1 to the right with comparision.\\n* In last , now u start comparing which window requires minimum flip ( res ).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        n=len(s)\\n        cp=s+s\\n        s1=\"\"\\n        s2=\"\"\\n        for i in range(len(cp)):\\n            if i%2==0:\\n                s1+=\\'1\\'\\n                s2+=\\'0\\'\\n            else:\\n                s1+=\\'0\\'\\n                s2+=\\'1\\'\\n        \\n        res1=0\\n        res2=0\\n        res =10**6\\n        for i in range(len(cp)):\\n            if cp[i]!=s1[i]:\\n                res1+=1\\n                \\n            if cp[i]!=s2[i]:\\n                res2+=1\\n            \\n            if i>=n:\\n                if cp[i-n]!=s1[i-n]:\\n                    res1-=1\\n                if cp[i-n]!=s2[i-n]:\\n                    res2-=1\\n            if i>=n-1:\\n                res=min(res,res1,res2)\\n        \\n        return res\\n            \\nThank You !! \\uD83E\\uDD17\\nIf you got help then **Do Upvote** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1254231,
                "title": "java-solution-double-input-string-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        int n = s.length();\\n        for (int i = 0; i < 2 * n; i++) {\\n            if (i % 2 == 0) {\\n                sb1.append(\\'1\\');\\n                sb2.append(\\'0\\');\\n            } else {\\n                sb1.append(\\'0\\');\\n                sb2.append(\\'1\\');\\n            }\\n        }\\n        // construct two alternating strings\\n        String s1 = sb1.toString();\\n        String s2 = sb2.toString();\\n        // double the input string\\n        s += s;\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans = n;\\n        // use sliding window to compare \\n        for (int i = 0; i < 2 * n; i++) {\\n            if (s.charAt(i) != s1.charAt(i)) {\\n                ans1++;\\n            }\\n            if (s.charAt(i) != s2.charAt(i)) {\\n                ans2++;\\n            }\\n            if (i >= n) {   // left-most char is getting out of the sliding window\\n                if (s.charAt(i - n) != s1.charAt(i - n)) {\\n                    ans1--;\\n                }\\n                if (s.charAt(i - n) != s2.charAt(i - n)) {\\n                    ans2--;\\n                }\\n            }\\n            // get min ans\\n            if (i >= n - 1) {\\n                ans = Math.min(Math.min(ans1, ans2), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        int n = s.length();\\n        for (int i = 0; i < 2 * n; i++) {\\n            if (i % 2 == 0) {\\n                sb1.append(\\'1\\');\\n                sb2.append(\\'0\\');\\n            } else {\\n                sb1.append(\\'0\\');\\n                sb2.append(\\'1\\');\\n            }\\n        }\\n        // construct two alternating strings\\n        String s1 = sb1.toString();\\n        String s2 = sb2.toString();\\n        // double the input string\\n        s += s;\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans = n;\\n        // use sliding window to compare \\n        for (int i = 0; i < 2 * n; i++) {\\n            if (s.charAt(i) != s1.charAt(i)) {\\n                ans1++;\\n            }\\n            if (s.charAt(i) != s2.charAt(i)) {\\n                ans2++;\\n            }\\n            if (i >= n) {   // left-most char is getting out of the sliding window\\n                if (s.charAt(i - n) != s1.charAt(i - n)) {\\n                    ans1--;\\n                }\\n                if (s.charAt(i - n) != s2.charAt(i - n)) {\\n                    ans2--;\\n                }\\n            }\\n            // get min ans\\n            if (i >= n - 1) {\\n                ans = Math.min(Math.min(ans1, ans2), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254154,
                "title": "sliding-window",
                "content": "Golang.\\n```\\nfunc minFlips(s string) int {\\n    buf := make([]bool, len(s)<<1)\\n    for i := range s {\\n        buf[i] = s[i] == \\'1\\'\\n    }\\n    copy(buf[len(s):], buf[:len(s)])\\n    \\n    return min(count(buf, 0), count(buf, 1))\\n}\\n\\nfunc min(a, b int)int {\\n    if a < b {return a}\\n    \\n    return b\\n}\\n\\nfunc count(buf []bool, b int) int {\\n    r := 0\\n    cnt := 0\\n    \\n    for ; r < len(buf)>>1; r++{\\n        if r&1 == b {\\n            if buf[r] {cnt++}\\n        }else{\\n            if !buf[r] {cnt++}\\n        }\\n    }\\n    \\n    res := cnt\\n    for l := 0; r < len(buf); r++ {\\n         if r&1 == b {\\n            if buf[r] {cnt++}\\n        }else{\\n            if !buf[r] {cnt++}\\n        }\\n        if l&1 == b {\\n            if buf[l] {cnt--}\\n        }else{\\n            if !buf[l] {cnt--}\\n        }\\n        l++\\n        res = min(res, cnt)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minFlips(s string) int {\\n    buf := make([]bool, len(s)<<1)\\n    for i := range s {\\n        buf[i] = s[i] == \\'1\\'\\n    }\\n    copy(buf[len(s):], buf[:len(s)])\\n    \\n    return min(count(buf, 0), count(buf, 1))\\n}\\n\\nfunc min(a, b int)int {\\n    if a < b {return a}\\n    \\n    return b\\n}\\n\\nfunc count(buf []bool, b int) int {\\n    r := 0\\n    cnt := 0\\n    \\n    for ; r < len(buf)>>1; r++{\\n        if r&1 == b {\\n            if buf[r] {cnt++}\\n        }else{\\n            if !buf[r] {cnt++}\\n        }\\n    }\\n    \\n    res := cnt\\n    for l := 0; r < len(buf); r++ {\\n         if r&1 == b {\\n            if buf[r] {cnt++}\\n        }else{\\n            if !buf[r] {cnt++}\\n        }\\n        if l&1 == b {\\n            if buf[l] {cnt--}\\n        }else{\\n            if !buf[l] {cnt--}\\n        }\\n        l++\\n        res = min(res, cnt)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254043,
                "title": "simple-prefix-approach",
                "content": "#include <bits/stdc++.h>\\n#define int long long int \\nusing namespace std;\\nint32_t main()\\n{\\n    \\nstring s;\\ncin>>s;\\n\\n  int n =s.size();\\n        int a[n];\\n \\n    for(int i = 0; i < n; i++)\\n    {\\n\\n        if(s[i]==\\'1\\'){\\n            a[i] = 1;\\n        }\\n        else{\\n            a[i]=0;\\n        }\\n    }\\n \\n    int odd[n + 1];\\n    int even[n + 1];\\n \\n    odd[0] = 0;\\n    even[0] = 0;\\n \\n    for(int i = 0; i < n; i++)\\n    {\\n         \\n        \\n        if (i % 2 != 0)\\n        {\\n             \\n            \\n            odd[i + 1] = odd[i] + (a[i] == 1 ? 1 : 0);\\n            even[i + 1] = even[i] + (a[i] == 0 ? 1 : 0);\\n        }\\n \\n        \\n        else\\n        {\\n             \\n            \\n            odd[i + 1] = odd[i] + (a[i] == 0 ? 1 : 0);\\n            even[i + 1] = even[i] + (a[i] == 1 ? 1 : 0);\\n        }\\n    }\\n \\n\\n    for(int i =1;i<=n;i++){\\n        cout<<odd[i]<<\" \";\\n    }\\n    cout<<endl;\\n    for(int i =1;i<=n;i++){\\n        cout<<even[i]<<\" \";\\n    }\\n    cout<<endl;\\n    int minimum = min(odd[n], even[n]);\\n\\n    if(n%2!=0){\\n    for(int i = 0; i < n; i++)\\n    {\\n\\n\\n            minimum = min(minimum, odd[n] - odd[i + 1] + even[i + 1]);\\n            minimum = min(minimum, even[n] - even[i + 1] + odd[i + 1]);\\n\\n    }\\n}\\n \\ncout<<minimum;\\nreturn 0;\\n}\\n",
                "solutionTags": [],
                "code": "#include <bits/stdc++.h>\\n#define int long long int \\nusing namespace std;\\nint32_t main()\\n{\\n    \\nstring s;\\ncin>>s;\\n\\n  int n =s.size();\\n        int a[n];\\n \\n    for(int i = 0; i < n; i++)\\n    {\\n\\n        if(s[i]==\\'1\\'){\\n            a[i] = 1;\\n        }\\n        else{\\n            a[i]=0;\\n        }\\n    }\\n \\n    int odd[n + 1];\\n    int even[n + 1];\\n \\n    odd[0] = 0;\\n    even[0] = 0;\\n \\n    for(int i = 0; i < n; i++)\\n    {\\n         \\n        \\n        if (i % 2 != 0)\\n        {\\n             \\n            \\n            odd[i + 1] = odd[i] + (a[i] == 1 ? 1 : 0);\\n            even[i + 1] = even[i] + (a[i] == 0 ? 1 : 0);\\n        }\\n \\n        \\n        else\\n        {\\n             \\n            \\n            odd[i + 1] = odd[i] + (a[i] == 0 ? 1 : 0);\\n            even[i + 1] = even[i] + (a[i] == 1 ? 1 : 0);\\n        }\\n    }\\n \\n\\n    for(int i =1;i<=n;i++){\\n        cout<<odd[i]<<\" \";\\n    }\\n    cout<<endl;\\n    for(int i =1;i<=n;i++){\\n        cout<<even[i]<<\" \";\\n    }\\n    cout<<endl;\\n    int minimum = min(odd[n], even[n]);\\n\\n    if(n%2!=0){\\n    for(int i = 0; i < n; i++)\\n    {\\n\\n\\n            minimum = min(minimum, odd[n] - odd[i + 1] + even[i + 1]);\\n            minimum = min(minimum, even[n] - even[i + 1] + odd[i + 1]);\\n\\n    }\\n}\\n \\ncout<<minimum;\\nreturn 0;\\n}\\n",
                "codeTag": "C++"
            },
            {
                "id": 1254016,
                "title": "javascript-2-pointer-time-o-n-space-o-1",
                "content": "```javascript\\n/*\\n\\nstartZeroNumFlips:  number of flips if string were to start at i and start with 0\\nstartOneNumFlips:  number of flips if string were to start at i and start with 1\\n\\n*/\\n var minFlips = function(s) {\\n    // value to hold starting with zero\\n    let startZeroNumFlips = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (i % 2) {\\n            if (s[i] === \\'0\\') startZeroNumFlips++;\\n        } else {\\n            if (s[i] === \\'1\\') startZeroNumFlips++;\\n        }\\n    }\\n    let startOneNumFlips = s.length - startZeroNumFlips;\\n\\n    let minimumFlips = Math.min(startZeroNumFlips, startOneNumFlips);\\n    const isEvenLength = s.length % 2 === 0;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        \\n        // check the previous char to see which\\n        // value to decrement\\n        if (s[i - 1] === \\'1\\') {\\n            startZeroNumFlips--;    \\n        } else {\\n            startOneNumFlips--;\\n        }\\n\\n        // swap the 2 variables because we shifted the index by 1\\n        [startOneNumFlips, startZeroNumFlips] = [startZeroNumFlips, startOneNumFlips];\\n\\n        // add corresponding number of flips\\n        if (isEvenLength) {\\n            if (s[i - 1] === \\'1\\') {\\n                startOneNumFlips++;\\n            } else {\\n                startZeroNumFlips++;\\n            }\\n        } else {\\n            if (s[i - 1] === \\'1\\') {\\n                startZeroNumFlips++;\\n            } else {\\n                startOneNumFlips++;\\n            }\\n        }\\n\\n        // calculate the number of flips\\n        minimumFlips = Math.min(startZeroNumFlips, startOneNumFlips, minimumFlips);\\n    }\\n    return minimumFlips;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/*\\n\\nstartZeroNumFlips:  number of flips if string were to start at i and start with 0\\nstartOneNumFlips:  number of flips if string were to start at i and start with 1\\n\\n*/\\n var minFlips = function(s) {\\n    // value to hold starting with zero\\n    let startZeroNumFlips = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (i % 2) {\\n            if (s[i] === \\'0\\') startZeroNumFlips++;\\n        } else {\\n            if (s[i] === \\'1\\') startZeroNumFlips++;\\n        }\\n    }\\n    let startOneNumFlips = s.length - startZeroNumFlips;\\n\\n    let minimumFlips = Math.min(startZeroNumFlips, startOneNumFlips);\\n    const isEvenLength = s.length % 2 === 0;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        \\n        // check the previous char to see which\\n        // value to decrement\\n        if (s[i - 1] === \\'1\\') {\\n            startZeroNumFlips--;    \\n        } else {\\n            startOneNumFlips--;\\n        }\\n\\n        // swap the 2 variables because we shifted the index by 1\\n        [startOneNumFlips, startZeroNumFlips] = [startZeroNumFlips, startOneNumFlips];\\n\\n        // add corresponding number of flips\\n        if (isEvenLength) {\\n            if (s[i - 1] === \\'1\\') {\\n                startOneNumFlips++;\\n            } else {\\n                startZeroNumFlips++;\\n            }\\n        } else {\\n            if (s[i - 1] === \\'1\\') {\\n                startZeroNumFlips++;\\n            } else {\\n                startOneNumFlips++;\\n            }\\n        }\\n\\n        // calculate the number of flips\\n        minimumFlips = Math.min(startZeroNumFlips, startOneNumFlips, minimumFlips);\\n    }\\n    return minimumFlips;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253899,
                "title": "java-dp-o-n",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int n = s.length();\\n        int[][] f =  new int[n][2]; \\n\\t\\t// f[i][0]: cost when starting as 0 at index 1 ending at index i\\n\\t\\t// f[i][1]: cost when starting as 1 at index 0 ending at index i\\n        for (int i = 0, val1 = 0, val2 = 1, res1 = 0, res2 = 0; i < n; i++, val1 ^= 1, val2 ^= 1) {\\n            int val = s.charAt(i) - \\'0\\';\\n            res1 += val ^ val1;\\n            res2 += val ^ val2;\\n            f[i][0] = res1;\\n            f[i][1] = res2;\\n        }\\n        int[][] g =  new int[n][2];\\n\\t\\t// g[i][0]: cost when starting as 0 at index n - 1 ending at index i\\n\\t\\t// g[i][1]: cost when starting as 1 at index n - 1 ending at index i\\n        for (int i = n - 1, val1 = 0, val2 = 1, res1 = 0, res2 = 0; i >= 0; i--, val1 ^= 1, val2 ^= 1) {\\n            int val = s.charAt(i) - \\'0\\';\\n            res1 += val ^ val1;\\n            res2 += val ^ val2;\\n            g[i][0] = res1;\\n            g[i][1] = res2;\\n        }\\n        int res =  Math.min(g[0][1], g[0][0]);\\n        for (int i = 1; i < n; i++) {\\n\\t\\t    // g[i][1] + f[i - 1][0] denotes leftmost is 0 and rightmost is 1, split between index i -1 and i \\n\\t\\t\\t// g[i][0] + f[i - 1][1] denotes leftmost is 1 and rightmost is 0, split between index i -1 and i \\n            res = Math.min(res, Math.min(g[i][1] + f[i - 1][0], g[i][0] + f[i - 1][1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int n = s.length();\\n        int[][] f =  new int[n][2]; \\n\\t\\t// f[i][0]: cost when starting as 0 at index 1 ending at index i\\n\\t\\t// f[i][1]: cost when starting as 1 at index 0 ending at index i\\n        for (int i = 0, val1 = 0, val2 = 1, res1 = 0, res2 = 0; i < n; i++, val1 ^= 1, val2 ^= 1) {\\n            int val = s.charAt(i) - \\'0\\';\\n            res1 += val ^ val1;\\n            res2 += val ^ val2;\\n            f[i][0] = res1;\\n            f[i][1] = res2;\\n        }\\n        int[][] g =  new int[n][2];\\n\\t\\t// g[i][0]: cost when starting as 0 at index n - 1 ending at index i\\n\\t\\t// g[i][1]: cost when starting as 1 at index n - 1 ending at index i\\n        for (int i = n - 1, val1 = 0, val2 = 1, res1 = 0, res2 = 0; i >= 0; i--, val1 ^= 1, val2 ^= 1) {\\n            int val = s.charAt(i) - \\'0\\';\\n            res1 += val ^ val1;\\n            res2 += val ^ val2;\\n            g[i][0] = res1;\\n            g[i][1] = res2;\\n        }\\n        int res =  Math.min(g[0][1], g[0][0]);\\n        for (int i = 1; i < n; i++) {\\n\\t\\t    // g[i][1] + f[i - 1][0] denotes leftmost is 0 and rightmost is 1, split between index i -1 and i \\n\\t\\t\\t// g[i][0] + f[i - 1][1] denotes leftmost is 1 and rightmost is 0, split between index i -1 and i \\n            res = Math.min(res, Math.min(g[i][1] + f[i - 1][0], g[i][0] + f[i - 1][1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039554,
                "title": "simple-and-clean-c-code",
                "content": "# Intuition\\nconcatinating s 2 times and checking for window of size n\\n\\n# Approach\\ncounting number of 1\\'s and 0\\'s at even and odd places checking it for window of size n \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        s+=s;\\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(2,vector<int>(2,0));\\n        while(j<2*n){\\n//counting number of 0\\'s and 1\\'s at even and odd positions\\n            v[j%2][s[j]-\\'0\\']++;  \\n\\n//window of size n\\n            if(j-i+1==n){\\n\\n//only two combinations are possible \\n// 1:- 0 at even positions and 1 at odd positions\\n// 2:- 1 at even positions and 0 at odd positions\\n// keeping track of minimum possible answer\\n\\n\\n    ans=min(ans,min(n-(v[0][1]+v[1][0]),n-(v[1][1]+v[0][0])));\\n                v[i%2][s[i]-\\'0\\']--;\\n                i++;\\n            }\\n        j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        s+=s;\\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(2,vector<int>(2,0));\\n        while(j<2*n){\\n//counting number of 0\\'s and 1\\'s at even and odd positions\\n            v[j%2][s[j]-\\'0\\']++;  \\n\\n//window of size n\\n            if(j-i+1==n){\\n\\n//only two combinations are possible \\n// 1:- 0 at even positions and 1 at odd positions\\n// 2:- 1 at even positions and 0 at odd positions\\n// keeping track of minimum possible answer\\n\\n\\n    ans=min(ans,min(n-(v[0][1]+v[1][0]),n-(v[1][1]+v[0][0])));\\n                v[i%2][s[i]-\\'0\\']--;\\n                i++;\\n            }\\n        j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986144,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = size(s), a = 0, b = 0, ans = INT_MAX;\\n        s += s;\\n        for(int i = 0; i < 2*n; i++) {\\n            if(s[i]-\\'0\\' == i%2) ++a;\\n            if(s[i]-\\'0\\' != i%2) ++b;\\n            \\n            if(i >= n) {\\n                if(s[i-n]-\\'0\\' == (i-n)%2) --a;\\n                if(s[i-n]-\\'0\\' != (i-n)%2) --b;\\n            }\\n            if(i >= n-1)\\n                ans = min({a, b, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = size(s), a = 0, b = 0, ans = INT_MAX;\\n        s += s;\\n        for(int i = 0; i < 2*n; i++) {\\n            if(s[i]-\\'0\\' == i%2) ++a;\\n            if(s[i]-\\'0\\' != i%2) ++b;\\n            \\n            if(i >= n) {\\n                if(s[i-n]-\\'0\\' == (i-n)%2) --a;\\n                if(s[i-n]-\\'0\\' != (i-n)%2) --b;\\n            }\\n            if(i >= n-1)\\n                ans = min({a, b, ans});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962721,
                "title": "key-idea-fully-explained-python",
                "content": "## **Intuition**\\nImagine elements are sitting in form of a cycle, type1 operation is rotating that cycle\\n\\nThe order of type1 operation does not matter, because its just moving in a cycle\\nas long as the type2 operation is done on the right elements\\n\\n## **Solution for even length cycle**\\nImagine you have another cycle of alternating binary, so 0101 or 1010\\n\\nRotating the array cycle and comparing to alternating binary is\\nsame as rotating the alternating binary and comparing it to array cycle\\n\\nRealise that there are only two options because if you rotate alternating binary twice, you go back to the intial state\\n\\n## **Solution for odd length cycle**\\n10101 or 01010\\nif the cycle length is odd, then the head & tail of the alternating cycle will be the same\\nSo rotating alternating binary twice DOES NOT take us back to the intial state\\n\\nWe must explore every rotation and compare to both 10101 or 01010 every time\\n```\\n_     10101             _     01010     \\n0      0101             1      1010\\n01      101             10      010\\n010      01             101      10\\n0101      1             1010      0\\n01010     _             10101     _\\n```\\nBrute force would take O(n^2) time\\nBut we can do this O(n) by precomputing total difference and subtracting the difference calculated on fly\\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef minFlips(self, s: str) -> int:\\n    n = len(s)\\n    ch1 = \"0\"; ch2 = \"1\"\\n    OP1 = OP2 = 0\\n    for ch in s:\\n        OP1 += (ch != ch1)\\n        OP2 += (ch != ch2)\\n        ch1, ch2 = ch2, ch1\\n    ans = min(OP1, OP2)\\n\\n    if not n%2: return ans \\n    \\n    ch1 = \"0\"; ch2 = \"1\"\\n    op1 = op2 = 0\\n    for ch in s:\\n        op1 += (ch != ch1)\\n        op2 += (ch != ch2)\\n        ch1, ch2 = ch2, ch1\\n        \\n        ans = min(ans, op1 + OP2 - op2)\\n        ans = min(ans, op2 + OP1 - op1)\\n    \\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n_     10101             _     01010     \\n0      0101             1      1010\\n01      101             10      010\\n010      01             101      10\\n0101      1             1010      0\\n01010     _             10101     _\\n```\n```\\ndef minFlips(self, s: str) -> int:\\n    n = len(s)\\n    ch1 = \"0\"; ch2 = \"1\"\\n    OP1 = OP2 = 0\\n    for ch in s:\\n        OP1 += (ch != ch1)\\n        OP2 += (ch != ch2)\\n        ch1, ch2 = ch2, ch1\\n    ans = min(OP1, OP2)\\n\\n    if not n%2: return ans \\n    \\n    ch1 = \"0\"; ch2 = \"1\"\\n    op1 = op2 = 0\\n    for ch in s:\\n        op1 += (ch != ch1)\\n        op2 += (ch != ch2)\\n        ch1, ch2 = ch2, ch1\\n        \\n        ans = min(ans, op1 + OP2 - op2)\\n        ans = min(ans, op2 + OP1 - op1)\\n    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3940965,
                "title": "simple-python3-solution-99-9-sliding-window-simple-and-elegant-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the minimum number of flips needed to make a given binary string have alternating characters. The solution aims to achieve this by considering two possible alternate patterns: one starting with \"0\" and the other starting with \"1\". Then, it iterates through the string while keeping track of the differences between the original string and these two alternate patterns. The goal is to find the minimum number of differences at any position that matches the length of the original string.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the length of the input string n.\\n\\n2. Duplicate the input string by concatenating it with itself (s = s + s). This doubling of the string helps handle circular cases more easily.\\n\\n3. Initialize two alternate patterns, alt1 and alt2, where each character alternates between \"0\" and \"1\" (starting with different characters).\\n\\n4. Initialize variables: res to store the minimum number of flips needed, l to track the left end of the current substring, diff1 and diff2 to track the differences between the substring and the two alternate patterns.\\n\\n5. Iterate through the string using the variable r as the right end of the substring.\\n\\n- Update diff1 and diff2 by comparing the current character with the corresponding characters in alt1 and alt2.\\n- If the length of the current substring is greater than n, adjust the differences by removing the contribution of the leftmost character (s[l]) from the counts.\\n- If the length of the current substring is exactly n, update res with the minimum of the current values of res, diff1, and diff2. This accounts for the possibility of flipping a substring with the minimum differences.\\n\\n6. Finally, return the value of res, which represents the minimum number of flips needed to create an alternating pattern of characters.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 88.65% of Python3 Users\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 87.33% of Python Users\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s + s\\n        alt1 , alt2 = \" \" , \" \"\\n\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        l = 0\\n        diff1 , diff2 = 0 , 0 \\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1 +=1\\n            if s[r] != alt2[r]:\\n                diff2 +=1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1-=1\\n                if s[l] != alt2[l]:\\n                    diff2-=1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n        return res\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s + s\\n        alt1 , alt2 = \" \" , \" \"\\n\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        l = 0\\n        diff1 , diff2 = 0 , 0 \\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1 +=1\\n            if s[r] != alt2[r]:\\n                diff2 +=1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1-=1\\n                if s[l] != alt2[l]:\\n                    diff2-=1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n        return res\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903825,
                "title": "1888-minimum-number-of-flips-to-make-the-binary-string-alternating",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n      n = len(s)\\n      s = s+s\\n      alt1=\"\"\\n      alt2 =\"\"\\n      for i in range(len(s)):#store\\n        alt1 += \"0\" if i%2==0 else \"1\"\\n        alt2 += \"1\" if i%2==0 else \"0\"\\n      diff1,diff2 = 0,0\\n      l = 0\\n      res = len(s)\\n      for r in range(len(s)):#iterate\\n        if s[r]!=alt1[r]:#condition\\n            diff1 = diff1+1#count\\n        if s[r]!=alt2[r]:#condition\\n          diff2 = diff2+1#count\\n        if (r-l+1)>n:#count\\n          if s[l]!=alt1[l]:\\n            diff1 = diff1-1#count\\n          if s[l]!=alt2[l]:\\n            diff2 = diff2-1#count\\n          l = l+1#contract\\n        if (r-l+1)==n:\\n          res = min(res,diff1,diff2)#store\\n      return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n      n = len(s)\\n      s = s+s\\n      alt1=\"\"\\n      alt2 =\"\"\\n      for i in range(len(s)):#store\\n        alt1 += \"0\" if i%2==0 else \"1\"\\n        alt2 += \"1\" if i%2==0 else \"0\"\\n      diff1,diff2 = 0,0\\n      l = 0\\n      res = len(s)\\n      for r in range(len(s)):#iterate\\n        if s[r]!=alt1[r]:#condition\\n            diff1 = diff1+1#count\\n        if s[r]!=alt2[r]:#condition\\n          diff2 = diff2+1#count\\n        if (r-l+1)>n:#count\\n          if s[l]!=alt1[l]:\\n            diff1 = diff1-1#count\\n          if s[l]!=alt2[l]:\\n            diff2 = diff2-1#count\\n          l = l+1#contract\\n        if (r-l+1)==n:\\n          res = min(res,diff1,diff2)#store\\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869281,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int org_len = s.length();\\n        string a(org_len * 2, \\'0\\'); // 1 on evens\\n        string b(org_len * 2, \\'0\\'); // 1 on odds\\n        s = s + s;\\n\\n        //construct ideal\\n        for (int i = 0; i < org_len * 2; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                a[i] = \\'1\\';\\n            }\\n            else\\n            {\\n                b[i] = \\'1\\';\\n            }\\n        }\\n\\n        //sliding window comparison \\n     \\n        int diff1 = 0;\\n        int diff2 = 0;\\n\\n        for (int i = 0; i < org_len; i++)\\n        {\\n            if (s[i] != a[i]) diff1++;\\n            if (s[i] != b[i]) diff2++;\\n        }\\n\\n        int min_flip = min(diff1, diff2);\\n\\n        int lo = 0;\\n        for (int hi = org_len; hi < s.length(); lo++, hi++)\\n        {\\n            if (s[lo] != a[lo]) diff1--;\\n            if (s[lo] != b[lo]) diff2--;\\n            if (s[hi] != a[hi]) diff1++;\\n            if (s[hi] != b[hi]) diff2++;\\n\\n            min_flip = min(min_flip, diff1);\\n            min_flip = min(min_flip, diff2);\\n        }\\n        \\n        return min_flip;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int org_len = s.length();\\n        string a(org_len * 2, \\'0\\'); // 1 on evens\\n        string b(org_len * 2, \\'0\\'); // 1 on odds\\n        s = s + s;\\n\\n        //construct ideal\\n        for (int i = 0; i < org_len * 2; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                a[i] = \\'1\\';\\n            }\\n            else\\n            {\\n                b[i] = \\'1\\';\\n            }\\n        }\\n\\n        //sliding window comparison \\n     \\n        int diff1 = 0;\\n        int diff2 = 0;\\n\\n        for (int i = 0; i < org_len; i++)\\n        {\\n            if (s[i] != a[i]) diff1++;\\n            if (s[i] != b[i]) diff2++;\\n        }\\n\\n        int min_flip = min(diff1, diff2);\\n\\n        int lo = 0;\\n        for (int hi = org_len; hi < s.length(); lo++, hi++)\\n        {\\n            if (s[lo] != a[lo]) diff1--;\\n            if (s[lo] != b[lo]) diff2--;\\n            if (s[hi] != a[hi]) diff1++;\\n            if (s[hi] != b[hi]) diff2++;\\n\\n            min_flip = min(min_flip, diff1);\\n            min_flip = min(min_flip, diff2);\\n        }\\n        \\n        return min_flip;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838661,
                "title": "o-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the string length is odd, perform both operations (flip and rotate). Else, perform only flip operation.\\n\\nThe alternating binary string can either start with 0 (case 1) or with 1 (case 2)\\n\\nTwo ways to find the minimum number of flips:\\n1. Try both cases and check which case requires minimum flips. \\n    - For each case loop over all characters of the input string, if the current character is not the expected character according to alternation, increase the flip count by 1.\\n    - Time complexity = O(case1 + case2) -> O(n + n) -> O(n)\\n2. Count even odd position flips and return the minimum\\n    - For case 1, all 0\\'s are required at even position and 1\\'s at odd position. Flip bits that are not at their position i.e flip 0\\'s at odd position and 1\\'s at even positions\\n    - For case 2, all 0\\'s are required at odd position and 1\\'s at even position. Flip 0\\'s at even position and 1\\'s at odd position\\n    - Count 1\\'s at odd and even positions to find the required flips for each case. Check which case requires minimum flips, case 1 (flip 1\\'s at even position) or case 2 (flip 1\\'s at odd position)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        even, odd = (n + 1) // 2, n // 2\\n        x = s[::2].count(\\'1\\') - s[1::2].count(\\'1\\')\\n        res = min(even - x, odd + x)\\n        if n & 1:\\n            for c in s:\\n                x = 2 * int(c) - x\\n                res = min(res, even - x, odd + x)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        even, odd = (n + 1) // 2, n // 2\\n        x = s[::2].count(\\'1\\') - s[1::2].count(\\'1\\')\\n        res = min(even - x, odd + x)\\n        if n & 1:\\n            for c in s:\\n                x = 2 * int(c) - x\\n                res = min(res, even - x, odd + x)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823144,
                "title": "my-solutions",
                "content": "**1. Iterate from left to right, and then do it from right to left, at last combine the results**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int left[n + 1][options];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i + 1][zero_i] = (s[i] == zero ? 0 : 1) + left[i][one_i];\\n      left[i + 1][one_i] = (s[i] == one ? 0 : 1) + left[i][zero_i];\\n    }\\n    \\n    int ret = min(left[n][zero_i], left[n][one_i]);\\n    int right[options]{};\\n    for (int i = n - 1; i > -1; --i) {\\n      const int right_zero = (s[i] == zero ? 0 : 1) + right[one_i];\\n      const int right_one = (s[i] == one ? 0 : 1) + right[zero_i];\\n      right[zero_i] = right_zero;\\n      right[one_i] = right_one;\\n      if (is_odd) {\\n        ret = min({ret, right[zero_i] + left[i][zero_i], right[one_i] + left[i][one_i]});\\n      } else {\\n        ret = min({ret, right[zero_i] + left[i][one_i], right[one_i] + left[i][zero_i]});\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the sliding window**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int ret = numeric_limits<int>::max();\\n    int sliding_window[n + 1][options];\\n    memset(sliding_window, 0, sizeof(sliding_window));\\n    for (int i = 0; i < 2 * n - 1; ++i) {\\n      const char c = s[i % n];\\n      const int previous_index = i % (n + 1);\\n      const int index = (i + 1) % (n + 1);\\n      sliding_window[index][zero_i] = (c == zero ? 0 : 1) + sliding_window[previous_index][one_i];\\n      sliding_window[index][one_i] = (c == one ? 0 : 1) + sliding_window[previous_index][zero_i];\\n      if (i >= n - 1) {\\n        const int prev_window_start = (i + 2) % (n + 1);\\n        if (is_odd) {\\n          ret = min({ret,\\n                     sliding_window[index][zero_i] - sliding_window[prev_window_start][one_i],\\n                     sliding_window[index][one_i] - sliding_window[prev_window_start][zero_i]});\\n        } else {\\n          ret = min({ret,\\n                     sliding_window[index][zero_i] - sliding_window[prev_window_start][zero_i],\\n                     sliding_window[index][one_i] - sliding_window[prev_window_start][one_i]});\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the slinding window with the constant space complexity**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int ret = numeric_limits<int>::max();\\n    int end[options]{};\\n    int start[options]{};\\n    for (int i = 0; i < 2 * n - 1; ++i) {\\n      int original_end[options];\\n      memcpy(original_end, end, sizeof(original_end));\\n      const char end_c = s[i % n];\\n      end[zero_i] = (end_c == zero ? 0 : 1) + original_end[one_i];\\n      end[one_i] = (end_c == one ? 0 : 1) + original_end[zero_i];\\n      if (i >= n - 1) {\\n        if (i > n - 1) {\\n          int original_start[options];\\n          memcpy(original_start, start, sizeof(original_start));\\n          const char start_c = s[i - n];\\n          start[zero_i] = (start_c == zero ? 0 : 1) + original_start[one_i];\\n          start[one_i] = (start_c == one ? 0 : 1) + original_start[zero_i];\\n        }\\n        if (is_odd) {\\n          ret = min({ret, end[zero_i] - start[one_i], end[one_i] - start[zero_i]});\\n        } else {\\n          ret = min({ret, end[zero_i] - start[zero_i], end[one_i] - start[one_i]});\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int left[n + 1][options];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i + 1][zero_i] = (s[i] == zero ? 0 : 1) + left[i][one_i];\\n      left[i + 1][one_i] = (s[i] == one ? 0 : 1) + left[i][zero_i];\\n    }\\n    \\n    int ret = min(left[n][zero_i], left[n][one_i]);\\n    int right[options]{};\\n    for (int i = n - 1; i > -1; --i) {\\n      const int right_zero = (s[i] == zero ? 0 : 1) + right[one_i];\\n      const int right_one = (s[i] == one ? 0 : 1) + right[zero_i];\\n      right[zero_i] = right_zero;\\n      right[one_i] = right_one;\\n      if (is_odd) {\\n        ret = min({ret, right[zero_i] + left[i][zero_i], right[one_i] + left[i][one_i]});\\n      } else {\\n        ret = min({ret, right[zero_i] + left[i][one_i], right[one_i] + left[i][zero_i]});\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int ret = numeric_limits<int>::max();\\n    int sliding_window[n + 1][options];\\n    memset(sliding_window, 0, sizeof(sliding_window));\\n    for (int i = 0; i < 2 * n - 1; ++i) {\\n      const char c = s[i % n];\\n      const int previous_index = i % (n + 1);\\n      const int index = (i + 1) % (n + 1);\\n      sliding_window[index][zero_i] = (c == zero ? 0 : 1) + sliding_window[previous_index][one_i];\\n      sliding_window[index][one_i] = (c == one ? 0 : 1) + sliding_window[previous_index][zero_i];\\n      if (i >= n - 1) {\\n        const int prev_window_start = (i + 2) % (n + 1);\\n        if (is_odd) {\\n          ret = min({ret,\\n                     sliding_window[index][zero_i] - sliding_window[prev_window_start][one_i],\\n                     sliding_window[index][one_i] - sliding_window[prev_window_start][zero_i]});\\n        } else {\\n          ret = min({ret,\\n                     sliding_window[index][zero_i] - sliding_window[prev_window_start][zero_i],\\n                     sliding_window[index][one_i] - sliding_window[prev_window_start][one_i]});\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const string &s) {\\n    constexpr char zero = \\'0\\';\\n    constexpr char one = \\'1\\';\\n    constexpr int options = 2;\\n    constexpr int zero_i = 0;\\n    constexpr int one_i = 1;\\n    const int n = static_cast<int>(s.size());\\n    const bool is_odd = (n & 0b1) == 0b1;\\n    \\n    int ret = numeric_limits<int>::max();\\n    int end[options]{};\\n    int start[options]{};\\n    for (int i = 0; i < 2 * n - 1; ++i) {\\n      int original_end[options];\\n      memcpy(original_end, end, sizeof(original_end));\\n      const char end_c = s[i % n];\\n      end[zero_i] = (end_c == zero ? 0 : 1) + original_end[one_i];\\n      end[one_i] = (end_c == one ? 0 : 1) + original_end[zero_i];\\n      if (i >= n - 1) {\\n        if (i > n - 1) {\\n          int original_start[options];\\n          memcpy(original_start, start, sizeof(original_start));\\n          const char start_c = s[i - n];\\n          start[zero_i] = (start_c == zero ? 0 : 1) + original_start[one_i];\\n          start[one_i] = (start_c == one ? 0 : 1) + original_start[zero_i];\\n        }\\n        if (is_odd) {\\n          ret = min({ret, end[zero_i] - start[one_i], end[one_i] - start[zero_i]});\\n        } else {\\n          ret = min({ret, end[zero_i] - start[zero_i], end[one_i] - start[one_i]});\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756245,
                "title": "execution-beats-100-memory-beats-100-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Track the count of zeros at odd index, zeros at even index, ones at odd index and ones at even index respectively\\n- The total number of flip operations would be the following:\\n```\\nmin(\\n  |zerosAtOdd| + |onesAtEven|, // if the final result starts with zero\\n  |zerosAtEven| + |onesAtOdd|, // if the result starts with one\\n)\\n```\\n- For each shift, we track the above four counts:\\n  - For shifted number\\n    - If `n` is odd, its \"index oddity\" does not change\\n    - Otherwise, \"index oddity\" changes\\n  - For the rest elements, their \"index oddity\" are swapped, in other words, elements previously located at odd indices will be located at even indices, and vice versa\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(1)\\n\\n# Code\\n```\\nfunction minFlips(s: string): number {\\n  const memo = [\\n    [0, 0],\\n    [0, 0],\\n  ];\\n\\n  for (let i = 0; i < s.length; i++) {\\n    memo[s.charAt(i)][i & 1]++;\\n  }\\n  let ans = Math.min(memo[0][0] + memo[1][1], memo[0][1] + memo[1][0]);\\n  const isEvenLength = (s.length & 1) === 0;\\n  for (let i = 0; i < s.length; i++) {\\n    swap(memo[0], 0, 1);\\n    swap(memo[1], 0, 1);\\n\\n    if (!isEvenLength) {\\n      memo[s.charAt(i)][1]--;\\n      memo[s.charAt(i)][0]++;\\n    }\\n    ans = Math.min(\\n      ans,\\n      Math.min(memo[0][0] + memo[1][1], memo[0][1] + memo[1][0])\\n    );\\n  }\\n  return ans;\\n}\\n\\nfunction swap(arr: number[], i: number, j: number) {\\n  const tmp = arr[i];\\n  arr[i] = arr[j];\\n  arr[j] = tmp;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nmin(\\n  |zerosAtOdd| + |onesAtEven|, // if the final result starts with zero\\n  |zerosAtEven| + |onesAtOdd|, // if the result starts with one\\n)\\n```\n```\\nfunction minFlips(s: string): number {\\n  const memo = [\\n    [0, 0],\\n    [0, 0],\\n  ];\\n\\n  for (let i = 0; i < s.length; i++) {\\n    memo[s.charAt(i)][i & 1]++;\\n  }\\n  let ans = Math.min(memo[0][0] + memo[1][1], memo[0][1] + memo[1][0]);\\n  const isEvenLength = (s.length & 1) === 0;\\n  for (let i = 0; i < s.length; i++) {\\n    swap(memo[0], 0, 1);\\n    swap(memo[1], 0, 1);\\n\\n    if (!isEvenLength) {\\n      memo[s.charAt(i)][1]--;\\n      memo[s.charAt(i)][0]++;\\n    }\\n    ans = Math.min(\\n      ans,\\n      Math.min(memo[0][0] + memo[1][1], memo[0][1] + memo[1][0])\\n    );\\n  }\\n  return ans;\\n}\\n\\nfunction swap(arr: number[], i: number, j: number) {\\n  const tmp = arr[i];\\n  arr[i] = arr[j];\\n  arr[j] = tmp;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745540,
                "title": "python-medium-sliding-window",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s += s\\n        arr = [int(char) for char in s]\\n\\n\\n        def calc(arr):\\n            N = len(arr) // 2\\n\\n            prefSum = [0]\\n            ans = float(\"inf\")\\n\\n            for i in range(len(arr)):\\n                if i % 2 == 0:\\n                    if arr[i] == 0:\\n                        prefSum.append(prefSum[-1] + 1)\\n\\n                    else:\\n                        prefSum.append(prefSum[-1])\\n\\n                else:\\n                    if arr[i] == 1:\\n                        prefSum.append(prefSum[-1] + 1)\\n\\n                    else:\\n                        prefSum.append(prefSum[-1])\\n\\n                \\n                if i >= N:\\n                    ans = min(ans, prefSum[i] - prefSum[i - N])\\n\\n               \\n\\n\\n  \\n            return ans\\n\\n            \\n        r = [char ^ 1 for char in arr]\\n        return min(calc(arr), calc(r))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        s += s\\n        arr = [int(char) for char in s]\\n\\n\\n        def calc(arr):\\n            N = len(arr) // 2\\n\\n            prefSum = [0]\\n            ans = float(\"inf\")\\n\\n            for i in range(len(arr)):\\n                if i % 2 == 0:\\n                    if arr[i] == 0:\\n                        prefSum.append(prefSum[-1] + 1)\\n\\n                    else:\\n                        prefSum.append(prefSum[-1])\\n\\n                else:\\n                    if arr[i] == 1:\\n                        prefSum.append(prefSum[-1] + 1)\\n\\n                    else:\\n                        prefSum.append(prefSum[-1])\\n\\n                \\n                if i >= N:\\n                    ans = min(ans, prefSum[i] - prefSum[i - N])\\n\\n               \\n\\n\\n  \\n            return ans\\n\\n            \\n        r = [char ^ 1 for char in arr]\\n        return min(calc(arr), calc(r))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738642,
                "title": "java-9ms-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA valid sequence either starts with 0 (0101..) or starts with 1 (1010...), compare with given string then the difference number is the flip operations needed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen string length is even, the cycle operation doesn\\'t really matter. Since a valid even length sequence is still valid after cycle.\\n\\nWhen string length is odd, the cycle operation means the string can be split to two parts: one even length valid sequence and one odd length valid sequence. Iterate all splits, find the minimum summed difference of two parts.\\n\\nPrefix Sum is used to record summed difference at each point.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Runtime\\n9ms\\n\\n# Code\\n```\\nclass Solution {\\n    static final int[] BITS = new int[(int) \\'1\\' + 1];\\n    static {\\n        BITS[\\'0\\'] = 0;\\n        BITS[\\'1\\'] = 1;\\n    }\\n\\n    public int minFlips(String s) {\\n        byte[] bytes = s.getBytes();\\n        int length = bytes.length;\\n        if (length <= 1) {\\n            return 0;\\n        }\\n\\n        // evenSeq represents 010101..., first number is 0\\n        // oddSeq  represents 101010..., first number is 1\\n        int evenSeq = 0, oddSeq = 1;\\n\\n        // Prefix sum of diff for even sequence and odd sequence\\n        int[] evenDiff = new int[length];\\n        int[] oddDiff = new int[length];\\n\\n        evenDiff[0] = BITS[bytes[0]] ^ evenSeq;\\n        oddDiff[0] = BITS[bytes[0]] ^ oddSeq;\\n\\n        for (int i = 1; i < length; i++) {\\n            // Flip the sequence number\\n            evenSeq = 1 - evenSeq;\\n            oddSeq = 1 - oddSeq;\\n\\n            // Sum diff\\n            evenDiff[i] = evenDiff[i - 1] + (BITS[bytes[i]] ^ evenSeq);\\n            oddDiff[i] = oddDiff[i - 1] + (BITS[bytes[i]] ^ oddSeq);\\n        }\\n\\n        // When string length is even, no matter how it cycles, it\\'s either even sequence or odd sequence\\n        int result = Math.min(evenDiff[length - 1], oddDiff[length - 1]);\\n        if (length % 2 == 0 || result == 0) {\\n            return result;\\n        }\\n\\n        // When string length is odd, need consider cycle. E.g, for 1010101:\\n        // Cycle starting \\'10\\'  to the end will get: 1010110\\n        // Cycle starting \\'101\\' to the end will get: 0101101\\n        // In these cases, the string becomes either evenSeq at left + oddSeq at right\\n        // , or oddSeq at left + evenSeq at right\\n        for (int i = length - 1; i > 0; i--) {\\n\\n            // `oddDiff[length - 1] - oddDiff[i - 1]` gives the diff for odd sequence at right side\\n            // `evenDiff[length - 1] - evenDiff[i - 1]` gives the diff for even sequence at right side\\n            result = Math.min(result, oddDiff[length - 1] - oddDiff[i - 1] + evenDiff[i - 1]);\\n            result = Math.min(result, evenDiff[length - 1] - evenDiff[i - 1] + oddDiff[i - 1]);\\n            if (result == 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    static final int[] BITS = new int[(int) \\'1\\' + 1];\\n    static {\\n        BITS[\\'0\\'] = 0;\\n        BITS[\\'1\\'] = 1;\\n    }\\n\\n    public int minFlips(String s) {\\n        byte[] bytes = s.getBytes();\\n        int length = bytes.length;\\n        if (length <= 1) {\\n            return 0;\\n        }\\n\\n        // evenSeq represents 010101..., first number is 0\\n        // oddSeq  represents 101010..., first number is 1\\n        int evenSeq = 0, oddSeq = 1;\\n\\n        // Prefix sum of diff for even sequence and odd sequence\\n        int[] evenDiff = new int[length];\\n        int[] oddDiff = new int[length];\\n\\n        evenDiff[0] = BITS[bytes[0]] ^ evenSeq;\\n        oddDiff[0] = BITS[bytes[0]] ^ oddSeq;\\n\\n        for (int i = 1; i < length; i++) {\\n            // Flip the sequence number\\n            evenSeq = 1 - evenSeq;\\n            oddSeq = 1 - oddSeq;\\n\\n            // Sum diff\\n            evenDiff[i] = evenDiff[i - 1] + (BITS[bytes[i]] ^ evenSeq);\\n            oddDiff[i] = oddDiff[i - 1] + (BITS[bytes[i]] ^ oddSeq);\\n        }\\n\\n        // When string length is even, no matter how it cycles, it\\'s either even sequence or odd sequence\\n        int result = Math.min(evenDiff[length - 1], oddDiff[length - 1]);\\n        if (length % 2 == 0 || result == 0) {\\n            return result;\\n        }\\n\\n        // When string length is odd, need consider cycle. E.g, for 1010101:\\n        // Cycle starting \\'10\\'  to the end will get: 1010110\\n        // Cycle starting \\'101\\' to the end will get: 0101101\\n        // In these cases, the string becomes either evenSeq at left + oddSeq at right\\n        // , or oddSeq at left + evenSeq at right\\n        for (int i = length - 1; i > 0; i--) {\\n\\n            // `oddDiff[length - 1] - oddDiff[i - 1]` gives the diff for odd sequence at right side\\n            // `evenDiff[length - 1] - evenDiff[i - 1]` gives the diff for even sequence at right side\\n            result = Math.min(result, oddDiff[length - 1] - oddDiff[i - 1] + evenDiff[i - 1]);\\n            result = Math.min(result, evenDiff[length - 1] - evenDiff[i - 1] + oddDiff[i - 1]);\\n            if (result == 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722258,
                "title": "linear-time",
                "content": "\\n# Approach\\nsliding window\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s+s\\n        alt1,alt2 = \"\",\"\"\\n\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        diff1,diff2 = 0 , 0\\n        l = 0\\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1 += 1\\n            if s[r] != alt2[r]:\\n                diff2 += 1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1 -= 1\\n                if s[l] != alt2[l]:\\n                    diff2 -= 1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s+s\\n        alt1,alt2 = \"\",\"\"\\n\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        diff1,diff2 = 0 , 0\\n        l = 0\\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1 += 1\\n            if s[r] != alt2[r]:\\n                diff2 += 1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1 -= 1\\n                if s[l] != alt2[l]:\\n                    diff2 -= 1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668759,
                "title": "sliding-window-approach",
                "content": "# Approach\\nApproach is simple to to make the string either 1010... or 0101...\\nIf we try to make the string as 1010... in (x) flips then we can make the string 0101... in (n - x) flips which can be seen through common examples. So we can track down the whole process for every string by taking the first character and appending it to the last. But this process can take up O(n2) time. We can optimise the process by using sliding window process. \\n                    \\n                            s=     01110101\\n                            news = 1010101010101...........\\nFor better understanding i have taken news to be a of infinite length.\\nIf we take s as the given string and news as the string we want to convert into, the strings after removal and appending of first character becomes\\n                          ```\\n```\\n        s = 1110101 1\\n     news = 0101010 0 1010101.....\\n```\\n\\nTo have a better comparison I have moved the first character of news to back of news as it is of infinte length we can assume it to be vanished.\\nWe can see apart from the last character all other character of s share the same corresponding bits with news. So we can make a sliding window of length n and make s to be twice that of itself and move our window to track down the changes in only last charater entered and unmark its contribution from first.\\n\\nTo make it convenient for 0101.. i have taken flip to start from 0 and altered it with xor every time we pass through the loop to create the effect of 01010...\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.length();\\n        string final = s + s;\\n        int flip = 0, cost = 0;\\n        for(int i = 0; i < n; i++){\\n            if(flip != (s[i]- \\'0\\')){\\n                cost++;\\n            }\\n            flip = flip^1;\\n        }\\n        int start = 0;\\n        int ans = min(cost,n-cost);\\n        for(int i = n; i < 2*n; i++){\\n            if(start != (final[i] - \\'0\\')){\\n                cost--;\\n            }\\n            start = start^1;\\n            if(final[i] - \\'0\\' != flip){\\n                cost++;\\n            }\\n            flip = flip^1;\\n            ans = min(ans,min(cost,n-cost));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\n\\nTo have a better comparison I have moved the first character of news to back of news as it is of infinte length we can assume it to be vanished.\\nWe can see apart from the last character all other character of s share the same corresponding bits with news. So we can make a sliding window of length n and make s to be twice that of itself and move our window to track down the changes in only last charater entered and unmark its contribution from first.\\n\\nTo make it convenient for 0101.. i have taken flip to start from 0 and altered it with xor every time we pass through the loop to create the effect of 01010...\\n```\n```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653766,
                "title": "easiest-to-read-o-n-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        string s1(n, \\'0\\');\\n        string s2(n, \\'0\\');\\n\\n        bool flag = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (flag)\\n                s1[i] = \\'1\\';\\n            if (!flag)\\n                s2[i] = \\'1\\';\\n            flag = !flag;\\n        }\\n\\n        if (n % 2 == 0) {\\n            s1 += s1;\\n            s2 += s2;\\n        } else {\\n            s1 += s2;\\n            s2 += s1;\\n        }\\n\\n        int ans = 0;\\n        \\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] != s1[i]) cnt1++;\\n            \\n            if(s[i] != s2[i]) cnt2++;\\n        }\\n\\n        ans = min(cnt1 , cnt2);\\n\\n        int i = 0;\\n        int j = n;\\n        s += s;\\n\\n        while(j < s.size()){\\n            if(s[i] != s1[i]) cnt1--;\\n            \\n            if(s[i] != s2[i]) cnt2--;\\n            \\n            if(s[j] != s1[j]) cnt1++;\\n\\n            if(s[j] != s2[j]) cnt2++;\\n\\n            i++;j++;\\n           \\n            ans = min(ans , min(cnt1 , cnt2));\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        string s1(n, \\'0\\');\\n        string s2(n, \\'0\\');\\n\\n        bool flag = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (flag)\\n                s1[i] = \\'1\\';\\n            if (!flag)\\n                s2[i] = \\'1\\';\\n            flag = !flag;\\n        }\\n\\n        if (n % 2 == 0) {\\n            s1 += s1;\\n            s2 += s2;\\n        } else {\\n            s1 += s2;\\n            s2 += s1;\\n        }\\n\\n        int ans = 0;\\n        \\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] != s1[i]) cnt1++;\\n            \\n            if(s[i] != s2[i]) cnt2++;\\n        }\\n\\n        ans = min(cnt1 , cnt2);\\n\\n        int i = 0;\\n        int j = n;\\n        s += s;\\n\\n        while(j < s.size()){\\n            if(s[i] != s1[i]) cnt1--;\\n            \\n            if(s[i] != s2[i]) cnt2--;\\n            \\n            if(s[j] != s1[j]) cnt1++;\\n\\n            if(s[j] != s2[j]) cnt2++;\\n\\n            i++;j++;\\n           \\n            ans = min(ans , min(cnt1 , cnt2));\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646245,
                "title": "simple-python-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFlips(self, s):\\n        n=len(s)\\n        s+=s\\n        st1=\\'01\\'*(2*n)\\n        st2=\\'10\\'*(2*n)\\n        dif1,dif2=0,0\\n        ans=len(s)\\n        for i in range(2*n):\\n            if s[i]!=st1[i]:\\n                dif1+=1\\n            if s[i]!=st2[i]:\\n                dif2+=1\\n            if i>=n:\\n                if s[i-n]!=st1[i-n]:\\n                    dif1-=1\\n                if s[i-n]!=st2[i-n]:\\n                    dif2-=1\\n                ans=min(ans,dif1,dif2)\\n        return ans\\n                \\n        \\n        \\n        \\'\\'\\'\\n        #kindly ignore this\\n        n=len(s)\\n        s=s+s\\n        st1,st2=\"\",\"\"\\n        for i in range(len(s)):\\n            if i%2==0:\\n                st1+=\\'0\\'\\n                st2+=\\'1\\'\\n            else:\\n                st1+=\\'1\\'\\n                st2+=\\'0\\'\\n        diff1,diff2=0,0\\n        ans=len(s)\\n        l=0\\n        r=0\\n        while r<len(s):\\n            if s[r]!=st1[r]:\\n                diff1+=1\\n            if s[r]!=st2[r]:\\n                diff2+=1\\n            if (r-l+1)>n:\\n                if s[l]!=st1[l]:\\n                    diff1-=1\\n                if s[l]!=st2[l]:\\n                    diff2-=1\\n                l+=1\\n            if r-l+1==n:\\n                ans=min(ans,diff1,diff2)\\n            r+=1\\n        return ans\\n        \\'\\'\\'\\n            \\n        \\n\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, s):\\n        n=len(s)\\n        s+=s\\n        st1=\\'01\\'*(2*n)\\n        st2=\\'10\\'*(2*n)\\n        dif1,dif2=0,0\\n        ans=len(s)\\n        for i in range(2*n):\\n            if s[i]!=st1[i]:\\n                dif1+=1\\n            if s[i]!=st2[i]:\\n                dif2+=1\\n            if i>=n:\\n                if s[i-n]!=st1[i-n]:\\n                    dif1-=1\\n                if s[i-n]!=st2[i-n]:\\n                    dif2-=1\\n                ans=min(ans,dif1,dif2)\\n        return ans\\n                \\n        \\n        \\n        \\'\\'\\'\\n        #kindly ignore this\\n        n=len(s)\\n        s=s+s\\n        st1,st2=\"\",\"\"\\n        for i in range(len(s)):\\n            if i%2==0:\\n                st1+=\\'0\\'\\n                st2+=\\'1\\'\\n            else:\\n                st1+=\\'1\\'\\n                st2+=\\'0\\'\\n        diff1,diff2=0,0\\n        ans=len(s)\\n        l=0\\n        r=0\\n        while r<len(s):\\n            if s[r]!=st1[r]:\\n                diff1+=1\\n            if s[r]!=st2[r]:\\n                diff2+=1\\n            if (r-l+1)>n:\\n                if s[l]!=st1[l]:\\n                    diff1-=1\\n                if s[l]!=st2[l]:\\n                    diff2-=1\\n                l+=1\\n            if r-l+1==n:\\n                ans=min(ans,diff1,diff2)\\n            r+=1\\n        return ans\\n        \\'\\'\\'\\n            \\n        \\n\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640806,
                "title": "sliding-window-neetcode",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int org_len=s.length();\\n        s=s+s;\\n\\n        StringBuilder sb1=new StringBuilder();\\n        StringBuilder sb2=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i%2==0) sb1.append(\"0\");\\n            else sb1.append(\"1\");\\n            if(i%2==1) sb2.append(\"0\");\\n            else sb2.append(\"1\");\\n        }\\n        String zerostart=sb1.toString();\\n        String onestart=sb2.toString();\\n\\n        int diff1=0, diff2=0,min=org_len;\\n\\n        for(int i=0;i<org_len;i++)\\n        {\\n            if(zerostart.charAt(i)!=s.charAt(i)) diff1++;\\n            if(onestart.charAt(i)!=s.charAt(i)) diff2++;\\n        }\\n\\n        min=Math.min(min,Math.min(diff1,diff2));\\n        int l=0;\\n        for(int i=org_len;i<s.length();i++)\\n        {\\n            if(zerostart.charAt(i)!=s.charAt(i)) diff1++;\\n            if(onestart.charAt(i)!=s.charAt(i)) diff2++;\\n            if(zerostart.charAt(l)!=s.charAt(l)) diff1--;\\n            if(onestart.charAt(l)!=s.charAt(l)) diff2--;\\n            l++;\\n            min=Math.min(min,Math.min(diff1,diff2));\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int org_len=s.length();\\n        s=s+s;\\n\\n        StringBuilder sb1=new StringBuilder();\\n        StringBuilder sb2=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i%2==0) sb1.append(\"0\");\\n            else sb1.append(\"1\");\\n            if(i%2==1) sb2.append(\"0\");\\n            else sb2.append(\"1\");\\n        }\\n        String zerostart=sb1.toString();\\n        String onestart=sb2.toString();\\n\\n        int diff1=0, diff2=0,min=org_len;\\n\\n        for(int i=0;i<org_len;i++)\\n        {\\n            if(zerostart.charAt(i)!=s.charAt(i)) diff1++;\\n            if(onestart.charAt(i)!=s.charAt(i)) diff2++;\\n        }\\n\\n        min=Math.min(min,Math.min(diff1,diff2));\\n        int l=0;\\n        for(int i=org_len;i<s.length();i++)\\n        {\\n            if(zerostart.charAt(i)!=s.charAt(i)) diff1++;\\n            if(onestart.charAt(i)!=s.charAt(i)) diff2++;\\n            if(zerostart.charAt(l)!=s.charAt(l)) diff1--;\\n            if(onestart.charAt(l)!=s.charAt(l)) diff2--;\\n            l++;\\n            min=Math.min(min,Math.min(diff1,diff2));\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635764,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size() ;\\n        vector<int>left0(n) ;\\n        vector<int>left1(n) ;\\n        vector<int>right0(n) ;\\n        vector<int>right1(n) ;\\n        if(s[0] == \\'0\\')\\n            left1[0] = 1 ;\\n        else \\n            left0[0] = 1 ;\\n        if(s[n-1] == \\'0\\')\\n            right1[n-1] = 1 ;\\n        else\\n            right0[n-1] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            left0[i] = left0[i-1] ;    \\n            left1[i] = left1[i-1] ;    \\n            if(i %2 == 1){\\n                if(s[i] == \\'1\\')\\n                    left1[i]++ ;\\n                else\\n                    left0[i]++ ;\\n            }\\n            else{\\n                if(s[i] == \\'1\\')\\n                    left0[i]++ ;\\n                else\\n                    left1[i]++ ;                \\n            }\\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            right0[i] = right0[i+1] ;    \\n            right1[i] = right1[i+1] ;  \\n            if((n-1-i) %2 == 1){\\n                if(s[i] == \\'1\\')\\n                    right1[i]++ ;\\n                else\\n                    right0[i]++ ;\\n            }\\n            else{\\n                if(s[i] == \\'1\\')\\n                    right0[i]++ ;\\n                else\\n                    right1[i]++ ;                \\n            }\\n        }\\n        int ret = n ;\\n        ret = min(ret , left0[n-1]) ;\\n        ret = min(ret , left1[n-1]) ;\\n        for(int i = 1; i < n-1; i++){\\n            ret = min(ret, left0[i] + right1[i+1]) ;\\n            ret = min(ret, left1[i] + right0[i+1]) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size() ;\\n        vector<int>left0(n) ;\\n        vector<int>left1(n) ;\\n        vector<int>right0(n) ;\\n        vector<int>right1(n) ;\\n        if(s[0] == \\'0\\')\\n            left1[0] = 1 ;\\n        else \\n            left0[0] = 1 ;\\n        if(s[n-1] == \\'0\\')\\n            right1[n-1] = 1 ;\\n        else\\n            right0[n-1] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            left0[i] = left0[i-1] ;    \\n            left1[i] = left1[i-1] ;    \\n            if(i %2 == 1){\\n                if(s[i] == \\'1\\')\\n                    left1[i]++ ;\\n                else\\n                    left0[i]++ ;\\n            }\\n            else{\\n                if(s[i] == \\'1\\')\\n                    left0[i]++ ;\\n                else\\n                    left1[i]++ ;                \\n            }\\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            right0[i] = right0[i+1] ;    \\n            right1[i] = right1[i+1] ;  \\n            if((n-1-i) %2 == 1){\\n                if(s[i] == \\'1\\')\\n                    right1[i]++ ;\\n                else\\n                    right0[i]++ ;\\n            }\\n            else{\\n                if(s[i] == \\'1\\')\\n                    right0[i]++ ;\\n                else\\n                    right1[i]++ ;                \\n            }\\n        }\\n        int ret = n ;\\n        ret = min(ret , left0[n-1]) ;\\n        ret = min(ret , left1[n-1]) ;\\n        for(int i = 1; i < n-1; i++){\\n            ret = min(ret, left0[i] + right1[i+1]) ;\\n            ret = min(ret, left1[i] + right0[i+1]) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621381,
                "title": "hint-implemented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nImplementation of the method in the hint\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        result = float(\\'inf\\')\\n        countOdd = 0\\n        countEven = 0\\n\\n        for i in range(0, len(s)):\\n            if s[i] == \\'1\\' and i % 2 == 0:\\n                countEven += 1\\n            elif s[i] == \\'1\\' and i % 2 == 1:\\n                countOdd += 1\\n            else:\\n                continue\\n        s = s * 2\\n        print(countEven, countOdd)\\n        for i in range(0, n):\\n            if s[i] == \\'1\\':\\n                countEven -= 1\\n            if s[i+n] == \\'1\\':\\n                if n % 2 == 0:\\n                    countEven += 1\\n                else:\\n                    countOdd += 1\\n            tmp = countOdd\\n            countOdd = countEven\\n            countEven = tmp\\n            \\n            odd = math.floor(n / 2)\\n            even = math.floor(n / 2)\\n            if n % 2 == 1:\\n                even += 1\\n            \\n            # 1\\'s in the even positions\\n            x = even - countEven + countOdd\\n            \\n\\n            # 1\\'s in the odd positions\\n            y = odd - countOdd + countEven\\n            result = min(result,x)\\n            result = min(result,y)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        result = float(\\'inf\\')\\n        countOdd = 0\\n        countEven = 0\\n\\n        for i in range(0, len(s)):\\n            if s[i] == \\'1\\' and i % 2 == 0:\\n                countEven += 1\\n            elif s[i] == \\'1\\' and i % 2 == 1:\\n                countOdd += 1\\n            else:\\n                continue\\n        s = s * 2\\n        print(countEven, countOdd)\\n        for i in range(0, n):\\n            if s[i] == \\'1\\':\\n                countEven -= 1\\n            if s[i+n] == \\'1\\':\\n                if n % 2 == 0:\\n                    countEven += 1\\n                else:\\n                    countOdd += 1\\n            tmp = countOdd\\n            countOdd = countEven\\n            countEven = tmp\\n            \\n            odd = math.floor(n / 2)\\n            even = math.floor(n / 2)\\n            if n % 2 == 1:\\n                even += 1\\n            \\n            # 1\\'s in the even positions\\n            x = even - countEven + countOdd\\n            \\n\\n            # 1\\'s in the odd positions\\n            y = odd - countOdd + countEven\\n            result = min(result,x)\\n            result = min(result,y)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594277,
                "title": "easy-to-understand-the-solution",
                "content": "\\n\\n# Approach\\nsliding window\\n# Complexity\\n- Time complexity:\\nO(m)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s + s\\n        alt1,alt2 = \"\",\"\"\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        diff1,diff2 = 0,0\\n        l = 0\\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1+=1\\n            if s[r] != alt2[r]:\\n                diff2+=1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1-=1\\n                if s[l] != alt2[l]:\\n                    diff2-=1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n        return res\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        s = s + s\\n        alt1,alt2 = \"\",\"\"\\n        for i in range(len(s)):\\n            alt1 += \"0\" if i % 2 else \"1\"\\n            alt2 += \"1\" if i % 2 else \"0\"\\n\\n        res = len(s)\\n        diff1,diff2 = 0,0\\n        l = 0\\n        for r in range(len(s)):\\n            if s[r] != alt1[r]:\\n                diff1+=1\\n            if s[r] != alt2[r]:\\n                diff2+=1\\n\\n            if (r-l+1) > n:\\n                if s[l] != alt1[l]:\\n                    diff1-=1\\n                if s[l] != alt2[l]:\\n                    diff2-=1\\n                l+=1\\n\\n            if (r-l+1) == n:\\n                res = min(res,diff1,diff2)\\n        return res\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586463,
                "title": "python-constant-length-sliding-window-commented-tc-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        N, s = len(s), s + s\\n        diff, ans = 0, math.inf\\n\\n        ## Alternating Strings Can only be of 2 types\\n        ## Type1 = 010101010...\\n        ## Type2 = 101010101...\\n        ## Another thing to notice is that they would always be complementary to each other\\n        ## i.e. if 2 swaps are needed to change a string to type1, N-2 swaps would be needed to change to type2 and vice-versa\\n        type1 = \"\".join([str(1*(i%2)) for i in range(2*N)])\\n\\n        ## For the original-string(window of size N) check the swaps needed\\n        for char, a in zip(s[:N], type1[:N]):\\n            if char != a: diff += 1    \\n        ans = min(ans, diff, N - diff)\\n\\n        ## This is the best case scenario - i.e. the string is already alternating\\n        if ans == 0:\\n            return 0\\n\\n        ## Now simulating a sliding window to incorporate the 1st Operation given in the problem\\n        ## i.e. Removing the first character and appending it to the end\\n        ## The rest is generic constant length sliding window with constantly checking the leftmost and rightmost(newly added) characters\\n        for i in range(1,N):\\n            if type1[i-1] != s[i-1]: diff -= 1\\n            if type1[i+N-1] != s[i+N-1]: diff += 1\\n            ans = min(ans, diff, N - diff)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        N, s = len(s), s + s\\n        diff, ans = 0, math.inf\\n\\n        ## Alternating Strings Can only be of 2 types\\n        ## Type1 = 010101010...\\n        ## Type2 = 101010101...\\n        ## Another thing to notice is that they would always be complementary to each other\\n        ## i.e. if 2 swaps are needed to change a string to type1, N-2 swaps would be needed to change to type2 and vice-versa\\n        type1 = \"\".join([str(1*(i%2)) for i in range(2*N)])\\n\\n        ## For the original-string(window of size N) check the swaps needed\\n        for char, a in zip(s[:N], type1[:N]):\\n            if char != a: diff += 1    \\n        ans = min(ans, diff, N - diff)\\n\\n        ## This is the best case scenario - i.e. the string is already alternating\\n        if ans == 0:\\n            return 0\\n\\n        ## Now simulating a sliding window to incorporate the 1st Operation given in the problem\\n        ## i.e. Removing the first character and appending it to the end\\n        ## The rest is generic constant length sliding window with constantly checking the leftmost and rightmost(newly added) characters\\n        for i in range(1,N):\\n            if type1[i-1] != s[i-1]: diff -= 1\\n            if type1[i+N-1] != s[i+N-1]: diff += 1\\n            ans = min(ans, diff, N - diff)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560195,
                "title": "python-count-matches-with-101-and-010-pattern-and-rotate",
                "content": "The idea (from hint #1):\\n1. Count matched bits with the patterns `101...` or `010...`. Pick min `mismatches`. (easy)\\nThis will cover basic cases such as: `111000`:\\n```\\n111000\\n101010\\n ^  ^  -> 2 mismatches\\n111000\\n010101\\n^ ^^ ^  -> 4 mismatches\\nPick min(2,4)\\n```\\n2. Now the interestig part: case `110`\\nIf we count mismatches the way we do it in #1, we\\'ll get 1 mismatch with `010` pattern.\\nWe can rotate the original sequence to the left and get `101` which matches `101` pattern and thus gives us `0` mismatches.\\n\\nHow to handle the case?\\nWe do the same in code... **brute force** will be n^2:\\n1. Rotate to the left by 1\\n2. Count mismatches\\n3. `min(min_mismatches, current_mismatches)`\\n\\n**How to optimize?**\\nIf we see that there is an array/subarray and we calculate the same operation again on the array/subarray in every cycle, it\\'s time to think about an optimization. But which one?\\nWe do for every *shift to left cycle*:\\n1. Remove first element from the array\\n2. Add removed item to the end of the array\\n3. Calculate mismatches.\\n\\n**Hint:** do you see that you calculate the middle part `[i + 1 ... N - 1]` more than 1 time???\\nThis is where you can optimize the array **window**: remove an element from the beginning and add the element to the end **AND** instead of recalculating the array again, you can just substract changes from the final mismatches for the **removed from the window element** and add new changes to mismatches for the **newly added to the window element**.\\nSo we have an example of **sliding window** optimization technique here.\\n\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \"\"\"\\n        111000\\n        101010\\n         -  -  2\\n        111000\\n        010101\\n        - -- - 4\\n        \\n        010\\n        010\\n            0\\n        010\\n        101\\n        --- 3\\n        \\n        1110\\n        1010\\n         -   1\\n        1110\\n        0101\\n        - -- 3\\n        \\n        110\\n        101\\n         -  1\\n        110\\n        010\\n        -   1\\n        \\n        BUT if rotate by 1:\\n        101\\n        101 0\\n        \\n        110\\n        101\\n         -- 2\\n        110\\n        010\\n        -   1\\n        Rotate by 1 left and add 1 from right\\n        10\\n        01\\n         -- 2\\n        10\\n        10\\n        -   0\\n        add to right\\n        10 1\\n        01 0\\n        -- - 3\\n        10 1\\n        10 1\\n             0\\n        \"\"\"\\n        N = len(s)\\n        odd_mismatch = 0\\n        even_mismatch = 0\\n        for i in range(N):\\n            even_mismatch += int(s[i]) != i % 2 # 010\\n            odd_mismatch += int(s[i]) != 1 - i % 2 # 101\\n\\n        min_mismatch = float(inf)\\n        for i in range(N):\\n            even_mismatch -= int(s[i]) != i % 2\\n            odd_mismatch -= int(s[i]) != 1 - i % 2\\n                                  \\n            even_mismatch += int(s[(i + N) % N]) != (i + N) % 2\\n            odd_mismatch += int(s[(i + N) % N]) != 1 - (i + N) % 2\\n            \\n            min_mismatch = min(min_mismatch, even_mismatch, odd_mismatch)\\n        \\n        return min_mismatch\\n```\\nShorter version:\\n```\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n111000\\n101010\\n ^  ^  -> 2 mismatches\\n111000\\n010101\\n^ ^^ ^  -> 4 mismatches\\nPick min(2,4)\\n```\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \"\"\"\\n        111000\\n        101010\\n         -  -  2\\n        111000\\n        010101\\n        - -- - 4\\n        \\n        010\\n        010\\n            0\\n        010\\n        101\\n        --- 3\\n        \\n        1110\\n        1010\\n         -   1\\n        1110\\n        0101\\n        - -- 3\\n        \\n        110\\n        101\\n         -  1\\n        110\\n        010\\n        -   1\\n        \\n        BUT if rotate by 1:\\n        101\\n        101 0\\n        \\n        110\\n        101\\n         -- 2\\n        110\\n        010\\n        -   1\\n        Rotate by 1 left and add 1 from right\\n        10\\n        01\\n         -- 2\\n        10\\n        10\\n        -   0\\n        add to right\\n        10 1\\n        01 0\\n        -- - 3\\n        10 1\\n        10 1\\n             0\\n        \"\"\"\\n        N = len(s)\\n        odd_mismatch = 0\\n        even_mismatch = 0\\n        for i in range(N):\\n            even_mismatch += int(s[i]) != i % 2 # 010\\n            odd_mismatch += int(s[i]) != 1 - i % 2 # 101\\n\\n        min_mismatch = float(inf)\\n        for i in range(N):\\n            even_mismatch -= int(s[i]) != i % 2\\n            odd_mismatch -= int(s[i]) != 1 - i % 2\\n                                  \\n            even_mismatch += int(s[(i + N) % N]) != (i + N) % 2\\n            odd_mismatch += int(s[(i + N) % N]) != 1 - (i + N) % 2\\n            \\n            min_mismatch = min(min_mismatch, even_mismatch, odd_mismatch)\\n        \\n        return min_mismatch\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537574,
                "title": "10ms-6-lines-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minFlips(String s) {\\n    char[] chars = s.toCharArray();\\n    int length = chars.length, count1[] = new int[2], oddLength = length >> 1, evenLength = oddLength + 1, result = length;\\n    for (int i = 0; i < length; i++) if (chars[i] == \\'1\\') count1[i & 1]++;\\n    if ((length & 1) == 0) return Math.min(oddLength - (count1[0] -= count1[1]), oddLength + count1[0]);\\n    for (int i = 0, diff = count1[0] - count1[1]; i < length; i++) result = Math.min(result, Math.min(evenLength - (diff = chars[i] == \\'1\\' ? -diff + 2 : -diff), oddLength + diff));\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minFlips(String s) {\\n    char[] chars = s.toCharArray();\\n    int length = chars.length, count1[] = new int[2], oddLength = length >> 1, evenLength = oddLength + 1, result = length;\\n    for (int i = 0; i < length; i++) if (chars[i] == \\'1\\') count1[i & 1]++;\\n    if ((length & 1) == 0) return Math.min(oddLength - (count1[0] -= count1[1]), oddLength + count1[0]);\\n    for (int i = 0, diff = count1[0] - count1[1]; i < length; i++) result = Math.min(result, Math.min(evenLength - (diff = chars[i] == \\'1\\' ? -diff + 2 : -diff), oddLength + diff));\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508785,
                "title": "python-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFlips(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=len(s) \\n        s=s+s\\n        alt1,alt2=\\'\\',\\'\\'\\n\\n        for i in range (len(s)):\\n            alt1+=\\'0\\'if i % 2 ==0 else \\'1\\'\\n            alt2+=\\'1\\'if i % 2 ==0 else \\'0\\'\\n        \\n        diff1,diff2=0,0\\n        L=0\\n        result=len(s)\\n        for R in range(len(s)):\\n            if s[R] != alt1[R]:\\n                diff1+=1\\n            if s[R] != alt2[R]:\\n                diff2+=1\\n                \\n            if R-L +1 > n:\\n                if s[L] != alt1[L]:\\n                    diff1 -=1\\n                if s[L] != alt2[L]:\\n                    diff2 -=1\\n                L+=1\\n            if R-L+1==n:\\n                result = min(result,diff1,diff2)\\n        print(result)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=len(s) \\n        s=s+s\\n        alt1,alt2=\\'\\',\\'\\'\\n\\n        for i in range (len(s)):\\n            alt1+=\\'0\\'if i % 2 ==0 else \\'1\\'\\n            alt2+=\\'1\\'if i % 2 ==0 else \\'0\\'\\n        \\n        diff1,diff2=0,0\\n        L=0\\n        result=len(s)\\n        for R in range(len(s)):\\n            if s[R] != alt1[R]:\\n                diff1+=1\\n            if s[R] != alt2[R]:\\n                diff2+=1\\n                \\n            if R-L +1 > n:\\n                if s[L] != alt1[L]:\\n                    diff1 -=1\\n                if s[L] != alt2[L]:\\n                    diff2 -=1\\n                L+=1\\n            if R-L+1==n:\\n                result = min(result,diff1,diff2)\\n        print(result)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418046,
                "title": "kotlin-100-100",
                "content": "# Intuition\\nSliding window on s + s\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun minFlips(s: String): Int {\\n         var evenMap = intArrayOf(0,0)\\n        var oddMap = intArrayOf(0,0)\\n\\n        s.forEachIndexed { index, value ->\\n            val num = value.toInt() - \\'0\\'.toInt()\\n            if( index and 1 == 0){// when index is even\\n                evenMap[num]++\\n            }else{\\n                oddMap[num]++\\n            }\\n        }\\n\\n\\n        var filled  = Math.max(evenMap[0] + oddMap[1], evenMap[1] + oddMap[0])\\n\\n        var doubleS = s.plus(s)\\n        var startIndex = 0\\n        for( i in s.length..doubleS.lastIndex){\\n            val newNum = doubleS[i].toInt() - \\'0\\'.toInt()\\n            val oldNum = doubleS[startIndex].toInt() - \\'0\\'.toInt()\\n\\n            if( startIndex and 1 == 0){\\n                evenMap[oldNum]--\\n            }else{\\n                oddMap[oldNum]--\\n            }\\n\\n            if( i and 1 == 0){\\n                evenMap[newNum]++\\n            }else{\\n                oddMap[newNum]++\\n            }\\n\\n            filled  = Math.max(filled, Math.max(evenMap[0] + oddMap[1], evenMap[1] + oddMap[0]))\\n            startIndex++\\n        }\\n\\n        return s.length - filled\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minFlips(s: String): Int {\\n         var evenMap = intArrayOf(0,0)\\n        var oddMap = intArrayOf(0,0)\\n\\n        s.forEachIndexed { index, value ->\\n            val num = value.toInt() - \\'0\\'.toInt()\\n            if( index and 1 == 0){// when index is even\\n                evenMap[num]++\\n            }else{\\n                oddMap[num]++\\n            }\\n        }\\n\\n\\n        var filled  = Math.max(evenMap[0] + oddMap[1], evenMap[1] + oddMap[0])\\n\\n        var doubleS = s.plus(s)\\n        var startIndex = 0\\n        for( i in s.length..doubleS.lastIndex){\\n            val newNum = doubleS[i].toInt() - \\'0\\'.toInt()\\n            val oldNum = doubleS[startIndex].toInt() - \\'0\\'.toInt()\\n\\n            if( startIndex and 1 == 0){\\n                evenMap[oldNum]--\\n            }else{\\n                oddMap[oldNum]--\\n            }\\n\\n            if( i and 1 == 0){\\n                evenMap[newNum]++\\n            }else{\\n                oddMap[newNum]++\\n            }\\n\\n            filled  = Math.max(filled, Math.max(evenMap[0] + oddMap[1], evenMap[1] + oddMap[0]))\\n            startIndex++\\n        }\\n\\n        return s.length - filled\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354515,
                "title": "sliding-window-o-n-rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_flips(s: String) -> i32 {\\n        let n = s.len();\\n        let mut chars: Vec<char> = s.chars().collect();\\n\\n        let mut chars_0 = vec![];\\n        let mut chars_1 = vec![];\\n\\n        for i in 0..n*2 {\\n            if i % 2 == 0 {\\n                chars_0.push(\\'0\\');\\n                chars_1.push(\\'1\\');\\n            } else {\\n                chars_0.push(\\'1\\');\\n                chars_1.push(\\'0\\');\\n            }\\n        }\\n\\n        let mut res = n*2;\\n        let (mut cnt_0, mut cnt_1) = (0, 0);\\n\\n        let mut l = 0;\\n        for r in 0..n*2 {\\n            if chars[r % n] != chars_0[r] { cnt_0 += 1 }\\n            if chars[r % n] != chars_1[r] { cnt_1 += 1 }\\n\\n            if (r - l + 1) > n {\\n                if chars[l % n] != chars_0[l] { cnt_0 -= 1 }\\n                if chars[l % n] != chars_1[l] { cnt_1 -= 1 }\\n                l += 1;\\n            }\\n\\n            if (r - l + 1) == n {\\n                res = res.min(cnt_0).min(cnt_1);\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_flips(s: String) -> i32 {\\n        let n = s.len();\\n        let mut chars: Vec<char> = s.chars().collect();\\n\\n        let mut chars_0 = vec![];\\n        let mut chars_1 = vec![];\\n\\n        for i in 0..n*2 {\\n            if i % 2 == 0 {\\n                chars_0.push(\\'0\\');\\n                chars_1.push(\\'1\\');\\n            } else {\\n                chars_0.push(\\'1\\');\\n                chars_1.push(\\'0\\');\\n            }\\n        }\\n\\n        let mut res = n*2;\\n        let (mut cnt_0, mut cnt_1) = (0, 0);\\n\\n        let mut l = 0;\\n        for r in 0..n*2 {\\n            if chars[r % n] != chars_0[r] { cnt_0 += 1 }\\n            if chars[r % n] != chars_1[r] { cnt_1 += 1 }\\n\\n            if (r - l + 1) > n {\\n                if chars[l % n] != chars_0[l] { cnt_0 -= 1 }\\n                if chars[l % n] != chars_1[l] { cnt_1 -= 1 }\\n                l += 1;\\n            }\\n\\n            if (r - l + 1) == n {\\n                res = res.min(cnt_0).min(cnt_1);\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3305353,
                "title": "beats-96-python-explained-o-n-no-sliding-window-or-dp",
                "content": "# Intuition\\n\\nFew observations at first:\\n- The problem essentially breaks down to weather to start the string with \"0\" or \"1\".\\n- If there are odd nos of elements, the start and end characters will always be the same after re-arranging.\\n- If even, start and end will be different.\\n\\nIf we for now forget about the 1st clause to make the problem simpler we will notice that we can easily find out the number of misplaced elements for a case of string starting with \"0\" (over a single iteration), and to find out the same for string starting with \"1\", we can simply do:\\n```\\nn - (no of missplaced elems if str starts with \"0\")\\n```\\nAnd the min of both will be the answer.\\n\\nNow comes the 1st clause, we notice that we can optimize our answer even further in certain cases if we apply the 1st clause. How?\\n\\nImagine str starts with 0, but we are currently considering a case where start should have been 1 (i.e  str[1] should be 0 and so on). \\n```\\nActual:\\n0110..n\\nShould have been:\\n1010..n\\nDiff (Y: yes, N: no):\\nYYNN..n\\n\\n--After replacing 1st elem to the end--\\nActual:\\n110..0\\nShould have been (maintaing the diff sequence):\\n010..0 (if str length is odd)\\n010..1 (if str length is even)\\n```\\nThis means str[0] (i.e 0) needs to be reversed. Let\\'s say for this case we have (r) such misplaced elements. But since our goal is to reduce r, what if we apply the 1st clause and put it at the end? Will it be of any use?\\n\\nThere can be 2 cases here:\\n- String is even: here after putting the 1st elem \"0\" at the end, now the 1st element should be \"1\" for same r. But as we observed before, for even, first and last elements should be the same, thus the \"0\" that we just removed and put at the end needs to be converted to \"1\" again. Thus, we see there is no net change in r, since ultimately we had to reverse that \"0\" anyway.\\n- String is odd: here we do the same thing, put the 1st \"0\" at the end, thus now the 1st element should be \"1\" if we try to keep r the same. But we notice that unlike the previous case we already have the desired element at the end, i.e \"0\", thus we can say we have successfully reduced one inversion that would have happened otherwise, i.e r=r-1.\\n\\n# Approach\\n\\n- We first find out r for both cases (i.e if we consider start=0 or start=1).\\n- If the length of string is even, we just return the least of both r, since we have already proved this case cannot be optimized further.\\n- We continue for odd length:\\n- For both cases of start=0,1 we do:\\n- iterate over each index of the string, and each step we are considering as if the current start element is moved to the end.\\n- By moving, 2 situations can occur, we are moved an element that is already correct, thus now it becomes incorrect (since the next elem becomes start, and it will not be equal to the current one but for odd lengths it should have been equal), thus r=r+1. Or it was incorrect, thus now by moving it to end actually helps (as discussed earlier), i.e r=r-1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        r0 = 0\\n        curr = \\'0\\'\\n        for i in range(n):\\n            if s[i]!=curr:\\n                r0+=1\\n            curr = \\'1\\' if curr==\\'0\\' else \\'0\\'\\n        r1 = n - r0\\n        if n%2==0:\\n            return min(r0,r1)\\n        def minn(r,curr):\\n            res = r\\n            for i in range(n):\\n                if curr!=s[i]:\\n                    r-=1\\n                else:\\n                    r+=1\\n                res = min(res,r)\\n                curr = \\'0\\' if curr==\\'1\\' else \\'1\\'\\n            res = min(res,r)\\n            return res\\n        return min(minn(r0,\\'0\\'),minn(r1,\\'1\\'))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nn - (no of missplaced elems if str starts with \"0\")\\n```\n```\\nActual:\\n0110..n\\nShould have been:\\n1010..n\\nDiff (Y: yes, N: no):\\nYYNN..n\\n\\n--After replacing 1st elem to the end--\\nActual:\\n110..0\\nShould have been (maintaing the diff sequence):\\n010..0 (if str length is odd)\\n010..1 (if str length is even)\\n```\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        r0 = 0\\n        curr = \\'0\\'\\n        for i in range(n):\\n            if s[i]!=curr:\\n                r0+=1\\n            curr = \\'1\\' if curr==\\'0\\' else \\'0\\'\\n        r1 = n - r0\\n        if n%2==0:\\n            return min(r0,r1)\\n        def minn(r,curr):\\n            res = r\\n            for i in range(n):\\n                if curr!=s[i]:\\n                    r-=1\\n                else:\\n                    r+=1\\n                res = min(res,r)\\n                curr = \\'0\\' if curr==\\'1\\' else \\'1\\'\\n            res = min(res,r)\\n            return res\\n        return min(minn(r0,\\'0\\'),minn(r1,\\'1\\'))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281223,
                "title": "simple-o-n-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The order of shifting and flipping doesn\\'t matter.\\n- Go through the chars and find the number of bits that don\\'t match. Now we have the base.\\n- For each \\'shifting\\', the previous matching bits no longer match and vice versa. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int len = s.length();\\n        int notMatched = len;\\n        int minNotMatched = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            if(i%2 == 0 && s.charAt(i)==\\'0\\' || i%2 == 1 && s.charAt(i)==\\'1\\'){\\n                notMatched--;\\n            } \\n        }\\n        \\n        int notMatched2 = len - notMatched;\\n        minNotMatched = notMatched < notMatched2 ? notMatched : notMatched2;\\n        boolean frontMatched = s.charAt(0)==\\'0\\';\\n        \\n        for(int i=1;i<len;i++){\\n            int front = s.charAt(i-1)-\\'0\\';\\n            int end = 1 - len%2;\\n            if(frontMatched){\\n                notMatched = len - notMatched - 1 + (front!= end ? 1 : 0);\\n            }\\n            else{\\n                notMatched = len - notMatched + (front!= end ? 1 : 0);\\n            }\\n            notMatched2 = len - notMatched;\\n            minNotMatched = Math.min(minNotMatched, notMatched);\\n            minNotMatched = Math.min(minNotMatched, notMatched2);\\n            frontMatched = s.charAt(i)==\\'0\\';\\n        }\\n        return minNotMatched;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int len = s.length();\\n        int notMatched = len;\\n        int minNotMatched = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            if(i%2 == 0 && s.charAt(i)==\\'0\\' || i%2 == 1 && s.charAt(i)==\\'1\\'){\\n                notMatched--;\\n            } \\n        }\\n        \\n        int notMatched2 = len - notMatched;\\n        minNotMatched = notMatched < notMatched2 ? notMatched : notMatched2;\\n        boolean frontMatched = s.charAt(0)==\\'0\\';\\n        \\n        for(int i=1;i<len;i++){\\n            int front = s.charAt(i-1)-\\'0\\';\\n            int end = 1 - len%2;\\n            if(frontMatched){\\n                notMatched = len - notMatched - 1 + (front!= end ? 1 : 0);\\n            }\\n            else{\\n                notMatched = len - notMatched + (front!= end ? 1 : 0);\\n            }\\n            notMatched2 = len - notMatched;\\n            minNotMatched = Math.min(minNotMatched, notMatched);\\n            minNotMatched = Math.min(minNotMatched, notMatched2);\\n            frontMatched = s.charAt(i)==\\'0\\';\\n        }\\n        return minNotMatched;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229200,
                "title": "java-solution-if-u-are-facing-tle-u-must-refer-this",
                "content": "<h3>You may get a doubt y am i using char array instead u can use string but in java to access data ch[i] consumes less time when compared to ch.charAt(i)!! You can even use string builder instead of char array</h3>\\n<h3>If this was helpful like++</h3>\\n\\n\\n# code\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int l=s.length();\\n        s=s+s;\\n        char ch[]=s.toCharArray();\\n        int i,j,n=s.length();\\n        char a[]=new char[n];\\n        char b[]=new char[n];\\n        for(i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a[i]=\\'0\\';\\n                b[i]=\\'1\\';\\n            }\\n            else\\n            {\\n                a[i]=\\'1\\';\\n                b[i]=\\'0\\';\\n            }\\n        }\\n        int count1=0,count2=0;\\n        int mini=1000_000;\\n        i=0;j=0;\\n        while(j<n)\\n        {\\n            if(ch[j]!=a[j])\\n                count1++;\\n            if(ch[j]!=b[j])\\n                count2++;\\n            if(j-i+1>l)\\n            {\\n                if(ch[i]!=a[i])\\n                count1--;\\n                if(ch[i]!=b[i])\\n                count2--;\\n                i++;\\n            }\\n            if(j-i+1==l)\\n            mini=Math.min(mini,Math.min(count1,count2));\\n            j++;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int l=s.length();\\n        s=s+s;\\n        char ch[]=s.toCharArray();\\n        int i,j,n=s.length();\\n        char a[]=new char[n];\\n        char b[]=new char[n];\\n        for(i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a[i]=\\'0\\';\\n                b[i]=\\'1\\';\\n            }\\n            else\\n            {\\n                a[i]=\\'1\\';\\n                b[i]=\\'0\\';\\n            }\\n        }\\n        int count1=0,count2=0;\\n        int mini=1000_000;\\n        i=0;j=0;\\n        while(j<n)\\n        {\\n            if(ch[j]!=a[j])\\n                count1++;\\n            if(ch[j]!=b[j])\\n                count2++;\\n            if(j-i+1>l)\\n            {\\n                if(ch[i]!=a[i])\\n                count1--;\\n                if(ch[i]!=b[i])\\n                count2--;\\n                i++;\\n            }\\n            if(j-i+1==l)\\n            mini=Math.min(mini,Math.min(count1,count2));\\n            j++;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162053,
                "title": "easy-greasy-without-sliding-window-no-extra-memory-and-loops",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf s.count % 2 == 0 we can do without sliding window approach and straight away return result \\u2013 min operations between 2 possible variations.\\nFor example:\\n1. 010101 - starting with 0\\n2. 101010 - starting with 1\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minFlips(_ s: String) -> Int {\\n        var diff0 = 0, diff1 = 0\\n        for (i, char) in s.enumerated() {\\n            let alt0: Character = i % 2 == 0 ? \"0\" : \"1\"\\n            let alt1: Character = i % 2 == 0 ? \"1\" : \"0\"\\n            if char != alt0 { diff0 += 1 }\\n            if char != alt1 { diff1 += 1 } \\n        }\\n        if s.count % 2 == 0 {return min(diff0, diff1)}\\n\\n        var res0 = diff0, res1 = diff1\\n        for (i, char) in s.enumerated() {\\n            let alt0: Character = i % 2 == 0 ? \"0\" : \"1\"\\n            let alt1: Character = i % 2 == 0 ? \"1\" : \"0\"\\n            diff0 += char != alt0 ? -1 : 1\\n            diff1 += char != alt1 ? -1 : 1\\n\\n            res0 = min(diff0, res0)\\n            res1 = min(diff1, res1)\\n        }\\n        return min(res0, res1)\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    func minFlips(_ s: String) -> Int {\\n        var diff0 = 0, diff1 = 0\\n        for (i, char) in s.enumerated() {\\n            let alt0: Character = i % 2 == 0 ? \"0\" : \"1\"\\n            let alt1: Character = i % 2 == 0 ? \"1\" : \"0\"\\n            if char != alt0 { diff0 += 1 }\\n            if char != alt1 { diff1 += 1 } \\n        }\\n        if s.count % 2 == 0 {return min(diff0, diff1)}\\n\\n        var res0 = diff0, res1 = diff1\\n        for (i, char) in s.enumerated() {\\n            let alt0: Character = i % 2 == 0 ? \"0\" : \"1\"\\n            let alt1: Character = i % 2 == 0 ? \"1\" : \"0\"\\n            diff0 += char != alt0 ? -1 : 1\\n            diff1 += char != alt1 ? -1 : 1\\n\\n            res0 = min(diff0, res0)\\n            res1 = min(diff1, res1)\\n        }\\n        return min(res0, res1)\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148331,
                "title": "python-easy-to-understand-tc-o-n-sc-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        mod_s = s\\n        mod_s += s\\n        tgt1 = []\\n        tgt2 = []\\n        flag = 0\\n        for i in range(len(mod_s)):\\n            tgt1.append(f\\'{flag}\\')\\n            tgt2.append(f\\'{int(not(flag))}\\')\\n            flag = int(not(flag))\\n        res = [0,0]\\n        for k in range(len(s)):\\n            if s[k]!=tgt1[k]:\\n                res[0]+=1\\n            if s[k]!=tgt2[k]:\\n                res[1]+=1\\n        l = 1\\n        r = len(s)\\n        ans = min(res)\\n        while r<len(mod_s):\\n            if mod_s[r]!=tgt1[r]:\\n                res[0]+=1\\n            if mod_s[l-1]!=tgt1[l-1]:\\n                res[0]-=1\\n            if mod_s[r]!=tgt2[r]:\\n                res[1]+=1\\n            if mod_s[l-1]!=tgt2[l-1]:\\n                res[1]-=1\\n            l+=1\\n            r+=1\\n            ans = min(ans,min(res))\\n        return ans\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        mod_s = s\\n        mod_s += s\\n        tgt1 = []\\n        tgt2 = []\\n        flag = 0\\n        for i in range(len(mod_s)):\\n            tgt1.append(f\\'{flag}\\')\\n            tgt2.append(f\\'{int(not(flag))}\\')\\n            flag = int(not(flag))\\n        res = [0,0]\\n        for k in range(len(s)):\\n            if s[k]!=tgt1[k]:\\n                res[0]+=1\\n            if s[k]!=tgt2[k]:\\n                res[1]+=1\\n        l = 1\\n        r = len(s)\\n        ans = min(res)\\n        while r<len(mod_s):\\n            if mod_s[r]!=tgt1[r]:\\n                res[0]+=1\\n            if mod_s[l-1]!=tgt1[l-1]:\\n                res[0]-=1\\n            if mod_s[r]!=tgt2[r]:\\n                res[1]+=1\\n            if mod_s[l-1]!=tgt2[l-1]:\\n                res[1]-=1\\n            l+=1\\n            r+=1\\n            ans = min(ans,min(res))\\n        return ans\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136134,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n        int n=s.size();\\n     int ans=INT_MAX;\\n     int diff1=0;\\n     int diff2=0;\\n     s=s+s;\\n     string alt1=\"\";\\n     string alt2=\"\";\\n     for (int i=0;i<s.size();i++)\\n     {\\n         if (i&1) \\n         {alt1+=\"1\";\\n         alt2+=\"0\";\\n         }\\n         else{\\n             alt1+=\"0\";\\n             alt2+=\"1\";\\n         }\\n     }\\n     int l=0;\\n     for (int r=0;r<s.size();r++)\\n     {\\n         if (s[r]!=alt1[r])\\n         diff1++;\\n         if (s[r]!=alt2[r])\\n         diff2++;\\n         if (r-l+1>n)\\n         {\\n             if (s[l]!=alt1[l])\\n             diff1--;\\n             if (s[l]!=alt2[l])\\n             diff2--;\\n             l++;\\n         }\\n         if (r-l+1==n)\\n         {\\n             ans=min(ans,diff1);\\n             ans=min(ans,diff2);\\n         }\\n     }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) \\n    {\\n        int n=s.size();\\n     int ans=INT_MAX;\\n     int diff1=0;\\n     int diff2=0;\\n     s=s+s;\\n     string alt1=\"\";\\n     string alt2=\"\";\\n     for (int i=0;i<s.size();i++)\\n     {\\n         if (i&1) \\n         {alt1+=\"1\";\\n         alt2+=\"0\";\\n         }\\n         else{\\n             alt1+=\"0\";\\n             alt2+=\"1\";\\n         }\\n     }\\n     int l=0;\\n     for (int r=0;r<s.size();r++)\\n     {\\n         if (s[r]!=alt1[r])\\n         diff1++;\\n         if (s[r]!=alt2[r])\\n         diff2++;\\n         if (r-l+1>n)\\n         {\\n             if (s[l]!=alt1[l])\\n             diff1--;\\n             if (s[l]!=alt2[l])\\n             diff2--;\\n             l++;\\n         }\\n         if (r-l+1==n)\\n         {\\n             ans=min(ans,diff1);\\n             ans=min(ans,diff2);\\n         }\\n     }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081724,
                "title": "kotlin-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- since we knew that there\\'s only two kinds of alternated string, one starts with \"0\", the other starts with \"1\". so we can generated by ouselves first\\n- second, make a copy at the end of string (like 796 Rotate String), with this new string, we can easily implemnet sliding window method to identify which window require minimun flips\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O (n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun minFlips(s: String): Int {\\n        var left = 0\\n        val newString: String = s + s\\n        var res = newString.length\\n        var alterList1 = mutableListOf<String>(); var alterList2 = mutableListOf<String>()\\n        for (i in 0 until newString.length) {\\n            if (i % 2 == 1) {\\n                alterList1.add(\"0\")\\n                alterList2.add(\"1\")\\n            } else {\\n                alterList1.add(\"1\")\\n                alterList2.add(\"0\")\\n            }\\n        }\\n        val alter1 = alterList1.joinToString(\"\")\\n        val alter2 = alterList2.joinToString(\"\")\\n\\n\\n        var diff1 = 0; var diff2 = 0\\n        for (right in 0 until newString.length) {\\n            if (newString[right] != alter1[right]) diff1 ++\\n            if (newString[right] != alter2[right]) diff2 ++\\n\\n            if ((right - left + 1) > s.length) {\\n                if (newString[left] != alter1[left]) diff1 --\\n                if (newString[left] != alter2[left]) diff2 --\\n                left ++\\n            }\\n            if ((right - left + 1) == s.length) {\\n                res = minOf(res, diff1, diff2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    fun minFlips(s: String): Int {\\n        var left = 0\\n        val newString: String = s + s\\n        var res = newString.length\\n        var alterList1 = mutableListOf<String>(); var alterList2 = mutableListOf<String>()\\n        for (i in 0 until newString.length) {\\n            if (i % 2 == 1) {\\n                alterList1.add(\"0\")\\n                alterList2.add(\"1\")\\n            } else {\\n                alterList1.add(\"1\")\\n                alterList2.add(\"0\")\\n            }\\n        }\\n        val alter1 = alterList1.joinToString(\"\")\\n        val alter2 = alterList2.joinToString(\"\")\\n\\n\\n        var diff1 = 0; var diff2 = 0\\n        for (right in 0 until newString.length) {\\n            if (newString[right] != alter1[right]) diff1 ++\\n            if (newString[right] != alter2[right]) diff2 ++\\n\\n            if ((right - left + 1) > s.length) {\\n                if (newString[left] != alter1[left]) diff1 --\\n                if (newString[left] != alter2[left]) diff2 --\\n                left ++\\n            }\\n            if ((right - left + 1) == s.length) {\\n                res = minOf(res, diff1, diff2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022163,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(string s) {\\n        var n=s.Length;\\n        int res = Int32.MaxValue, cur = 0;        \\n        for (int i = 0; i < 2*n; i++)  {\\n            if (s[i%n] - \\'0\\' == i%2) cur++; \\n            if (i >= n && s[i%n] - \\'0\\' == i%n%2) cur--; \\n            if (i >= n-1)  res = Math.Min(res, Math.Min(cur, n-cur));             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(string s) {\\n        var n=s.Length;\\n        int res = Int32.MaxValue, cur = 0;        \\n        for (int i = 0; i < 2*n; i++)  {\\n            if (s[i%n] - \\'0\\' == i%2) cur++; \\n            if (i >= n && s[i%n] - \\'0\\' == i%n%2) cur--; \\n            if (i >= n-1)  res = Math.Min(res, Math.Min(cur, n-cur));             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004358,
                "title": "sliding-window-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDuplicate the input string twice becuase type 1 rule can be applied max n(length of string) times then it will become the original string.\\n\\nOn the same line target strings will also be duplicated.\\n\\nInput String:\\n1101 => 11011101\\n\\nTarget String 1\\n1010 => 10101010\\n\\nTarget String 2\\n1010 => 10101010\\n\\nAfter calculating the cost in the current string will apply type 1 rule then compute the cost after it, since we alreday computed the cost of the current window we can simply remove the cost of start and add the cost of end if required.\\n\\nminimum of both cost strings will be the final answer.\\n\\n# Complexity\\n- Time complexity:\\n- O(2*n) => ~O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n) if you consider the replication of the string\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        t1, t2 = \"01\"*n, \"10\"*n\\n        c1, c2 = 0, 0\\n        c = float(\\'inf\\')\\n        s = s*2\\n        for i in range(2*n):\\n            if s[i] != t1[i]:\\n                c1 += 1\\n\\n            if s[i] != t2[i]:\\n                c2 += 1\\n\\n            if i >= n and s[i-n] != t1[i-n]:\\n                c1 -= 1\\n\\n            if i >= n and s[i-n] != t2[i-n]:\\n                c2 -= 1\\n\\n            if i >= n-1:\\n                c = min(c, c1, c2)\\n\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        t1, t2 = \"01\"*n, \"10\"*n\\n        c1, c2 = 0, 0\\n        c = float(\\'inf\\')\\n        s = s*2\\n        for i in range(2*n):\\n            if s[i] != t1[i]:\\n                c1 += 1\\n\\n            if s[i] != t2[i]:\\n                c2 += 1\\n\\n            if i >= n and s[i-n] != t1[i-n]:\\n                c1 -= 1\\n\\n            if i >= n and s[i-n] != t2[i-n]:\\n                c2 -= 1\\n\\n            if i >= n-1:\\n                c = min(c, c1, c2)\\n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993255,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinFlips(int oddOne,int evenOne, int oddZero, int evenZero) {\\n        return min(oddOne+evenZero,evenOne+oddZero);\\n    }\\n    int minFlips(string s) {\\n        int oddOne = 0,evenOne = 0,oddZero = 0,evenZero = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\')  {\\n                oddOne += (i&1);\\n                evenOne += ((i%2)==0);\\n            } else {\\n                oddZero += (i&1);\\n                evenZero += ((i%2)==0);\\n            }\\n        }\\n        int ans = getMinFlips(oddOne,evenOne,oddZero,evenZero);\\n        int len = s.size();\\n        if (len % 2 == 0) return ans;\\n        for (int i = 0; i < s.size(); i++) {\\n            swap(oddOne,evenOne);\\n            swap(oddZero,evenZero);\\n            if (len % 2 == 1) {\\n                if (s[i] == \\'1\\') {\\n                    oddOne --;\\n                    evenOne ++;\\n                } else {\\n                    oddZero --;\\n                    evenZero ++;\\n                }\\n            }\\n            ans = min(ans,getMinFlips(oddOne,evenOne,oddZero,evenZero));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinFlips(int oddOne,int evenOne, int oddZero, int evenZero) {\\n        return min(oddOne+evenZero,evenOne+oddZero);\\n    }\\n    int minFlips(string s) {\\n        int oddOne = 0,evenOne = 0,oddZero = 0,evenZero = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\')  {\\n                oddOne += (i&1);\\n                evenOne += ((i%2)==0);\\n            } else {\\n                oddZero += (i&1);\\n                evenZero += ((i%2)==0);\\n            }\\n        }\\n        int ans = getMinFlips(oddOne,evenOne,oddZero,evenZero);\\n        int len = s.size();\\n        if (len % 2 == 0) return ans;\\n        for (int i = 0; i < s.size(); i++) {\\n            swap(oddOne,evenOne);\\n            swap(oddZero,evenZero);\\n            if (len % 2 == 1) {\\n                if (s[i] == \\'1\\') {\\n                    oddOne --;\\n                    evenOne ++;\\n                } else {\\n                    oddZero --;\\n                    evenZero ++;\\n                }\\n            }\\n            ans = min(ans,getMinFlips(oddOne,evenOne,oddZero,evenZero));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989578,
                "title": "python-parity-count-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        even, odd = 0, 0\\n        for i in range(n):\\n            if i%2 and s[i] == \\'1\\': odd += 1\\n            if not i%2 and s[i] == \\'1\\': even += 1\\n        if not n%2: \\n            return min(odd + n//2 - even, even + n//2 - odd)\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                even, odd = odd + 1, even - 1 \\n                res = min(res, min(even + n//2 - odd, odd + n//2 + 1 - even))\\n            else:\\n                even, odd = odd, even\\n                res = min(res, min(even + n//2 - odd, odd + n//2 + 1 - even))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        even, odd = 0, 0\\n        for i in range(n):\\n            if i%2 and s[i] == \\'1\\': odd += 1\\n            if not i%2 and s[i] == \\'1\\': even += 1\\n        if not n%2: \\n            return min(odd + n//2 - even, even + n//2 - odd)\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                even, odd = odd + 1, even - 1 \\n                res = min(res, min(even + n//2 - odd, odd + n//2 + 1 - even))\\n            else:\\n                even, odd = odd, even\\n                res = min(res, min(even + n//2 - odd, odd + n//2 + 1 - even))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988803,
                "title": "python3-solved-using-sliding-window",
                "content": "# Intuition\\nFirst of all, in order to turn string s into alternating binary sequence, it is limited to matching 2 forms: one that starts with a 1 and other that starts with a 0. Thus, I can consider every rearrangement of prefix to the end of string after appending and consider how many index positions differ w/ respect to 2 target strings -> imply the number of flip operations(type #2 operation) I need to do. Basically, I minimize over considering the possibilities.\\n\\n# Approach\\nFirst, consider the initial window to intialize the ans and zeroDiffs and oneDiffs for current window. For every window after, I initially spliced string s and reconstructed new string for every new window I consider after moving different combinations of prefix. However, this is too costly and it would be better to extend string s onto itself so that I can just directly get the new string. However, I don\\'t really need to derivate new string since beg variable will keep track of starting index of current window so that beg - 1 index position will indicate beginning digit char of previous window I already considered and beg + n - 1 will be the last digit in current window. In this way, I can efficiently compute number of flips I need to do for current window to match both target strings by building upon answer already gotten from previous windows\\' computations and simply consider the differences in digits from prefix char removed from beg. to being added to the end. \\n\\n# Complexity\\n- Time complexity:\\nO(N work intializing target strings and processing initial window + N while loop iterations about* O(1) operations) -> O(N)\\n\\n- Space complexity:\\nO(2 * N) -> O(N) due to startsOne and startsZero target strings both of length n!\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        #Basically, we know that given string s of length n, there are only 2 ways it can be alternating seq.\\n        #one that starts with a 1 and other that starts with a 0!\\n        #For ex. len(s) == 4, then 0101 or 1010!\\n\\n        #What we can do is see how many index positions differ that would require flip operation(type-2) and \\n        #favor matching to one of two target strings that require less type 2 operations. Then, perform type 1 operation\\n        #and do the same thing for new string s!\\n\\n        #Once new string matches to original input, we know we performed type 1 operation as much as possible and considered\\n        #every possible orientation of string input s!\\n\\n        #However, we can avoid doing redundant work by extending the 2 target strings by 1 char every time \\n        #we move 1 char to the back via type 1 operation!\\n        n = len(s)\\n        ans = float(inf)\\n        startsOne = \"\"\\n        for i in range(n):\\n            if(i % 2 == 0):\\n                startsOne += \"1\"\\n            else:\\n                startsOne += \"0\"\\n        startsZero = \"\"\\n        for j in range(n):\\n            if(j % 2 == 0):\\n                startsZero += \"0\"\\n            else:\\n                startsZero += \"1\"\\n        \\n        #Additionally, we don\\'t want to manually splice original string and create new strings after taking away\\n        #the prefix and appending to the end!\\n\\n        #We can simply add string to itself and consider different windows of string until we get to window that\\n        #equals original input string s.\\n        s += s\\n\\n        #first, consider window of original input string s and compare how many pos. differ w/ respect to \\n        #2 target strings!\\n        zeroDiffs = 0\\n        oneDiffs = 0\\n\\n        for i in range(n):\\n            if(s[i] != startsZero[i]):\\n                zeroDiffs += 1\\n            if(s[i] != startsOne[i]):\\n                oneDiffs += 1\\n        ans = min(ans, min(zeroDiffs, oneDiffs))\\n\\n        #now consider rermaining windows after moving one char at a time with new prefix moved to back of string s \\n        #via type 1 operation!\\n        beg = 1\\n        #as long as we did not move prefix s.t. we end up with original string, keep trying to minimize \\n        #number of type #2 operations of flipping to keep string alternating!\\n\\n        #every iteration of while loop: we consider string after moving prefix s.t.\\n        #we consider new string s[beg: beg+n]\\n        while beg < n:\\n            #extend the target strings as accordingly!\\n            if(startsZero[-1] == \"0\"):\\n                startsZero += \"1\"\\n            else:\\n                startsZero += \"0\"\\n            \\n            if(startsOne[-1] == \"0\"):\\n                startsOne += \"1\"\\n            else:\\n                startsOne += \"0\"\\n            \\n            #update the diffs based on recently moved character as prefix for current window we are iterating on!\\n            #if it differs than the target string at corresponding pos., decrement # of differences since\\n            #that char is no longer part of current window!\\n            if(s[beg-1] != startsZero[beg-1]):\\n                zeroDiffs -= 1\\n            if(s[beg-1] != startsOne[beg-1]):\\n                oneDiffs -= 1\\n\\n            #now, take account the new moved char to end and update diffs!\\n            if(s[beg + n - 1] != startsZero[-1]):\\n                zeroDiffs += 1\\n            if(s[beg+n-1] != startsOne[-1]):\\n                oneDiffs += 1\\n            \\n            ans = min(ans, min(zeroDiffs, oneDiffs))\\n            beg += 1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        #Basically, we know that given string s of length n, there are only 2 ways it can be alternating seq.\\n        #one that starts with a 1 and other that starts with a 0!\\n        #For ex. len(s) == 4, then 0101 or 1010!\\n\\n        #What we can do is see how many index positions differ that would require flip operation(type-2) and \\n        #favor matching to one of two target strings that require less type 2 operations. Then, perform type 1 operation\\n        #and do the same thing for new string s!\\n\\n        #Once new string matches to original input, we know we performed type 1 operation as much as possible and considered\\n        #every possible orientation of string input s!\\n\\n        #However, we can avoid doing redundant work by extending the 2 target strings by 1 char every time \\n        #we move 1 char to the back via type 1 operation!\\n        n = len(s)\\n        ans = float(inf)\\n        startsOne = \"\"\\n        for i in range(n):\\n            if(i % 2 == 0):\\n                startsOne += \"1\"\\n            else:\\n                startsOne += \"0\"\\n        startsZero = \"\"\\n        for j in range(n):\\n            if(j % 2 == 0):\\n                startsZero += \"0\"\\n            else:\\n                startsZero += \"1\"\\n        \\n        #Additionally, we don\\'t want to manually splice original string and create new strings after taking away\\n        #the prefix and appending to the end!\\n\\n        #We can simply add string to itself and consider different windows of string until we get to window that\\n        #equals original input string s.\\n        s += s\\n\\n        #first, consider window of original input string s and compare how many pos. differ w/ respect to \\n        #2 target strings!\\n        zeroDiffs = 0\\n        oneDiffs = 0\\n\\n        for i in range(n):\\n            if(s[i] != startsZero[i]):\\n                zeroDiffs += 1\\n            if(s[i] != startsOne[i]):\\n                oneDiffs += 1\\n        ans = min(ans, min(zeroDiffs, oneDiffs))\\n\\n        #now consider rermaining windows after moving one char at a time with new prefix moved to back of string s \\n        #via type 1 operation!\\n        beg = 1\\n        #as long as we did not move prefix s.t. we end up with original string, keep trying to minimize \\n        #number of type #2 operations of flipping to keep string alternating!\\n\\n        #every iteration of while loop: we consider string after moving prefix s.t.\\n        #we consider new string s[beg: beg+n]\\n        while beg < n:\\n            #extend the target strings as accordingly!\\n            if(startsZero[-1] == \"0\"):\\n                startsZero += \"1\"\\n            else:\\n                startsZero += \"0\"\\n            \\n            if(startsOne[-1] == \"0\"):\\n                startsOne += \"1\"\\n            else:\\n                startsOne += \"0\"\\n            \\n            #update the diffs based on recently moved character as prefix for current window we are iterating on!\\n            #if it differs than the target string at corresponding pos., decrement # of differences since\\n            #that char is no longer part of current window!\\n            if(s[beg-1] != startsZero[beg-1]):\\n                zeroDiffs -= 1\\n            if(s[beg-1] != startsOne[beg-1]):\\n                oneDiffs -= 1\\n\\n            #now, take account the new moved char to end and update diffs!\\n            if(s[beg + n - 1] != startsZero[-1]):\\n                zeroDiffs += 1\\n            if(s[beg+n-1] != startsOne[-1]):\\n                oneDiffs += 1\\n            \\n            ans = min(ans, min(zeroDiffs, oneDiffs))\\n            beg += 1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978846,
                "title": "c-o-n-beats-96-clean-code",
                "content": "# Approach\\n1. Divide the given string `s` into 4 groups, `\\'1\\'` in odd/even idx & `\\'0\\'` in odd/even pos. Like code below, as `cnt[i % 2][s[i] - \\'0\\']`\\n2. Order of `rotation` & `flip` doesn\\'t matter, we always assume performing rorations before flips; Thus at given number of rotations, `correct_chars = min(cnt[1][1] + cnt[0][0], cnt[1][0] + cnt[0][1])`\\n3. We could reuse results from `rotation - 1` to generate `rotation` results, as the code shown below; \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int cnt[2][2] = {{0, 0}, {0, 0}};\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++cnt[i % 2][s[i] - \\'0\\'];\\n        }\\n\\n        int opt = numeric_limits<int>::min(), tmp;\\n        for (int i = 0; i < s.size(); ++i) {\\n            tmp = max(cnt[1][1] + cnt[0][0], cnt[1][0] + cnt[0][1]);\\n            opt = max(opt, tmp);\\n\\n            --cnt[0][s[i] - \\'0\\'];\\n            swap(cnt[0][0], cnt[1][0]);\\n            swap(cnt[0][1], cnt[1][1]);\\n            ++cnt[(s.size() - 1) % 2][s[i] - \\'0\\'];\\n        }\\n\\n        return s.size() - opt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int cnt[2][2] = {{0, 0}, {0, 0}};\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++cnt[i % 2][s[i] - \\'0\\'];\\n        }\\n\\n        int opt = numeric_limits<int>::min(), tmp;\\n        for (int i = 0; i < s.size(); ++i) {\\n            tmp = max(cnt[1][1] + cnt[0][0], cnt[1][0] + cnt[0][1]);\\n            opt = max(opt, tmp);\\n\\n            --cnt[0][s[i] - \\'0\\'];\\n            swap(cnt[0][0], cnt[1][0]);\\n            swap(cnt[0][1], cnt[1][1]);\\n            ++cnt[(s.size() - 1) % 2][s[i] - \\'0\\'];\\n        }\\n\\n        return s.size() - opt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960291,
                "title": "python-straightforward-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        targets = [\"0\", \"1\"]\\n        for _ in range(1, 2 * len(s)):\\n            targets[0] += \"1\" if targets[0][-1] == \"0\" else \"0\"\\n            targets[1] += \"0\" if targets[1][-1] == \"1\" else \"1\"\\n\\n        diffs = [0] * 2\\n        n = min_diff = len(s)\\n        s *= 2\\n        l = 0\\n        for r in range(len(s)):\\n            for i, t in enumerate(targets):\\n                if s[r] != t[r]:\\n                   diffs[i] += 1\\n            \\n            if (r - l + 1) > n:\\n                for i, t in enumerate(targets):\\n                    if s[l] != t[l]:\\n                        diffs[i] -= 1\\n                l += 1\\n\\n            if (r - l + 1) == n:\\n                min_diff = min(min_diff, *diffs)\\n\\n        return min_diff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        targets = [\"0\", \"1\"]\\n        for _ in range(1, 2 * len(s)):\\n            targets[0] += \"1\" if targets[0][-1] == \"0\" else \"0\"\\n            targets[1] += \"0\" if targets[1][-1] == \"1\" else \"1\"\\n\\n        diffs = [0] * 2\\n        n = min_diff = len(s)\\n        s *= 2\\n        l = 0\\n        for r in range(len(s)):\\n            for i, t in enumerate(targets):\\n                if s[r] != t[r]:\\n                   diffs[i] += 1\\n            \\n            if (r - l + 1) > n:\\n                for i, t in enumerate(targets):\\n                    if s[l] != t[l]:\\n                        diffs[i] -= 1\\n                l += 1\\n\\n            if (r - l + 1) == n:\\n                min_diff = min(min_diff, *diffs)\\n\\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854317,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int N = s.size(), start = 1, start1 = 1, res1 = 0, res2 = 0, res = INT_MAX;\\n        s = s+s;\\n        for(int i = 0; i < 2*N-1; i++) {\\n            res1 += s[i] != start + \\'0\\';\\n            res2 += s[i] == start + \\'0\\';\\n            start = 1 - start;\\n            if(i >= N-1) {\\n                res = min(res, min(res1, res2));\\n                res1 -= (s[i-N+1] != start1 + \\'0\\');\\n                res2 -= (s[i-N+1] == start1 + \\'0\\');\\n                start1 = 1 - start1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int N = s.size(), start = 1, start1 = 1, res1 = 0, res2 = 0, res = INT_MAX;\\n        s = s+s;\\n        for(int i = 0; i < 2*N-1; i++) {\\n            res1 += s[i] != start + \\'0\\';\\n            res2 += s[i] == start + \\'0\\';\\n            start = 1 - start;\\n            if(i >= N-1) {\\n                res = min(res, min(res1, res2));\\n                res1 -= (s[i-N+1] != start1 + \\'0\\');\\n                res2 -= (s[i-N+1] == start1 + \\'0\\');\\n                start1 = 1 - start1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845683,
                "title": "java-tc-o-n-sc-o-1-beats-73-14",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(1)\\n# Code\\n```\\nclass Solution {\\n\\n    int zerosInOddPos = 0;\\n    int zerosInEvenPos = 0;\\n    int onesInOddPos = 0;\\n    int onesInEvenPos = 0; \\n    public int minFlips(String s) {\\n        for(int i = 0; i < s.length(); i++)\\n            addToVariable(i, s.charAt(i));\\n\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'0\\')\\n                zerosInEvenPos--;\\n            else onesInEvenPos--;\\n            swap(zerosInEvenPos, zerosInOddPos, onesInEvenPos, onesInOddPos);\\n            addToVariable(s.length() + 1, s.charAt(i));\\n            res = Math.min(res, Math.min(zerosInOddPos + onesInEvenPos, zerosInEvenPos + onesInOddPos));\\n        }\\n        return res;\\n    }\\n    private void swap(int z1, int z2, int o1, int o2){\\n        zerosInEvenPos = z2;\\n        zerosInOddPos = z1;\\n        onesInEvenPos = o2;\\n        onesInOddPos = o1;\\n    }\\n    private void addToVariable(int index, char val){\\n        if(index % 2 == 0){\\n            if(val == \\'0\\')\\n                zerosInEvenPos++;\\n            else onesInEvenPos++;\\n        }\\n        else{\\n            if(val == \\'0\\')\\n                zerosInOddPos++;\\n            else onesInOddPos++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int zerosInOddPos = 0;\\n    int zerosInEvenPos = 0;\\n    int onesInOddPos = 0;\\n    int onesInEvenPos = 0; \\n    public int minFlips(String s) {\\n        for(int i = 0; i < s.length(); i++)\\n            addToVariable(i, s.charAt(i));\\n\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'0\\')\\n                zerosInEvenPos--;\\n            else onesInEvenPos--;\\n            swap(zerosInEvenPos, zerosInOddPos, onesInEvenPos, onesInOddPos);\\n            addToVariable(s.length() + 1, s.charAt(i));\\n            res = Math.min(res, Math.min(zerosInOddPos + onesInEvenPos, zerosInEvenPos + onesInOddPos));\\n        }\\n        return res;\\n    }\\n    private void swap(int z1, int z2, int o1, int o2){\\n        zerosInEvenPos = z2;\\n        zerosInOddPos = z1;\\n        onesInEvenPos = o2;\\n        onesInOddPos = o1;\\n    }\\n    private void addToVariable(int index, char val){\\n        if(index % 2 == 0){\\n            if(val == \\'0\\')\\n                zerosInEvenPos++;\\n            else onesInEvenPos++;\\n        }\\n        else{\\n            if(val == \\'0\\')\\n                zerosInOddPos++;\\n            else onesInOddPos++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830871,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, s):\\n        result = n = len(s)\\n\\n        s1, s2 = \"01\"*n, \"10\"*n\\n\\n        if n%2 == 1:\\n            s += s\\n\\n        r1 = r2 = 0\\n\\n        for i in range(len(s)):\\n            if s1[i] == s[i]:\\n                r1 += 1\\n\\n            if s2[i] == s[i]:\\n                r2 += 1\\n\\n            if i>=n and s1[i-n] == s[i-n]:\\n                r1 -= 1\\n\\n            if i>=n and s2[i-n] == s[i-n]:\\n                r2 -= 1\\n\\n            if i>=n-1:\\n                result = min(result,r1,r2)\\n\\n        return result\\n\\n        \\n\\n            \\n\\n            \\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n                \\n\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s):\\n        result = n = len(s)\\n\\n        s1, s2 = \"01\"*n, \"10\"*n\\n\\n        if n%2 == 1:\\n            s += s\\n\\n        r1 = r2 = 0\\n\\n        for i in range(len(s)):\\n            if s1[i] == s[i]:\\n                r1 += 1\\n\\n            if s2[i] == s[i]:\\n                r2 += 1\\n\\n            if i>=n and s1[i-n] == s[i-n]:\\n                r1 -= 1\\n\\n            if i>=n and s2[i-n] == s[i-n]:\\n                r2 -= 1\\n\\n            if i>=n-1:\\n                result = min(result,r1,r2)\\n\\n        return result\\n\\n        \\n\\n            \\n\\n            \\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n                \\n\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828276,
                "title": "c-simplest-code-with-explanation-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        \\n        int n = s.size();\\n        s = s + s; // concate the string itself at end (type 1 operation)\\n        \\n        // create the both possible alternating string\\n        string alt1,alt2;\\n        for(int i=0; i < s.size(); i++){\\n            if(i%2 == 0) {\\n                alt1 += \\'0\\';\\n                alt2 += \\'1\\';\\n            }\\n            else{\\n                alt1 += \\'1\\';\\n                alt2 += \\'0\\';\\n            }\\n        }\\n        \\n        // we can create the window of k = s.size() and keep moving it and get minimum type 2 operation\\n        int l=0,r=0;\\n        int diff1=0,diff2=0;\\n        int res = INT_MAX;\\n        \\n        while(r < s.size()) // keep in mind : s.size() == 2*n(initial_len)\\n        {\\n            if(s[r] != alt1[r]) diff1++;\\n            if(s[r] != alt2[r]) diff2++;\\n            \\n            if((r-l+1) > n){\\n                  if(s[l] != alt1[l]) diff1--;\\n                  if(s[l] != alt2[l]) diff2--;\\n                  l++;\\n            }\\n            \\n            if((r-l+1) == n){\\n                res = min(res,min(diff1,diff2));\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        \\n        int n = s.size();\\n        s = s + s; // concate the string itself at end (type 1 operation)\\n        \\n        // create the both possible alternating string\\n        string alt1,alt2;\\n        for(int i=0; i < s.size(); i++){\\n            if(i%2 == 0) {\\n                alt1 += \\'0\\';\\n                alt2 += \\'1\\';\\n            }\\n            else{\\n                alt1 += \\'1\\';\\n                alt2 += \\'0\\';\\n            }\\n        }\\n        \\n        // we can create the window of k = s.size() and keep moving it and get minimum type 2 operation\\n        int l=0,r=0;\\n        int diff1=0,diff2=0;\\n        int res = INT_MAX;\\n        \\n        while(r < s.size()) // keep in mind : s.size() == 2*n(initial_len)\\n        {\\n            if(s[r] != alt1[r]) diff1++;\\n            if(s[r] != alt2[r]) diff2++;\\n            \\n            if((r-l+1) > n){\\n                  if(s[l] != alt1[l]) diff1--;\\n                  if(s[l] != alt2[l]) diff2--;\\n                  l++;\\n            }\\n            \\n            if((r-l+1) == n){\\n                res = min(res,min(diff1,diff2));\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824440,
                "title": "java-following-hints-in-description-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        if(s.length()==1) return 0;\\n        int mf = 0;\\n        int zerosInEvenPosition = 0;\\n        int zerosInOddPosition = 0;\\n        int onesInEvenPosition = 0;\\n        int onesInOddPosition = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'0\\') {\\n                if(i%2==0) zerosInEvenPosition++;\\n                else zerosInOddPosition++;\\n            } else {\\n                if(i%2==0) onesInEvenPosition++;\\n                else onesInOddPosition++;\\n            }\\n        }\\n        mf = Math.min(zerosInEvenPosition, zerosInOddPosition)\\n            + Math.min(onesInEvenPosition, onesInOddPosition);\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'0\\') {\\n                zerosInEvenPosition--;\\n                int temp =  zerosInEvenPosition;\\n                zerosInEvenPosition = zerosInOddPosition;\\n                zerosInOddPosition = temp;\\n                temp =  onesInEvenPosition;\\n                onesInEvenPosition = onesInOddPosition;\\n                onesInOddPosition = temp;\\n                if((s.length()-1)%2==0) {\\n                    zerosInEvenPosition++;\\n                } else {\\n                    zerosInOddPosition++;\\n                }\\n            } else {\\n                onesInEvenPosition--;\\n                int temp =  zerosInEvenPosition;\\n                zerosInEvenPosition = zerosInOddPosition;\\n                zerosInOddPosition = temp;\\n                temp =  onesInEvenPosition;\\n                onesInEvenPosition = onesInOddPosition;\\n                onesInOddPosition = temp;\\n                if((s.length()-1)%2==0) {\\n                    onesInEvenPosition++;\\n                } else {\\n                    onesInOddPosition++;\\n                }\\n            }\\n            int f = Math.min(zerosInEvenPosition, zerosInOddPosition)\\n                    + Math.min(onesInEvenPosition, onesInOddPosition);  \\n            mf = Math.min(mf, f);\\n        }\\n        return mf;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        if(s.length()==1) return 0;\\n        int mf = 0;\\n        int zerosInEvenPosition = 0;\\n        int zerosInOddPosition = 0;\\n        int onesInEvenPosition = 0;\\n        int onesInOddPosition = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'0\\') {\\n                if(i%2==0) zerosInEvenPosition++;\\n                else zerosInOddPosition++;\\n            } else {\\n                if(i%2==0) onesInEvenPosition++;\\n                else onesInOddPosition++;\\n            }\\n        }\\n        mf = Math.min(zerosInEvenPosition, zerosInOddPosition)\\n            + Math.min(onesInEvenPosition, onesInOddPosition);\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'0\\') {\\n                zerosInEvenPosition--;\\n                int temp =  zerosInEvenPosition;\\n                zerosInEvenPosition = zerosInOddPosition;\\n                zerosInOddPosition = temp;\\n                temp =  onesInEvenPosition;\\n                onesInEvenPosition = onesInOddPosition;\\n                onesInOddPosition = temp;\\n                if((s.length()-1)%2==0) {\\n                    zerosInEvenPosition++;\\n                } else {\\n                    zerosInOddPosition++;\\n                }\\n            } else {\\n                onesInEvenPosition--;\\n                int temp =  zerosInEvenPosition;\\n                zerosInEvenPosition = zerosInOddPosition;\\n                zerosInOddPosition = temp;\\n                temp =  onesInEvenPosition;\\n                onesInEvenPosition = onesInOddPosition;\\n                onesInOddPosition = temp;\\n                if((s.length()-1)%2==0) {\\n                    onesInEvenPosition++;\\n                } else {\\n                    onesInOddPosition++;\\n                }\\n            }\\n            int f = Math.min(zerosInEvenPosition, zerosInOddPosition)\\n                    + Math.min(onesInEvenPosition, onesInOddPosition);  \\n            mf = Math.min(mf, f);\\n        }\\n        return mf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803624,
                "title": "go-beats-100-runtime-use-sliding-window",
                "content": "# Complexity\\n- Time complexity: $$O(len(s))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(len(s))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minFlips(s string) int {\\n\\ts += s\\n\\ttarget_1 := make([]byte, len(s))\\n\\ttarget_2 := make([]byte, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\ttarget_1[i] = 0\\n\\t\\t\\ttarget_2[i] = 1\\n\\t\\t} else {\\n\\t\\t\\ttarget_1[i] = 1\\n\\t\\t\\ttarget_2[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tres := len(s)\\n\\tdiff1, diff2 := 0, 0\\n\\n\\tl := 0\\n\\tfor r := 0; r < len(s); r++ {\\n\\t\\tif target_1[r] != (s[r] - \\'0\\') {\\n\\t\\t\\tdiff1++\\n\\t\\t}\\n\\n\\t\\tif target_2[r] != (s[r] - \\'0\\') {\\n\\t\\t\\tdiff2++\\n\\t\\t}\\n\\n\\t\\tif (r - l + 1) > (len(s) / 2) {\\n\\t\\t\\tif target_1[l] != (s[l] - \\'0\\') {\\n\\t\\t\\t\\tdiff1--\\n\\t\\t\\t}\\n\\t\\t\\tif target_2[l] != (s[l] - \\'0\\') {\\n\\t\\t\\t\\tdiff2--\\n\\t\\t\\t}\\n\\t\\t\\tl++\\n\\t\\t}\\n\\n\\t\\tif (r - l + 1) == (len(s) / 2) {\\n\\t\\t\\tres = min(res, min(diff1, diff2))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minFlips(s string) int {\\n\\ts += s\\n\\ttarget_1 := make([]byte, len(s))\\n\\ttarget_2 := make([]byte, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\ttarget_1[i] = 0\\n\\t\\t\\ttarget_2[i] = 1\\n\\t\\t} else {\\n\\t\\t\\ttarget_1[i] = 1\\n\\t\\t\\ttarget_2[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tres := len(s)\\n\\tdiff1, diff2 := 0, 0\\n\\n\\tl := 0\\n\\tfor r := 0; r < len(s); r++ {\\n\\t\\tif target_1[r] != (s[r] - \\'0\\') {\\n\\t\\t\\tdiff1++\\n\\t\\t}\\n\\n\\t\\tif target_2[r] != (s[r] - \\'0\\') {\\n\\t\\t\\tdiff2++\\n\\t\\t}\\n\\n\\t\\tif (r - l + 1) > (len(s) / 2) {\\n\\t\\t\\tif target_1[l] != (s[l] - \\'0\\') {\\n\\t\\t\\t\\tdiff1--\\n\\t\\t\\t}\\n\\t\\t\\tif target_2[l] != (s[l] - \\'0\\') {\\n\\t\\t\\t\\tdiff2--\\n\\t\\t\\t}\\n\\t\\t\\tl++\\n\\t\\t}\\n\\n\\t\\tif (r - l + 1) == (len(s) / 2) {\\n\\t\\t\\tres = min(res, min(diff1, diff2))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2794688,
                "title": "c-circular-array-o-n-time-o-1",
                "content": "If you think about it, the type 1 operation really just means the array is circular so you have to pick the best starting position. So try to start from each position in the array and make everything 1010 or 0101. We calculate the cost of the wrap-around as we iterate through the array so it can be O(N).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(string& s, char beg){\\n        int fromStart = 0, toEnd0 = 0, toEnd1 = 0;\\n        int ans = 10e8;\\n        char last = beg;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == last) fromStart++;\\n            last = last == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        if(fromStart == 0) return 0;\\n        last = beg == \\'1\\' ? \\'0\\' : \\'1\\';\\n        char seq0 = \\'0\\', seq1 = \\'1\\';\\n        for(int i = 1, j = 0; i < s.length(); i++, j++){\\n            if(s[i-1] != last) fromStart--;\\n            if(s[j] == seq0) toEnd0++;\\n            if(s[j] == seq1) toEnd1++;\\n            if(last == \\'1\\' && (s.length()-i-1)%2 == 0) ans = min(ans, toEnd0+fromStart);\\n            if(last == \\'1\\' && (s.length()-i-1)%2 == 1) ans = min(ans, toEnd1+fromStart);\\n            if(last == \\'0\\' && (s.length()-i-1)%2 == 0) ans = min(ans, toEnd1+fromStart);\\n            if(last == \\'0\\' && (s.length()-i-1)%2 == 1) ans = min(ans, toEnd0+fromStart);\\n            last = last == \\'1\\' ? \\'0\\' : \\'1\\';\\n            seq0 = seq0 == \\'1\\' ? \\'0\\' : \\'1\\';\\n            seq1 = seq1 == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        return ans;\\n    }\\n    int minFlips(string s) {\\n        return min(helper(s, \\'1\\'), helper(s,\\'0\\'));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int helper(string& s, char beg){\\n        int fromStart = 0, toEnd0 = 0, toEnd1 = 0;\\n        int ans = 10e8;\\n        char last = beg;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == last) fromStart++;\\n            last = last == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2782465,
                "title": "sliding-window-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minFlips = function(s) {\\n    let length = s.length-1\\n    let flipMap = {\\n        \\'1\\': \\'0\\',\\n        \\'0\\': \\'1\\'\\n    }\\n    s = s + s\\n    let alt1 = \\'1\\'\\n    let alt2 = \\'0\\'\\n    let left = 0\\n    let right = 0\\n    let diff1 = 0\\n    let diff2 = 0\\n    let min = Infinity\\n\\n    while (right < s.length) {\\n        if (right > 0) {\\n            alt1 = flipMap[alt1]\\n            alt2 = flipMap[alt2]\\n        }\\n\\n        let current = s[right]\\n        if (current !== alt1) diff1++\\n        if (current !== alt2) diff2++\\n        if (right-left === length) {\\n            min = Math.min(diff1, diff2, min)\\n            if ((length+1)%2 === 0) {\\n                if (s[left] !== flipMap[alt1]) diff1--\\n                if (s[left] !== flipMap[alt2]) diff2--\\n            } else {\\n                if (s[left] !== alt1) diff1--\\n                if (s[left] !== alt2) diff2--\\n            }\\n            left++\\n        }\\n        right++\\n    }\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minFlips = function(s) {\\n    let length = s.length-1\\n    let flipMap = {\\n        \\'1\\': \\'0\\',\\n        \\'0\\': \\'1\\'\\n    }\\n    s = s + s\\n    let alt1 = \\'1\\'\\n    let alt2 = \\'0\\'\\n    let left = 0\\n    let right = 0\\n    let diff1 = 0\\n    let diff2 = 0\\n    let min = Infinity\\n\\n    while (right < s.length) {\\n        if (right > 0) {\\n            alt1 = flipMap[alt1]\\n            alt2 = flipMap[alt2]\\n        }\\n\\n        let current = s[right]\\n        if (current !== alt1) diff1++\\n        if (current !== alt2) diff2++\\n        if (right-left === length) {\\n            min = Math.min(diff1, diff2, min)\\n            if ((length+1)%2 === 0) {\\n                if (s[left] !== flipMap[alt1]) diff1--\\n                if (s[left] !== flipMap[alt2]) diff2--\\n            } else {\\n                if (s[left] !== alt1) diff1--\\n                if (s[left] !== alt2) diff2--\\n            }\\n            left++\\n        }\\n        right++\\n    }\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768597,
                "title": "c-sliding-window-solution-with-explanation-space-o-1-time-o-n",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minFlips(string_view s)\\n    {\\n        // 1888. Minimum Number of flips to Make the Binary String Alternating:\\n        // https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(1)\\n\\n        // Note about methodology:\\n        // This question is actually asking us to find the minimum number of shared characters the input array\\n        // has with a leading 0 or a leading 1 alternating binary array. This means there are two target solutions.\\n        // In addition, we can append values to the end of the vector from the beginning of it.\\n        // For problems where an array must be analyzed and the starting index can be [0 ... n]\\n        // oftentimes, you can expand the array so that it wraps around from the beginning to the end.\\n        // An example can include: [1,1,1,0,0,0] -> [1,1,1,0,0,0,1,1,1,0,0,0]\\n        // This then can be formulated as sliding window problem solution so that you can check all possibilities\\n        // of the array combinations starting points.\\n\\n        // In this problem, we compare the inputted array to a leading zero array.\\n        // The variable rightIsZero shows the status of the alternating array at any arbitrary index.\\n        // Looping through the input array [1,1,1,0,0,0], we count the changes required for the entire array\\n        // to match the leading zero array.\\n        // Next, we loop through the input array again to inspect the wrap around combinations \\n        // (i.e. starting at index i = s.size() in this array > [1,1,1,0,0,0,1,1,1,0,0,0]))\\n        // In this loop, count the total number of changes needed to match the leading zero array if it were extended outward\\n        // Then subtract the number of changes needed if it had been changed in the first loop.\\n        // To find the minimum, we need to find the minimum of:\\n        // 1) total changes at this iteration, 2) leading 1 array changes at this iteration (by finding the complement calculation)\\n        // and 3) previous min change values\\n        // return this min value\\n\\n        bool rightIsZero = true;\\n        int countChanges = 0;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if ((rightIsZero && s[i] != \\'0\\') || (!rightIsZero && s[i] != \\'1\\'))\\n                countChanges++;\\n\\n            rightIsZero = rightIsZero ? false : true;\\n        }\\n\\n        bool leftIsZero = true;\\n        int minChanges = countChanges;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (rightIsZero && s[i] != \\'0\\' || !rightIsZero && s[i] != \\'1\\')\\n                countChanges++;\\n\\n            if (leftIsZero && s[i] != \\'0\\' || !leftIsZero && s[i] != \\'1\\')\\n                countChanges--;\\n\\n            int complement = s.size() - countChanges;\\n            minChanges = min(complement, min(countChanges, minChanges));\\n            rightIsZero = !rightIsZero;\\n            leftIsZero = !leftIsZero;\\n        }\\n\\n        return minChanges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minFlips(string_view s)\\n    {\\n        // 1888. Minimum Number of flips to Make the Binary String Alternating:\\n        // https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(1)\\n\\n        // Note about methodology:\\n        // This question is actually asking us to find the minimum number of shared characters the input array\\n        // has with a leading 0 or a leading 1 alternating binary array. This means there are two target solutions.\\n        // In addition, we can append values to the end of the vector from the beginning of it.\\n        // For problems where an array must be analyzed and the starting index can be [0 ... n]\\n        // oftentimes, you can expand the array so that it wraps around from the beginning to the end.\\n        // An example can include: [1,1,1,0,0,0] -> [1,1,1,0,0,0,1,1,1,0,0,0]\\n        // This then can be formulated as sliding window problem solution so that you can check all possibilities\\n        // of the array combinations starting points.\\n\\n        // In this problem, we compare the inputted array to a leading zero array.\\n        // The variable rightIsZero shows the status of the alternating array at any arbitrary index.\\n        // Looping through the input array [1,1,1,0,0,0], we count the changes required for the entire array\\n        // to match the leading zero array.\\n        // Next, we loop through the input array again to inspect the wrap around combinations \\n        // (i.e. starting at index i = s.size() in this array > [1,1,1,0,0,0,1,1,1,0,0,0]))\\n        // In this loop, count the total number of changes needed to match the leading zero array if it were extended outward\\n        // Then subtract the number of changes needed if it had been changed in the first loop.\\n        // To find the minimum, we need to find the minimum of:\\n        // 1) total changes at this iteration, 2) leading 1 array changes at this iteration (by finding the complement calculation)\\n        // and 3) previous min change values\\n        // return this min value\\n\\n        bool rightIsZero = true;\\n        int countChanges = 0;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if ((rightIsZero && s[i] != \\'0\\') || (!rightIsZero && s[i] != \\'1\\'))\\n                countChanges++;\\n\\n            rightIsZero = rightIsZero ? false : true;\\n        }\\n\\n        bool leftIsZero = true;\\n        int minChanges = countChanges;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (rightIsZero && s[i] != \\'0\\' || !rightIsZero && s[i] != \\'1\\')\\n                countChanges++;\\n\\n            if (leftIsZero && s[i] != \\'0\\' || !leftIsZero && s[i] != \\'1\\')\\n                countChanges--;\\n\\n            int complement = s.size() - countChanges;\\n            minChanges = min(complement, min(countChanges, minChanges));\\n            rightIsZero = !rightIsZero;\\n            leftIsZero = !leftIsZero;\\n        }\\n\\n        return minChanges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765210,
                "title": "sliding-window-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        string p=s+s;\\n        int i=0,j=0,k=s.size();\\n        int z=0,n=0,res=INT_MAX;\\n        while(j<p.size()){\\n            \\n            if(j%2==0 && p[j]!=\\'0\\' || j%2>0 && p[j]!=\\'1\\')\\n                z++;     \\n            \\n            if(j%2==0 && p[j]!=\\'1\\' || j%2>0 && p[j]!=\\'0\\')\\n                n++;\\n            \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                res=min(res,min(z,n));\\n                \\n            if(i%2==0 && p[i]!=\\'0\\' || i%2>0 && p[i]!=\\'1\\')\\n                z--;\\n           \\n            if(i%2==0 && p[i]!=\\'1\\' || i%2>0 && p[i]!=\\'0\\')\\n                n--;\\n                 \\n             i++; j++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        string p=s+s;\\n        int i=0,j=0,k=s.size();\\n        int z=0,n=0,res=INT_MAX;\\n        while(j<p.size()){\\n            \\n            if(j%2==0 && p[j]!=\\'0\\' || j%2>0 && p[j]!=\\'1\\')\\n                z++;     \\n            \\n            if(j%2==0 && p[j]!=\\'1\\' || j%2>0 && p[j]!=\\'0\\')\\n                n++;\\n            \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                res=min(res,min(z,n));\\n                \\n            if(i%2==0 && p[i]!=\\'0\\' || i%2>0 && p[i]!=\\'1\\')\\n                z--;\\n           \\n            if(i%2==0 && p[i]!=\\'1\\' || i%2>0 && p[i]!=\\'0\\')\\n                n--;\\n                 \\n             i++; j++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746350,
                "title": "dp-approach-tc-o-n-sc-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have choices if we can use type 1 operation  1 time 2 time, n time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a 2d dp array starting from last which stores no of type 2 operation require to make string of type \"010..\" or \"1010..\"\\ndp[i][0] stores no of operation require to make 010 type string\\ndp[i][1] stores no of operation require to make 101 type string\\n\\nNow start from 0 position\\nfor each i it means till i we will use type 1 query\\n\\nconsider\\n01234567 \\n11010101\\n\\nnow suppose we are at index 2 so till 2 will use type 1 query\\nso the string becomes\\n\\npart1  part2\\n10101 110\\n\\nfor part1 we have two option eiher we can make it \"010\" type string or \"1010\" type string\\n\\npart 2 type will depend on part1 type\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        if(n==1)return 0;\\n        if(n==2)return s[0]==s[1];\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            dp[i][0]=(s[i]==\\'0\\'?0:1)+dp[i+1][1];\\n            dp[i][1]=(s[i]==\\'1\\'?0:1)+dp[i+1][0];\\n        }\\n        int ans=min(dp[0][0],dp[0][1]);\\n        for(int i=0;i<n-1;i++){\\n            int sz=n-i-1;\\n            int c=i+1;\\n            //considering 010..\\n            int op1=dp[i+1][0];\\n            char end;\\n            sz%2?end=\\'0\\':end=\\'1\\';\\n            if(end==\\'1\\'){\\n                if(c&1)\\n                    op1+=abs(dp[0][0]-dp[i+1][1]);\\n                else\\n                    op1+=abs(dp[0][0]-dp[i+1][0]);\\n            }else{\\n                \\n                if(c&1)\\n                    op1+=abs(dp[0][1]-dp[i+1][0]);\\n                else\\n                    op1+=abs(dp[0][1]-dp[i+1][1]);\\n            }\\n            //considering 10101\\n            int op2=dp[i+1][1];\\n            sz%2?end=\\'1\\':end=\\'0\\';\\n            if(end==\\'1\\'){\\n                if(c&1)\\n                    op2+=abs(dp[0][0]-dp[i+1][1]);\\n                else\\n                    op2+=abs(dp[0][0]-dp[i+1][0]);\\n            }else{\\n                \\n                if(c&1)\\n                    op2+=abs(dp[0][1]-dp[i+1][0]);\\n                else\\n                    op2+=abs(dp[0][1]-dp[i+1][1]);\\n            }\\n            ans=min(ans,min(op1,op2));\\n            \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();\\n        if(n==1)return 0;\\n        if(n==2)return s[0]==s[1];\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            dp[i][0]=(s[i]==\\'0\\'?0:1)+dp[i+1][1];\\n            dp[i][1]=(s[i]==\\'1\\'?0:1)+dp[i+1][0];\\n        }\\n        int ans=min(dp[0][0],dp[0][1]);\\n        for(int i=0;i<n-1;i++){\\n            int sz=n-i-1;\\n            int c=i+1;\\n            //considering 010..\\n            int op1=dp[i+1][0];\\n            char end;\\n            sz%2?end=\\'0\\':end=\\'1\\';\\n            if(end==\\'1\\'){\\n                if(c&1)\\n                    op1+=abs(dp[0][0]-dp[i+1][1]);\\n                else\\n                    op1+=abs(dp[0][0]-dp[i+1][0]);\\n            }else{\\n                \\n                if(c&1)\\n                    op1+=abs(dp[0][1]-dp[i+1][0]);\\n                else\\n                    op1+=abs(dp[0][1]-dp[i+1][1]);\\n            }\\n            //considering 10101\\n            int op2=dp[i+1][1];\\n            sz%2?end=\\'1\\':end=\\'0\\';\\n            if(end==\\'1\\'){\\n                if(c&1)\\n                    op2+=abs(dp[0][0]-dp[i+1][1]);\\n                else\\n                    op2+=abs(dp[0][0]-dp[i+1][0]);\\n            }else{\\n                \\n                if(c&1)\\n                    op2+=abs(dp[0][1]-dp[i+1][0]);\\n                else\\n                    op2+=abs(dp[0][1]-dp[i+1][1]);\\n            }\\n            ans=min(ans,min(op1,op2));\\n            \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738004,
                "title": "c-sliding-window-easy-to-understand-best-for-beginners-o-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    void flip(char &c){\\n        if (c == \\'1\\') c = \\'0\\';\\n        else c = \\'1\\';\\n    }\\n    \\n    int min_flips(string &s, int n, char c){\\n        int best = n;\\n        vector<int> dp(2*n + 1);\\n        for (int i = 0; i < 2*n; i++){\\n            dp[i+1] = dp[i] + (c != s[i]);\\n            if (i >= n){\\n                best = min(best, dp[i+1] - dp[i+1-n]);\\n            }\\n            flip(c);\\n        }\\n        return best;\\n    }\\n    \\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        return min(min_flips(s, n, \\'0\\'), min_flips(s, n, \\'1\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flip(char &c){\\n        if (c == \\'1\\') c = \\'0\\';\\n        else c = \\'1\\';\\n    }\\n    \\n    int min_flips(string &s, int n, char c){\\n        int best = n;\\n        vector<int> dp(2*n + 1);\\n        for (int i = 0; i < 2*n; i++){\\n            dp[i+1] = dp[i] + (c != s[i]);\\n            if (i >= n){\\n                best = min(best, dp[i+1] - dp[i+1-n]);\\n            }\\n            flip(c);\\n        }\\n        return best;\\n    }\\n    \\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        return min(min_flips(s, n, \\'0\\'), min_flips(s, n, \\'1\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717873,
                "title": "c-o-n-time-dp",
                "content": "```\\nint     n, x, T;\\nint     f[2][2][2];\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        n = s.size();   s = \"#\" + s;\\n        T = 1-(n&1);                   \\n        \\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = f[0][0][1] = 0;\\n\\n        for (int i = 1; i <= n; i++) {                          x = i&1;\\n            for (int w = 0; w <= 1; w++) {\\n                f[x][0][w] = f[1-x][0][1-w] + (s[i]-\\'0\\'!=w);\\n                f[x][1][w] = min(f[1-x][1][1-w], f[1-x][0][w^T]) + (s[i]-\\'0\\'!=w);\\n            }\\n        }\\n        \\n        int ans = n;\\n        for (int w = 0; w <= 1; w++) ans = min(ans, min(f[x][0][w], f[x][1][w]));\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint     n, x, T;\\nint     f[2][2][2];\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        n = s.size();   s = \"#\" + s;\\n        T = 1-(n&1);                   \\n        \\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = f[0][0][1] = 0;\\n\\n        for (int i = 1; i <= n; i++) {                          x = i&1;\\n            for (int w = 0; w <= 1; w++) {\\n                f[x][0][w] = f[1-x][0][1-w] + (s[i]-\\'0\\'!=w);\\n                f[x][1][w] = min(f[1-x][1][1-w], f[1-x][0][w^T]) + (s[i]-\\'0\\'!=w);\\n            }\\n        }\\n        \\n        int ans = n;\\n        for (int w = 0; w <= 1; w++) ans = min(ans, min(f[x][0][w], f[x][1][w]));\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684945,
                "title": "c-sliding-window-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length of string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(const string& s) {\\n        const int n = size(s);\\n        int ret, a = 0;\\n        for (int i = 0; i < n; ++i)\\n            a += (\\'0\\' == s[i]) ^ (i & 1);\\n        ret = min(a, n - a);\\n        if (n & 1)\\n            for (int i = 0; i < n; ++i) {\\n                a += (\\'0\\' == s[i]) ^ (i & 1 ^ 1);\\n                a -= (\\'0\\' == s[i]) ^ (i & 1);\\n                ret = min({ret, a, n - a});\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(const string& s) {\\n        const int n = size(s);\\n        int ret, a = 0;\\n        for (int i = 0; i < n; ++i)\\n            a += (\\'0\\' == s[i]) ^ (i & 1);\\n        ret = min(a, n - a);\\n        if (n & 1)\\n            for (int i = 0; i < n; ++i) {\\n                a += (\\'0\\' == s[i]) ^ (i & 1 ^ 1);\\n                a -= (\\'0\\' == s[i]) ^ (i & 1);\\n                ret = min({ret, a, n - a});\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678280,
                "title": "c-solution-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\n    int minFlips(string arr) {\\n        int k=arr.length(); //window size\\n        int ans1=0,ans2=0,ans=INT_MAX;\\n        \\n        char d1=\\'0\\',d2=\\'1\\'; //last digit of window\\n        char s1=\\'0\\',s2=\\'1\\'; // first digit of window\\n        arr+=arr; // make it double size for window sliding  \\n        \\n        int n=arr.length(); // new string size\\n        int i=0;int j=0;\\n        \\n        while(j<n){\\n            if(arr[j]!=d1) {ans1++;}\\n            if(arr[j]!=d2){ans2++;}\\n            \\n            if(j-i+1<k){\\n                j++;\\n            }\\n    \\n            else if(j-i+1==k){\\n                ans=min(ans,min(ans1,ans2));\\n                if(arr[i]!=s1) ans1--;\\n                if(arr[i]!=s2) ans2--;\\n                s1==\\'0\\'?s1=\\'1\\':s1=\\'0\\';\\n                s2==\\'1\\'?s2=\\'0\\':s2=\\'1\\';\\n                i++,j++;\\n            }\\n            \\n            d1==\\'0\\'?d1=\\'1\\':d1=\\'0\\';\\n            d2==\\'1\\'?d2=\\'0\\':d2=\\'1\\';\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int minFlips(string arr) {\\n        int k=arr.length(); //window size\\n        int ans1=0,ans2=0,ans=INT_MAX;\\n        \\n        char d1=\\'0\\',d2=\\'1\\'; //last digit of window\\n        char s1=\\'0\\',s2=\\'1\\'; // first digit of window\\n        arr+=arr; // make it double size for window sliding  \\n        \\n        int n=arr.length(); // new string size\\n        int i=0;int j=0;\\n        \\n        while(j<n){\\n            if(arr[j]!=d1) {ans1++;}\\n            if(arr[j]!=d2){ans2++;}\\n            \\n            if(j-i+1<k){\\n                j++;\\n            }\\n    \\n            else if(j-i+1==k){\\n                ans=min(ans,min(ans1,ans2));\\n                if(arr[i]!=s1) ans1--;\\n                if(arr[i]!=s2) ans2--;\\n                s1==\\'0\\'?s1=\\'1\\':s1=\\'0\\';\\n                s2==\\'1\\'?s2=\\'0\\':s2=\\'1\\';\\n                i++,j++;\\n            }\\n            \\n            d1==\\'0\\'?d1=\\'1\\':d1=\\'0\\';\\n            d2==\\'1\\'?d2=\\'0\\':d2=\\'1\\';\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676741,
                "title": "python-o-n-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        # count[0][0] = number of \\'0\\' in even positions\\n        # count[0][1] = number of \\'0\\' in odd  positions\\n        # count[1][0] = number of \\'1\\' in even positions\\n        # count[1][1] = number of \\'1\\' in odd  positions\\n        numBits, count = len(s), [[0, 0], [0, 0]]\\n        for i in range(numBits):\\n            count[ord(s[i]) - ord(\\'0\\')][i % 2] += 1\\n        ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\\n        for i in range(numBits):\\n            # Remove the bit from its position\\n            count[ord(s[i]) - ord(\\'0\\')][i % 2] -= 1\\n            # Append the bit on the end\\n            count[ord(s[i]) - ord(\\'0\\')][(numBits + i) % 2] += 1\\n            # Re-calculate the answer\\n            ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        # count[0][0] = number of \\'0\\' in even positions\\n        # count[0][1] = number of \\'0\\' in odd  positions\\n        # count[1][0] = number of \\'1\\' in even positions\\n        # count[1][1] = number of \\'1\\' in odd  positions\\n        numBits, count = len(s), [[0, 0], [0, 0]]\\n        for i in range(numBits):\\n            count[ord(s[i]) - ord(\\'0\\')][i % 2] += 1\\n        ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\\n        for i in range(numBits):\\n            # Remove the bit from its position\\n            count[ord(s[i]) - ord(\\'0\\')][i % 2] -= 1\\n            # Append the bit on the end\\n            count[ord(s[i]) - ord(\\'0\\')][(numBits + i) % 2] += 1\\n            # Re-calculate the answer\\n            ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669127,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        m = len(s)\\n        \\n        s += s \\n        \\n        n = len(s)\\n        \\n        a1 = \"\"\\n        a2 = \"\"\\n        \\n        for i in range(0,n):\\n            \\n            if(i % 2 == 0):\\n                \\n                a1 += \"1\"\\n                a2 += \"0\"\\n            \\n            else:\\n                \\n                a1 += \"0\"\\n                a2 += \"1\"\\n \\n        ans1 = 0 \\n        ans2 = 0 \\n        \\n        for i in range(0,m):\\n            \\n            if(s[i] != a1[i]):\\n                \\n                ans1 += 1 \\n            \\n            if(s[i] != a2[i]):\\n                \\n                ans2 += 1 \\n        \\n        \\n        min_ = min(ans1,ans2)\\n        \\n        j = 0\\n        for i in range(m,n):\\n            \\n            if(a1[j] != s[j] ):\\n                \\n                ans1 -= 1 \\n            \\n            if(a2[j] != s[j]):\\n                \\n                ans2 -= 1 \\n            \\n            if(a1[i] != s[i] ):\\n                \\n                ans1 += 1 \\n            \\n            if(a2[i] != s[i] ):\\n                \\n                ans2 += 1 \\n            \\n            \\n            min_ = min(min_ , ans1 , ans2)\\n            \\n            j += 1 \\n        \\n        \\n        return min_ \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        \\n        m = len(s)\\n        \\n        s += s \\n        \\n        n = len(s)\\n        \\n        a1 = \"\"\\n        a2 = \"\"\\n        \\n        for i in range(0,n):\\n            \\n            if(i % 2 == 0):\\n                \\n                a1 += \"1\"\\n                a2 += \"0\"\\n            \\n            else:\\n                \\n                a1 += \"0\"\\n                a2 += \"1\"\\n \\n        ans1 = 0 \\n        ans2 = 0 \\n        \\n        for i in range(0,m):\\n            \\n            if(s[i] != a1[i]):\\n                \\n                ans1 += 1 \\n            \\n            if(s[i] != a2[i]):\\n                \\n                ans2 += 1 \\n        \\n        \\n        min_ = min(ans1,ans2)\\n        \\n        j = 0\\n        for i in range(m,n):\\n            \\n            if(a1[j] != s[j] ):\\n                \\n                ans1 -= 1 \\n            \\n            if(a2[j] != s[j]):\\n                \\n                ans2 -= 1 \\n            \\n            if(a1[i] != s[i] ):\\n                \\n                ans1 += 1 \\n            \\n            if(a2[i] != s[i] ):\\n                \\n                ans2 += 1 \\n            \\n            \\n            min_ = min(min_ , ans1 , ans2)\\n            \\n            j += 1 \\n        \\n        \\n        return min_ \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652313,
                "title": "minimum-flips-in-cycling-sequence-using-sliding-window",
                "content": "```\\nclass Solution:\\n    def minsum(self, arr, n, k):\\n        res = float(\\'inf\\')\\n        curr = 0\\n        for i in range(n):\\n            curr += arr[i]\\n            if i >= k:\\n                curr -= arr[i - k]\\n            if i >= k - 1:\\n                res = min(res, curr)\\n        return res\\n    \\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        res = n\\n        a = [0] * n * 2\\n        b = [0] * n * 2\\n        for i in range(2 * n):\\n            if int(s[i % n]) != i % 2:\\n                a[i] = 1\\n            else:\\n                b[i] = 1\\n        asum = self.minsum(a, 2 * n, n)\\n        bsum = self.minsum(b, 2 * n, n)\\n        return min(asum, bsum)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minsum(self, arr, n, k):\\n        res = float(\\'inf\\')\\n        curr = 0\\n        for i in range(n):\\n            curr += arr[i]\\n            if i >= k:\\n                curr -= arr[i - k]\\n            if i >= k - 1:\\n                res = min(res, curr)\\n        return res\\n    \\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n        res = n\\n        a = [0] * n * 2\\n        b = [0] * n * 2\\n        for i in range(2 * n):\\n            if int(s[i % n]) != i % 2:\\n                a[i] = 1\\n            else:\\n                b[i] = 1\\n        asum = self.minsum(a, 2 * n, n)\\n        bsum = self.minsum(b, 2 * n, n)\\n        return min(asum, bsum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640034,
                "title": "python-o-n-time-sliding-window-solutions-one-in-o-n-space-other-in-o-1-space",
                "content": "I found that there were no good python solutions on here (lack of comments, not very efficient).\\nInspired by and building upon chejianhao\\'s solution, here is a (hopefullh) well commented O(n) time solution: one with O(n) space which is, IMO more readable, and one with O(1) space.\\n\\nThe crux of the solution is comparing each element of `s` to what it must look like after all operations - `\\'010101\\'`... or `\\'101010\\'`...\\nFor each element of s, we check whether it matches the element of the same index from 0101.. or 1010... and count how many mismatches there are. \\n\\nTo take into account the operation of taking the beginning elements of `s` and appending it to the end, I naively append the entirety of `s` to `s` in the O(n) solution. In the O(1) solution, I use some clever arithmetic to figure out what index of `s` the loop would be in after wrapping around.\\n\\n### O(n) Space\\n```\\nclass Solution:  \\n    def minFlips(self, s: str) -> int:\\n\\t\\t# We need to store the length of the original s\\n        length = len(s)\\n\\t\\t# Add s to s gets allows us to consider the case where the starting elements are moved\\n\\t\\t# to the end of the list\\n\\t\\t# e.g. 00101 -> 0010100101. Optimal is 01010 which can be found at 0[01010]0101\\n\\t\\ts += s\\n        \\n        ans_1, ans_2 = 0, 0\\n\\t\\t# we set ans to length because the maximum possible operations must be less than \\n\\t\\t# the length of the string. What you set it to isn\\'t a huge deal, as it will be overwritten \\n\\t\\t# in the first min() call that appears later. It just needs some large int\\n        ans = length\\n\\t\\t\\n\\t\\t# a function that gives us what a alternating sequence with 1 at odd positions would\\n        # have had in index j. Note that an \"even\" fn is not needed as we can just \"else\" it\\n\\t\\t# Essentially, we\\'re making 01010101 without actually making a list of 0\\'s and 1\\'s.\\n        odd = lambda j: \\'0\\' if j % 2 else \\'1\\'\\n\\t\\t\\n        for i in range(len(s)):\\n\\t\\t\\t# The final array after switching will have to be either 010101... or 101010...\\n\\t\\t\\t# So, we count how many elements need switching to conform to either.\\n            if s[i] != odd(i):\\n                ans_1 += 1\\n            else:\\n                ans_2 += 1\\n\\t\\t\\t# If we have wrapped around s, we need to consider that the elements at the start\\n            # of our \"window\" are no longer in the window.\\n            if i >= length:\\n                if s[i - length] != odd(i - length):\\n                    ans_1 -= 1\\n                else:\\n                    ans_2 -= 1\\n\\t\\t\\t# If we have wrapped around s, we need to consider that the elements at the start\\n            # of our \"window\" are no longer in the window.\\n            if i >= length - 1:\\n                ans = min(ans_1, ans_2, ans)\\n                    \\n        return ans\\n```\\n\\n### O(1) Space \\n\\n```\\nclass Solution:  \\n    def minFlips(self, s: str) -> int:\\n        length = len(s)\\n        ans_1, ans_2 = 0, 0\\n        ans = length\\n        \\n        # a function that gives us what a alternating sequence with 1 at odd positions would\\n        # have had in index j. Note that an \"even\" fn is not needed as we can just \"else\" it\\n        odd = lambda j: \\'0\\' if j % 2 else \\'1\\'\\n        \\n        # We need to do length * 2 because we are emulating a s = s + s\\n        for idx in range(length * 2):\\n            # i is the index in s after wrapping around. If idx has gone through s once,\\n            # idx // length = 1, so idx - 1 * length would give you the position in original s\\n            i = idx - (idx // length) * length\\n            \\n            if s[i] != odd(idx):\\n                ans_1 += 1\\n            else:\\n                ans_2 += 1\\n            \\n            # If we have wrapped around s, we need to consider that the elements at the start\\n            # of our \"window\" are no longer in the window.\\n            if idx >= length:\\n                if s[i] != odd(i):\\n                    ans_1 -= 1\\n                else:\\n                    ans_2 -= 1\\n                    \\n            # Once our window has looked expanded to include the entirety of s, we check which\\n            # solution is smallest\\n            if idx >= length - 1:\\n                ans = min(ans_1, ans_2, ans)\\n                    \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:  \\n    def minFlips(self, s: str) -> int:\\n\\t\\t# We need to store the length of the original s\\n        length = len(s)\\n\\t\\t# Add s to s gets allows us to consider the case where the starting elements are moved\\n\\t\\t# to the end of the list\\n\\t\\t# e.g. 00101 -> 0010100101. Optimal is 01010 which can be found at 0[01010]0101\\n\\t\\ts += s\\n        \\n        ans_1, ans_2 = 0, 0\\n\\t\\t# we set ans to length because the maximum possible operations must be less than \\n\\t\\t# the length of the string. What you set it to isn\\'t a huge deal, as it will be overwritten \\n\\t\\t# in the first min() call that appears later. It just needs some large int\\n        ans = length\\n\\t\\t\\n\\t\\t# a function that gives us what a alternating sequence with 1 at odd positions would\\n        # have had in index j. Note that an \"even\" fn is not needed as we can just \"else\" it\\n\\t\\t# Essentially, we\\'re making 01010101 without actually making a list of 0\\'s and 1\\'s.\\n        odd = lambda j: \\'0\\' if j % 2 else \\'1\\'\\n\\t\\t\\n        for i in range(len(s)):\\n\\t\\t\\t# The final array after switching will have to be either 010101... or 101010...\\n\\t\\t\\t# So, we count how many elements need switching to conform to either.\\n            if s[i] != odd(i):\\n                ans_1 += 1\\n            else:\\n                ans_2 += 1\\n\\t\\t\\t# If we have wrapped around s, we need to consider that the elements at the start\\n            # of our \"window\" are no longer in the window.\\n            if i >= length:\\n                if s[i - length] != odd(i - length):\\n                    ans_1 -= 1\\n                else:\\n                    ans_2 -= 1\\n\\t\\t\\t# If we have wrapped around s, we need to consider that the elements at the start\\n            # of our \"window\" are no longer in the window.\\n            if i >= length - 1:\\n                ans = min(ans_1, ans_2, ans)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617275,
                "title": "o-n-time-o-1-space-super-super-clear-explanation-compare-diff-with-two-patterns",
                "content": "![image](https://assets.leetcode.com/users/images/2cd07e97-6657-4262-a196-546cbb5d7f48_1664008149.398474.png)\\n\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b, ans = 0, 0, math.inf\\n        for i, n in enumerate(s):\\n            o = (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2)\\n            a, b = a + 1 - o, b + o\\n\\n        if len(s) % 2 == 0:\\n            return min(a, b)\\n\\n        for n in s:\\n            a_ = b - (n != \\'0\\') + (n != \\'1\\')\\n            b_ = a - (n != \\'1\\') + (n != \\'0\\')\\n            a, b = a_, b_\\n            ans = min((ans, a, b))\\n\\n        return ans\\n\\noptimized\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b, ans = 0, 0, math.inf\\n        for i, n in enumerate(s):\\n            o = (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2)\\n            a, b = a + 1 - o, b + o\\n\\n        if len(s) % 2 == 0:\\n            return min(a, b)\\n\\n        for n in s:\\n            a, b = b - (n != \\'0\\') + (n != \\'1\\'), a - (n != \\'1\\') + (n != \\'0\\')\\n            ans = min((ans, a, b))\\n\\n        return ans\\n\\n\\nanother idea\\n\\n![image](https://assets.leetcode.com/users/images/4807061f-3918-4486-814d-afeb6cafda45_1664008176.3852367.png)\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        d, min_, max_ = 0, math.inf, -math.inf\\n\\n        for i, n in enumerate(s):\\n            d += 1 if (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2) else -1\\n            min_, max_ = min(min_, d), max(max_, d)\\n\\n        a, b = (len(s) + d) // 2, (len(s) - d) // 2\\n        return min(a, b) if len(s) % 2 == 0 else min(a - max_, b + min_)\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/2cd07e97-6657-4262-a196-546cbb5d7f48_1664008149.398474.png)\\n\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b, ans = 0, 0, math.inf\\n        for i, n in enumerate(s):\\n            o = (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2)\\n            a, b = a + 1 - o, b + o\\n\\n        if len(s) % 2 == 0:\\n            return min(a, b)\\n\\n        for n in s:\\n            a_ = b - (n != \\'0\\') + (n != \\'1\\')\\n            b_ = a - (n != \\'1\\') + (n != \\'0\\')\\n            a, b = a_, b_\\n            ans = min((ans, a, b))\\n\\n        return ans\\n\\noptimized\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b, ans = 0, 0, math.inf\\n        for i, n in enumerate(s):\\n            o = (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2)\\n            a, b = a + 1 - o, b + o\\n\\n        if len(s) % 2 == 0:\\n            return min(a, b)\\n\\n        for n in s:\\n            a, b = b - (n != \\'0\\') + (n != \\'1\\'), a - (n != \\'1\\') + (n != \\'0\\')\\n            ans = min((ans, a, b))\\n\\n        return ans\\n\\n\\nanother idea\\n\\n![image](https://assets.leetcode.com/users/images/4807061f-3918-4486-814d-afeb6cafda45_1664008176.3852367.png)\\n\\n    def minFlips(self, s: str) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        d, min_, max_ = 0, math.inf, -math.inf\\n\\n        for i, n in enumerate(s):\\n            d += 1 if (n == \\'1\\' and i % 2 == 0) or (n == \\'0\\' and i % 2) else -1\\n            min_, max_ = min(min_, d), max(max_, d)\\n\\n        a, b = (len(s) + d) // 2, (len(s) - d) // 2\\n        return min(a, b) if len(s) % 2 == 0 else min(a - max_, b + min_)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2606035,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int il = s.length();\\n        s = new StringBuilder(s).append(s).toString();\\n        int len = s.length();    \\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(i%2 == 0)\\n            {\\n                sb1.append(\\'0\\');\\n                sb2.append(\\'1\\');\\n            }\\n            else\\n            {\\n                sb1.append(\\'1\\');\\n                sb2.append(\\'0\\');\\n            }\\n        }\\n        String altOne = sb1.toString();\\n        String altTwo = sb2.toString();\\n        int minOperations = Integer.MAX_VALUE;\\n        int altOneDiff = 0;\\n        int altTwoDiff = 0;        \\n        for(int i=0;i<il;i++)\\n        {\\n            if(s.charAt(i) != altOne.charAt(i))\\n                altOneDiff++;\\n            if(s.charAt(i) != altTwo.charAt(i))\\n                altTwoDiff++;\\n        }\\n        int start = 0;\\n        minOperations = Math.min(minOperations, Math.min(altOneDiff, altTwoDiff));       \\n        for(int j = il; j < 2*il-1 ; j++)\\n        {          \\n            if(s.charAt(start) != altOne.charAt(start))\\n               altOneDiff--;\\n            if(s.charAt(j) != altOne.charAt(j))\\n                altOneDiff++;\\n            \\n            if(s.charAt(start) != altTwo.charAt(start))\\n                altTwoDiff--;\\n            if(s.charAt(j) != altTwo.charAt(j))\\n                altTwoDiff++;\\n            minOperations = Math.min(minOperations, Math.min(altOneDiff, altTwoDiff));\\n            start++;\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int il = s.length();\\n        s = new StringBuilder(s).append(s).toString();\\n        int len = s.length();    \\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(i%2 == 0)\\n            {\\n                sb1.append(\\'0\\');\\n                sb2.append(\\'1\\');\\n            }\\n            else\\n            {\\n                sb1.append(\\'1\\');\\n                sb2.append(\\'0\\');\\n            }\\n        }\\n        String altOne = sb1.toString();\\n        String altTwo = sb2.toString();\\n        int minOperations = Integer.MAX_VALUE;\\n        int altOneDiff = 0;\\n        int altTwoDiff = 0;        \\n        for(int i=0;i<il;i++)\\n        {\\n            if(s.charAt(i) != altOne.charAt(i))\\n                altOneDiff++;\\n            if(s.charAt(i) != altTwo.charAt(i))\\n                altTwoDiff++;\\n        }\\n        int start = 0;\\n        minOperations = Math.min(minOperations, Math.min(altOneDiff, altTwoDiff));       \\n        for(int j = il; j < 2*il-1 ; j++)\\n        {          \\n            if(s.charAt(start) != altOne.charAt(start))\\n               altOneDiff--;\\n            if(s.charAt(j) != altOne.charAt(j))\\n                altOneDiff++;\\n            \\n            if(s.charAt(start) != altTwo.charAt(start))\\n                altTwoDiff--;\\n            if(s.charAt(j) != altTwo.charAt(j))\\n                altTwoDiff++;\\n            minOperations = Math.min(minOperations, Math.min(altOneDiff, altTwoDiff));\\n            start++;\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579421,
                "title": "javascript-sliding-window-o-n-time-o-1-space",
                "content": "```\\nvar minFlips = function(s) {\\n  let s1 = 0, s2 = 0, len = s.length, min = Infinity;\\n  for (let i = 0; i < 2*len; i++) {\\n    s1 += parseInt(s[i % len]) === i % 2 ? 0 : 1;\\n    s2 += parseInt(s[i % len]) === (1 - i % 2) ? 0 : 1;\\n    if (i >= len) {\\n      const j = i - len;\\n      s1 -= parseInt(s[j]) === j % 2 ? 0 : 1;\\n      s2 -= parseInt(s[j]) === (1 - j % 2) ? 0 : 1;\\n      min = Math.min(min, s1, s2);\\n    }\\n  }\\n  \\n  return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minFlips = function(s) {\\n  let s1 = 0, s2 = 0, len = s.length, min = Infinity;\\n  for (let i = 0; i < 2*len; i++) {\\n    s1 += parseInt(s[i % len]) === i % 2 ? 0 : 1;\\n    s2 += parseInt(s[i % len]) === (1 - i % 2) ? 0 : 1;\\n    if (i >= len) {\\n      const j = i - len;\\n      s1 -= parseInt(s[j]) === j % 2 ? 0 : 1;\\n      s2 -= parseInt(s[j]) === (1 - j % 2) ? 0 : 1;\\n      min = Math.min(min, s1, s2);\\n    }\\n  }\\n  \\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557454,
                "title": "94-c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string A) {\\n        int n=A.size();\\n        int evenzero=0;\\n        int oddone=0;\\n        // logic: you can assign every even place with one or zero and odd place with zero or one; \\n        for(int i=0;i<n;i++){\\n            if(i%2==0 && A[i]==\\'0\\'){\\n                evenzero++;\\n            }\\n            else if(i%2==1 && A[i]==\\'1\\'){\\n                oddone++;\\n            }\\n        }\\n        \\n        int ans=min(evenzero+oddone,n-evenzero-oddone);\\n        if(n%2==0){\\n            return ans;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(A[i]==\\'0\\'){\\n                evenzero--;\\n            }else oddone++;\\n            int newoddone=(n/2)-evenzero;\\n            int newevenzero=(n/2)+1-oddone;\\n            oddone=newoddone;\\n            evenzero=newevenzero;\\n            int curmin=min(evenzero+oddone,n-evenzero-oddone);\\n            ans=min(ans,curmin);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string A) {\\n        int n=A.size();\\n        int evenzero=0;\\n        int oddone=0;\\n        // logic: you can assign every even place with one or zero and odd place with zero or one; \\n        for(int i=0;i<n;i++){\\n            if(i%2==0 && A[i]==\\'0\\'){\\n                evenzero++;\\n            }\\n            else if(i%2==1 && A[i]==\\'1\\'){\\n                oddone++;\\n            }\\n        }\\n        \\n        int ans=min(evenzero+oddone,n-evenzero-oddone);\\n        if(n%2==0){\\n            return ans;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(A[i]==\\'0\\'){\\n                evenzero--;\\n            }else oddone++;\\n            int newoddone=(n/2)-evenzero;\\n            int newevenzero=(n/2)+1-oddone;\\n            oddone=newoddone;\\n            evenzero=newevenzero;\\n            int curmin=min(evenzero+oddone,n-evenzero-oddone);\\n            ans=min(ans,curmin);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552412,
                "title": "java-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public static int minFlips(String s) {\\n        int min = Integer.MAX_VALUE;\\n        String sCopy = s;\\n       s = s.repeat(2);\\n        int countZero = 0;\\n        int countOne = 0;\\n        int i;\\n        for(i = 0; i < sCopy.length(); i++) {\\n            if(i % 2 == 0 && s.charAt(i) == \\'1\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'0\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 0 && s.charAt(i) == \\'0\\') {\\n                countOne++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'1\\') {\\n                countOne++;\\n            }\\n            min = Math.min(countOne, countZero);\\n\\n        }\\n     //   min = Math.min((Math.min(countOne, countZero)), min);\\n        int j = 0;\\n        while(i < s.length()) {\\n            if(i % 2 == 0 && s.charAt(i) == \\'1\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'0\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 0 && s.charAt(i) == \\'0\\') {\\n                countOne++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'1\\') {\\n                countOne++;\\n            }\\n            i++;\\n\\n            if(j % 2 == 0 && s.charAt(j) == \\'1\\') {\\n                countZero--;\\n            }\\n            if(j % 2 == 1 && s.charAt(j) == \\'0\\') {\\n                countZero--;\\n            }\\n            if(j % 2 == 0 && s.charAt(j) == \\'0\\') {\\n                countOne--;\\n            }\\n            if(j % 2 == 1 && s.charAt(j) == \\'1\\') {\\n                countOne--;\\n            }\\n            j++;\\n            min = Math.min((Math.min(countOne, countZero)), min);\\n\\n        }\\n        return min;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int minFlips(String s) {\\n        int min = Integer.MAX_VALUE;\\n        String sCopy = s;\\n       s = s.repeat(2);\\n        int countZero = 0;\\n        int countOne = 0;\\n        int i;\\n        for(i = 0; i < sCopy.length(); i++) {\\n            if(i % 2 == 0 && s.charAt(i) == \\'1\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'0\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 0 && s.charAt(i) == \\'0\\') {\\n                countOne++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'1\\') {\\n                countOne++;\\n            }\\n            min = Math.min(countOne, countZero);\\n\\n        }\\n     //   min = Math.min((Math.min(countOne, countZero)), min);\\n        int j = 0;\\n        while(i < s.length()) {\\n            if(i % 2 == 0 && s.charAt(i) == \\'1\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'0\\') {\\n                countZero++;\\n            }\\n            if(i % 2 == 0 && s.charAt(i) == \\'0\\') {\\n                countOne++;\\n            }\\n            if(i % 2 == 1 && s.charAt(i) == \\'1\\') {\\n                countOne++;\\n            }\\n            i++;\\n\\n            if(j % 2 == 0 && s.charAt(j) == \\'1\\') {\\n                countZero--;\\n            }\\n            if(j % 2 == 1 && s.charAt(j) == \\'0\\') {\\n                countZero--;\\n            }\\n            if(j % 2 == 0 && s.charAt(j) == \\'0\\') {\\n                countOne--;\\n            }\\n            if(j % 2 == 1 && s.charAt(j) == \\'1\\') {\\n                countOne--;\\n            }\\n            j++;\\n            min = Math.min((Math.min(countOne, countZero)), min);\\n\\n        }\\n        return min;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551813,
                "title": "clean-python",
                "content": "```\\n    def minFlips(self, s: str) -> int:\\n        res=float(\\'inf\\')\\n        double_s=s+s\\n        alt1,alt2=[\\'0\\']*len(double_s),[\\'1\\']*len(double_s)\\n        for i in range(0,len(double_s),2):\\n            alt1[i]=\\'1\\'\\n            alt2[i]=\\'0\\'\\n        diff1,diff2=0,0\\n        for i in range(len(s)):\\n            if s[i]!=alt1[i]:diff1+=1\\n            if s[i]!=alt2[i]:diff2+=1\\n        res=min(res,diff1,diff2)\\n        for j in range(len(s),len(double_s)):\\n            if double_s[j-len(s)]!=alt1[j-len(s)]:diff1-=1\\n            if double_s[j]!=alt1[j]:diff1+=1\\n            #process alt2\\n            if double_s[j-len(s)]!=alt2[j-len(s)]:diff2-=1\\n            if double_s[j]!=alt2[j]:diff2+=1\\n            res=min(res,diff1,diff2)\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\n    def minFlips(self, s: str) -> int:\\n        res=float(\\'inf\\')\\n        double_s=s+s\\n        alt1,alt2=[\\'0\\']*len(double_s),[\\'1\\']*len(double_s)\\n        for i in range(0,len(double_s),2):\\n            alt1[i]=\\'1\\'\\n            alt2[i]=\\'0\\'\\n        diff1,diff2=0,0\\n        for i in range(len(s)):\\n            if s[i]!=alt1[i]:diff1+=1\\n            if s[i]!=alt2[i]:diff2+=1\\n        res=min(res,diff1,diff2)\\n        for j in range(len(s),len(double_s)):\\n            if double_s[j-len(s)]!=alt1[j-len(s)]:diff1-=1\\n            if double_s[j]!=alt1[j]:diff1+=1\\n            #process alt2\\n            if double_s[j-len(s)]!=alt2[j-len(s)]:diff2-=1\\n            if double_s[j]!=alt2[j]:diff2+=1\\n            res=min(res,diff1,diff2)\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2551475,
                "title": "c-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s)\\n    {\\n        int n=s.size();\\n        s+=s;\\n        string s1,s2;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            s1+=i%2?\\'1\\':\\'0\\';\\n            s2+=i%2?\\'0\\':\\'1\\';\\n        }\\n        int ans1=0,ans2=0,res=INT_MAX;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(s[i]!=s1[i]) ans1++;\\n            if(s[i]!=s2[i]) ans2++;\\n            if(i>=n)\\n            {\\n                if(s[i-n]!=s1[i-n]) ans1--;\\n                if(s[i-n]!=s2[i-n]) ans2--;\\n            }\\n            if(i>=n-1)\\n            {\\n                res=min({ans1,ans2,res});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minFlips(string s)\\n    {\\n        int n=s.size();\\n        s+=s;\\n        string s1,s2;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            s1+=i%2?\\'1\\':\\'0\\';\\n            s2+=i%2?\\'0\\':\\'1\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2546255,
                "title": "java-tle",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {  \\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MAX_VALUE;\\n         String zeros = startZero(s.length());\\n        String one = startOne(s.length());\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            sb = new StringBuilder(sb.substring(i, sb.length()) + sb.substring(0, i));\\n           min = Math.min(countMatches(sb.toString(), zeros), countMatches(sb.toString(), one));\\n            ans = Math.min(ans, min);           \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public String startZero(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <=n ; i++) {\\n            if(i % 2 == 0) {\\n                sb.append(\"0\");\\n            } else {\\n                sb.append(\"1\");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n     public String startOne(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <=n ; i++) {\\n            if(i % 2 == 0) {\\n                sb.append(\"1\");\\n            } else {\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int countMatches(String s1, String s2) {\\n        int count = 0;\\n        for(int i = 0; i < s1.length(); i++) {\\n            if(s1.charAt(i) != s2.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {  \\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MAX_VALUE;\\n         String zeros = startZero(s.length());\\n        String one = startOne(s.length());\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            sb = new StringBuilder(sb.substring(i, sb.length()) + sb.substring(0, i));\\n           min = Math.min(countMatches(sb.toString(), zeros), countMatches(sb.toString(), one));\\n            ans = Math.min(ans, min);           \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public String startZero(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <=n ; i++) {\\n            if(i % 2 == 0) {\\n                sb.append(\"0\");\\n            } else {\\n                sb.append(\"1\");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n     public String startOne(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <=n ; i++) {\\n            if(i % 2 == 0) {\\n                sb.append(\"1\");\\n            } else {\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int countMatches(String s1, String s2) {\\n        int count = 0;\\n        for(int i = 0; i < s1.length(); i++) {\\n            if(s1.charAt(i) != s2.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519722,
                "title": "c-code-for-beginners-very-easy",
                "content": "Please see the below cases to realise that a even length string has NO effect on the overall answer, even if you switch the prefix\\n\\n\\t\\t\\n* **EVEN**\\n\\t\\tSTRING - 101100 \\n\\t\\t\\t\\tWithout Switching Prefixes, JUST FLIPPING\\n\\t\\t\\t\\t1) TYPE 1 -> 010101  (flips required-> 4)\\n\\t\\t\\t\\t2) TYPE 2 -> 101010  (flips required-> 2)\\n\\t\\t\\t\\t\\nNow, lets try switching a prefix of length 3, i.e. 101 to the end and delete from start. So the string becomes 100**101**. And now we try to flip bits to see answer minimum\\n\\t\\t\\t\\t1) TYPE 1 -> 010101  (flips required-> 2)\\n\\t\\t\\t\\t2) TYPE 2 -> 101010  (flips required-> 4)\\n\\nAs you see, it does not matter, even if you swap the prefix, its always gonna result in the same answer. Lets see for the odd length now\\n\\n* **ODD**\\n\\tSTRING - 1011001\\n\\t\\tWithout Switching Prefixes, JUST FLIPPING\\n\\t\\t\\t\\t1) TYPE 1 -> 0101010  (flips required-> 5)\\n\\t\\t\\t\\t2) TYPE 2 -> 1010101  (flips required-> 2)\\n\\t\\t\\t\\t\\nNow, lets try switching a prefix of length 3, i.e. 101 to the end and delete from start. So the string becomes 1001**101**. And now we try to flip bits to see answer minimum\\n\\t\\t\\t\\t1) TYPE 1 -> 0101010  (flips required-> 5)\\n\\t\\t\\t\\t2) TYPE 2 -> 1010101  (flips required-> 2)\\n\\nwhoops!! Same answer, but lets see, what if I have prefix 4 removed and appended to end.\\nSo the string becomes 001**1011**. And now we try to flip bits to see answer minimum\\n\\t\\t\\t    1) TYPE 1 -> 0101010  (flips required-> 3)\\n\\t\\t\\t\\t2) TYPE 2 -> 1010101  (flips required-> 4)\\n\\nSo, we see, that we DO get some seperate answer. If you still not believe me, try for youself, and see that for any prefix in a string of even length, you will always get the same minimum as answer.\\n\\nCODE-\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();        \\n        vector<int> oddOne(n);\\n        vector<int> evenOne(n);\\n        oddOne[0]=s[0]==\\'1\\' ? 1 : 0;\\n        evenOne[0]=s[0]==\\'1\\' ? 0 : 1;\\n        for(int i=1;i<n;i++){\\n            if(i%2!=0){\\n                oddOne[i]=s[i]==\\'1\\' ? oddOne[i-1] : oddOne[i-1]+1;\\n                evenOne[i]=s[i]==\\'0\\' ? evenOne[i-1] : evenOne[i-1]+1;\\n            }\\n            else{\\n                oddOne[i]=s[i]==\\'0\\' ? oddOne[i-1] : oddOne[i-1]+1;\\n                evenOne[i]=s[i]==\\'1\\' ? evenOne[i-1] : evenOne[i-1]+1;\\n            }\\n        }\\n        if(n%2==0){\\n            return min(oddOne.back(),evenOne.back());\\n        }\\n        \\n        int res=min(oddOne.back(),evenOne.back());\\n        for(int i=0;i<n;i++){\\n            int oneEven=evenOne[i];\\n            int oneOdd=oddOne[n-1]-oddOne[i];  \\n            res=min(res,oneEven+oneOdd);        // 1010101...+0101010...\\n            \\n            oneOdd=oddOne[i];\\n            oneEven=evenOne[n-1]-evenOne[i];  \\n            res=min(res,oneEven+oneOdd);        // 01010101...+10101010...\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n=s.size();        \\n        vector<int> oddOne(n);\\n        vector<int> evenOne(n);\\n        oddOne[0]=s[0]==\\'1\\' ? 1 : 0;\\n        evenOne[0]=s[0]==\\'1\\' ? 0 : 1;\\n        for(int i=1;i<n;i++){\\n            if(i%2!=0){\\n                oddOne[i]=s[i]==\\'1\\' ? oddOne[i-1] : oddOne[i-1]+1;\\n                evenOne[i]=s[i]==\\'0\\' ? evenOne[i-1] : evenOne[i-1]+1;\\n            }\\n            else{\\n                oddOne[i]=s[i]==\\'0\\' ? oddOne[i-1] : oddOne[i-1]+1;\\n                evenOne[i]=s[i]==\\'1\\' ? evenOne[i-1] : evenOne[i-1]+1;\\n            }\\n        }\\n        if(n%2==0){\\n            return min(oddOne.back(),evenOne.back());\\n        }\\n        \\n        int res=min(oddOne.back(),evenOne.back());\\n        for(int i=0;i<n;i++){\\n            int oneEven=evenOne[i];\\n            int oneOdd=oddOne[n-1]-oddOne[i];  \\n            res=min(res,oneEven+oneOdd);        // 1010101...+0101010...\\n            \\n            oneOdd=oddOne[i];\\n            oneEven=evenOne[n-1]-evenOne[i];  \\n            res=min(res,oneEven+oneOdd);        // 01010101...+10101010...\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470397,
                "title": "easy-c-solution-using-prefix-sum",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>p1,p2;\\n    int query(int l,int r,vector<int>&query){\\n        if(l<0||l>=n) return 0;\\n        if(l == 0) return query[r];\\n        return query[r] - query[l-1];\\n    }\\n    int minFlips(string s) {\\n        n = s.size();\\n        p1.resize(n,0);\\n        p2.resize(n,0);\\n        int c1 = 0,c2 = 1;\\n\\n        for(int i = 0;i<s.size();i++,c1 = !c1,c2 = !c2){\\n            int curr = s[i] - \\'0\\';\\n            if(curr!=c1) p1[i]++;\\n            if(curr!=c2) p2[i]++;\\n            if(i>0){\\n                p1[i]+=p1[i-1];\\n                p2[i]+=p2[i-1];\\n            }\\n        }\\n        \\n        /*\\n            odd ,0 p2\\n            odd, 1 p1\\n            even 0 p1\\n            even 1 p2\\n        */\\n        int ans = min(query(0,n-1,p1),query(0,n-1,p2));\\n        for(int i = 0;i<n-1;i++){\\n            int c1,c2;\\n            if((n-i+1)&1){\\n                /*\\n                     010  1\\n                     101  0\\n                     \\n                */\\n                \\n                //for 010 1\\n                if((i+1)&1) {\\n                    c1 = query(i+1,n-1,p2) + query(0,i,p2);\\n                    c2 = query(i+1,n-1,p1) + query(0,i,p1);\\n                }\\n                else{\\n                    c1 = query(i+1,n-1,p1) + query(0,i,p2);\\n                    c2 = query(i+1,n-1,p2) + query(0,i,p1);\\n                }\\n            }\\n            else{\\n                /*\\n                    0101 010\\n                    1010 101\\n                */\\n                if((i+1)&1) {\\n                    c1 = query(i+1,n-1,p2) + query(0,i,p1);\\n                    c2 = query(i+1,n-1,p1) + query(0,i,p2);\\n                }\\n                else{\\n                    c1 = query(i+1,n-1,p1) + query(0,i,p1);\\n                    c2 = query(i+1,n-1,p2) + query(0,i,p2);\\n                }\\n               \\n            }\\n             ans = min(ans,min(c1,c2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>p1,p2;\\n    int query(int l,int r,vector<int>&query){\\n        if(l<0||l>=n) return 0;\\n        if(l == 0) return query[r];\\n        return query[r] - query[l-1];\\n    }\\n    int minFlips(string s) {\\n        n = s.size();\\n        p1.resize(n,0);\\n        p2.resize(n,0);\\n        int c1 = 0,c2 = 1;\\n\\n        for(int i = 0;i<s.size();i++,c1 = !c1,c2 = !c2){\\n            int curr = s[i] - \\'0\\';\\n            if(curr!=c1) p1[i]++;\\n            if(curr!=c2) p2[i]++;\\n            if(i>0){\\n                p1[i]+=p1[i-1];\\n                p2[i]+=p2[i-1];\\n            }\\n        }\\n        \\n        /*\\n            odd ,0 p2\\n            odd, 1 p1\\n            even 0 p1\\n            even 1 p2\\n        */\\n        int ans = min(query(0,n-1,p1),query(0,n-1,p2));\\n        for(int i = 0;i<n-1;i++){\\n            int c1,c2;\\n            if((n-i+1)&1){\\n                /*\\n                     010  1\\n                     101  0\\n                     \\n                */\\n                \\n                //for 010 1\\n                if((i+1)&1) {\\n                    c1 = query(i+1,n-1,p2) + query(0,i,p2);\\n                    c2 = query(i+1,n-1,p1) + query(0,i,p1);\\n                }\\n                else{\\n                    c1 = query(i+1,n-1,p1) + query(0,i,p2);\\n                    c2 = query(i+1,n-1,p2) + query(0,i,p1);\\n                }\\n            }\\n            else{\\n                /*\\n                    0101 010\\n                    1010 101\\n                */\\n                if((i+1)&1) {\\n                    c1 = query(i+1,n-1,p2) + query(0,i,p1);\\n                    c2 = query(i+1,n-1,p1) + query(0,i,p2);\\n                }\\n                else{\\n                    c1 = query(i+1,n-1,p1) + query(0,i,p1);\\n                    c2 = query(i+1,n-1,p2) + query(0,i,p2);\\n                }\\n               \\n            }\\n             ans = min(ans,min(c1,c2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429189,
                "title": "c-solution",
                "content": "```\\nint minFlips(char * s){\\n    int len = strlen(s), idx = 0;\\n    int minOpers = INT_MAX, diff1 = 0, diff2 = 0, l = 0, r = 0;\\n    char *gStr = calloc(1, 2 * len + 1);        // given string\\n    // alternating target string starting with zero\\n    char *zTar = calloc(1, 2 * len + 1);     \\n    // alternating target string starting with one\\n    char *oTar = calloc(1, 2 * len + 1);\\n    \\n    // concatenate all strings to itself\\n    strcat(gStr, s);    strcat(gStr, s);\\n    \\n    for(int i = 0; i < 2 * len; i++) {\\n        zTar[idx] = i % 2 ? \\'1\\' : \\'0\\';\\n        oTar[idx++] = i % 2 ? \\'0\\' : \\'1\\';\\n    }\\n    \\n    while(r < 2 * len) {\\n        // include character differce at right index position\\n        diff1 += gStr[r] != zTar[r] ;\\n        diff2 += gStr[r] != oTar[r] ;\\n        \\n        // decrement left side of window if window len is greater then string length\\n        if (r - l + 1 > len) {      \\n            // exclude character difference if we had considered at left index\\n            if(gStr[l] != zTar[l]) diff1--;\\n            if(gStr[l] != oTar[l]) diff2--;\\n            l++;\\n        }\\n        \\n        // update the result if window size of len\\n        if(r - l + 1 == len) {\\n            // update result with minimum of differences for either of targets\\n            minOpers = fmin(minOpers, fmin(diff1, diff2));\\n        }\\n        \\n        // increment right side of window after every iteration\\n        r++;\\n    }\\n    return minOpers;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minFlips(char * s){\\n    int len = strlen(s), idx = 0;\\n    int minOpers = INT_MAX, diff1 = 0, diff2 = 0, l = 0, r = 0;\\n    char *gStr = calloc(1, 2 * len + 1);        // given string\\n    // alternating target string starting with zero\\n    char *zTar = calloc(1, 2 * len + 1);     \\n    // alternating target string starting with one\\n    char *oTar = calloc(1, 2 * len + 1);\\n    \\n    // concatenate all strings to itself\\n    strcat(gStr, s);    strcat(gStr, s);\\n    \\n    for(int i = 0; i < 2 * len; i++) {\\n        zTar[idx] = i % 2 ? \\'1\\' : \\'0\\';\\n        oTar[idx++] = i % 2 ? \\'0\\' : \\'1\\';\\n    }\\n    \\n    while(r < 2 * len) {\\n        // include character differce at right index position\\n        diff1 += gStr[r] != zTar[r] ;\\n        diff2 += gStr[r] != oTar[r] ;\\n        \\n        // decrement left side of window if window len is greater then string length\\n        if (r - l + 1 > len) {      \\n            // exclude character difference if we had considered at left index\\n            if(gStr[l] != zTar[l]) diff1--;\\n            if(gStr[l] != oTar[l]) diff2--;\\n            l++;\\n        }\\n        \\n        // update the result if window size of len\\n        if(r - l + 1 == len) {\\n            // update result with minimum of differences for either of targets\\n            minOpers = fmin(minOpers, fmin(diff1, diff2));\\n        }\\n        \\n        // increment right side of window after every iteration\\n        r++;\\n    }\\n    return minOpers;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2382730,
                "title": "c-window-seperately-handling-odd-even-length-sequence",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int count = 0;\\n        int a = 1;\\n        int Min = INT_MAX;\\n        int len = s.size();\\n        \\n        for(int i = 0; i < len; i++){\\n            if(s[i]-\\'0\\' != a){ count++;}\\n\\n            a ^= 1;\\n        }\\n        Min = min(Min, count);\\n        \\n        if(len % 2 == 0){\\n            a = 0;\\n            count = 0;\\n            for(int i = 0; i < len; i++){\\n                if(s[i]-\\'0\\' != a){ count++;}\\n\\n                a ^= 1;\\n            }\\n            Min = min(Min, count);\\n        }else{\\n            for(int i = 0; i < 2*len; i++){\\n                if(s[i%len]-\\'0\\' == a){ count--;}\\n                else{ count++;}\\n                a ^= 1;\\n                \\n                Min = min(Min, count);\\n            }\\n        }\\n        return Min;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int count = 0;\\n        int a = 1;\\n        int Min = INT_MAX;\\n        int len = s.size();\\n        \\n        for(int i = 0; i < len; i++){\\n            if(s[i]-\\'0\\' != a){ count++;}\\n\\n            a ^= 1;\\n        }\\n        Min = min(Min, count);\\n        \\n        if(len % 2 == 0){\\n            a = 0;\\n            count = 0;\\n            for(int i = 0; i < len; i++){\\n                if(s[i]-\\'0\\' != a){ count++;}\\n\\n                a ^= 1;\\n            }\\n            Min = min(Min, count);\\n        }else{\\n            for(int i = 0; i < 2*len; i++){\\n                if(s[i%len]-\\'0\\' == a){ count--;}\\n                else{ count++;}\\n                a ^= 1;\\n                \\n                Min = min(Min, count);\\n            }\\n        }\\n        return Min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331644,
                "title": "simple-sliding-window-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans1 = 0,ans2 = 0,ans = n;\\n        s += s;\\n        string s1 = \"\",s2 = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            s1 += (i%2==0) ? \\'0\\' : \\'1\\';\\n            s2 += (i%2==1) ? \\'0\\' : \\'1\\';\\n        }\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            ans1 += (s1[i] != s[i]);\\n            ans2 += (s2[i] != s[i]);\\n            \\n            if(i>=n)\\n            {\\n                ans1 -= (s1[i-n] != s[i-n]);\\n                ans2 -= (s2[i-n] != s[i-n]);\\n            }\\n            \\n            if(i>=(n-1))\\n            {\\n                ans = min({ans,ans1,ans2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        int ans1 = 0,ans2 = 0,ans = n;\\n        s += s;\\n        string s1 = \"\",s2 = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            s1 += (i%2==0) ? \\'0\\' : \\'1\\';\\n            s2 += (i%2==1) ? \\'0\\' : \\'1\\';\\n        }\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            ans1 += (s1[i] != s[i]);\\n            ans2 += (s2[i] != s[i]);\\n            \\n            if(i>=n)\\n            {\\n                ans1 -= (s1[i-n] != s[i-n]);\\n                ans2 -= (s2[i-n] != s[i-n]);\\n            }\\n            \\n            if(i>=(n-1))\\n            {\\n                ans = min({ans,ans1,ans2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311858,
                "title": "time-limit-exceeded-java",
                "content": "I\\'m a very novice programmer but have used java in the past so I decided to start learning/enjoying the challenge of coding problems. I have only just begun therefore my code is certainly not optimized and the algorithm likely isnt either as I don\\'t know all of javas methods and the best way to use them. If anyone could tell me how I could lower run time and better optimize my code the way its written, that would be amazing!\\n\\n```\\n        String s2 = \"\";\\n        int total = 0;\\n\\t\\tint counter = 0;\\n\\t\\tint smallest = s.length();\\n        \\n//Check to see if the given string is already alternating\\n\\t\\tfor (int i = 1; i < s.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (s.charAt(i) != s.charAt(i - 1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n            else\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (counter == s.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tcounter = 0;\\n//check every possible variation of the string using the Type-1 operation. Count the amount of Type-2 operations necessary for it to be alternating with the total.\\n\\t\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\t{\\n\\t\\t\\ts = s.substring(1) + s.charAt(0);\\n\\t\\t\\ts2 = s;\\n\\t\\t\\t\\n\\t\\t\\tfor (int k = 1; k < s.length(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s.charAt(k) == s.charAt(k - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttotal++;\\n\\t\\t\\t\\t\\tif (s.charAt(k) == \\'1\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts = s.substring(0,k) + \\'0\\' + s.substring(k + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts = s.substring(0,k) + \\'1\\' + s.substring(k + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ts = s2;\\n//Check if the current variation requires less Type-2 operations than the smallest one already found.\\n\\t\\t\\tif (total < smallest)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsmallest = total;\\n\\t\\t\\t\\ttotal = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn smallest;\\n```",
                "solutionTags": [],
                "code": "```\\n        String s2 = \"\";\\n        int total = 0;\\n\\t\\tint counter = 0;\\n\\t\\tint smallest = s.length();\\n        \\n//Check to see if the given string is already alternating\\n\\t\\tfor (int i = 1; i < s.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (s.charAt(i) != s.charAt(i - 1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n            else\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (counter == s.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tcounter = 0;\\n//check every possible variation of the string using the Type-1 operation. Count the amount of Type-2 operations necessary for it to be alternating with the total.\\n\\t\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\t{\\n\\t\\t\\ts = s.substring(1) + s.charAt(0);\\n\\t\\t\\ts2 = s;\\n\\t\\t\\t\\n\\t\\t\\tfor (int k = 1; k < s.length(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s.charAt(k) == s.charAt(k - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttotal++;\\n\\t\\t\\t\\t\\tif (s.charAt(k) == \\'1\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts = s.substring(0,k) + \\'0\\' + s.substring(k + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts = s.substring(0,k) + \\'1\\' + s.substring(k + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ts = s2;\\n//Check if the current variation requires less Type-2 operations than the smallest one already found.\\n\\t\\t\\tif (total < smallest)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsmallest = total;\\n\\t\\t\\t\\ttotal = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn smallest;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268441,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n\\n        s = s+s\\n        fip1 = [(\\'0\\' if i%2==0 else \\'1\\') for i in range(len(s))]\\n        fip2 = [(\\'1\\' if i%2==0 else \\'0\\') for i in range(len(s))]\\n        i = 0\\n        min1 = 0\\n        min2 = 0\\n        final = len(s)\\n        for j in range(len(s)):\\n            \\n            if fip1[j]!=(s[j]):\\n                min1+=1\\n            if fip2[j]!= (s[j]):\\n                min2+=1\\n\\n            if (j-i+1) == n:\\n                final = min(final,min1,min2)\\n                if (s[i]) != fip1[i]:\\n                    min1-=1\\n                if (s[i]) != fip2[i]:\\n                    min2-=1\\n                i+=1\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n        n = len(s)\\n\\n        s = s+s\\n        fip1 = [(\\'0\\' if i%2==0 else \\'1\\') for i in range(len(s))]\\n        fip2 = [(\\'1\\' if i%2==0 else \\'0\\') for i in range(len(s))]\\n        i = 0\\n        min1 = 0\\n        min2 = 0\\n        final = len(s)\\n        for j in range(len(s)):\\n            \\n            if fip1[j]!=(s[j]):\\n                min1+=1\\n            if fip2[j]!= (s[j]):\\n                min2+=1\\n\\n            if (j-i+1) == n:\\n                final = min(final,min1,min2)\\n                if (s[i]) != fip1[i]:\\n                    min1-=1\\n                if (s[i]) != fip2[i]:\\n                    min2-=1\\n                i+=1\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215789,
                "title": "c-solution-using-sliding-window",
                "content": "```\\n int minFlips(string s) {\\n        int n=s.length();\\n        s += s;\\n        string s1,s2;\\n        for(int i=0; i<s.length(); i++){\\n            \\n            s1 += i%2 ? \\'0\\':\\'1\\';\\n            s2 += i%2 ? \\'1\\':\\'0\\';\\n        }\\n        int diff1=0 , diff2=0 , ans=INT_MAX;\\n        for(int i=0; i<s.length(); i++){\\n             if(s[i]!=s1[i])\\n                 ++diff1;\\n             if(s[i]!=s2[i])\\n                 ++diff2;\\n            if(i>=n){\\n                if(s[i-n]!=s1[i-n])\\n                  --diff1;\\n                if(s[i-n]!=s2[i-n])\\n                  --diff2;\\n            }\\n            if(i>=n-1)\\n                ans=min({ans,diff1,diff2});\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minFlips(string s) {\\n        int n=s.length();\\n        s += s;\\n        string s1,s2;\\n        for(int i=0; i<s.length(); i++){\\n            \\n            s1 += i%2 ? \\'0\\':\\'1\\';\\n            s2 += i%2 ? \\'1\\':\\'0\\';\\n        }\\n        int diff1=0 , diff2=0 , ans=INT_MAX;\\n        for(int i=0; i<s.length(); i++){\\n             if(s[i]!=s1[i])\\n                 ++diff1;\\n             if(s[i]!=s2[i])\\n                 ++diff2;\\n            if(i>=n){\\n                if(s[i-n]!=s1[i-n])\\n                  --diff1;\\n                if(s[i-n]!=s2[i-n])\\n                  --diff2;\\n            }\\n            if(i>=n-1)\\n                ans=min({ans,diff1,diff2});\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159187,
                "title": "c-slide-window-to-count-difference",
                "content": "```\\n//firslty double the string  s+=s, then use a slide window to get the minimum difference between s and two reference strings  (speed >97%)\\n//for example the original string is \"1011001\"\\n//1. double it to make it as  \"10110011011001\"\\n//2. slide window compare it to  \"10101010101010\" & \"01010101010101\" to find out the minimum differences count\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        \\n        string s1(n*2, \\'0\\'), s2(n*2, \\'0\\');\\n        for (int i = 0; i< 2*n; i+=2) s1[i] = \\'1\\';\\n        for (int i = 1; i< 2*n; i+=2) s2[i] = \\'1\\';\\n\\n        return min(minDiff(n, s, s1), minDiff(n, s, s2));\\n    }\\n\\n    int minDiff(int n, string& s, string& v) {\\n        int minCount(INT_MAX),diffCount(0);\\n        for (int i = 0; i <n; ++i)  \\n\\t\\t   diffCount+= s[i] != v[i];\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            diffCount += ( s[i + n-1] != v[i + n-1])  - (s[i-1] != v[i-1]);\\n            minCount = min(minCount, diffCount);\\n        }\\n        \\n        return minCount;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//firslty double the string  s+=s, then use a slide window to get the minimum difference between s and two reference strings  (speed >97%)\\n//for example the original string is \"1011001\"\\n//1. double it to make it as  \"10110011011001\"\\n//2. slide window compare it to  \"10101010101010\" & \"01010101010101\" to find out the minimum differences count\\n\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.size();\\n        s += s;\\n        \\n        string s1(n*2, \\'0\\'), s2(n*2, \\'0\\');\\n        for (int i = 0; i< 2*n; i+=2) s1[i] = \\'1\\';\\n        for (int i = 1; i< 2*n; i+=2) s2[i] = \\'1\\';\\n\\n        return min(minDiff(n, s, s1), minDiff(n, s, s2));\\n    }\\n\\n    int minDiff(int n, string& s, string& v) {\\n        int minCount(INT_MAX),diffCount(0);\\n        for (int i = 0; i <n; ++i)  \\n\\t\\t   diffCount+= s[i] != v[i];\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            diffCount += ( s[i + n-1] != v[i + n-1])  - (s[i-1] != v[i-1]);\\n            minCount = min(minCount, diffCount);\\n        }\\n        \\n        return minCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116049,
                "title": "two-pointer-and-sliding-window-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int len = s.size();\\n        s = s+s;\\n        // sliding window to check 01010.../10101... pattern of size len\\n        int evenZero=0, oddZero=0;\\n        int evenOne=0,  oddOne=0;\\n        int res = len;\\n        \\n        for(int i=0; i<len*2; i++){\\n            if(s[i]==\\'0\\'){\\n                if(i%2) oddZero++;\\n                else evenZero++;\\n            }else{  // 1\\n                if(i%2) oddOne++;\\n                else evenOne++;\\n            }\\n            // shrink to size of len and calculate the flip count\\n            if(i>=len){\\n                char preC = s[i-len];\\n                if(preC ==\\'0\\'){\\n                    if((i-len)%2) oddZero--;\\n                    else evenZero--;\\n                }else{ // 1\\n                    if((i-len)%2) oddOne--;\\n                    else evenOne--;\\n                }\\n            }\\n            \\n            //calculate curFlip\\n            if(i<(len-1)) continue;\\n            res = min(res, evenZero+oddOne);  // 010101.... for s starting at even index or 10101.... for s starting at odd index\\n            res = min(res, oddZero+evenOne);  // 101010.... for s starting at even index or 01010.... for s starting at odd index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int len = s.size();\\n        s = s+s;\\n        // sliding window to check 01010.../10101... pattern of size len\\n        int evenZero=0, oddZero=0;\\n        int evenOne=0,  oddOne=0;\\n        int res = len;\\n        \\n        for(int i=0; i<len*2; i++){\\n            if(s[i]==\\'0\\'){\\n                if(i%2) oddZero++;\\n                else evenZero++;\\n            }else{  // 1\\n                if(i%2) oddOne++;\\n                else evenOne++;\\n            }\\n            // shrink to size of len and calculate the flip count\\n            if(i>=len){\\n                char preC = s[i-len];\\n                if(preC ==\\'0\\'){\\n                    if((i-len)%2) oddZero--;\\n                    else evenZero--;\\n                }else{ // 1\\n                    if((i-len)%2) oddOne--;\\n                    else evenOne--;\\n                }\\n            }\\n            \\n            //calculate curFlip\\n            if(i<(len-1)) continue;\\n            res = min(res, evenZero+oddOne);  // 010101.... for s starting at even index or 10101.... for s starting at odd index\\n            res = min(res, oddZero+evenOne);  // 101010.... for s starting at even index or 01010.... for s starting at odd index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059398,
                "title": "concise-python-code",
                "content": "```\\nclass Solution:\\n  def minFlips(self, s: str) -> int:\\n    len_s = len(s)\\n    odd_len = len_s % 2 == 1\\n    diff_01, diff_10 = 0, 0\\n    ret = len_s\\n    status_01 = \"01\"\\n\\n    for p in range(2 * len_s):\\n      ch = s[p % len_s]\\n      ch_01 = status_01[p % 2]\\n      if ch != ch_01:\\n        diff_01 += 1\\n      else:\\n        diff_10 += 1\\n\\n      if p > len_s - 1 and odd_len:\\n        if ch == ch_01:\\n          diff_01 -= 1\\n        else:\\n          diff_10 -= 1\\n\\n      # print(f\"p = {p}, diff_01={diff_01}, diff_10={diff_10}\")\\n      if p >= len_s - 1:\\n        ret = min(ret, diff_01, diff_10)\\n        \\n    return ret\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def minFlips(self, s: str) -> int:\\n    len_s = len(s)\\n    odd_len = len_s % 2 == 1\\n    diff_01, diff_10 = 0, 0\\n    ret = len_s\\n    status_01 = \"01\"\\n\\n    for p in range(2 * len_s):\\n      ch = s[p % len_s]\\n      ch_01 = status_01[p % 2]\\n      if ch != ch_01:\\n        diff_01 += 1\\n      else:\\n        diff_10 += 1\\n\\n      if p > len_s - 1 and odd_len:\\n        if ch == ch_01:\\n          diff_01 -= 1\\n        else:\\n          diff_10 -= 1\\n\\n      # print(f\"p = {p}, diff_01={diff_01}, diff_10={diff_10}\")\\n      if p >= len_s - 1:\\n        ret = min(ret, diff_01, diff_10)\\n        \\n    return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055644,
                "title": "c-shifting-faster-than-93-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        \\n        int n=s.length();\\n        int even0=0, even1=0, odd0=0, odd1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                if(i&1) odd1++;\\n                else even1++;\\n            }\\n            else\\n            {\\n                if(i&1) odd0++;\\n                else even0++;\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans, min(n-(even1+odd0), n-(odd1+even0)));\\n            //rotate and update counts\\n            //first index is even\\n            if(s[i]==\\'1\\')\\n            {\\n                even1--;\\n                swap(even1,odd1);\\n                swap(even0,odd0);\\n                if(n&1) even1++;\\n                else odd1++;\\n            }\\n            else\\n            {\\n                even0--;\\n                swap(even1,odd1);\\n                swap(even0,odd0);\\n                if(n&1) even0++;\\n                else odd0++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        \\n        int n=s.length();\\n        int even0=0, even1=0, odd0=0, odd1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                if(i&1) odd1++;\\n                else even1++;\\n            }\\n            else\\n            {\\n                if(i&1) odd0++;\\n                else even0++;\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans, min(n-(even1+odd0), n-(odd1+even0)));\\n            //rotate and update counts\\n            //first index is even\\n            if(s[i]==\\'1\\')\\n            {\\n                even1--;\\n                swap(even1,odd1);\\n                swap(even0,odd0);\\n                if(n&1) even1++;\\n                else odd1++;\\n            }\\n            else\\n            {\\n                even0--;\\n                swap(even1,odd1);\\n                swap(even0,odd0);\\n                if(n&1) even0++;\\n                else odd0++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043331,
                "title": "python-left-and-right-preprocessing-intuitive-approach",
                "content": "The approach is to\\n(1) to consider each position i for possible rotation;\\n(2) precompute the operations for left and right parts to be 01 or 10;\\n(3) merge the two parts;\\n(4) corner case is that no rotation necessary.\\n\\n```\\ndef minFlips(self, s: str) -> int:\\n        n=len(s)\\n        left01=[0]*n\\n        left10=[0]*n\\n        right10=[0]*n\\n        right01=[0]*n\\n        ctleft01=0\\n        ctleft10=0\\n        ctright01=0\\n        ctright10=0\\n        for i,c in enumerate(s):\\n            if (i%2==0 and c==\\'1\\') or (i%2==1 and c==\\'0\\'):\\n                ctleft01+=1\\n            if (i%2==0 and c==\\'0\\') or (i%2==1 and c==\\'1\\'):\\n                ctleft10+=1\\n            left01[i]=ctleft01\\n            left10[i]=ctleft10\\n        for i in range(n-1,-1,-1):\\n            j=n-1-i\\n            if (j%2==0 and s[i]==\\'1\\') or (j%2==1 and s[i]==\\'0\\'):\\n                ctright01+=1\\n            if (j%2==0 and s[i]==\\'0\\') or (j%2==1 and s[i]==\\'1\\'):\\n                ctright10+=1\\n            right01[i]=ctright01\\n            right10[i]=ctright10\\n            \\n        res=n\\n        for i in range(n-1):\\n            res=min(res, left01[i]+right10[i+1], left10[i]+right01[i+1])\\n        res=min(res, left01[n-1], left10[n-1])    \\n        return res",
                "solutionTags": [],
                "code": "The approach is to\\n(1) to consider each position i for possible rotation;\\n(2) precompute the operations for left and right parts to be 01 or 10;\\n(3) merge the two parts;\\n(4) corner case is that no rotation necessary.\\n\\n```\\ndef minFlips(self, s: str) -> int:\\n        n=len(s)\\n        left01=[0]*n\\n        left10=[0]*n\\n        right10=[0]*n\\n        right01=[0]*n\\n        ctleft01=0\\n        ctleft10=0\\n        ctright01=0\\n        ctright10=0\\n        for i,c in enumerate(s):\\n            if (i%2==0 and c==\\'1\\') or (i%2==1 and c==\\'0\\'):\\n                ctleft01+=1\\n            if (i%2==0 and c==\\'0\\') or (i%2==1 and c==\\'1\\'):\\n                ctleft10+=1\\n            left01[i]=ctleft01\\n            left10[i]=ctleft10\\n        for i in range(n-1,-1,-1):\\n            j=n-1-i\\n            if (j%2==0 and s[i]==\\'1\\') or (j%2==1 and s[i]==\\'0\\'):\\n                ctright01+=1\\n            if (j%2==0 and s[i]==\\'0\\') or (j%2==1 and s[i]==\\'1\\'):\\n                ctright10+=1\\n            right01[i]=ctright01\\n            right10[i]=ctright10\\n            \\n        res=n\\n        for i in range(n-1):\\n            res=min(res, left01[i]+right10[i+1], left10[i]+right01[i+1])\\n        res=min(res, left01[n-1], left10[n-1])    \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1998768,
                "title": "my-ghetto-java-solution",
                "content": "May not be elegant but it works \\uD83D\\uDE09\\n\\n```\\nclass Solution {\\n    public int minFlips(String s) {\\n      final int n = s.length();\\n      final int totalOdd = n/2;\\n      final int totalEven = totalOdd + (n % 2);\\n      int onesInEven = 0;\\n      int onesInOdd = 0;\\n\\n      for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'0\\') {\\n          continue;\\n        }\\n\\n        if (i % 2 == 0) {\\n          // Even\\n          onesInEven++;\\n        } else {\\n          // Odd\\n          onesInOdd++;\\n        }\\n      }\\n\\n      int flipsForOneInEven = (totalEven - onesInEven) + onesInOdd;\\n      int flipsForOneInOdd = (totalOdd - onesInOdd) + onesInEven;\\n      int min = Math.min(flipsForOneInEven, flipsForOneInOdd);\\n\\n      if (n%2 == 0 || min == 0) {\\n        return min;\\n      }\\n\\n      int temp, tempMin;\\n\\n      for (int i=0; i < n-1; i++) {\\n        char c = s.charAt(i);\\n\\n        temp = onesInEven;\\n        onesInEven = onesInOdd;\\n        onesInOdd = temp;\\n\\n        if (c == \\'1\\') {\\n          onesInEven++;\\n          onesInOdd--;\\n        }\\n\\n        flipsForOneInEven = (totalEven - onesInEven) + onesInOdd;\\n        flipsForOneInOdd = (totalOdd - onesInOdd) + onesInEven;\\n        tempMin = Math.min(flipsForOneInEven, flipsForOneInOdd);\\n        \\n        if (tempMin == 0) {\\n          return 0;\\n        }\\n        \\n        if (tempMin < min) {\\n          min = tempMin;\\n        }\\n      }\\n\\n      return min;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String s) {\\n      final int n = s.length();\\n      final int totalOdd = n/2;\\n      final int totalEven = totalOdd + (n % 2);\\n      int onesInEven = 0;\\n      int onesInOdd = 0;\\n\\n      for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'0\\') {\\n          continue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1942414,
                "title": "scala",
                "content": "```\\nobject Solution {\\n    def diff(source: String, dest: String, destStartIdx: Int): Int = {\\n        Range(destStartIdx,source.length + destStartIdx).filter { i => source(i-destStartIdx) != dest(i) }.size\\n    }\\n    \\n    def minFlips(s: String): Int = {\\n        // 11010\\n        // 10101\\n        val ss = s ++ s\\n        val startWithZero = (s.zipWithIndex.foldLeft(new StringBuilder()){ case(acc, (elem,i)) => \\n            if((i & 1) == 0)\\n                acc += \\'0\\'\\n            else\\n                acc += \\'1\\'\\n            \\n            acc\\n        }).result\\n        var startWithOne = (s.zipWithIndex.foldLeft(new StringBuilder()){ case(acc, (elem,i)) => \\n            if((i & 1) == 0)\\n                acc += \\'1\\'\\n            else\\n                acc += \\'0\\'\\n            \\n            acc\\n        }).result\\n        \\n        var countStartWithZero = diff(startWithZero, ss, 0)\\n        var countStartWithOne = diff(startWithOne, ss, 0)\\n        \\n        var ans = countStartWithZero min countStartWithOne\\n        for(i <- s.length until ss.length) {\\n            val tmp = countStartWithZero\\n            countStartWithZero = countStartWithOne\\n            countStartWithOne = tmp\\n            \\n            if(ss(i-s.length) != \\'1\\') {\\n                countStartWithZero -= 1\\n            } else {\\n                countStartWithOne -= 1\\n            }\\n            \\n            if((s.length & 1) == 0) {\\n                if(ss(i) != \\'1\\') {\\n                    countStartWithZero += 1\\n                } else {\\n                    countStartWithOne += 1\\n                }\\n            } else {\\n                if(ss(i) != \\'0\\') {\\n                    countStartWithZero += 1\\n                } else {\\n                    countStartWithOne += 1\\n                }\\n            }\\n            \\n            ans = ans min countStartWithZero min countStartWithOne\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def diff(source: String, dest: String, destStartIdx: Int): Int = {\\n        Range(destStartIdx,source.length + destStartIdx).filter { i => source(i-destStartIdx) != dest(i) }.size\\n    }\\n    \\n    def minFlips(s: String): Int = {\\n        // 11010\\n        // 10101\\n        val ss = s ++ s\\n        val startWithZero = (s.zipWithIndex.foldLeft(new StringBuilder()){ case(acc, (elem,i)) => \\n            if((i & 1) == 0)\\n                acc += \\'0\\'\\n            else\\n                acc += \\'1\\'\\n            \\n            acc\\n        }).result\\n        var startWithOne = (s.zipWithIndex.foldLeft(new StringBuilder()){ case(acc, (elem,i)) => \\n            if((i & 1) == 0)\\n                acc += \\'1\\'\\n            else\\n                acc += \\'0\\'\\n            \\n            acc\\n        }).result\\n        \\n        var countStartWithZero = diff(startWithZero, ss, 0)\\n        var countStartWithOne = diff(startWithOne, ss, 0)\\n        \\n        var ans = countStartWithZero min countStartWithOne\\n        for(i <- s.length until ss.length) {\\n            val tmp = countStartWithZero\\n            countStartWithZero = countStartWithOne\\n            countStartWithOne = tmp\\n            \\n            if(ss(i-s.length) != \\'1\\') {\\n                countStartWithZero -= 1\\n            } else {\\n                countStartWithOne -= 1\\n            }\\n            \\n            if((s.length & 1) == 0) {\\n                if(ss(i) != \\'1\\') {\\n                    countStartWithZero += 1\\n                } else {\\n                    countStartWithOne += 1\\n                }\\n            } else {\\n                if(ss(i) != \\'0\\') {\\n                    countStartWithZero += 1\\n                } else {\\n                    countStartWithOne += 1\\n                }\\n            }\\n            \\n            ans = ans min countStartWithZero min countStartWithOne\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1858622,
                "title": "c-faster-than-95",
                "content": "Comparing original string with \"0101010101....\" series or \"101010101010101010....\" series.\\nmin diff with either of series is our answer.\\n\\nFirst series contains 0 in even position and 1 on odd position (position starting with zero) and vice versa for second series.\\n\\nif n is even we just to look at whole string once because in even case if we pull some chars from start and append in end it doesn\\'t change what chars we are comparing with because series are repeating sequences.\\n\\nOnly in case if n is odd we need to check this part.\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.length();\\n        \\n        int diff1 = 0, diff2 = 0;\\n        \\n        if (n&1) s = s+s;\\n        \\n        int ws = 0;\\n        int result = INT_MAX;\\n        for (int we = 0; we < s.length(); ++we) {\\n            if ((s[we] ==\\'1\\') ^ (we&1)) {\\n                diff1++;\\n            } else {\\n                diff2++;\\n            }\\n            \\n            if (we - ws + 1 == n) {\\n                result = min(result, min(diff1, diff2));\\n                if (result == 0) break;\\n                if ((s[ws] ==\\'1\\') ^ (ws&1)) {\\n                    diff1--;\\n                } else {\\n                    diff2--;\\n                }\\n                ws++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int n = s.length();\\n        \\n        int diff1 = 0, diff2 = 0;\\n        \\n        if (n&1) s = s+s;\\n        \\n        int ws = 0;\\n        int result = INT_MAX;\\n        for (int we = 0; we < s.length(); ++we) {\\n            if ((s[we] ==\\'1\\') ^ (we&1)) {\\n                diff1++;\\n            } else {\\n                diff2++;\\n            }\\n            \\n            if (we - ws + 1 == n) {\\n                result = min(result, min(diff1, diff2));\\n                if (result == 0) break;\\n                if ((s[ws] ==\\'1\\') ^ (ws&1)) {\\n                    diff1--;\\n                } else {\\n                    diff2--;\\n                }\\n                ws++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849893,
                "title": "simple-rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_flips(s: String) -> i32 {\\n        let mut map = vec![vec![0; s.len() + 1], vec![0; s.len() + 1]];\\n        let bytes = s.as_bytes();\\n        for idx in 0..2 {\\n            let c = if idx == 0 { \\'0\\' } else { \\'1\\' };\\n            let rev_c = if idx == 0 { \\'1\\' } else { \\'0\\' };\\n            let mut cnt = 0;\\n            for i in 0..bytes.len() {\\n                let d = if i % 2 == 0 { c } else { rev_c } as u8;\\n                cnt += if bytes[i] == d { 0 } else { 1 };\\n                map[idx as usize][i + 1] = cnt;\\n            }\\n        }\\n\\n        (0..s.len())\\n            .map(|idx| {\\n                let rev = idx % 2 != s.len() % 2;\\n                vec![0, 1]\\n                    .iter()\\n                    .map(|c| {\\n                        let rev_c = 1 - *c;\\n                        let d = if rev { rev_c } else { *c };\\n                        if idx % 2 == 0 {\\n                            map[*c][s.len()] - map[*c][idx] + map[d][idx]\\n                        } else {\\n                            map[rev_c][s.len()] - map[rev_c][idx] + map[d][idx]\\n                        }\\n                    })\\n                    .min()\\n                    .unwrap()\\n            })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_flips(s: String) -> i32 {\\n        let mut map = vec![vec![0; s.len() + 1], vec![0; s.len() + 1]];\\n        let bytes = s.as_bytes();\\n        for idx in 0..2 {\\n            let c = if idx == 0 { \\'0\\' } else { \\'1\\' };\\n            let rev_c = if idx == 0 { \\'1\\' } else { \\'0\\' };\\n            let mut cnt = 0;\\n            for i in 0..bytes.len() {\\n                let d = if i % 2 == 0 { c } else { rev_c } as u8;\\n                cnt += if bytes[i] == d { 0 } else { 1 };\\n                map[idx as usize][i + 1] = cnt;\\n            }\\n        }\\n\\n        (0..s.len())\\n            .map(|idx| {\\n                let rev = idx % 2 != s.len() % 2;\\n                vec![0, 1]\\n                    .iter()\\n                    .map(|c| {\\n                        let rev_c = 1 - *c;\\n                        let d = if rev { rev_c } else { *c };\\n                        if idx % 2 == 0 {\\n                            map[*c][s.len()] - map[*c][idx] + map[d][idx]\\n                        } else {\\n                            map[rev_c][s.len()] - map[rev_c][idx] + map[d][idx]\\n                        }\\n                    })\\n                    .min()\\n                    .unwrap()\\n            })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845026,
                "title": "python-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n\\t\\n        alt1 = \"\"\\n        alt2 = \"\"\\n        val1, val2 = \"0\", \"1\"\\n        s = s * 2\\n        # Lets create two alternating strings. These are the strings we want our input string to be like.\\n        for _ in range(len(s)):\\n            alt1 += val1\\n            alt2 += val2\\n            val1, val2 = val2, val1\\n        # alt1 and alt2 will be something like this \"0101010101\" and \"1010101010\". The length of alt1 and alt2 will \\n        # be double the length of the string s.\\n\\n        # Now lets count the differences between our alternating strings (alt1 and alt2) separately and the input string(s)\\n        count1 = 0\\n        count2 = 0\\n        for i in range(len(s) // 2):\\n            if s[i] != alt1[i]:\\n                count1 += 1\\n            if s[i] != alt2[i]:\\n                count2 += 1\\n            minValue = min(count1, count2)\\n        \\n        # For the second half of the alternating string, we see the differences. \\n        # Instead of removing from the front and appending it, we slide the window (of length len(s)).\\n        sz = len(s)\\n        hsz = sz // 2\\n        for i in range(hsz, sz):\\n            # If the appended character was different, add 1 to count1\\n            if s[i] != alt1[i]:\\n                count1 += 1\\n            # If the character that we hypothetically popped was different, then we remove 1 from count1\\n            if s[i - hsz] != alt1[i - hsz]:\\n                count1 -= 1\\n            \\n            # Do the same as above with the second alternating string\\n            if s[i] != alt2[i]:\\n                count2 += 1\\n            if s[i - hsz] != alt2[i - hsz]:\\n                count2 -= 1\\n            # We use minValue as well because our input string has a posibility of already being alternating without modification\\n            minValue = min(minValue, count1, count2)\\n        \\n        return minValue\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, s: str) -> int:\\n\\t\\n        alt1 = \"\"\\n        alt2 = \"\"\\n        val1, val2 = \"0\", \"1\"\\n        s = s * 2\\n        # Lets create two alternating strings. These are the strings we want our input string to be like.\\n        for _ in range(len(s)):\\n            alt1 += val1\\n            alt2 += val2\\n            val1, val2 = val2, val1\\n        # alt1 and alt2 will be something like this \"0101010101\" and \"1010101010\". The length of alt1 and alt2 will \\n        # be double the length of the string s.\\n\\n        # Now lets count the differences between our alternating strings (alt1 and alt2) separately and the input string(s)\\n        count1 = 0\\n        count2 = 0\\n        for i in range(len(s) // 2):\\n            if s[i] != alt1[i]:\\n                count1 += 1\\n            if s[i] != alt2[i]:\\n                count2 += 1\\n            minValue = min(count1, count2)\\n        \\n        # For the second half of the alternating string, we see the differences. \\n        # Instead of removing from the front and appending it, we slide the window (of length len(s)).\\n        sz = len(s)\\n        hsz = sz // 2\\n        for i in range(hsz, sz):\\n            # If the appended character was different, add 1 to count1\\n            if s[i] != alt1[i]:\\n                count1 += 1\\n            # If the character that we hypothetically popped was different, then we remove 1 from count1\\n            if s[i - hsz] != alt1[i - hsz]:\\n                count1 -= 1\\n            \\n            # Do the same as above with the second alternating string\\n            if s[i] != alt2[i]:\\n                count2 += 1\\n            if s[i - hsz] != alt2[i - hsz]:\\n                count2 -= 1\\n            # We use minValue as well because our input string has a posibility of already being alternating without modification\\n            minValue = min(minValue, count1, count2)\\n        \\n        return minValue\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1875883,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            },
            {
                "id": 1729890,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            },
            {
                "id": 1768976,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            },
            {
                "id": 1942821,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            },
            {
                "id": 2003585,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            },
            {
                "id": 1967320,
                "content": [
                    {
                        "username": "feinsteinalex7",
                        "content": "Is it just me or should this be hard?"
                    },
                    {
                        "username": "RedHessian",
                        "content": "With the hints it\\'s pretty intuitive, and also it doesn\\'t require any tricks with data structures"
                    },
                    {
                        "username": "tanvirpirjada",
                        "content": "01001001101   can anyone tell me how this inpute take only two flips ????????"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@mohan9814](/mohan9814) We don\\'t have to count no of operation 1"
                    },
                    {
                        "username": "mohan9814",
                        "content": "[@achalk14](/achalk14) then in total 5 operations have been performed\\n"
                    },
                    {
                        "username": "achalk14",
                        "content": "Operation 1 applied 3 times will make it 01001101010, then\\nOperation 2 applied 2 times will make it 01010101010"
                    },
                    {
                        "username": "abhinav415",
                        "content": "Hints are really good. They give good insight into the problem"
                    },
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard\\n"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain to me what the hints are trying to hint? not even able to understand hints"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Without hint, it\\'s definitely a hard problem"
                    }
                ]
            }
        ]
    }
]