[
    {
        "title": "Restore IP Addresses",
        "question_content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\n\tFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\n\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 20\n\ts consists of digits only.",
        "solutions": [
            {
                "id": 30972,
                "title": "who-can-beat-this-code",
                "content": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "solutionTags": [],
                "code": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 30949,
                "title": "my-code-in-java",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        public boolean isValid(String s){\\n            if(s.length()>3 || s.length()==0 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255)\\n                return false;\\n            return true;\\n        }\\n    }\\n\\n3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.\\nIn isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the string's length is longer than 1 and the first letter is '0' then it's invalid; or the string whose integer representation greater than 255 is invalid.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30944,
                "title": "very-simple-dfs-solution",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31140,
                "title": "python-easy-to-understand-solution-backtracking",
                "content": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079368,
                "title": "c-easy-solution-iterative-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3079183,
                "title": "easy-explanation-with-video-and-pics-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-21 at 6.45.12 AM.png](https://assets.leetcode.com/users/images/a62d9067-6cbb-417d-8f3f-bf9fb150d0d1_1674263738.058996.png)\\n\\nLets take a very simple scenario where we insert just one dot.\\nQuick Observation: The length of the string can be 1, 2 or 3 as the range is 0,255.\\n\\nOnce the function has inserted the dot it will verify if the string is valid or not, in the above example 355 is not valid, so we can discard it.\\n\\nHowever we have one more invalid case i.e 3.555 The approach we can use here is though we are inserting one dot we will make it to insert 2 dots so that the same function will check the validitity of the second part and remove the last dot from ans.\\n\\nThe same approach goes for 3 dots, at each step add a dot --> generate valid answers and pass it down again. \\n\\n![Screenshot 2023-01-21 at 6.51.38 AM.png](https://assets.leetcode.com/users/images/b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse an additional input to the function that is index, which says the function where the string starts from, it is as good as forgetting the already dotted part of the string.\\n\\n\\nAdditional Improvement: Check if the string length is greater than 12, than its completely invalid, Similarly if already 2 dots inserted and the remaining string length is 7 its invalid as well.\\n\\nhttps://youtu.be/h2HmKNdmZ_c\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/15fbfe1e-a57a-475a-a229-a438ed3f1672_1674264427.05538.webp)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079269,
                "title": "beats-100-0ms-easy-solution-fully-explained-c-python3-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\\n# Intuition\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can\\'t be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30998,
                "title": "my-concise-ac-java-code",
                "content": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [],
                "code": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31098,
                "title": "easy-java-code-of-backtracking-within-16-lines",
                "content": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079133,
                "title": "python3-backtracking-for-beginners",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\nWe have no other choices but to generate **all** possible valid IP **addresses** as the problem asked, backtracking is a good candidate.\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\\n\\n**For this problem**, we want to build all valid IP addresses one by one (Brute Force). So we do a recursive call on each state. \\n - State is defined as the position ```i``` in ```s``` we are currently visiting and the address we have previously build.\\n - If ```i == len(s)```, we have reached to the end of ```s```, and no more state can be generated. We check if the current ```address``` we build is of exactly four numbers, and add it to the result if it is.\\n - Now, at each position ```i```, we have at most two choices, and we need to check for each option to see if it will result in a valid address.\\n    (1) Add the current digit to the last number in ```address``` if the last number is not 0 (No leading zero) and the concatenated number is <= 255.\\n    (2) Add the current digit in ```address``` as a new number if ```address``` contains less than 4 numbers.\\n - We start the backtracking process by using the first digit in ```s``` as the first number in ```address```.\\n - I used intgers in the address I\\'m building for easier comparing and concatenation.\\n\\n**Code with comments**\\n\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Code with no comments**\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n05/20/2023, Third time I see this question, here is what I did in 10 min:\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\n```i```\n```s```\n```i == len(s)```\n```s```\n```address```\n```i```\n```address```\n```address```\n```address```\n```s```\n```address```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31151,
                "title": "share-0ms-neat-and-clear-c-solution-using-dfs",
                "content": "    class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }\\n        void dfs(string s,int start,int step,string ip,vector<string>& result){\\n            if(start==s.size()&&step==4){\\n                ip.erase(ip.end()-1); //remove the last '.' from the last decimal number\\n                result.push_back(ip);\\n                return;\\n            }\\n            if(s.size()-start>(4-step)*3) return;\\n            if(s.size()-start<(4-step)) return;\\n            int num=0;\\n            for(int i=start;i<start+3;i++){\\n                num=num*10+(s[i]-'0');\\n                if(num<=255){\\n                    ip+=s[i];\\n                    dfs(s,i+1,step+1,ip+'.',result);\\n                }\\n                if(num==0) break;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1272225,
                "title": "easy-to-understand-backtracking-c-with-comments",
                "content": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }\\n    \\n    void recur(int i, int dots, string temp, vector<string>& ans, string s)\\n    {\\n\\t\\t// we have to place 3 dots in the string to make 4 partitions\\n\\t\\t\\n        if(dots==3)\\n        {\\n           // pushing last partition after checking its validity\\n\\t\\t\\t\\t\\n            if(isValid(s.substr(i)))\\n            {\\n           \\n                ans.push_back(temp+s.substr(i));\\n                \\n            }\\n            return;\\n        }\\n\\t\\t\\n        // placing the dot at every valid position\\n\\t\\t\\n        for(int j=i; j<s.size() ;j++)\\n        {\\n\\n\\t\\tif( isValid(s.substr(i, j-i+1)))\\n\\t\\t{\\n\\t\\t\\ttemp.push_back(s[j]);\\n\\t\\t\\ttemp.push_back(\\'.\\');\\n\\n\\t\\t\\trecur(j+1, dots+1, temp, ans, s);\\n\\n\\t\\t   // removing the dot after calling recur function \\n\\n\\t\\t   // note that we don\\'t remove the last digit that was placed in temp string as we just have to change positions of dots only and not digits in string\\n\\t\\t\\ttemp.pop_back();\\n\\n\\n            }\\n        }\\n        \\n        return;\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        vector<string> ans;\\n        \\n        if(s.size()<4) return ans;\\n        \\n        recur(0, 0, \"\", ans, s);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }",
                "codeTag": "Java"
            },
            {
                "id": 3079573,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This code defines a class called \"Solution\" that contains a single public method called \"`restoreIpAddresses`\". This method takes a single input, a string called \"s\", and returns a list of strings.\\n\\n2. The method first initializes two lists, \"`addresses`\" and \"`address`\". \"addresses\" will ultimately hold all of the valid IP addresses that can be created from the input string \"s\", and \"address\" is a temporary list used to store each individual segment of an IP address (i.e., the four numbers that make up an IP address) as the code generates them.\\n\\n3. The method then calls a private helper function called \"`rec`\". This function takes four inputs: the input string \"s\", an integer \"i\" that keeps track of the current position in the string, the \"address\" list, and the \"addresses\" list.\\n\\n4. The function starts by checking if the \"address\" list has a size of 4. If it does, this means that all four segments of the IP address have been generated and it checks if i is equal to the length of the input string. If both of these conditions are true, it means that all of the characters in the input string have been used to generate a valid IP address, so the function converts the \"address\" list to a string and adds it to the \"addresses\" list.\\n\\n5. If the \"address\" list does not have a size of 4, the function enters a loop. The loop iterates from i+1 to i+3 (or until it reaches the end of the input string) and for each iteration, it creates a new string called \"nextInt\" which is a substring of the input string \"s\" starting from index i and ending at index j. Then it checks if the integer value of nextInt is less than or equal to 255 and either nextInt is equal to \"0\" or it doesn\\'t start with \"0\", then it adds this nextInt to the \"address\" list and recursively calls the function with updated inputs. After this call, it removes the last element of \"address\" list.\\n\\n6. This process continues until the function generates all possible valid IP addresses from the input string. The final list of valid IP addresses is returned by the \"restoreIpAddresses\" method.\\n\\n# Code\\n```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31113,
                "title": "java-recursive-backtracking-easy-to-read",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31184,
                "title": "beautiful-c-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }\\n        \\n    private:\\n        void backtracking(string s, int start, int part)\\n        {\\n            if(start == s.size() && part == 4)\\n            {\\n                result.push_back(solution);\\n                return;\\n            }\\n            \\n            for(int i = start; i < s.size(); i++)\\n            {\\n                if(part < 4 && i-start < 3 && validIP(s, start, i))\\n                {\\n                    solution.append(s.substr(start, i-start+1));\\n                    part++;\\n                    if(part < 4) solution.push_back('.');\\n    \\n                    backtracking(s, i+1, part);\\n                    \\n                    if(part < 4) solution.pop_back();\\n                    part--;\\n                    for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n                }\\n            }\\n        }\\n        \\n        bool validIP(string s, int start, int end)\\n        {\\n            string temp = s.substr(start, end-start+1);\\n            int ip = stoll(temp);\\n            \\n            if(s[start] == '0' && start != end) return false;\\n            else if(ip >= 0 && ip <= 255) return true;\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3079263,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3079377,
                "title": "clean-codes-full-explanation-recursion-c-java-python3",
                "content": "# Exaplanation to Approach :\\n1. The main idea to solve this problem is to use Recursion.\\n2. Consider every position of the input string and, there exist two possible cases:\\n    - Place a dot over the current position.\\n    - Take this character, i.e don\\u2019t place the dot over this position.\\n3. At every step of the recursion, we have the following data:\\n    - curr stores the string between two dots.\\n    - res stores the possible IP Address.\\n    - index stores the current position in the input string.\\n4. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n5. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/336747b3-ffea-40aa-b4e0-bf2146e509ea_1674271394.8886068.gif)\\n\\n# Code [C++] :\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\\n# Code [Java] :\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\\n# Code [Python3] :\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164573,
                "title": "c-c-python-super-clean-iterative-approach-and-fast-recursive-without-converting-to-numbers",
                "content": "# TL;DR\\n## Iterative solution. No pruning done.\\n#### Python\\n```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\\t\\t\\n#### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\t\\n## Iterative solution, with pruning. Super fast with minimal loops.\\n### c\\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\\n## Recursive solution, with pruning. Not as pretty, but fast\\nI didn\\'t bother doing this in python, because... well you don\\'t care about speed if you\\'re using python.\\n### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\\t\\n# Details\\nA simple solution would be to just try every possible length for the 4 ip numbers. That\\'s 3^4 = 81 possible values, so quite doable if your time constant isn\\'t too bad. In fact, since the total length of all the numbers must equal the string size, if you know your first 3 number lengths, the 4th is known. Therefore there is actually only 3^3 = 27 possible values to check; very doable.\\n\\nThings to be aware of are;\\n1. Numbers, apart from _0_, do not start with \\'0\\'. _0_ itself is only ever a single digit. eg. \"00\" and \"01\" are not valid numbers.\\n2. Numbers must be less than or equal to 255.\\n\\nChecking 1. is relatively simple. `len == 1 || \\'0\\' != digit[0]` will handle that.\\n\\nChecking 2. can be done many ways;\\n* Convert the number string to an actual number using `atoi`, `stoi` or similar. This can be an expensive operation to do a lot, since it often requires terminateing the substring/creating a copy.\\n* An ugly as if. `if (3 != len || (\\'2\\' > digit[0] || (\\'2\\' == digit[0] && (\\'5\\' > digit[1] || (\\'5\\' == digit[1] && \\'5\\' >= digit[2])))))`, which is fast, but makes your eyes bleed.\\n* `memcmp` directly against a string. Fast and efficent.\\n\\nI choose to use the `memcmp` approach because it allows the entire solution to be done without ever converting a string to a number or a number to a string.\\n\\n### Iterative solution\\nWtih that decided and aiming for neat code, I produced the logical iterative approach. This has no pruning, so it will always perform 27 comparisons, even if the input string size means there is no possible solution. For example \"0\" or \"00000\" will not cause a quick bail out. I think the clean code was worth it, particularly since the constant will be low.\\n\\nI originally used some stl to follow the DRY principle, but it\\'s not as clean. This is what I had;\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\nI decided to unroll it and decided to keep it clean. It is the same reason I didn\\'t use the non concatinating and faster code below to build the final result string.\\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```\\n\\nThe fastest solution is in c and basically just builds on the above approaches, but shifts the individual checks for each group into the associated `for`. The reason for this is in the above cases, the outside loop could produce an invalid value but the value will only be checked after all the nesting in the `if`, thus causing multiple loops that bail because of the same condition. It\\'s a bit ugly, but super fast.\\n\\n### Recursive solution\\nThe pruning, recursive solution is not nearly as clean, but is very quick. The only real trick to was to use a `switch` statement and abuse the fall-though to try the diffent length and handle the less than 255 at the same time.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3080185,
                "title": "beats-100-simple-c-very-short-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply use brute force and one thing here is that length of any integer can\\'t be more than three because 255 is limit so we can use 4 loops of 3 size and check if individual integers are less than 256 .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 4 loops from 1 to 3 and check the substrings are less than 256 .\\nSome Implementation Techniques to be taken care of:\\n- first check i+j+k+m== s.size because we should not take some part of string that is valid but not of given string size.\\n- then don\\'t take directly substr because it can have leading zeroes like \"`255 045 003 12`\" On taking stoi leading zeores will be gone then convert to string again.(Beacuse (str)\"045\"--> (int)$$45$$)\\n- then compare with 256 to all substrings use stoi again  for comparing .(Direct string comparison may not work)\\n- then add the dots in btween substrings and check if final length is given string length + 3 then push in ans (in case if it exceeds size or less than so make sure to check).\\n- **HelpFull?UpVoTe\\uD83D\\uDD3C:\\u2764**\\n# Complexity\\n- Time complexity:($$O(1)$$) Actually $$O(M^N*N)$$\\n- Since loops $$O(M*M*M*M)$$  and then substr take another N iterations.\\n- Here M=3 and N=4 so constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n- actually $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079197,
                "title": "day-21-beginner-friendly-backtracking-solution-with-diagram",
                "content": "# Intuition\\n1. if length of string is greater than 12 then it never be a valid IP address.\\n2. we will put dot for every point and for each dot we have 3 choices.\\n![b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png](https://assets.leetcode.com/users/images/259966b7-f127-4826-b1e5-04fb798c881c_1674266598.3424137.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list (or vector in C++), res, to store the valid IP addresses.\\n2. Check if the length of the input string is greater than 12, if so return the empty list.\\n3. Create a backtrack function that takes four parameters: s, i, dots, and currIp.\\n4. s is the input string\\n5. i is the current index of the string being processed\\n6. dots represents the number of dots that have been added to the current IP address\\n7. currIp represents the current IP address being formed\\n8. Within the backtrack function, check if the number of dots is equal to 4 and the current index is equal to the length of the input string, in which case add the current IP address to the res list and return.\\n9. Check if the number of dots is greater than 4, if so return.\\n10. Iterate through the input string using a for loop, starting from the current index and ending at the minimum of current index plus 3 or the length of the input string.\\n11. Within the for loop, check if the substring of the input string from the current index to the current loop index is less than 256 and either the current index is equal to the loop index or the character at the current index of the input string is not equal to 0.\\n12. If the above conditions are met, recursively call the backtrack function, passing in the loop index plus 1, dots plus 1, current IP address concatenated with the substring of the input string and a dot as the parameters.\\n13. After the for loop, return the res list.\\n\\nThis algorithm generates all possible valid IP addresses from the given string by adding dots between the substrings of the input string and then checks if it is a valid IP address.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(3^n)**\\nThe time complexity of the above code is O(3^4) which is equivalent to O(81).\\n\\n**The reason is that for each character in the input string, there are 3 choices:**\\n\\n1. The character is the last character of an octet, the next octet starts from the next character.\\n2. The character is the second last character of an octet, the next octet starts from the next character.\\n3. The character is the third last character of an octet, the next octet starts from the next character.\\n\\n**As we are using backtracking and at most 4 octets are possible , so it will check all the possible combinations of 3^4 which is equal to 81.**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n1. The space complexity of the code is O(n), where n is the length of the input string. This is because the maximum recursion depth is equal to the length of the input string and each level of recursion requires O(n) space to store the current IP address. The resultant list of IP addresses also takes O(n) space as the length of each IP address is equal to the length of the input string.\\n2. It is worth noting that since we are keeping track of the number of dots and the current IP address, the actual space complexity is O(1) since the amount of extra space used does not depend on the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754098,
                "title": "must-read-highly-commented-cpp-code-each-and-every-line-commented-with-examples-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtracking(string s, int start, int part)\\n    {\\n        \\n        if(start == s.size() && part == 4)\\n        {\\n            result.push_back(solution);\\n            return;\\n        }\\n        //Start trasversing the string till the end of the string.\\n        for(int i = start; i < s.size(); i++)\\n        {\\n            //if we satisfy 3 Conditions, we need to continue else Not.\\n            /*\\n            1- if part<4 means if we have a.b. part==2, need more processing. \\n            2- (i-start<3): we are just handling max to max 3 characters. like if we have\\n                1234.5 stop processing.\\n            3- the string from start to current i. string(start,i)= is valid\\n            */\\n            if(part < 4 && i-start < 3 && validIP(s, start, i))\\n            {\\n                //append that string to solution.[ its appennd]\\n                solution.append(s.substr(start, i-start+1));\\n                //included 1 part so incrementing the part by 1.\\n                part++;\\n                //if parts remaining : then we add \\'.\\' else we dont need like 123.456.123.2\\n                if(part < 4) solution.push_back(\\'.\\');\\n                //go from i+1 and do the reaming from i+1 till end of the string.\\n                backtracking(s, i+1, part);\\n                // if its the last part No need of popping the last character eg: 255.255.111.35, \\n                //No need of popping the 35.\\n                if(part < 4) solution.pop_back();\\n                \\n                \\n                //decrement the parts coz we are trying the next combination.\\n                // eg: 255.255.11 part was 3, Now we are ready to remove 11, and try for 111 so do\\n                // parts--.\\n                part--;\\n                //remove the part added. \\n                for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n            }\\n            //else continue;\\n        }\\n    }\\n    \\n    \\n    bool validIP(string s, int start, int end)\\n    {\\n        //find the substring from start to the end and convert into integer.\\n        string temp = s.substr(start, end-start+1);\\n        int ip = stoi(temp);\\n        \\n        //if we have ip=012, its invalid but if its ip=0 its valid like 127.0.0.1 :p\\n        if(s[start] == \\'0\\' && start != end) return false;\\n        //self explanatory\\n        else if(ip >= 0 && ip <= 255) return true;\\n        \\n        //eg: 256\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 30946,
                "title": "dfs-in-python",
                "content": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "codeTag": "Java"
            },
            {
                "id": 672543,
                "title": "javascript-the-most-clean-backtracking-solution",
                "content": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818933,
                "title": "python-backtracking-solution-99-with-illustration-and-example",
                "content": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "codeTag": "Python3"
            },
            {
                "id": 791997,
                "title": "beautiful-code-of-backtracking-with-generic-explanation",
                "content": "**Inspiration: BackToBackSWE**\\n* **Choice**: Take a snippet of length 1 to 3 \\n* **Constraint**: Each snippet must be in the range [0,255] and not leading zeroes\\n* **Goal**: When the build pointer will be at the end and we have 4 snippets or segments in total\\n\\n*If we have more than 4 segments or the build pointer goes out of limit, that won\\'t give the valid decomposition and we have to backtrack and try another length for the snippet.*\\n\\n**Time and space: O(1) since we have limited ip addresses (There are only 2^32 ip addresses since ipV4 is of 32 bit.)** (More about this at the end)\\n\\n```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```\\nTime complexity:  The big O notation shows an upper bound of number of your operations as your input size increases. But for this problem the input size cannot go over 12 digits and there are no more than 2^32 possibilities for your IP address. So the curve of your graph becomes constant beyond a point as n (size of the string) can\\'t be greater than 12. Hence the upper bound for this algorithm is constant.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 31211,
                "title": "adding-a-python-solution-also-requesting-for-improvement",
                "content": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "solutionTags": [],
                "code": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "codeTag": "Java"
            },
            {
                "id": 1554723,
                "title": "beats-100-of-c-submissions-clear-commented-code-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079093,
                "title": "python3-simple-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880655,
                "title": "easy-undersrtand-java-solution-with-explanation",
                "content": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080515,
                "title": "recursion-deep-dive-explanation",
                "content": "\\n# Approach\\nFor every position, we have two choices, either to insert the dot over there, or to not insert, also we need all possible addresses. Recursion is a very obivous choice. for every possibility check whether there exists a valid address or not, if it does store it and return it.\\n\\n\\n# Code Explanation\\n***The convert_to_int(string str)*** function takes a string as input and converts it to an integer. It first checks if the string is empty or has more than 3 characters, in which case it returns 256. It then checks for leading zeroes in the string and if it finds any, it also returns 256. If the string is a valid number, it converts it to an integer and returns it.\\n\\n***The valid_ip(string IP_part)*** function takes a string as input and checks if it is a valid IP address. It first checks if the string contains any characters other than \\'.\\' or numbers and returns false if it finds any. It then iterates through the string, checking each substring between dots and using the convert_to_int(string str) function to convert it to an integer. If the integer is greater than 255 or the substring is empty, the function returns false. If all substrings are valid, the function returns true.\\n\\n***The recursive_function*** generates all possible IP addresses by adding dots to the input string. It takes four inputs: the input string, a vector to store the valid IP addresses, an integer \\'i\\' that keeps track of the current position in the string, and an integer \\'dot\\' that keeps track of the number of dots that have been added to the string. The function first checks if all 3 dots have been placed, and if so, it checks for the validity of the IP address using the valid_ip(string IP_part) function and stores it in the vector if it is valid. If all dots have not been placed yet, the function then checks if the current position \\'i\\' is within the bounds of the string. It then has two options: either not add a dot at the current position, or add a dot at the current position. In both cases, it calls itself recursively with the updated string, position and dot count.\\n\\nFinally, Call the recursive_function to generate **all possible IP addresses** and returns the vector of valid IP addresses.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n***Exponential***: This is because for every position there are two operation, either to putting dot, or not putting dot. However this wont be done for more than three dots. (So, somewhere less than exponential.) The other functions have relatively lower complexities (is_valid: O(n), convert to int: O(str.length)).\\n\\n- Space complexity:\\n ***O(n)***: This is because after every function call a new stack frame to the call stack is added, and the maximum depth of the recursion stack is n.\\n\\n\\n*DO UPVOTE IF YOU FOUND THIS HELPFUL :)*",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778168,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737445,
                "title": "python-concise-backtracking-using-template",
                "content": "Runtime: 28 ms, faster than 94.82% of Python3 online submissions for Restore IP Addresses.\\nMemory Usage: 13.8 MB, less than 54.16% of Python3 online submissions for Restore IP Addresses.\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504942,
                "title": "java-clean-code-with-choose-explore-unchoose-template-of-backtracking",
                "content": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3079578,
                "title": "java-easy-understanding-using-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926120,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336483,
                "title": "simple-dfs-python-solution-36ms",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31084,
                "title": "java-easy-to-understand-recursive-solution",
                "content": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3080285,
                "title": "c-simple-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621595,
                "title": "c-simple-recursion-100-faster-than-all-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345810,
                "title": "easy-to-understand-javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31060,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079577,
                "title": "c-easy-code-comment-explanation-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```\\n**please upvote if you like my code**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745164,
                "title": "simple-backtracking-solution-runtime-100-faster-memory-97-lesser",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593871,
                "title": "javascript-backtracking-solution",
                "content": "Credits to https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\nThis is classical backtracking challenge.\\nI listed few more solutions for simmilar problems below:\\n* https://leetcode.com/problems/restore-ip-addresses\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\\n* https://leetcode.com/problems/combination-sum\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168080,
                "title": "concise-java-backtracking-solution",
                "content": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31066,
                "title": "simple-java-solution-beating-100-of-java-submissions",
                "content": "    /*Description of variables\\n    result - list of valid ip addr strings\\n    digits -char array representation of s\\n    len - length of s\\n    currIpAddr - char array that contains the IP addr we are building using backtracking\\n    remSegs - no. of segments remaining to be parsed. there 4 segments to an ip addr\\n    start - start index in the digits array for the current ip addr segment\\n    pos - next index to be populated in the currIpAddr array\\n\\n    */\\n\\n    public class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateIpAddresses(char[] digits, int remSegs, int start, int len, \\n                                     char[] currIpAddr, int pos, List<String> result) {\\n            if(start == len && remSegs == 0) {\\n                result.add(String.valueOf(currIpAddr));\\n                return;\\n            }   \\n        \\n       //1. Checks for length of s too small\\n       //2. Maximum Length of the remaining segments. Since a sgemnt can be upto 3 digits\\n       // Length can not exceed 3x the remaining segments.\\n       //3. Minimum Length of s. Each segment has to be atleast 1 digit\\n        if((start > len) || ((len - start) > (3 * remSegs)) || ((len - start) < remSegs))\\n            return;\\n        \\n        if(remSegs < 4)\\n            currIpAddr[pos++] = DOT;\\n        \\n        int num = 0;\\n        \\n        for(int i = 0; i < Math.min(len-start, 3);i++) {\\n            num = (10*num) + (int)(digits[start+i] - '0');\\n            \\n            if(i > 0 && num < 10)// leading 0 cases i = 1, then the number should be > 10.\\n                return;\\n            \\n            ////\"010010\"\\n            //Valid: [\"0.10.0.10\",\"0.100.1.0\"]\\n            //Invalid: [\"0.1.0.010\",\"0.1.00.10\",\"0.1.001.0\",\"0.10.0.10\",\"0.10.01.0\",\"0.100.1.0\",\\n            //\"01.0.0.10\",\"01.0.01.0\",\"01.00.1.0\",\"010.0.1.0\"]\\n            \\n            if(num <= 255) {\\n                currIpAddr[pos+i] = digits[start+i];\\n                generateIpAddresses(digits, remSegs-1, start+i+1, len, currIpAddr, pos+i+1, result);\\n            }\\n        }\\n      }    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31146,
                "title": "my-short-c-recursive-version-4-ms-with-explanation",
                "content": "The idea is to have a recursive function buildIP to generate an IP string with \"num\" numbers using the substring [start, npos] of s. First it checks the substring has proper number of digits (>=num && <=3*num). Also it checks if the substring starts with '0' and has some extra digits. If so, it is not a valid case, so abandon it. Otherwise, if it is the last number, then check if it is no larger than 255 and if so, add to the resulting vector. If it is not the last number, recursively call itself to build the rest of the number sequence. For the current number, it can only be 1, 2, or 3 digits. Again, remember to check if it starts with '0' and is no larger than 255.\\n \\n\\n       class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }\\n                else\\n                {\\n                    buildIP(res, s, start+1, num-1, cur+ s.substr(start,1) + \".\");\\n                    if(s[start]!='0')\\n                    {\\n                        buildIP(res, s, start+2, num-1, cur+ s.substr(start,2) + \".\");\\n                        if(atoi(s.substr(start,3).c_str())<=255) buildIP(res, s, start+3, num-1, cur+ s.substr(start,3) + \".\");\\n                    }\\n                }\\n            }\\n        \\n            vector<string> restoreIpAddresses(string s) {\\n               int len = s.size();\\n               vector<string> res;\\n               buildIP(res, s, 0, 4, \"\");\\n               return res;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3080381,
                "title": "c-backtracking-easy-approach-with-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry out all possibilities. \\nfirst possibility: take single character\\nsecond and thirs possibility: take 2 and 3 characters respectively. for this case ensure that number doesn\\'t start with 0 and is less than 255\\ncount number of dots you add (i.e splits you have made). if this is equal to 3 (excluding last dot added ) and end of string is reached we have a valid ip\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use dfs to explore all the combinations. \\nat each ith postion, we need to try out with next i +1, i+2 and i+3 substring. \\nif this substring is valid (for single digit 0-9 are valid cases and for 2 or 3 digits if them number doesn\\'t start with 0 and is less than 255) proceed for next 1 to 3 substr\\nwe stop only when \\n\\n# Complexity\\n- Time complexity:\\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079523,
                "title": "java-backtracking-approach-better-than-leetcode-solution",
                "content": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079507,
                "title": "java-easy-recursive",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079467,
                "title": "0ms-runtime-code-c-python-explained",
                "content": "# Solution:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n*Please upvote if helped*",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078796,
                "title": "commented-java-solution-using-backtracking",
                "content": "In order to produce all solutions we must iterate over all collections of characters of size 1-3 and see if they form a valid IP integer. If it does, we add it to our \"temp\" list and continue recursing through the input until temp has 4 strings and is using all the digits from input. To proceed producing the other results that don\\'t contain the first collection of characters we chose, we remove the item we just added to temp and continue iterating over the size of collection of characters we may include in one integer of the IP address.\\n\\n```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nLet me know if you have questions",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597069,
                "title": "my-java-backtrack-solution",
                "content": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 31028,
                "title": "simple-python-backtracking-solution",
                "content": "If the length of current is 4 and start point equals to the length of s, then add it to the result.\\nThen check the next 3 number from index start, and make sure that it does not exceed the total length of s. If the first digit is 0 and i>start, like 09 or 01, then skip those conditions.\\n\\n```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31145,
                "title": "my-cpp-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}\\n    \\tvoid dfs(vector<string>& res, string s, string ans,int idx, int depth)\\n    \\t{\\n    \\t\\tif (depth > 4) return;\\n    \\t\\tif ((depth == 4) && (idx == s.size()))\\n    \\t\\t{\\n    \\t\\t    ans.erase(ans.end()-1);\\n    \\t\\t\\tres.push_back(ans);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 1; i < 4; ++i)\\n    \\t\\t{\\n    \\t    \\tif (s[idx] == '0' && i>1) return;\\n    \\t\\t\\tif (idx + i > s.size()) return;\\n    \\t\\t\\tauto tmp = s.substr(idx, i);\\n    \\t\\t\\tif (stoi(tmp) < 256)\\n    \\t\\t\\t{\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\tdfs(res, s, ans+ tmp+\".\", idx + i, depth + 1);\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn;\\n    \\t\\t\\t}\\n    \\t\\t}\\t\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3083003,
                "title": "simplest-rejava-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe \"solve\" method uses a recursive approach to build all possible IP addresses by adding characters from the input string to the \"str\" variable either as it is or with a dot in front of it. When the index reaches the end of the input string or **the number of dots used reaches 4**, the current IP address is checked for validity using the \"correct\" method. If it is valid, it is added to the list of valid IP addresses.\\n\\nThe \"correct\" method checks if the given IP address is a valid IP address by checking **if the length of the IP address is not 0, if the last character is not a dot, if the length of each segment between dots is between 1 and 3 and if each segment is between 0 and 255 and also if there are 3 dots in the IP address.**\\n\\nIn summary, this code uses a recursive approach to generate all possible IP addresses from a given string and then checks each one for validity using the \"correct\" method.\\n\\n# Complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the above code is **O(n)** where **n is the length of the input string**. The main source of space usage is the *recursion stack* used by the \"solve\" method.\\n\\nThe maximum depth of the recursion will be equal to the length of the input string because at each level of the recursion, we are either adding a character or a dot to the IP address string. Since we are not storing any other data during the recursion, the space complexity is directly proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```\\n\\n***Please consider upvoting if you found this information helpful.***",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082691,
                "title": "python-simple-backtracking",
                "content": "**Solution**:\\n    We can solve this problem with backtracking. At each iteration, we will pick the next term for a proposed ip address as long as the term is valid. We know that we have a valid ip if we used all digits and we picked 4 terms and thus, we can append the proposed ip into the result. Then, we backtrack.  \\n\\n**Complexity**:\\n    Time: O(3**n) \\n    Space: O(3\\\\**n)\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080249,
                "title": "recursion-optimal-w-explanation-c-nmcodex",
                "content": "Please upvote if you like it. Upvote costs nothing \\uD83D\\uDE0E\\n\\n> Many coders have been shared the best solutions. Hope this will also help you a lot.\\n# Intuition\\nDefinitely we need to check each and every possible string.\\n> String length is 20, then we should not worry about time limit. \\n> Even if length is greater, time will be still constant *(better explained in `Complexity Section`)*\\n\\nWe have three conditions:\\n```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\\n\\n# Approach\\n1. Take initial string `temp` as empty and  a variable for `dot` count.\\n2. Take all possibilities.\\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\\n3. When complete string traversed and `dots are 3` then insert it in `unordered_set`.\\n> In code, insert element when dots are 4 because we delete last dot as well before inserting.\\n4. `If dots exceeds 4 return`.\\n5. Copy all elements from `set to vector` and then `return vector`\\n\\n# Complexity\\n- Time complexity:\\n> The IP address ranges from 0.0.0.0 to 255.255.255.255\\nSo, there can be maximum 2^32 address \\nTime complexity will be `constant` ---- **O(2^32)**  ----> **`O(1)`**.\\n- Space complexity:\\n> **`O(N) + Auxiliary space`**\\nUsing a unordered_set and recursion stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079985,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079544,
                "title": "python3-31-ms-faster-than-95-31-of-python3-clean-and-easy-to-understand",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3079244,
                "title": "c-backtracking-solution-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- base case if we place all dots then just check curr substr is valid or not, and push back to ans \\n- for every idx to n check if that curr substring (idx, i-idx+1) is valid or not .\\n    - if yes then push curr char and \\'.\\' and call furthur\\n    - backtrack also\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079131,
                "title": "95-javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/6vln3Liz3_g\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\\nMap approach for avoiding duplicate\\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152282,
                "title": "java-solution-brute-force-o-1-time-well-explained",
                "content": "I totally agree that the problem description should be more clear. If you are confused by the problem, feel free to take a look of the post. I also attach the code below and the explanation to the time complexity. Hope it is helpful.\\n\\nHere are several rules of a valid IP address:\\n\\n  (1) **Three dots**. A Valid IP address contains **ONLY 3 dots**, i.e. \"192.168.0.1\".\\n  (2) **No zero leading** in each section, i.e. \"192.168.00.1\" or \"192.168.0.01\" These two IP address are both invalid.\\n  (3) The number in each section should be in the range **[0, 255]**. No greater than 255 && no smaller than 0.\\n  (4) A valid IP address should contains at least four digits, i.e. \"0.0.0.0\". It\\'s a valid IP address.\\n\\nBy my solution, we can achieve **O(1) time** and O(1) space. The reason we can achieve constant time complexity is because that there are only 256 possible numbers in a section (0 - 255). 256 is 2^8, and we have four sections in an IP address. Therefore, (2^8) * (2^8) * (2^8) * (2^8) = 2^32. Hence, we can achieve O(2^32) time complexity which is O(1) time.  \\n\\n\\n```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420292,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363591,
                "title": "java-backtracking-solution",
                "content": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319009,
                "title": "python-short-and-simple-backtracking-python-solution",
                "content": "I use \"level\" to refer to different portions of the IP address\\n```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31087,
                "title": "short-easy-understand-4ms-backtracking-c-solution",
                "content": "    class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }\\n            else if(sol.size()==4 && length!=0) return;\\n            else if(sol.size()!=4 && length==0) return;\\n            \\n            for(int i=1;i<=3 && i<=length;i++){\\n                string ts = s.substr(s.length()-length,i);\\n                int num = stoi(ts);\\n                if(num>=0 && num<=255 && (i==1 || ts[0]!='0')){\\n                    sol.push_back(ts);\\n                    helper(s,sol,res,length-i);\\n                    sol.pop_back();\\n                }\\n            }\\n        }\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> res;\\n            vector<string> sol;\\n            helper(s,sol,res,s.length());\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31095,
                "title": "backtracking-solution-in-java-easy-to-understand",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }\\n            StringBuilder builder = new StringBuilder();\\n            helper(result, s, builder, 0, 0);\\n            return result;\\n        }\\n        \\n        private void helper(List<String> result, String s, StringBuilder builder, int start, int count){\\n            if(start == s.length() && count == 3){\\n                result.add(builder.toString());\\n                return;\\n            }\\n            for(int i = start + 1; i <= s.length(); i++){\\n                String tmp = s.substring(start, i);\\n                if(tmp.length() > 3 || tmp.length() > 1 && tmp.charAt(0) == '0' || Integer.parseInt(tmp) > 255){\\n                    return;\\n                }\\n                StringBuilder newBuilder = new StringBuilder(builder);\\n                if(newBuilder.length() != 0){\\n                    newBuilder.append(\".\");\\n                }\\n                newBuilder.append(tmp);\\n                helper(result, s, newBuilder, i, newBuilder.length() == tmp.length() ? count : count + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3696351,
                "title": "superb-logic-with-backtracking-constraints-concept",
                "content": "# Awesome Logic with backtracking\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091216,
                "title": "c-string-partition-code-with-comments-simple-explanation",
                "content": "![93. Restore IP Addresses.png](https://assets.leetcode.com/users/images/f916078e-6ab9-48f4-bf63-a2f662defee9_1674494214.1065774.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Pls upvote my solution, it helps me stay motivated to bring up more solutions like this :)**",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085871,
                "title": "java-no-backtracking",
                "content": "# Please Upvote :D\\n---\\n![image.png](https://assets.leetcode.com/users/images/c68b647b-ba51-4581-9a86-8ca233011c3c_1674387621.138504.png)\\n\\n---\\n*We will be forming each part of the IP-address iteratively.*\\n``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```\\n---\\n#### Time complexity: \\n- We are using `3` loops which would run `3 x 3 x 3` times.\\n- Inside that we are performing `substring()` operation `4` times on a string which can be at max `12` in length.\\n- So time complexity becomes $$O(3 * 3 * 3 * 4 * 12) => O(432)$$ in worst case which is constant in nature.\\n\\nSo we can say our time complexity is $$O(1)$$.\\n\\n---\\n#### Space complexity:\\nWe are using a stringbuilder who will store a string of size `12 + 3 = 15` at max which is again constant in nature.\\nSo we can say our space coplexity is $$O(1)$$.\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083045,
                "title": "c-solution-iterative-approach-simple-explanation",
                "content": "# Intuition \\nIterative Approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the length of the given string is greater than 12 that means there is no valid ip as maximum number is 255 and it has only 3 charater and we have to divide the string and insert dot 4 times.\\n2. Now divide the string into substrings and verify the condition on each substring\\n - length is less then or equal to 3 \\n - no leading zeros and\\n - it\\'s value in integer is less than or equal to 255\\n3. At the end insert the string into ans vector. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it helps you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082015,
                "title": "golang-simple-solution",
                "content": "# Intuition\\nDivide given string into valid 4 substring and check if each substring is valid\\n\\n# Approach\\n1. Divide given string into valid 4 substrings\\n2. Check value of each substring is valid (0-255)\\n3. Join substring and check if there was not leading zeros. After joining lengths should match\\n\\n# Complexity\\n- Time complexity:\\nWe run 3 for loops for 3 values (1,2,3)\\nO(3*3) -> O(1). We are not dependent on length of input string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081001,
                "title": "recursive-iterative-c",
                "content": "# Recursive\\n```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Iterative\\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080823,
                "title": "c-ez-recursive-solution-explained",
                "content": "**Time taken for execution : 4ms**\\nI am generating all the possible subsets by placing the 3 dots in every position of the given string and validating them before pushing them into the answer vector.\\nThe maximum valid IP address can be generated with a string of length 12 ***[ 255.255.255.255 ]*** .  So we can easily return an empty vector for strings of size > 12.\\nThe maximum possible set generated fore the string will be I guess some 1000, so generating all the set is feasible.\\n\\n**If someone can help me determine the time complexity of the following code it will be highly appreciated. Thank You.**\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3080447,
                "title": "simple-recursion-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080432,
                "title": "python-backtracking",
                "content": "\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080261,
                "title": "easy-c-backtracking-approach-fast-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```\\n![fays.png](https://assets.leetcode.com/users/images/7890de43-b728-4040-b0ec-b8add9211e5c_1674286460.3253233.png)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080237,
                "title": "easy-c-solution",
                "content": "Here is the simple c++ sol.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080191,
                "title": "c-sweet-n-simple-backtracking-solution-with-valid-function",
                "content": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool valid(string temp)\\n    {\\n        if(temp.size()==0 || temp.size()>3 ||(temp.size()>1 && temp[0]==\\'0\\') || stoi(temp)>255)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    void Rec(int indx, string s, string temp, vector<string> &ans, int dots)\\n    {\\n        if(dots==0)\\n        {\\n            if(indx==s.size())\\n            {\\n                ans.push_back(temp.substr(0, temp.size()-1));\\n            }\\n            return;\\n        }\\n\\n        for(int i =indx;i<s.size();i++)\\n        {\\n            if(valid(s.substr(indx, i-indx+1)))\\n            {\\n                temp.push_back(s[i]);\\n                temp.push_back(\\'.\\');\\n                Rec(i+1, s, temp, ans, dots-1);\\n                temp.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        string temp;\\n        vector<string> ans;\\n        Rec(0, s, temp, ans, 4);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079824,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3079820,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nWe will consider every 1 ,2 and 3 size substrings and try to partition the string into 4 parts and see if they match our condition. We will make use of recursion(backtracking) in it.\\n\\n# Approach\\nWe will consider every 1,2 and 3 size substrings with conditions-\\n- The total partitions should be 4\\n- We should not have any preceding 0.\\n- If we reach the end we will add the string to our ans\\n\\nSo at every ind, we have 3 cases. \\n- We will add the single char to our ans string and add \".\" at end\\n- We will add the next 2 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0).\\n- We will add the next 3 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0) along with that it should not be greater that 255.\\n\\n# Complexity\\n- Time complexity:\\nWe are making 3 recursion calls at every index. SO TC (3^n).\\n\\n- Space complexity:\\nSC O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079724,
                "title": "backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand",
                "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n1. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n2. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n4.  (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\nRequest \\uD83D\\uDE0A :\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/684aadb8-5eea-47f4-aef2-31007841e162_1674279208.2528946.png)\\n\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\\n\\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```\\n\\n\\n\\n\\n\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079606,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\n1. Generate all possible index `points` to divide given `s` into `4` parts such that `1 <= len(part) <= 3` for each `part`.\\n\\n2. Define `is_valid_ip` which takes `parts` and returns `true` if all `part` has `0 <= int(part) <= 255` and has no leading zeroes.\\n\\n3. Calculate `candidate_ips` by splitting `s` at `points`.\\n\\n4. Filter only the `valid_ips` from `candidate_ips`.\\n\\n5. Join each into a `string` and return.\\n\\n# Complexity\\n- Time complexity: $$O(m^n * n)$$\\n\\n- Space complexity: $$O(m * n)$$\\n\\nwhere,\\n`n is number of parts in ip, i.e 4`, and \\n`m is max length of each part, i.e 3`\\n\\n# Code\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060566,
                "title": "c-java-100-solution-using-backtracking-restore-ip-addresses",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795387,
                "title": "python-solution-backtrack-recursive-easy-comments",
                "content": "### Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Backtrack (Recursive) approach***\\n\\n### Complexity\\n- Time complexity: O(3^5)    \\n   ( As there are max 4 integers (chunk) in all )\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718493,
                "title": "very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906017,
                "title": "backtracking-c-commented",
                "content": "-> We simply have to divide the given string into 4 parts where integer value of each part should be between 0 to 255 .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905399,
                "title": "intuitive-python-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "codeTag": "Java"
            },
            {
                "id": 1498413,
                "title": "python-iterative-solution-not-optimal-solution-but-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383843,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206516,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179768,
                "title": "java-backtracking-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789947,
                "title": "simple-python-backtracking",
                "content": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774340,
                "title": "java-backtracking-1ms",
                "content": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283437,
                "title": "c-concise-recursive-solution",
                "content": "1. We try out all the three different lengths (1-3) at each index.\\n2. We check if the value obtained for each length is valid. If yes, we recursively proceed.\\n3. If the index reach the end and the number of strings on the path is 4, then we store the path.\\n4. For faster return, we can check if the current cout has already been at least 4.\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253515,
                "title": "beats-100-c-4-small-loops",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 151356,
                "title": "javascript-backtracking",
                "content": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136053,
                "title": "c-runtime-beats-97-61-of-cpp-submissions",
                "content": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30942,
                "title": "c-0ms-recursive-solution-clean-and-easy-to-understand",
                "content": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31108,
                "title": "share-my-clean-dfs-java-code",
                "content": "    /*\\n        dfs. \\u5728\\u6bcf\\u4e00\\u5c42, \\u53d6\\u5b57\\u7b26\\u4e32\\u7684\\u524d1/2/3\\u4e2a\\u5b57\\u6bcd\\n        \\u7b2c\\u56db\\u5c42\\u65f6\\u68c0\\u67e5\\u5e76collect answer.\\n    */\\n    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }\\n        \\n        private void dfs(List<String> ans, StringBuilder cur, String s, int level) {\\n            if (level == 4) {  // all previous 4 segments are done\\n                if (s.length() == 0) {  // s is entirely used\\n                    ans.add(cur.toString().substring(0, cur.length() - 1));  // remove the dot at tail\\n                }\\n                return;\\n            }\\n            for (int i = 1; i <= Math.min(3, s.length()); ++i) {  // length of each segment are at most 3\\n                String curPart = s.substring(0, i);\\n                if (curPart.length() > 1 && curPart.charAt(0) == '0' || Integer.parseInt(curPart) > 255) {\\n                    break;\\n                }\\n                cur.append(curPart).append(\".\");\\n                dfs(ans, cur, s.substring(i), level + 1);\\n                cur.delete(cur.length() - curPart.length() - 1, cur.length());\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31130,
                "title": "c-backtracking-solution-easy-understand",
                "content": "    class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }\\n\\n    private:\\n\\tvoid splitIP(int startIndex, int segments, string &str, std::vector<string> &ans, std::vector<string> &ip)\\n\\t{\\n\\t\\tif (startIndex >= str.length() && segments != 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex != str.length() && segments == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex == str.length() && segments == 0)\\n\\t\\t{\\n\\t\\t\\tans.push_back(ip[0] + '.' + ip[1] + '.' + ip[2] + '.' + ip[3]);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = startIndex; i < startIndex + 3 && i < str.length(); ++i)\\n\\t\\t{\\n\\t\\t\\tstring digit = str.substr(startIndex, i - startIndex + 1);\\n\\n\\t\\t\\tif (stoi(digit) > 255)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tip.push_back(digit);\\n\\t\\t\\tsplitIP(i + 1, segments - 1, str, ans, ip);\\n\\t\\t\\tip.pop_back();\\n\\n\\t\\t\\tif (str[startIndex] == '0')\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31197,
                "title": "accepted-recurssive-python-solution",
                "content": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "solutionTags": [],
                "code": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "codeTag": "Java"
            },
            {
                "id": 3187629,
                "title": "restore-ip-addresses-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step by step explanation of the algorithm:\\n\\n1. We define a recursive function restore_ip that takes four arguments: the current index in the string s, the current part number part, the current IP address ip, and the list of valid IP addresses result.\\n2. If we have reached the end of the string s and we have formed four parts in ip, we append ip to result.\\n3. If we have formed less than four parts in ip and there are still characters remaining in s, we try to place a dot after the next one or two digits.\\n4. If we have formed less than four parts in ip and there are at least two digits remaining in s, we try to place a dot after the next two digits.\\n5. If the current part in ip is not valid (i.e., it contains a leading zero or is greater than 255), we stop the recursion for this path.\\n6. If the current part in ip is valid, we recursively call restore_ip with the next index in s, the next part number, and the updated ip.\\n7. After all recursive calls are done, we return the list of valid IP addresses result.\\n\\n# Complexity\\n- Time complexity:\\n86.7%\\n\\n- Space complexity:\\n98.84%\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089341,
                "title": "python-simple-dfs-28-ms-faster-than-96-21",
                "content": "https://leetcode.com/submissions/detail/883564385/  \\nRuntime: **28 ms**, faster than 96.21% of Python3 online submissions for Restore IP Addresses.  \\nMemory Usage: 13.9 MB, less than 28.27% of Python3 online submissions for Restore IP Addresses.   \\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081448,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081237,
                "title": "java-recursive-solution-o-m-n-n",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080583,
                "title": "java-backtracking-string",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**Do UpVote**",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080525,
                "title": "java-recursive-code-with-explanation-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/4a164322-63c2-49e7-8692-78beb8580285_1674290937.229729.png)\\n\\n\\n\\uD83D\\uDC4D\\uD83D\\uDE0A**Upvote**\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080389,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080342,
                "title": "100-0ms-beat-me-dfs-backtracking-beats-100-proof-concise-2ways",
                "content": "# UPVOTE PLS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a10949e5-6062-412e-bde4-9f013bc3b35f_1674287824.969369.png)\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```\\n\\n# c++\\n```\\nvector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        int L=s.size();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.c_str(),\"\",0,0,ans);\\n        return ans;\\n    } \\n    void dfs(const char* s,string sec,int level,int cnt,vector<string> ans){\\n        if(level>4) return;\\n        int num=0,L=sec.size();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==strlen(s)+4)ans.push_back(sec.substr(0,L-1));\\n            return;\\n        }\\n        for(int i=cnt;i<strlen(s) && i<=cnt+2;i++){\\n            num = num*10+(int(s[i]-\\'0\\'));\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(std::to_string(num)).append(\".\"),level+1,i+1,ans);\\n        } }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080071,
                "title": "the-o-1-solution-and-backtracking-detailed-explanation",
                "content": "# Intuition\\nIP addresses are in the format of four octets, where each octet is a number between 0 and 255.\\nThe task is to find all possible ways of dividing a given string into four segments, such that each segment represents a valid octet in an IP address. The algorithm checks all possible combinations of dividing the string into four segments and checks if each segment represents a valid octet, if so it constructs a valid IP address and adds it to the result list.\\n\\n# Approach\\n1. Initialize an empty list called ***result*** to store the valid IP addresses.\\n2. Check if the length of the input string is less than 4 or greater than 12. If so, return the empty ***result*** list.\\n3. Use four nested for-loops to iterate through all possible combinations of the length of each segment of the IP address.\\n4. For each iteration, create a new StringBuilder object called ***ip*** to construct the current candidate IP address.\\n5. Use the substring() method to extract the individual segments from the input string, convert them to integers using the Integer.valueOf() method.\\n6. Check if each of the segments is less than or equal to 255, which is a requirement for valid IP addresses.\\n7. If all segments are valid, append them to the ***ip*** StringBuilder object, separated by periods.\\n8. Check if the length of the constructed IP address is equal to the length of the input string plus three (to account for the three periods added), and if so, add it to the ***result*** list.\\n9. Return the ***result*** list at the end of the method.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is **O(1)**, it is a constant time complexity because the number of iterations is fixed and does not depend on the size of the input. The outer for-loop runs four times, and each inner for-loop runs three times, so the total number of iterations is  81.\\n\\n- Space complexity:\\nThe space complexity of this code is O(n), where n is the number of valid IP addresses found. This is because the algorithm creates a new StringBuilder object for each valid IP address and adds it to the result list, so the maximum space needed is proportional to the number of valid IP addresses. However, this space usage can be considered as low as the number of valid IP addresses cannot be more than 3^4 = 81.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n## Backtracking Approach\\n1. Create a method called \"backtrack()\" which takes four parameters: the input string, the current starting index of the next segment, a list to store the current candidate IP address, and the final result list.\\n2. Inside backtrack() method, check if the current candidate IP address has four segments. If it does, check if all characters of the input string have been used.\\n3. If all characters have been used, add the candidate IP address to the result list.\\n4. If the current candidate IP address does not have four segments, use a for-loop to iterate through all possible combinations of the next segment, from the current starting index to a maximum of three characters.\\n5. For each iteration, extract the segment using substring() method and check if it is a valid segment (i.e. less than or equal to 255 and not starting with a \"0\" if its length is greater than 1).\\n6. If the segment is valid, add it to the candidate IP address and call the backtrack() method recursively with the updated parameters.\\n7. Remove the last segment from the candidate IP address and continue with the next iteration.\\n8. Return the result list at the end of the method.\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```\\n> I understand that this can be improved further, but this is my current understanding of the problem. I will work on providing a more effective solution with an explanation.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080042,
                "title": "simple-java-beginners-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080018,
                "title": "c-easy-solution-without-recursion",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079727,
                "title": "c-100-faster-solution-dfs",
                "content": "C++ 100% faster solution \\n\\nThe code is commented and so it is self explanatory approach\\n\\nThe idea used here is to try to form all possible combinations with DFS\\n\\n```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079608,
                "title": "java-solution-beats-93-2ms-runtime-explained-with-comments-2-methods",
                "content": "#### Approach 1--> Using String and StringBuilder (6ms runtime Faster than 60%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\\n### Optimization of above code using List<String>\\n#### Approach 2--> Using StringBuilder & List<String>(Converting it to String) (2ms runtime and Faster than 93%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079562,
                "title": "c-backtracking-super-easy-code-with-comments",
                "content": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079520,
                "title": "python-just-dfs-and-backtracking-explained",
                "content": "This is a common DFS and backtracking problem. \\n\\nWe just need to take care of special requirements:\\n(1) the total number of fields is 4;\\n(2) no leading \\'0\\' for a number if it is not \\'0\\'\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079362,
                "title": "easy-to-understand-backtracking",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/backtracking/RestoreIpAddresses.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3079289,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3079241,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079180,
                "title": "c-backtraking-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/PFb5zPn0vvY\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079173,
                "title": "clean-and-clear-the-interview-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking problem where we try to place a dot in every possible position and then check if it is valid\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n spots to choose the placement of the first dot\\n- n - 1 spots to choose placement of second dot\\n- n - 2 for third\\n- n - 3 for fourth\\nTotal = n * (n - 1) * (n - 2) * (n - 3) = $$O(n^2)$$\\n- Space complexity: $$O(n^4)$$ \\nIn the worst case we need to store every possible permutation of dots\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079164,
                "title": "typescript-dfs-backtracking",
                "content": "# Intuition\\nUse DFS for backtracking to generate all possible IP addresses\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n    $$O(3^n)$$ \\n\\n- Space complexity:\\n$$O(d)$$\\n> d auxiliary  call stack space \\n\\n# Code\\n```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Backtracking"
                ],
                "code": "```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079140,
                "title": "beats-100-c-java-using-dfs-backtracking",
                "content": "> ## ***UPVOTE if U find it useful***\\n\\n# using backtracking\\n## **complexity \\n  Time complexity : O(2^n)\\n  Space complexity: O(n)**\\n```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# using DFS + Backtracking Beats 100%\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079082,
                "title": "daily-leetcoding-challenge-january-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3065416,
                "title": "javascript-clean-backtracking-solution-with-explanation",
                "content": "# Intuition\\nThis is similar to [Word Break](https://leetcode.com/problems/word-break/) except instead of checking if a string segment exists in a dictionary, we use a helper function to validate it.\\n\\n# Approach\\n1. In the main backtracking loop, build up the IP address segment.\\n2. If the segment is invalid, don\\'t use it.  Valid segment in this context means\\na. The segment should be a value <= 255.\\nb. The segment cannot be left zero padded if its length > 1.\\nc. If we already have 3 segments in our IP address candidate, the current segment length has to be equal to the remaining length of the input string.  Remember, you have to use all the digits in the input string to form the IP address.\\n3. Otherwise,  backtrack.\\n\\n# Complexity\\n- Time complexity: -\\n\\n- Space complexity: -\\n```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673083,
                "title": "c-100-faster-very-simple-3-cases-explanation-recursion",
                "content": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384635,
                "title": "c-backtracking-recursion",
                "content": "class Solution {\\npublic:\\n     ```\\n```\\n   void func(vector<string>& ans, string temp, int start,string s,int c)\\n        {\\n                if(c==4)\\n                {\\n                        if(start==s.size())\\n                        {\\n                                temp.pop_back();\\n                                ans.push_back(temp);\\n                        }\\n                                return;\\n                }\\n                int num=0;\\n                for(int i=start;i<s.size();i++)\\n                {\\n                        \\n                        num=num*10+(s[i]-\\'0\\');\\n                        if(num>255)\\n                        {\\n                                break;\\n                        }\\n                        if(s[i]==\\'0\\')\\n                        {\\n                                temp=temp+\"0\"+\".\";\\n                                func(ans,temp,i+1,s,c+1);\\n                                \\n//if digit is zero and the number after previous .(consider \"0.0\") is also zero then there wont be any further placing of . in this current loop so we break the for loop\\n                                if(num==0)\\n                                break;\\n                                \\n//else the number was not zero so we can make use of normal backtracking\\n                                else\\n                                        temp.pop_back();\\n                        }\\n                        \\n//Normal BackTrack for any other digit\\n                        else {\\n                                temp=temp+s[i]+\".\";\\n                                 func(ans,temp,i+1,s,c+1);\\n                                temp.pop_back();\\n                        }\\n                }\\n        }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        vector<string> ans;\\n            string temp=\"\";\\n            int c=0;\\n            func(ans,temp,0,s,c);\\n            return ans;\\n    }\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383310,
                "title": "simple-python-complex-time-complexity-code-faster-than-100",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "codeTag": "Java"
            },
            {
                "id": 2336781,
                "title": "c-faster-then-100-69-less-memory-backtracking-simple",
                "content": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2271339,
                "title": "best-working-java-solution-3-loops-only-beats-97",
                "content": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222868,
                "title": "beginner-friendly-dfs-backtracking-solution-in-c",
                "content": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2207698,
                "title": "javascript-simple-efficient-solution",
                "content": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028226,
                "title": "recursion-easy-to-understand-c",
                "content": "**APPROACH:**\\n* We know that that given string can be formed into IP address by dividing it into either 3-bit or 2-bit or 1-bit without any leading zero in first two conditions.\\n* so we have option of dividing string into 3 ways : Make group of 3-3 characters **OR** make group of 2-2 characters **OR** make group of 1 character. With checking condition of **no leading zero** and value of bits is **between 0 and 255 inclusive.**\\n* If group of 3 bit is invalid to use either of false of leading zero condition as well as overflow of value range 2- bit character condition is then followed.\\n* with every **success call** i**ncrement part by 1** and **bits value by the length of character chosen.**\\n* when bits reaches the same length as string length it means all characters are taken and ans is printed after neglecting that last dot.\\n\\n\\n**CODE:**\\n\\n```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```\\n\\n\\n**Not the best solution Feel free to suggest changes to make it better.**\\nENJOYING LEARNING :)\\n\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969572,
                "title": "java-code-with-easy-explaination",
                "content": "\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874942,
                "title": "easy-java-backtracking-with-comments-beats-99-97",
                "content": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nThe idea here is we take the start of the IP string, and try the three possible IP numbers. With each possibility, we remove the first IP number from the string, and then recurse with the new string. We use classic backtracking to explore all possible combinations of IP numbers to create an address.\\n\\nHope this helps, let me know if I missed anything.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872914,
                "title": "c-backtrcking-easy-to-understand-clean-code",
                "content": "# Approach 1\\nBy passing string as parameter\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing common string \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do share your suggestions & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868182,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1707782,
                "title": "c-backtracking-dfs-solution-explained-100-time-70-space",
                "content": "Nice problem which is a variant of more common combinatorics problems, but, as such, offers room for the same kind of approach to tackle it: a good old backtracking DFS across all the branches of our decision tree.\\n\\nIt would be tempting to try and move the `3` dots we have to consider creating a lot of substrings here and there, but that would not be too convenient, considering how many times we might be doing the same work over and over again, while progressing with partial strings we have already validated (and only once) is probably a much better approach.\\n\\nAnd to do so, we will need a few variables, all at class level:\\n* `res` will be our accumulator variable, storing the valid permutations we will find for the provided digits;\\n* `s` will store our initial string at class level, `tmp` our temporary one (as mentioned above to proceed incrementally with already validated string chunks);\\n* `len` will store the length of our initial input;\\n* `digitsLeft` will keep track of how many digits we still need to add in our current `tmp` iteration, initially set to `4`.\\n\\nIn our main function, we will first of all give a proper value to `len`, then check if it is a value worth checking: any string outside of the `4 - 12` range would of course not work for us, providing either too few or too many digits for us to parse.\\n\\nIf we are still in, then we can assign a proper value to `s` and launch our `dfs` helper to compute all the possible permutations.\\n\\nThis helper function will take only one parameter (since I prefer keep as much as possible at class level, instead of passing copies or references of any information at class level), `start`, telling us from which character in `s` we start parsing; we will then:\\n* check if we reached an end case - ie: we are done adding digits to `tmp` (`digitsLeft == 0`), in which case:\\n\\t* if we know we exactly finished parsing the string (`start == len`) we also know we are checking a valid string, so we can append it to `res`;\\n\\t* in any case, we stop recursing with a `return` statement;\\n* if we are in the general case, we need to then consider three possible scenarios:\\n\\t* we can add `1` digit to `tmp`, which is always a valid scenario (I still left a conditional as a placeholder, in order to further optimise that on later iterations and, in any case, more easily tell the decision block apart):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 1`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `2` digits to `tmp`, provided we have enough characters left and the first one is not `\\'0\\'` (no leading zeroes allowed!):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `3` digits to `tmp`, provided we have enough characters left and the first one is `\\'1\\'` followed by any number of `\\'2\\'` followed by any number `< \\'4\\'` or followed by `\\'5\\'` in turn: by any third digits `< \\'6\\'`:\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `s[start + 2]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`.\\n\\nOnce done, we can just `return` `res` and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nHey, we are adding and removing a lot of characters in our three cases, arent\\'t we? Well, it turns out that the third case will be valid only if the first two digits are in the valid range and the first to digits are in the valid range when the first one is (which happens always), so we can avoid a bit of repeated code, manage `digitsLeft` only once and streamline our construction of `tmp` a bit more efficiently and in a DRYer fashion, like this:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nNow, remember that placeholder conditional I put before the first block for adding one digit to `tmp`?\\n\\nI wanted to optimise it so that it would give us only calls when we have enough characters left to recurse; for example, if our initial string is `\"255255255255\"`, there is clearly no point in taking only `\\'2`\\', since we cannot make `3` other valid digits with the left over (`\"55255255255\"`); it turns out it works wonders, since I tried for example without these conditionals the previous code for `\"25525511135\"` would have `71` recursive calls; with my code, it is now only `9`\\uD83D\\uDE0E!\\n\\nWe will also need to update `tmp` regardless at each step, since we might have some cases in which the second digit is not enough, but the third is okay or the like; but it works wonders in this new version:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nThe last tiny bit of optimisation, to avoid reallocations, will be to set `res` initially always to get the maximum capacity of `19` (the longest possible series of permutations we might have for a string like `\"11111111\"`) and then resize accordingly, to avoid reallocations - it saves a bit of memory, it seems, but not as much as cutting on the needless recursions:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662631,
                "title": "intuitive-easy-to-understand-c-code",
                "content": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nAn upvote would be appreciated. ^_^",
                "solutionTags": [],
                "code": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433047,
                "title": "c-bracktracking-solution",
                "content": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381550,
                "title": "swift-restore-ip-addresses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340970,
                "title": "java-easy-accepted-solution",
                "content": "\\' \\' \\'\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n    \\n    public boolean check(String s) {\\n\\n\\t\\tif (s.length() > 3 || \\n            s.length() == 0 || \\n            s.charAt(0) == \\'0\\' && s.length() > 1 || \\n            Integer.parseInt(s) > 255) \\n         {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1323898,
                "title": "what-if-the-length-of-string-is-greater-than-12-java-solution-1ms",
                "content": "\\tclass Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(state == 5) return;\\n\\t\\t\\tfor(int i=1; i+idx <= s.length() && i <= 3; i++) {\\n\\t\\t\\t\\tString currStr = s.substring(idx, idx+i);\\n\\t\\t\\t\\tif(currStr.length() >= 2 && currStr.charAt(0) == \\'0\\') return;\\n\\t\\t\\t\\tint value = Integer.parseInt(currStr);\\n\\t\\t\\t\\tif(value >= 0 && value <= 255) {\\n\\t\\t\\t\\t\\tcans.append(\\'.\\').append(currStr);\\n\\t\\t\\t\\t\\trestoreIp(s, i+idx, state+1, cans);\\n\\t\\t\\t\\t\\tcans.delete(cans.length() - currStr.length() - 1, cans.length());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\t\\tres = new ArrayList<>();\\n\\t\\t\\tif(s.length() > 12) return res;\\n\\t\\t\\trestoreIp(s, 0, 1, new StringBuilder());\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1231786,
                "title": "c-backtracking",
                "content": "simple backtracking algorithm checking every condition\\nhere \\n\\ti=next index to be considered of string s\\n\\tcnt=number of elements\\n```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215702,
                "title": "python-recursion-no-backtracking",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944975,
                "title": "java-backtrack-solution-with-complexity-explanation",
                "content": "Let\\'s define general problem: given string `s`, find all possible groups of `M` numbers with each number at most `K` digit length. The time complexity of this code will be `O(MK\\xB2 K^M)`. Here is the code with comments.\\nIn reality a lot of  unnecessary branches are deleted, so this complexity is upper bound. Also, we can improve complexity to `O(MK K^M)`\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838805,
                "title": "simple-js-backtrack-solution-with-comments-beat-97",
                "content": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817580,
                "title": "my-simple-dfs-python-solution-beat-99-14",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767434,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767409,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767087,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767819,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767353,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767299,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1985960,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1973018,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1969609,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1853189,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1809457,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1798472,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1769855,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768530,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768193,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768189,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768071,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768051,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768005,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767964,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767956,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767955,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767915,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767914,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767893,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767864,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767847,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767837,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767815,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767610,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767556,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767398,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767396,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767395,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767357,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767354,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767352,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767348,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767347,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767346,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Phone Numbers",
        "question_content": "<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>file.txt</code> has the following content:</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>Your script should output the following valid phone numbers:</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n",
        "solutions": [
            {
                "id": 2254239,
                "title": "bash-simple-regular-expression-with-explanation",
                "content": "\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\\nthis is a grep command accepting two regular expressions\\n1 .```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n2 .```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n\\nThe construction is as follows \\n* ^: indicates the starting of the string\\n* $: indicates the end of the string\\n* [0-9]\\\\\\\\{3\\\\\\\\} : represent 3 numbers (\\\\\\\\{3\\\\\\\\})  between the range 0-9 ([0-9] a digit in the range) \\n* \\\\\\\\: suppresses the specialness of the character\\n* -e: to include multiple regex",
                "solutionTags": [],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\n```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\n```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206032,
                "title": "simple-bash-solutions-explained-grep-awk",
                "content": "I have compiled a list of possible solutions using grep or awk as well as explaining the tools/syntax used. Hope it helps!\\n\\n**Common syntax explained:**\\n* `^` Start of a line (not just within a line, ex `112-122-2313` **not** `022121-112-2313`)\\n* `[0-9]` regex expression to represent any digit between 0 and 9.\\n* `\\\\d` any digit (Perl-flavoured regular expression) *Note the compiler uses GNU/Linux so to use \\\\d use the `-P` tag*\\n* `{3}` repeated exactly 3 times, `{4}` repeated 4 times ect, hence `[0-9]{3}` means three numbers from 0-9.\\n* `$` end of a line\\n* `|` or expression\\n* `()` used to group expressions\\n* `\\\\(` or`\\\\)` used for literal parentheses \\n\\n\\n##### 1. Using a `grep` search with the extended regular expressions.\\n`-E` Extended regular expressions same as `egrep`\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\nor\\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\n\\n\\n##### 2. Using `grep` with Perl-flavoured regular expression\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n\\n##### 3. Using an `awk` search with regex values\\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492218,
                "title": "small-regex-100-faster",
                "content": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661297,
                "title": "valid-numbers",
                "content": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "solutionTags": [],
                "code": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "codeTag": "Unknown"
            },
            {
                "id": 843424,
                "title": "bash-easy-one-liner",
                "content": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558581,
                "title": "bash-grep-bre-ere-pcre",
                "content": "Regular exrepssion (regex) has at least 3 official flavors: \\n1) basic regex (BRE)\\n2) extended regex (ERE)\\n3) perl-compatible regex (PCRE)\\n\\nThey share great resemblance and yet differ in details. Below implementation uses `grep` as an example which by default applies BRE. `-E` turns on ERE and `-P` turns on PCRE. \\n\\n```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "solutionTags": [],
                "code": "```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474498,
                "title": "this-solution-is-faster-than-100-00-of-bash-online-submissions-for-valid-phone-numbers",
                "content": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362277,
                "title": "simple-the-interviewer-who-asked-this-question-should-be-disqualified-from-interview-panel",
                "content": "Simple: the interviewer who asked this question should be disqualified from interview panel.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1477728,
                "title": "two-one-line-solution-grep-or-sed-unix-solution",
                "content": "grep (find the numbers which are matched, which is straight-forward):\\n```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\nsed (delete the numbers which are mismatched):\\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380998,
                "title": "why-is-this-failing-when-it-works-locally",
                "content": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```\\n\\npasses 21/26 test cases but not \\n123-456-7891 ?",
                "solutionTags": [],
                "code": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733675,
                "title": "grep-easy-pattern-matching",
                "content": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\nPlease **UpVote**, if you understood the code.",
                "solutionTags": [],
                "code": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468126,
                "title": "simplest-regex",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834603,
                "title": "solution-0ms-100-3-1mb",
                "content": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218882,
                "title": "193-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- grep command is used to search for a pattern in a file or files.\\n- -E option is used to enable extended regular expressions.\\n```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n``` \\nis the regular expression pattern that we want to match against each line in the file.\\n- ^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern.\\n- \\\\( and \\\\) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions.\\n- [0-9]{3} is used to match exactly three digits.\\n- | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen.\\n- file.txt is the name of the file that we want to search.\\n\\nThis regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx.\\n\\nThe output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n```\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154012,
                "title": "grep-p-solution",
                "content": "## Intro\\n\\nThis is a simple Perl RegEx solution. It requires no other commands. If additional challenges were added, this may become a bit too noisy as a one liner.\\n\\n## Solution\\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\\n\\n## Breakdown\\n\\nWe start off with the start of line (`^`) check. Without this, we could hit invalid entries that say start with other characters.\\n\\n`(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)` - This is a group selector inside the outer parentheses (`()`), which is primarily for the usage of the pipe (`|`) which is used as an or. So to break it down further:\\n\\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\\n\\nSo we have two different start of line options, only matching the two possibilities we have. The top one is selecting a literal open parantheses, 3 digits, and a literal closing parantheses, followed by a space. Using curly braces with a number inside can be used to represent how many of a given character prior should exist. So this says 3 `\\\\d` should exist. `\\\\d` is any digit, same as `[0-9]`.\\n\\nThe bottom searchers for 3 digits followed by a hyphen.\\n\\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```\\n\\nWhat remains is 3 digits, a literal hyphen, and 4 digits, then end of line. We must anchor to the end of line using `$`, as sometimes there may be trailing whitespace or other characters.",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122020,
                "title": "short-solution-using-grep-with-explanation",
                "content": "**One-liner solution**\\n```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\n\\n**^ symbol for must begin with, xxx- OR \\'(xxx) \\' quoted for space.**\\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\\n\\n**$ symbol for must end with xxx-xxxx**\\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```\\n\\n**where x\\'s are digits**",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413833,
                "title": "grep-only-0ms-extended-regex-and-regex",
                "content": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```\\n\\n- https://www.gnu.org/software/grep/manual/grep.html\\n**-E**\\n**--extended-regexp**\\nInterpret patterns as extended regular expressions (EREs). (-E is specified by POSIX.)\\n\\n- https://www.zyxware.com/articles/4627/difference-between-grep-and-egrep\\n In egrep, +, ?, |, (, and ),  treated as meta characters. Where as in grep, they are rather treated as pattern instead of meta characters. By including \\'backslash\\' followed by meta character can let the grep to treat it as meta characters like \\\\?, \\\\+, \\\\{, \\\\|, \\\\(, and \\\\). \\n",
                "solutionTags": [],
                "code": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55474,
                "title": "simple-solution-using-awk",
                "content": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722034,
                "title": "one-line-bash-solution",
                "content": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 1290845,
                "title": "awk-and-regex",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038346,
                "title": "grep-regex",
                "content": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276464,
                "title": "grep-solution-beats-100",
                "content": "A easy way to get it by using grep\\n\\n-E means use regular expression\\n\\n```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199579,
                "title": "one-line-grep-e",
                "content": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55492,
                "title": "my-grep-e-solution",
                "content": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2562390,
                "title": "simple-sol-using-grep",
                "content": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259212,
                "title": "proper-grep-solution-with-standard-pcre-regex",
                "content": "Easy to understand what is going on.\\n\\nGrep flags used:\\n* \\t```-o``` for printing results in newline\\n* \\t```-P``` to enable standard PCRE regex matching followed by the regex expression.\\n\\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```-o```\n```-P```\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035332,
                "title": "grep-e",
                "content": "here is my code.\\nI use grep with extended RE.\\n`[0-9]{3}` means digit exactly 3 times\\n`^` is start of line\\n`$` is end of line\\n`|` is alternative\\n`()` are for grouping\\n`\\\\(` `\\\\)` are literally parentasis (not interpered as grouping)\\n```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903384,
                "title": "grep-e-solution-with-regex",
                "content": "## grep -E Solution with regex\\n--- \\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604453,
                "title": "0ms-solution-100-faster",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196980,
                "title": "sed-regex-1-liner-explanation",
                "content": "## Explanation\\nThe idea is to local certain pattern and print them out. `regex` is the perfect choice to locate the pattern. `sed` can be a easy to use helper here.\\n\\nThere are 2 patterns needed:\\n- For `123-456-7890`, we can use pattern like this\\n\\t- `^[0-9]{3}-[0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with 3 digits (`^[0-9]{3}`), then a dash `-`, another 3 digits (`[0-9]{3}`) with a dash `-`, then ending with 4 digits (`[0-9]{4}$`)\\n- For `(123) 456-7890`, pattern will be like\\n\\t- `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with a open parenthesis `\\\\(` need to use back slash to escape, then 3 digits (`[0-9]{3}`) and a ending parenthesis `\\\\)`, then a space ` `, the rest will be similar to the first pattern\\n\\nIn `sed`:\\n- `-n`: is to silence the auto printout (default by `sed`)\\n- `-r`: is to use extended regex \\n\\n## Implementation\\n```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989190,
                "title": "grep-extended-regex",
                "content": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2953181,
                "title": "just-bash-regex",
                "content": "Using bash regex only.\\nRead a file line by line, first check the simple expression in case most of the phone numbers will be in a simpler format.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709293,
                "title": "bash-one-liner",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310460,
                "title": "bash-cat-grep",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950357,
                "title": "this-solution-can-not-be-more-uglier-but-hey-at-least-it-works-d",
                "content": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 619864,
                "title": "grep-e-approach-simplified",
                "content": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345439,
                "title": "grep-e-solution-is-pretty-straightforward-to-me-why-doesn-t-this-work-any-ideas",
                "content": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315493,
                "title": "grep-e-solution",
                "content": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "solutionTags": [],
                "code": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 307062,
                "title": "using-bash-regex",
                "content": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134523,
                "title": "why-is-grep-e-d-3-d-3-d-4-d-3-d-3-d-4-file-txt-wrong",
                "content": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\nError message:\\n\\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\\n\\n\\nHowever, the following works:\\n\\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nThe only difference is `[0-9]` instead of `\\\\d`.\\n\\nOn my laptop (macOS), both work.",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519756,
                "title": "easy-and-simple-0-wow-0-0",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```\\nThis script uses grep command with extended regular expressions (-E) to match the pattern of valid phone numbers. The pattern matches either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The ^ and $ characters are used to match the beginning and end of each line respectively13",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524504,
                "title": "simple-solution-with-grep-e-with-or-detail-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nFor detail explnation please refer:\\nhttps://leet-codes.blogspot.com/2022/09/193-valid-phone-numbers.html\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400775,
                "title": "one-line-grep-command",
                "content": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 2297326,
                "title": "regex-runtime-649-ms-faster-than-5-46-of-go-submissions",
                "content": "**Complexity Analysis**\\n* Time: O(N), where N is the number of lines within the file.txt.\\n* Space: O(1), constant number of variables used.\\n\\n```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241958,
                "title": "one-line-solution-with-regex",
                "content": "Here is my solution:\\n\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nor \\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112639,
                "title": "bash-easy-one-liner",
                "content": "https://leetcode.com/problems/valid-phone-numbers/discuss/843424/BASH-Easy-One-Liner\\n\\n```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\\n\\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713083,
                "title": "grep-runtime-4-ms-memory-usage-3-1-mb",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1413815,
                "title": "0ms-solution-100-faster",
                "content": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349446,
                "title": "egrep-solution-with-cat",
                "content": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239047,
                "title": "no-grep-solution-actually-works",
                "content": "It took me a while, as some attempts \"work on my machine\" but not here lol. I\\'m sure this can be simplified, but it took me a few hours to get this to work, so will stop here and see if anyone out there improves upon it. Using a slightly shorter regex, and even looking at SO examples, people seem to not care about a number formatted like so `(123 456-7890` where one of the parentheses was missing. It wasn\\'t part of the tested inputs, but I wanted to account for it as an exercise.\\n\\nSo, I just resorted to using the `|` (or) operator to check both formats. It was key to include `^$` both times as without it, the regex would match the number \"0(001...\".\\n\\n\\n```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027254,
                "title": "grep-p",
                "content": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 703796,
                "title": "query-related-to-input",
                "content": "Can anyone tell me why this input is not valid \\n```(001)-345-0000```\\n\\nthis is my bash one liner\\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```\\n\\nit also accepts the above number but gets an error saying it should not get accepted\\n",
                "solutionTags": [],
                "code": "```(001)-345-0000```\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 576595,
                "title": "grep-e",
                "content": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 553002,
                "title": "mac-bash-or-linux-bash",
                "content": "At first, I use this code:\\n```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\\nIt works in my mac bash shell, but failed for the submission.\\nThen I changed my code to below:\\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```\\nThen passed...",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434768,
                "title": "solution-without-grep-awk-sed",
                "content": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429265,
                "title": "trivial-awk-solution-probably-been-posted-before",
                "content": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "solutionTags": [],
                "code": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399441,
                "title": "time-0ms-beats-100-with-memory-3-1-mb-simple-using-regex-grep",
                "content": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331165,
                "title": "grep-p-solution-using-conditional-regex-with-explanation",
                "content": "Conditional regular expressions are not always the most efficient solution. However, they _can_ be really useful in reducing the length of the regular expression by removing a long \"or\" statement with repeating elements. This is not one of those cases, but it\\'s a fun solution. The downside is that they are harder to read.\\n\\n```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n\\n`(\\\\()?` - capture opening parenthesis at start as group 1, if it exists\\n`\\\\d{3}` - 3 digit area code\\n`(?(1)\\\\) |-)` - If an opening parenthesis was captured as group 1, grab a closing parenthesis followed by a space. Otherwise, look for a dash.\\n`\\\\d{3}-\\\\d{4}` - get the rest of the number.\\n\\nThis is effectively equivalent to \\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319401,
                "title": "egrep-solution",
                "content": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274502,
                "title": "egrep-solution",
                "content": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261478,
                "title": "fastest-awk-solution-8ms",
                "content": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```\\n\\nSimply processes each line and checks if the entire record (default newline separated) has exactly the needed formats specified and prints each line that does.",
                "solutionTags": [],
                "code": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182286,
                "title": "grep",
                "content": "Never use solutions like these.\nDebugging this would be hell.\n```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "solutionTags": [],
                "code": "```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55477,
                "title": "whereis-wrong-with-my-pattern-ask-for-help",
                "content": "my grep solution, the code is like:\\n```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```\\nbut when it came across test case \"123-456-7891\", it didn't print out anything. could someone tell me why please?\\nYet I put test case \"123-456-7891\" into a file, and open it with notepad++ on windows, using the same pattern to find matched lines, and it worked! That really makes me confused",
                "solutionTags": [],
                "code": "```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55498,
                "title": "wrong-output-of-shell-question-valid-phone-number",
                "content": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 4077522,
                "title": "it-was-easy",
                "content": "\\u0628\\u0633\\u0645 \\u0627\\u0644\\u0644\\u0647 \\u0627\\u0644\\u0631\\u062D\\u0645\\u0646 \\u0627\\u0644\\u0631\\u062D\\u06CC\\u0645\\n## hello guys!\\nIt was really easy :) . am I rigth?\\nIt was only necessary to use the **`grep`** command and to know **Regex**.\\nu should have written something like this command :\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\nGod bless you and have nice time my friend !!",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076529,
                "title": "bash-script-to-extract-and-print-valid-phone-numbers-from-a-text-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find and print valid phone numbers from a text file. We need to define the patterns for valid phone numbers and extract them from the file.\\n\\n\\n# ApproachSpace complexity: The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use the grep command with regular expressions to match and extract valid phone numbers from the text file.\\nWe define two regular expressions to match two formats: (xxx) xxx-xxxx and xxx-xxx-xxxx.\\nThe -E option enables extended regular expressions.\\nWe use ^ to match the start of the line and $ to match the end of the line to ensure that we capture complete phone numbers.\\nWe use \\\\( and \\\\) to match parentheses and [0-9]{3} to match exactly three digits.\\nWe use [0-9]{4} to match exactly four digits.\\nThe | character is used to match either of the two formats.\\nFinally, we specify the input file as file.txt to search for valid phone numbers in it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The grep command operates in linear time based on the size of the input file, making it efficient for large files. So, the time complexity is O(n), where n is the size of the input file.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024485,
                "title": "one-line-solution-with-grep-99-5-performance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCommand checks two pattern in regex\\n1. `xxx-xxx-xxxx`\\n2. `(xxx) xxx-xxxx`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023972,
                "title": "simple-grep-and-regex-with-explanation-95-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most straight forward approach would be to use grep. grep already knows how to handle multilines so no special treatment required. Next is to just figure out a pattern.\\n\\nThe latter half of the number format share a common pattern, so it should allow me to combine the patterns into a single pattern with a `|` \\'or\\' operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first iteration omitted the line beginning/ending, which caught me off guard when the number is invalid when there are more numbers at the ends of it.\\n\\nSome considerations involve which flavor of grep do we want to use?\\nHow complex do we want our code?\\nDo we want to try fix broken formatted numbers?\\n\\nin the end, KISS applies\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ as each line is evaluated just once\\n\\n- Space complexity: $$O(1)$$ you only store matches, at most you\\'d store two copy of the same file in memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```\\n`-o` returns only pattern without the full line. It\\'s moot here since the whole line is to be matched, but would be handy if the phone number is hidden between other text.\\n\\n`-E` just enables the extended regex (ERE). See [difference](https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html) of Basic Regular Expressions (BRE) vs Extended Regular Expressions (ERE). **TL;DR** ERE is more readable and you end up with less `\\\\`.\\n\\n# [Regex Explanation](regexr.com/7jt1e)",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004162,
                "title": "bash-simple-solution-grep",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962899,
                "title": "one-liner-bash-command-to-get-valid-phone-numbers-with-minimum-complexity",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis script uses grep with the -E flag to enable extended regular expressions. The regular expression used in the script matches either of the valid phone number formats you mentioned. It uses the ^ and $ anchors to match the entire line, ensuring that there are no leading or trailing characters. \\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938487,
                "title": "using-bash-pattern-matching",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926378,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926363,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919277,
                "title": "using-awk-command",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900004,
                "title": "bash",
                "content": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 3892269,
                "title": "bash-with-regular-expression-and-grep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881004,
                "title": "faster-than-99-54",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855494,
                "title": "bash-expected-solution-grep-and-regex",
                "content": "# Solution\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833012,
                "title": "grep-regex-full-regex-step-by-step-explanation",
                "content": "# Approach\\n`grep` is a CLI tool that can be used to extract text from a file (among other things) that matches a regular expression (RegEx).\\n\\nFirst, `grep` can be used like `grep -E \\'\\' file.txt` where the regular expression goes inside the `\\'\\'`.\\n\\nTo denote that the full string is matched, `^` and `$` is used to denote start of the string and end of the string respectively. So regex is now `^$`.\\n\\nEach `x` represents a digit, which is `[0-9]` in RegEx. `xxx` denotes exactly 3 digits, which can be represented as `[0-9]{3}` in Regex, while `-` and ` ` can be matched by `-` and ` ` respectively. Also `(` and `)` can be matched by `\\\\(` and `\\\\)` (`(` and `)` need to be escaped using the `\\\\` as without escaping, they represent a group in RegEx).\\n\\nSo `xxx-xxx-xxxx` can be matched by `^[0-9]{3}-[0-9]{3}-[0-9]{4}$` and `(xxx) xxx-xxxx` can be matched by `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`.\\n\\nCombining these with an OR gives the final regex as:\\n`^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$`\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807278,
                "title": "bash-egrep",
                "content": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792036,
                "title": "simple-solution-using-grep-extended-and-regex",
                "content": "# Intuition\\nTo output patterns that matches either of the two cases, we can use regex for pattern matching and grep.\\n\\n# Aproach\\nIn both the cases, the last part of the pattern matching requires \\n1. number `0-9` 3 times - `[0-9]{3}`\\n2. then a `-` \\n3. and then `0-9` 4 times - `[0-9]{4}`\\n4. followed by the end of the line - `dollar sign`.\\n\\nRegex for this would be `[0-9]{3}-[0-9]{4}$`.\\n\\nFor the first part of the pattern, the pattern is either - `\\\\([0-9]{3}\\\\) ` or `[0-9]{3}-`. Start of the line is denoted by `^`\\n\\nThis can be expressed in regex as  `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`\\n\\n\\n# Code\\nFinal regex is the combination of the two regex. We will be using extended grep (by using -E) as the normal grep command does not support some of the regex used here.\\n\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791792,
                "title": "one-line-solution-using-grep-command",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\nin this script uses grep command with (-E) treats as an extended regular expression. it is used for matching the pattern of valid phone numbers.So by this the pattern matches to the (123) 456_7890 or 987-123-4567 format. ^ used for match the beginning and $ used for end of line respectively. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740773,
                "title": "beats-70-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706732,
                "title": "valid-phone-numbers-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701455,
                "title": "using-grep-p",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691134,
                "title": "beats-100-and-detailed-explanation",
                "content": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3675921,
                "title": "bash",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n``` ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669706,
                "title": "two-short-accepted-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\\n\\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660167,
                "title": "mine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659229,
                "title": "use-sed",
                "content": "# Intuition\\nUse `sed`\\n\\n# Approach\\n`BSD sed` accepts a `-E` option for specifying extended (modern) regular expressions.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(mn)$ - $m, n$ are the maxlength of lines in the file, and number of lines in the file\\n\\n- Space complexity:\\n$O(m)$ - `sed` processes a line of input file at a time held within its memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615463,
                "title": "valid-phone-numbers-intuition-with-image",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![2023-06-09_03-41-45.png](https://assets.leetcode.com/users/images/f47f81e2-c687-4d76-83a2-687590a0cc53_1686262419.4819312.png)\\n\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612561,
                "title": "bash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596986,
                "title": "using-regular-expression-matching-operator-bash-hyder-nabi",
                "content": "# Steps: \\n1. Read the input file line by line.\\n2. For each line X\\n    a. Match the line againest the pattern using =~ operator\\n    b. Print the line if match was successful\\n    c. Skip otherwise.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NoOfLines))$$\\n- Assuming the comparison takes $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544077,
                "title": "egrep-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529042,
                "title": "valid-phone-number-with-grep-and-regex-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI wanted to read the file line by line but then I realised that this could be solved more easily through regex.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was a lot of trial and errors because I could not see the tests to prepare my regex for it, after strugling for a while I took a look at some solutions and it helped me compose mine a lot better, for some reason using -P the Perl regex parsing method worked better than the -E Extended regex mode.\\n\\n# Explanation\\n\\nREGEX `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$`\\n\\nThe first part `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$` to catch `987-123-4567`\\n\\n- `^` it must begin with what comes after this sign\\n- `[\\\\d]{3}` grabs the first 3 digits\\n- `-[\\\\d]{3}` grabs 3 more digits, with a -\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\nThe second part `^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}DOLLAR SIGN` to catch `(123) 456-7890`\\n\\n- `^` it must begin with what comes after this sign\\n- `\\\\(\\\\d{3}\\\\)` grabs the first 3 digits in between `(`, `)`\\n- `\\\\s` adds a white space\\n- `[\\\\d]{3}` grabs 3 more digits\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\n\\n# Code\\n```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516737,
                "title": "a-simple-grep-approch-with-regexp",
                "content": "# Intuition\\nUsing a simple grep with regexp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511116,
                "title": "grep-one-liner-for-personal-note",
                "content": "- `.` - matches any single character except a newline.\\n- `^` - matches the start of a line.\\n- `$` - matches the end of a line.\\n- `*` - matches zero or more occurrences of the previous character or pattern.\\n- `+` - matches one or more occurrences of the previous character or pattern.\\n- `?` - matches zero or one occurrence of the previous character or pattern.\\n- `{m}` - matches exactly `m` occurrences of the previous character or pattern.\\n- `{m,n}` - matches between `m` and `n` occurrences of the previous character or pattern.\\n- `[abc]` - matches any of the characters `a`, `b`, or `c`.\\n- `[^abc]` - matches any character except `a`, `b`, or `c`.\\n- `[a-z]` - matches any character between `a` and `z`.\\n- `(` and `)` - used for grouping patterns together.\\n- `|` - used to specify alternatives between patterns.\\n- `\\\\` - used to escape a special character or to give special meaning to a character.\\n\\n# Code\\n```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505123,
                "title": "bash-grep-regex",
                "content": "# Intuition\\nUse grep with a regular expression.\\n\\n# Approach\\nUse grep with a regular expression.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490365,
                "title": "unique-solution-with-while-loop",
                "content": "##### Complexity \\nSee this image for reference\\n\\n![Uq.jpg](https://assets.leetcode.com/users/images/79b2042e-1ec6-4052-b802-b48d25982efd_1683309341.9463682.jpeg)\\n\\n\\n# Code\\n```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474368,
                "title": "solution",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473779,
                "title": "your-mother",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI sucked monkey. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecome a monkey. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n) runtime because it\\'s too big brain for you clowns.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nNo space complexity because it\\'s too complex for your tiny brains.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460156,
                "title": "laconic-solution-of-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUtilize RegExp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRegular expression\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n90ns\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n3.0 mb\\n# Code\\n```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453539,
                "title": "one-line-bash-command",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451451,
                "title": "with-explanation",
                "content": "https://leetcode.com/problems/valid-phone-numbers/solutions/3218882/193-solution-step-by-step-explanation/ \\n\\nplease check for more explanation\\n\\n# Approach\\n^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern. - ( and ) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions. - [0-9]{3} is used to match exactly three digits. - | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen. - file.txt is the name of the file that we want to search. This regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx. The output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402595,
                "title": "oneline-bash-command",
                "content": "\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396239,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389178,
                "title": "valid-phone-num-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370702,
                "title": "193-valid-phone-numbers",
                "content": "# Intuition\\nThe problem requires us to extract all valid phone numbers from a text file, where a valid phone number is defined as a number in either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The task is to write a one-liner bash script that can extract all valid phone numbers from the file.\\n\\n# Approach\\nThe approach involves using the grep command with extended regular expression syntax (-E option) to match lines that start with either (xxx) or xxx-, followed by three digits, a hyphen, and then four digits. The ^ and $ characters anchor the expression to the beginning and end of each line. The | character inside the parentheses matches either (xxx) or xxx-.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the program is O(n), where n is the total number of characters in the input file. This is because grep processes each line of the file only once, and its time complexity is proportional to the number of characters in the line.\\n\\n- Space complexity:\\nThe space complexity of the program is O(1), because it doesn\\'t require any extra space beyond the input file and the memory used by the grep command. The grep command works on a line-by-line basis and doesn\\'t store the entire input file in memory at once.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368147,
                "title": "single-line-use-grep",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364420,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341072,
                "title": "simple-regex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Just simple Regex \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> -\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> - \\n \\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336424,
                "title": "grep-p-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nm)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326851,
                "title": "using-gawk-to-solve-this-problem-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$0 prints the entire input if it pass the testcase.\\ninput is each new line from the file.\\n\\nTips:\\nYou have to escape parenthesis using backslash \\\\\\n{3} means 3 occurence.\\n[0-9] is the range\\nand (apple|mango) means either apple or mango.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310752,
                "title": "one-line",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285570,
                "title": "sed-easy-solution-1-line-solution-easy-explanation",
                "content": "\\n# Code\\n```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\\n# Explanation\\n- ```-n``` supress the default printing behaviour of sed.\\n\\n- ```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)``` \\'XXX \\' or \\'(XXX)\\'\\n     - ```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)``` should start with this pattern.\\n- ```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-``` \\'XXX-\\'\\n- ```[[:digit:]]\\\\{4\\\\}``` \\'XXX\\'\\n- ```$``` represents the End of the Line\\n- ```(/<Regular expression pattern>/p)``` syntax for sed command to print the matched RE.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\n```-n```\n```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)```\n```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)```\n```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-```\n```[[:digit:]]\\\\{4\\\\}```\n```$```\n```(/<Regular expression pattern>/p)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276839,
                "title": "193-valid-phone-numbers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244342,
                "title": "one-liner-with-explanation",
                "content": "# How it\\'s works\\n\\n- The grep command is used to search for lines in `file.txt` that match a regular expression.\\n\\n- The regular expression used in the command matches two possible formats for a valid phone number:\\n\\n- The phone number starts with an opening parenthesis, followed by three digits, a closing parenthesis, a space, three digits, a dash, and four digits.\\n\\n- The phone number starts with three digits, a dash, three digits, a dash, and four digits.\\nThe `-E` option is used to enable extended regular expressions.\\n\\n- The `^` and `$` symbols are used to ensure that the regular expression matches the entire line (i.e., the phone number must be the only thing on the line).\\n\\n- The | symbol is used to allow either the (xxx) xxx-xxxx or xxx-xxx-xxxx format to match.\\n\\n\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219386,
                "title": "some-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209903,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169534,
                "title": "sed-regex",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162746,
                "title": "easy-method-100-faster-one-linear",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157858,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133940,
                "title": "very-easy-soln",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132608,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125290,
                "title": "clean-code-high-speed-beats-98-9",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121902,
                "title": "accepted-bash",
                "content": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107103,
                "title": "readable-bash-solution-with-an-explanation",
                "content": "# Intuition\\nWe need a way to read out a file\\'s contents with applied filtering on a line basis. \\n\\n * *cat* short for concatenate (verb, to join or link together, as though in a chain) is a program to read one or multiple files and print them on the standard output of the terminal.\\n example:\\n ```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\\n * *grep* is the second piece of the puzzle. It is a program that takes whatever is passed to it and applies user supplied filtering in the form of *regular expressions* to each line.\\n ```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\\nNow let\\'s filter based on the formats in the problem description.\\n\\nThe first  pattern is `xxx-xxx-xxxx`, where `x` is any digit from 0 to 9. By default, grep understands only basic regular expressions, you can read up on what exactly that is by typing `man grep` inside a terminal. If we want the full regex experience we have to supply the `-P` flag, denoting that we want to use Perl flavoured regular expressions. We do this so we can use `\\\\d` to denote a digit, which grep wouldn\\'t understand otherwise.\\n\\nSo our first pattern would be \\n`^\\\\d{3}-\\\\d{3}-\\\\d{4}$`<br><br>\\n\\nIt reads as the following - 3 digits, followed by a hyphen `-` and 3 more digits, followed by a hyphen `-` and 4 more digits. The caret symbol `^` and the dollar `$` denote that we want that to be the full line. Caret means match the match has to begin from the first symbol on the line, and dollar means that it should be the last as well. In other words nothing should follow or preceed it.\\n\\nOur second pattern should match `(xxx) xxx-xxxx`, so the regex would look something like this:\\n`\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}`\\n\\nNote the escaping of the brackets with `\\\\(`, we do this because `(` is a special symbol for grouping things, so we have to escape it.\\n\\nThe last problem that we have to solve is to write a single regular expression that matches our first pattern *OR* our second one. we can do this like so - `(foo|bar)` this would either foo or bar.\\n\\nSo our final expression would look like this:\\n\\n`grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\n\\n\\nNow we need a way to combine *cat* and *grep*. In the terminal world, we use *pipes*, denoted by the `|` symbol. What piping does is that it feeds the output of one command to the next, like making a real pipe. We want to feed *grep* the output of `cat file.txt`:\\n`cat file.txt | grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\nTo make things more readable I like to extract the simple subpatterns inside bash variables, and so we come to our\\n\\n# Final Solution\\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\n```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095416,
                "title": "worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090510,
                "title": "80-beat-simple-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069619,
                "title": "trivial-beats-100",
                "content": "\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068129,
                "title": "valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056937,
                "title": "valid-phone-numbers-bash-solution",
                "content": "One Liner Bash Solution\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042657,
                "title": "grep-p-d-3-d-3-d-3-d-4-file-txt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe grep code has four parts in it as the valid phone number can be constructed using the possible combiantion of any three from the below four parts.\\n\\n1. ^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) ) ---> valid phone number can start ^(... either with \\n\\\\d{3}- --> 3 digits and - or (|) #2\\n2.  \\\\(\\\\d{3}\\\\) ) --> (3 digits and one space)\\n3. d{3}- --> 3 digits and a dash\\n4. d{4} --> 4 digits \\n\\nAny combination of above 1,3,4 or 1,2,4 is a valid phone number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011494,
                "title": "one-line-grep-with-shortest-regex",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n## Regex explain\\n\\nStart with `999-` or `(999) ` followed by `999-9999` then end line. Where `9` means numbers from `0` to `9`.\\n\\n`^` - Start line\\n`()` - Group expression\\n`\\\\d` - any number 0 to 9\\n`{n}` - repeat expression n times\\n`|` - or operator\\n`$` - Finish line",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006820,
                "title": "grep-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by using a regular expression to match valid phone numbers in a file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach to this problem is to use the grep command and a regular expression to search for valid phone numbers in the file.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of grep and the size of the file. In general, the time complexity of grep is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of grep and the size of the file. In general, the space complexity of grep is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2988675,
                "title": "bash-valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use `grep` to search the a particular pattern of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermined the regex of the valid phone numbers then use the `grep` to filter them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981642,
                "title": "pure-posix-compliant-shell-solution-without-external-commands-beats-99-89",
                "content": "# Approach\\n\\nPure POSIX shell without calls to external commands. This will work not only on Bash, but virtually any POSIX-compliant shell going back to the 80s.\\n\\nIn addition, despite being marginally slower (beats 99.89%) than what some other users have reported out of grep solutions, this is actually significantly faster than any of those solutions due to the fact that calls to external commands require the shell to fork.\\n\\nAs such, this can be as much as ~50x faster than grep.\\n\\n# Code\\n```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\\n\\n# Benchmarks\\n\\n* zsh = Homebrew zsh 5.9.0.1-dev\\n* bash5 = Homebrew Bash 5.2.2\\n* bash3 = Apple\\'s Bash 3.2.57\\n* dash = pkgsrc Debian Almquist shell\\n* yash = pkgsrc yash\\n* bosh = pkgsrc Schily bosh\\n* pbosh = pkgsrc Schily pbosh\\n* mksh = pkgsrc MirBSD Korn Shell\\n* oksh = pkgsrc OpenBSD Korn Shell\\n* pdksh = pkgsrc Public Domain Korn Shell\\n* ksh93 = pkgsrc AT&T Ksh93 Korn Shell (93u+m/1.0.4+f7ce04bb)\\n* ksh93u_plus = Apple\\'s AT&T Ksh93 Korn Shell (93u+ 2012-08-01)\\n* awk = pkgsrc awk (OneTrueAwk 20211208)\\n* nawk = pkgsrc nawk (OneTrueAwk 20121220)\\n* mawk = Homebrew mawk (1.3.4 20200120)\\n* bgrep = Apple\\'s FreeBSD grep (2.6.0-FreeBSD)\\n* ggrep = Homebrew GNU grep (3.8)\\n\\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\\n\\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967963,
                "title": "grep-short-and-fast-explanation",
                "content": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\\nOr just this. Where [0-9] instead of [:digit:].\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\\n\\n# Idea\\nWe need to check for one of this formats\\n(xxx) xxx-xxxx\\nxxx-xxx-xxxx\\n\\nAt the beginning we want one of the following:\\na) \"(xxx) \" ```\\\\([0-9]{3}\\\\) ```\\nb) \"xxx-\" ```[0-9]{3}\\\\-```\\nRest is same for both:\\n\"xxx-xxxx\" ```[0-9]{3}\\\\-[0-9]{4}```\\n\\n# Symbols meaning\\n**a|b** - Regex matches any string matching one of them.\\n**(a|b)** - To make subexpression\\n**\\\\\\\\** - Disabling/enabling meta-character\\n**{m}** - The preceding item is matched exactly m times. We can also use **{m,n}** or **{m,}** (m and more times), **{,n}** (at most n times).\\n**^** - The begin of a line\\n**$** - The end of a line.\\n**[:digit:] [:upper:] [:alpha:] [:alnum:]** - Character classes. Better not to use [a-z] to avoid dependence on language settings, as some languages have \\xE0,\\u010D,\\u017E ...\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\n```\\\\([0-9]{3}\\\\) ```\n```[0-9]{3}\\\\-```\n```[0-9]{3}\\\\-[0-9]{4}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957212,
                "title": "simple-grep-solution",
                "content": "# Approach\\nUse the `grep` command with [this regex pattern](https://regex101.com/r/Z7q2pZ/1) to show the valid phone numbers.\\n\\n# Code\\n```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937314,
                "title": "simple-one-line-100ms-beats-79-20",
                "content": "# Code\\n```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934322,
                "title": "bash-grep-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883195,
                "title": "one-line-shell-command-vs-bash-script-grep-e-matching-regular-expression-re",
                "content": "# Intuition\\nMy first thoughts focused on UNIX/Linux filter. It is a command that:\\n- Takes its input from standard inputs\\n- Precesses it according to some parameters and options\\n- Prodices its output on standard output\\n\\nIn general, filters are useful tool for text file processing.\\nIn addition, since the text requires yoo to serach the input file for lines containing a match to the given pattern, I select **grep -E** or **egrep** command beacuse it uses extended **Regular Expression** for matching the pattern.\\n**grep format: grep [options] pattern [file]**\\n\\n# Approach\\nThe text asks for two REs.\\nTherefore, the RE must have two expressions connected by an OR -> |.\\nThe character \\'\\\\\\' is used for special characters, such as \\'(\\' or \\')\\'.\\nThe \\'\\\\s\\' character is used for space or tab.\\nThe \\'\\\\s\\' character is used for space or tab\\nThe \\'^\\' character is used for the beginning of the line\\nthe \\'$\\' character is used for the end of the line\\nThe expression \\'[0-9]{3}\\' is used to identify a set of three digits.\\n\\nIn addition to the shell command version, I also added the bash script version.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nshell command:\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\\n\\nBash script:\\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2881574,
                "title": "bash-script-regex-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n awk \\'/^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878947,
                "title": "bash-beats-100-easy-to-understand",
                "content": "# Intuition\\nCheck each number line by line.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the file line by line and then use regular expression to verify the valid phone number.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868701,
                "title": "valid-phone-numbers",
                "content": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2863876,
                "title": "bash-using-while-and-if-statements",
                "content": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848522,
                "title": "1-line-using-grep-regex",
                "content": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "solutionTags": [],
                "code": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "codeTag": "Unknown"
            },
            {
                "id": 2810953,
                "title": "o-n-83ms-grep-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse regEx in grep\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngrep -E \\'regEx\\' file.txt\\n^([0-9]{3}-[0-9]{3}-[0-9]{4})\\\\$\\n^(\\\\\\\\([0-9]{3}\\\\\\\\) [0-9]{3}-[0-9]{4})\\\\$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) traverse of the file.txt\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if grep just gets lines not the whole file\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "String Matching"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807343,
                "title": "solution-using-awk-pattern",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728317,
                "title": "one-liner-using-grep-regex",
                "content": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572907,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571409,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571410,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571411,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 2051023,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1963994,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928438,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928138,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1728427,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1712426,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            }
        ]
    }
]