[
    {
        "title": "Maximal Score After Applying K Operations",
        "question_content": "You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\n\n\tchoose an index i such that 0 <= i < nums.length,\n\tincrease your score by nums[i], and\n\treplace nums[i] with ceil(nums[i] / 3).\n\nReturn the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.\n&nbsp;\nExample 1:\n\nInput: nums = [10,10,10,10,10], k = 5\nOutput: 50\nExplanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.\n\nExample 2:\n\nInput: nums = [1,10,3,3,3], k = 3\nOutput: 17\nExplanation: You can do the following operations:\nOperation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, k <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3017556,
                "title": "java-0ms-with-notes-explanation",
                "content": "\\n**Make sure to Upvote the code it means a lot to me!\\u270C\\uFE0F**\\n# Code with explanation\\n```\\nclass Solution {\\n    \\n    public long maxKelements(int[] arr, int k) {\\n        // Priorty Queue in reverse order is going to\\n        // give the highest number awailable\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = arr.length;\\n        long answer = 0;\\n\\n        // Add all the elements in priorty queue\\n        for(int i=0; i<n; i++){\\n            queue.add(arr[i]);\\n        }\\n\\n        //Loop k number of times as mentioned in question\\n        for(int i=0; i<k; i++){\\n\\n        //Now grab the element from queue by poll function\\n        // (it will give highest awailable always)\\n            int temp = queue.poll();\\n            answer += temp;\\n\\n        // After adding highest element in our answer\\n        // Give that number back to queue by doing the-\\n        //-operation as told in question ceil(num[i]/3)\\n            double s = (double)temp/3;\\n            queue.add((int)Math.ceil(s));\\n        }\\n        return answer;\\n    }\\n}\\n```\\n# Code \\n```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = arr.length;\\n        long answer = 0;\\n        for(int i=0; i<n; i++)  queue.add(arr[i]);\\n        for(int i=0; i<k; i++){\\n            int temp = queue.poll();\\n            answer += temp;\\n            double s = (double)temp/3;\\n            queue.add((int)Math.ceil(s));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long maxKelements(int[] arr, int k) {\\n        // Priorty Queue in reverse order is going to\\n        // give the highest number awailable\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = arr.length;\\n        long answer = 0;\\n\\n        // Add all the elements in priorty queue\\n        for(int i=0; i<n; i++){\\n            queue.add(arr[i]);\\n        }\\n\\n        //Loop k number of times as mentioned in question\\n        for(int i=0; i<k; i++){\\n\\n        //Now grab the element from queue by poll function\\n        // (it will give highest awailable always)\\n            int temp = queue.poll();\\n            answer += temp;\\n\\n        // After adding highest element in our answer\\n        // Give that number back to queue by doing the-\\n        //-operation as told in question ceil(num[i]/3)\\n            double s = (double)temp/3;\\n            queue.add((int)Math.ceil(s));\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        int n = arr.length;\\n        long answer = 0;\\n        for(int i=0; i<n; i++)  queue.add(arr[i]);\\n        for(int i=0; i<k; i++){\\n            int temp = queue.poll();\\n            answer += temp;\\n            double s = (double)temp/3;\\n            queue.add((int)Math.ceil(s));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017118,
                "title": "priority-queue",
                "content": "We pull from the priority queue `k` times, so the time complexity is O(n + k log n).\\n\\nNote that the population of a prioirty queue takes linear time O(n) if we do it at initialization. \\n\\n**C++**\\n```cpp\\nlong long maxKelements(vector<int>& nums, int k) {\\n    long long res = 0;\\n    priority_queue<int> pq(begin(nums), end(nums));\\n    while (k-- && !pq.empty()) {\\n        int n = pq.top(); pq.pop();\\n        res += n;\\n        if ((n + 2) / 3)\\n            pq.push((n + 2) / 3);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maxKelements(vector<int>& nums, int k) {\\n    long long res = 0;\\n    priority_queue<int> pq(begin(nums), end(nums));\\n    while (k-- && !pq.empty()) {\\n        int n = pq.top(); pq.pop();\\n        res += n;\\n        if ((n + 2) / 3)\\n            pq.push((n + 2) / 3);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016814,
                "title": "python-easy-solution-bisect-sort",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        score = 0\\n        while k != 0:\\n            temp = nums.pop()\\n            score += temp\\n            val = math.ceil(temp / 3)\\n            nums.insert(bisect.bisect(nums, val), val)\\n            k -= 1\\n        return score  \\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        score = 0\\n        while k != 0:\\n            temp = nums.pop()\\n            score += temp\\n            val = math.ceil(temp / 3)\\n            nums.insert(bisect.bisect(nums, val), val)\\n            k -= 1\\n        return score  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016759,
                "title": "c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int>pq;\\n        \\n        for(auto i:nums)pq.push(i);\\n        \\n        long long ans = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            int val = pq.top();\\n            ans+=val;\\n            pq.pop();\\n            pq.push(ceil(val*1.0/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int>pq;\\n        \\n        for(auto i:nums)pq.push(i);\\n        \\n        long long ans = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            int val = pq.top();\\n            ans+=val;\\n            pq.pop();\\n            pq.push(ceil(val*1.0/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016995,
                "title": "c-java-python3-priority-queue",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/cd738c7122f758231c4f575936d09271343de490) for solutions of weekly 327. \\n\\n**Intuition**\\nWe use a greedy approach to find the largest available number at any step. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0; \\n        priority_queue<int> pq(nums.begin(), nums.end()); \\n        while (k--) {\\n            int val = pq.top(); pq.pop();\\n            ans += val; \\n            pq.push((val+2)/3); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long ans = 0; \\n        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder()); \\n        for (int x : nums) pq.add(x); \\n        while (k-- > 0) {\\n            int val = pq.poll(); \\n            ans += val; \\n            pq.add((val+2)/3); \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        pq = [-x for x in nums]\\n        heapify(pq)\\n        ans = 0 \\n        for i in range(k): \\n            ans -= pq[0] \\n            heapreplace(pq, pq[0]//3)\\n        return ans \\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0; \\n        priority_queue<int> pq(nums.begin(), nums.end()); \\n        while (k--) {\\n            int val = pq.top(); pq.pop();\\n            ans += val; \\n            pq.push((val+2)/3); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long ans = 0; \\n        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder()); \\n        for (int x : nums) pq.add(x); \\n        while (k-- > 0) {\\n            int val = pq.poll(); \\n            ans += val; \\n            pq.add((val+2)/3); \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        pq = [-x for x in nums]\\n        heapify(pq)\\n        ans = 0 \\n        for i in range(k): \\n            ans -= pq[0] \\n            heapreplace(pq, pq[0]//3)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016923,
                "title": "java-solution-using-priority-queue-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        // Sort the array in ascending order\\n        Arrays.sort(nums);\\n        \\n        long sum = 0;\\n        int num = k;\\n        // Create a priority queue that stores the elements in descending order\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        // If the length of the array is less than k, set k to the length of the array\\n        if(nums.length <= k) {\\n            k = nums.length;\\n        }\\n        \\n        // Add the last k elements of the sorted array to the priority queue\\n        while(k > 0) {\\n            pq.add(nums[nums.length - k]);\\n            k--;\\n        }\\n        \\n        // Set k back to the original value of num\\n        k = num;\\n        \\n        // While there are still elements in the priority queue and k is greater than 0\\n        while(k > 0 && pq.size() > 0) {\\n            // Add the top element of the priority queue to the sum\\n            sum += pq.peek();\\n            // Calculate the new number based on whether the top element is divisible by 3\\n            int newNum = pq.peek() % 3 == 0 ? pq.peek() / 3 : pq.peek() / 3 + 1;\\n            // Remove the top element from the priority queue\\n            pq.poll();\\n            // Add the new number to the priority queue\\n            pq.add(newNum);\\n            // Decrement k\\n            k--;\\n        }\\n        \\n        // Return the sum\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        // Sort the array in ascending order\\n        Arrays.sort(nums);\\n        \\n        long sum = 0;\\n        int num = k;\\n        // Create a priority queue that stores the elements in descending order\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        // If the length of the array is less than k, set k to the length of the array\\n        if(nums.length <= k) {\\n            k = nums.length;\\n        }\\n        \\n        // Add the last k elements of the sorted array to the priority queue\\n        while(k > 0) {\\n            pq.add(nums[nums.length - k]);\\n            k--;\\n        }\\n        \\n        // Set k back to the original value of num\\n        k = num;\\n        \\n        // While there are still elements in the priority queue and k is greater than 0\\n        while(k > 0 && pq.size() > 0) {\\n            // Add the top element of the priority queue to the sum\\n            sum += pq.peek();\\n            // Calculate the new number based on whether the top element is divisible by 3\\n            int newNum = pq.peek() % 3 == 0 ? pq.peek() / 3 : pq.peek() / 3 + 1;\\n            // Remove the top element from the priority queue\\n            pq.poll();\\n            // Add the new number to the priority queue\\n            pq.add(newNum);\\n            // Decrement k\\n            k--;\\n        }\\n        \\n        // Return the sum\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016797,
                "title": "c-java-priority-queue-explained",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo maximize the score we have to select maximum element in nums[i] after every k operations\\nSo, to keep track of maximum element everytime we use max-heap,i.e, priority queue\\nStore all elements of nums in priority queue and alaways take top element of it as it is maximum always and add it in your score and in every operation pop that top element out of queue and insert ceil(top/3) in queue\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code [C++]\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long score = 0;\\n        for(auto it : nums) {\\n            pq.push(it);\\n        }\\n        \\n        while(k--){\\n            int top = pq.top(); // max element\\n            int add;\\n            if(top % 3 == 0) add = top / 3;\\n            else add = top/3 + 1;\\n            \\n            score += top;\\n            pq.pop();\\n            pq.push(add); // ceil(top/3)\\n        }\\n        \\n        return score;\\n    }\\n};\\n```\\n\\n# Code [JAVA]\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        long score = 0;\\n        for(int it : nums) pq.add(it);\\n        \\n        while(k-- > 0){\\n            int top = pq.poll(); // max element\\n            int add;\\n            if(top % 3 == 0) add = top / 3;\\n            else add = top/3 + 1;\\n            \\n            score += top;\\n            pq.add(add); // ceil(top/3)\\n        }\\n        \\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long score = 0;\\n        for(auto it : nums) {\\n            pq.push(it);\\n        }\\n        \\n        while(k--){\\n            int top = pq.top(); // max element\\n            int add;\\n            if(top % 3 == 0) add = top / 3;\\n            else add = top/3 + 1;\\n            \\n            score += top;\\n            pq.pop();\\n            pq.push(add); // ceil(top/3)\\n        }\\n        \\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        long score = 0;\\n        for(int it : nums) pq.add(it);\\n        \\n        while(k-- > 0){\\n            int top = pq.poll(); // max element\\n            int add;\\n            if(top % 3 == 0) add = top / 3;\\n            else add = top/3 + 1;\\n            \\n            score += top;\\n            pq.add(add); // ceil(top/3)\\n        }\\n        \\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017644,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/channel/@leetcodethehardway) if you are interested.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        // we want to take the max one in each round\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        // perform k rounds\\n        while (k--) {\\n            // get the max one\\n            int t = pq.top(); \\n            // pop it out\\n            pq.pop();\\n            // add to answer\\n            ans += t; \\n            // add the ceil value\\n            // ceil(x / y) = (x + y - 1) / y\\n            // ceil(t / 3) = (t + 3 - 1) / 3 = (t + 2) / 3\\n            pq.push((t + 2) / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        // we want to take the max one in each round\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        // perform k rounds\\n        while (k--) {\\n            // get the max one\\n            int t = pq.top(); \\n            // pop it out\\n            pq.pop();\\n            // add to answer\\n            ans += t; \\n            // add the ceil value\\n            // ceil(x / y) = (x + y - 1) / y\\n            // ceil(t / 3) = (t + 3 - 1) / 3 = (t + 2) / 3\\n            pq.push((t + 2) / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016738,
                "title": "c-priority-queue-solution-very-simple-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int i = nums.size()-1; \\n        while(k--){\\n            if(i < 0 || (pq.size() > 0 && pq.top() > nums[i])){ \\n                ans += pq.top(); \\n                pq.push(ceil((double)pq.top()/3));\\n                pq.pop();\\n            }else{\\n                ans += nums[i];\\n                pq.push(ceil((double)nums[i]/3));\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int i = nums.size()-1; \\n        while(k--){\\n            if(i < 0 || (pq.size() > 0 && pq.top() > nums[i])){ \\n                ans += pq.top(); \\n                pq.push(ceil((double)pq.top()/3));\\n                pq.pop();\\n            }else{\\n                ans += nums[i];\\n                pq.push(ceil((double)nums[i]/3));\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016885,
                "title": "c-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq;\\n        for(auto i: nums){\\n            pq.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int maxi = pq.top();\\n            pq.pop();\\n            score+= maxi;\\n            pq.push(ceil(maxi/3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq;\\n        for(auto i: nums){\\n            pq.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int maxi = pq.top();\\n            pq.pop();\\n            score+= maxi;\\n            pq.push(ceil(maxi/3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025170,
                "title": "python-heap-video-solution",
                "content": "I have explained the whole solution [here](https://youtu.be/WxtI_i3JfaM).\\n\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        h = [-v for v in nums]\\n        \\n        heapq.heapify(h)\\n        \\n        for i in range(k):\\n            x = -heapq.heappop(h)\\n            res += x\\n            x = math.ceil(x/3)\\n            heapq.heappush(h, -x)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        h = [-v for v in nums]\\n        \\n        heapq.heapify(h)\\n        \\n        for i in range(k):\\n            x = -heapq.heappop(h)\\n            res += x\\n            x = math.ceil(x/3)\\n            heapq.heappush(h, -x)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018762,
                "title": "simple-c-beats-100-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple we have to choose those numbers which are greater because we have to maximise score, also on dividing the selected element we are not sure that it can be lesser than reamning or greater than remaining so we should use max heap which will give us next greater element always.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a Priority Queue first we insert all the elements and it will sort them in increasing order and also on dividing the selected element (i.e, pq.top()) we should insert pq.top/3 as well and pop the top .In that way we will get always the greater element remaining...\\nFor more understanding look at the code and dry run ...\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<int>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(arr[i]);\\n        }\\n      long long int sum=0;\\n        while(!pq.empty() and k>0){\\n            sum+=(long long)pq.top();\\n            int t=ceil((double)pq.top()/3);\\n            pq.pop();\\n            pq.push(t);\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<int>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(arr[i]);\\n        }\\n      long long int sum=0;\\n        while(!pq.empty() and k>0){\\n            sum+=(long long)pq.top();\\n            int t=ceil((double)pq.top()/3);\\n            pq.pop();\\n            pq.push(t);\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018267,
                "title": "python-3-7-lines-heap-t-m-869-ms-29-1-mb",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\n        nums, ans = [-n for n in nums], 0\\n        heapify(nums)\\n\\n        n = heappop(nums)\\n        for _ in range(k):\\n            ans-= n\\n            n = heappushpop(nums, floor(n/3))\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/maximal-score-after-applying-k-operations/submissions/873911632/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\n        nums, ans = [-n for n in nums], 0\\n        heapify(nums)\\n\\n        n = heappop(nums)\\n        for _ in range(k):\\n            ans-= n\\n            n = heappushpop(nums, floor(n/3))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017019,
                "title": "c-priority-queue-clean-easy-to-understand-code",
                "content": "![image](https://assets.leetcode.com/users/images/066c7d8e-ad12-42a6-9770-26b4ba8349d1_1673151316.5240102.png)\\n\\n**n==nums.size()\\nT->O(k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\t\\tlong long count=0;\\n\\t\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\t\\tlong long count=0;\\n\\t\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3016999,
                "title": "js-fast-and-short",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n log n) due to heap.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar maxKelements = function (nums, k, res = 0) {\\n  const pq = new MaxPriorityQueue();\\n  for (let num of nums) {pq.enqueue(num);}\\n  while (k) {\\n    const el = pq.dequeue().element;\\n    res += el;\\n    pq.enqueue(Math.ceil(el / 3));\\n    k--;\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxKelements = function (nums, k, res = 0) {\\n  const pq = new MaxPriorityQueue();\\n  for (let num of nums) {pq.enqueue(num);}\\n  while (k) {\\n    const el = pq.dequeue().element;\\n    res += el;\\n    pq.enqueue(Math.ceil(el / 3));\\n    k--;\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016896,
                "title": "c-2-solution-using-multiset-and-priority-queue",
                "content": "**Please upvote \\u2B06\\uFE0F if you found it useful**\\n# Using multiset\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int score=0;\\n        multiset<int> ms;\\n        for(auto i:nums)\\n            ms.insert(i);\\n        while(k--){\\n            auto it=ms.end();\\n            it--;\\n            int a=*it;\\n            score+=a;\\n            ms.erase(it);\\n            ms.insert(a%3==0?a/3:a/3+1);\\n        }\\n        return score;\\n    }\\n};\\n```\\n# Using priority_queue\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int score=0;\\n        priority_queue<int> pq(nums.begin(),nums.end());\\n        while(k--){\\n            int a=pq.top();\\n            pq.pop();\\n            score+=a;\\n            pq.push(a%3==0?a/3:a/3+1);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int score=0;\\n        multiset<int> ms;\\n        for(auto i:nums)\\n            ms.insert(i);\\n        while(k--){\\n            auto it=ms.end();\\n            it--;\\n            int a=*it;\\n            score+=a;\\n            ms.erase(it);\\n            ms.insert(a%3==0?a/3:a/3+1);\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int score=0;\\n        priority_queue<int> pq(nums.begin(),nums.end());\\n        while(k--){\\n            int a=pq.top();\\n            pq.pop();\\n            score+=a;\\n            pq.push(a%3==0?a/3:a/3+1);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016775,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    long long maxKelements(vector<int>&v, int k) {\\n        ll n=v.size(), ans=0;\\n        priority_queue<ll>pq(begin(v), end(v));\\n        while(!pq.empty() && k--){\\n            ll it=pq.top();\\n            pq.pop();\\n            if(!it){ // no value in considering zeroes\\n                continue;\\n            }\\n            ans+=it;\\n            pq.push((it/3)+((it%3)!=0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    long long maxKelements(vector<int>&v, int k) {\\n        ll n=v.size(), ans=0;\\n        priority_queue<ll>pq(begin(v), end(v));\\n        while(!pq.empty() && k--){\\n            ll it=pq.top();\\n            pq.pop();\\n            if(!it){ // no value in considering zeroes\\n                continue;\\n            }\\n            ans+=it;\\n            pq.push((it/3)+((it%3)!=0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832686,
                "title": "100-beats-c-heap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(auto &i: nums)pq.push(i);\\n        int x;\\n        while(k-- && !pq.empty()){\\n            x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            if(ceil(x/3.0))pq.push(ceil(x/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(auto &i: nums)pq.push(i);\\n        int x;\\n        while(k-- && !pq.empty()){\\n            x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            if(ceil(x/3.0))pq.push(ceil(x/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057120,
                "title": "priority-queue",
                "content": "\\n\\n# Java\\n```\\n    public long maxKelements(int[] nums, int k) {\\n    Queue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n    for (int num : nums)\\n      queue.offer(num);\\n\\n    long score = 0;\\n    for (int i = 0; i < k; ++i) {\\n      int maxElement = queue.poll();\\n      score += maxElement;\\n      queue.offer((int) Math.ceil(maxElement / 3.0));\\n    }\\n\\n    return score;\\n  }\\n```\\n# C++\\n```\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n    long long score = 0;\\n    priority_queue<int> queue(begin(nums), end(nums));\\n\\n    for (int i = 0; i < k; ++i) {\\n        int maxElement = queue.top(); queue.pop();\\n        score += maxElement;\\n        queue.push(ceil(maxElement / 3.0));\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\n    public long maxKelements(int[] nums, int k) {\\n    Queue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n    for (int num : nums)\\n      queue.offer(num);\\n\\n    long score = 0;\\n    for (int i = 0; i < k; ++i) {\\n      int maxElement = queue.poll();\\n      score += maxElement;\\n      queue.offer((int) Math.ceil(maxElement / 3.0));\\n    }\\n\\n    return score;\\n  }\\n```\n```\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n    long long score = 0;\\n    priority_queue<int> queue(begin(nums), end(nums));\\n\\n    for (int i = 0; i < k; ++i) {\\n        int maxElement = queue.top(); queue.pop();\\n        score += maxElement;\\n        queue.push(ceil(maxElement / 3.0));\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031937,
                "title": "c-super-easy-priority-queue-basic-maths",
                "content": "# Intuition\\n    MAX HEAP and BASIC MATH OPERATION :-)\\n# Approach\\n - Declare a priority queue pq which implements max heap.\\n - Push the array elements onto the queue.\\n - In the construction of a Max-Heap, the largest element has priority.\\n - Pull the elements from the priority queue k times and the largest element is the first to be popped out from the heap.\\n - Calculate the sum accordingly.\\n - If the popped out element is found to be divisible by 3, then push ele/3 otherwise ele/3 + 1 because we want the ceil value of that ele.\\n - Return the calculated sum after performing k no of iterations.\\n\\n# Complexity\\n- Time complexity: O(n + k log n)\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        priority_queue <long long> pq;\\n        \\n        for(auto x: nums)\\n            pq.push(x);\\n        \\n        long long res = 0;\\n        while(k--)\\n        {\\n            long long ele = pq.top();\\n            pq.pop();\\n            \\n            res += ele;\\n            long long var = (ele % 3 == 0 ? ele/3 : ele/3 + 1);\\n            pq.push(var);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        priority_queue <long long> pq;\\n        \\n        for(auto x: nums)\\n            pq.push(x);\\n        \\n        long long res = 0;\\n        while(k--)\\n        {\\n            long long ele = pq.top();\\n            pq.pop();\\n            \\n            res += ele;\\n            long long var = (ele % 3 == 0 ? ele/3 : ele/3 + 1);\\n            pq.push(var);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017762,
                "title": "java-priorityqueue-collections-reverseorder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            p.add(nums[nums.length-i-1]);\\n        }\\n        long score=0;\\n        while(k!=0)\\n        {\\n            int v1=p.poll();\\n            score+=v1;\\n            int v2=(int)Math.ceil((double)v1/3);\\n            p.add(v2);\\n            k--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            p.add(nums[nums.length-i-1]);\\n        }\\n        long score=0;\\n        while(k!=0)\\n        {\\n            int v1=p.poll();\\n            score+=v1;\\n            int v2=(int)Math.ceil((double)v1/3);\\n            p.add(v2);\\n            k--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016941,
                "title": "ceil-function-issue-solved-intuition-explained-beginner-friendly",
                "content": "*****I think, you will gonna upvote my solution.\\nThanks in advance.*****\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every iteration we need a highest element in the array to apply the given operation.\\nSo the Max heap can help us by giving greatest element that too in O(log n) complexity.\\n\\nThe using of Ceil function is tricky here we need to convert it into floating point because the int by int division always gives an integer.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O( N * log N)$$ Insertion and deletion  in Max heap takes logarithmic time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for Priority Queue\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        \\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder()); // max Heap\\n        \\n        for(int i:nums)\\n        {\\n            pq.add(i);\\n        }\\n        \\n        // System.out.println(pq);\\n        \\n        long res=0;\\n        \\n        while(k-->0)\\n        {\\n            long t=pq.remove();\\n            \\n            res+=t;\\n            \\n            int c=(int)Math.ceil(t*1.0/3.0);\\n            \\n            pq.add(c);\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        \\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder()); // max Heap\\n        \\n        for(int i:nums)\\n        {\\n            pq.add(i);\\n        }\\n        \\n        // System.out.println(pq);\\n        \\n        long res=0;\\n        \\n        while(k-->0)\\n        {\\n            long t=pq.remove();\\n            \\n            res+=t;\\n            \\n            int c=(int)Math.ceil(t*1.0/3.0);\\n            \\n            pq.add(c);\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016893,
                "title": "beginner-approach-using-priority-queue-maxheap-with-commented-code",
                "content": "# Approach\\nWe need to select maximum value of nums array since we need maximum score, and replace nums[i] with ceil(nums[i]/3) and again we need to find maximum value of nums to add to score and this operation will continue exactly k times.\\nwe get maximum value every time using maxHeap (priority_queue).\\nTo understand better follow my below code.\\n\\n# Complexity\\n- Time complexity:\\nO(K*log(N))\\n\\n- Space complexity:\\nO(N).\\n\\nwhere N is nums.size().\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long int> pq;   //creating a maxHeap \\n        \\n        for(int i=0;i<nums.size();i++){    //inserting array elements to priority_queue\\n            pq.push(nums[i]);\\n        }\\n        \\n        long long int score=0;               //initializing score=0\\n        \\n        while(k--){                          //we need to apply exactly k operations\\n            int mxm=pq.top();                //finding mxmVal which is top of prior_que(maxHeap)\\n            pq.pop();                        //removing current mxmVal from prior_que(maxHeap) because we need to update with newValue\\n            score+=mxm;                      //adding curMxm to score\\n            \\n            int newVal=(mxm/3)+(mxm%3==0?0:1);  //now calculate new val which is ceil of curMxm/3\\n            pq.push(newVal);                    //push into prior_que(maxHeap)\\n        }\\n        \\n        return score;                         //finally return score\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long int> pq;   //creating a maxHeap \\n        \\n        for(int i=0;i<nums.size();i++){    //inserting array elements to priority_queue\\n            pq.push(nums[i]);\\n        }\\n        \\n        long long int score=0;               //initializing score=0\\n        \\n        while(k--){                          //we need to apply exactly k operations\\n            int mxm=pq.top();                //finding mxmVal which is top of prior_que(maxHeap)\\n            pq.pop();                        //removing current mxmVal from prior_que(maxHeap) because we need to update with newValue\\n            score+=mxm;                      //adding curMxm to score\\n            \\n            int newVal=(mxm/3)+(mxm%3==0?0:1);  //now calculate new val which is ceil of curMxm/3\\n            pq.push(newVal);                    //push into prior_que(maxHeap)\\n        }\\n        \\n        return score;                         //finally return score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016712,
                "title": "c-priority-queue-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long>p(nums.begin(),nums.end());\\n        long long score=0;\\n        while(k--){\\n            score+=p.top();\\n            int x=0;\\n            if(p.top()%3==0) p.push(ceil(p.top()/3));\\n            else p.push(ceil(p.top()/3)+1);\\n            p.pop();\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long>p(nums.begin(),nums.end());\\n        long long score=0;\\n        while(k--){\\n            score+=p.top();\\n            int x=0;\\n            if(p.top()%3==0) p.push(ceil(p.top()/3));\\n            else p.push(ceil(p.top()/3)+1);\\n            p.pop();\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408550,
                "title": "priority-queue-short-sweet-c-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        priority_queue<int> pq;//create max heap\\n        for(auto &i: nums)pq.push(i);//insert all elememts into heap\\n        int x;\\n        while(k--){\\n            // ans += pq.top();//get maximum top element\\n            x = pq.top()\\n            ans += x;//add maximum no into ans\\n            pq.pop();;//pop max element from heap\\n            pq.push(ceil(x/3.0));//push into ans ceil(maximum element / 3)\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        priority_queue<int> pq;//create max heap\\n        for(auto &i: nums)pq.push(i);//insert all elememts into heap\\n        int x;\\n        while(k--){\\n            // ans += pq.top();//get maximum top element\\n            x = pq.top()\\n            ans += x;//add maximum no into ans\\n            pq.pop();;//pop max element from heap\\n            pq.push(ceil(x/3.0));//push into ans ceil(maximum element / 3)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087096,
                "title": "java-easy-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nADD ELEMENTS IN THE PRIORITY QUEUE AND THEN REMOVE THEM BY ACCORDING TO K\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nREMOVE ELEMENTS FROM QUEUE AND THEN ADD IN S(SUM)\\nAND THEN CREATE THE AGAIN ADD THE VALUE IN PRIORITY QUEUE BBY RECALCULATING IT .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)+O(K)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n**Pls Upvote**\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) \\n    {\\n      PriorityQueue<Integer> pq= new PriorityQueue<Integer>(Collections.reverseOrder());\\n       for(int i=0;i<nums.length;i++)\\n       {\\n         pq.add(nums[i]);\\n       }\\n       long s=0;\\n       \\n       while(k>0 && !pq.isEmpty())\\n       {\\n          int t=pq.poll();\\n           s+=t;\\n           if(t%3==0)\\n          pq.add(t/3);\\n          else\\n          pq.add(t/3+1);\\n          k--;\\n          //System.out.print(pq);\\n       }\\n       return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) \\n    {\\n      PriorityQueue<Integer> pq= new PriorityQueue<Integer>(Collections.reverseOrder());\\n       for(int i=0;i<nums.length;i++)\\n       {\\n         pq.add(nums[i]);\\n       }\\n       long s=0;\\n       \\n       while(k>0 && !pq.isEmpty())\\n       {\\n          int t=pq.poll();\\n           s+=t;\\n           if(t%3==0)\\n          pq.add(t/3);\\n          else\\n          pq.add(t/3+1);\\n          k--;\\n          //System.out.print(pq);\\n       }\\n       return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050609,
                "title": "maxheap-after-seeing-this-i-am-sure-you-understand-it",
                "content": "```\\n  long long maxKelements(vector<int>& nums, int k) {\\n         int n=nums.size();\\n        long long score=0;\\n        priority_queue<double>maxh;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxh.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            score+=maxh.top();\\n            maxh.push(ceil(maxh.top()/3));\\n            maxh.pop();\\n        }\\n        return score; \\n    }\\n\\tt(c)=o(nlogn);\\n\\ts(c)=o(n)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  long long maxKelements(vector<int>& nums, int k) {\\n         int n=nums.size();\\n        long long score=0;\\n        priority_queue<double>maxh;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxh.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            score+=maxh.top();\\n            maxh.push(ceil(maxh.top()/3));\\n            maxh.pop();\\n        }\\n        return score; \\n    }\\n\\tt(c)=o(nlogn);\\n\\ts(c)=o(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3023945,
                "title": "javascript-o-k-log-n-time-o-n-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n    const pq = new MaxPriorityQueue();\\n    for(const e of nums) pq.enqueue(e);\\n    let score = 0;\\n    let operations = 0;\\n    while(operations < k) {\\n        const max = pq.dequeue().element;\\n        if(max == 0) break;\\n        score += max;\\n        pq.enqueue(Math.ceil(max / 3));\\n        operations++;\\n    }\\n    \\n    return score;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n    const pq = new MaxPriorityQueue();\\n    for(const e of nums) pq.enqueue(e);\\n    let score = 0;\\n    let operations = 0;\\n    while(operations < k) {\\n        const max = pq.dequeue().element;\\n        if(max == 0) break;\\n        score += max;\\n        pq.enqueue(Math.ceil(max / 3));\\n        operations++;\\n    }\\n    \\n    return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018035,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long>pq(nums.begin(),nums.end());\\n        long long ans=0;\\n        while(!pq.empty() && k--){\\n            long long x=pq.top();\\n            pq.pop();\\n            ans+=x;\\n            pq.push(ceil(x/3.0));\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long>pq(nums.begin(),nums.end());\\n        long long ans=0;\\n        while(!pq.empty() && k--){\\n            long long x=pq.top();\\n            pq.pop();\\n            ans+=x;\\n            pq.push(ceil(x/3.0));\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017896,
                "title": "c-priority-queue-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int p:nums){\\n            pq.push(p);\\n        }\\n        long long res=0;\\n        while(k--){\\n            int top=pq.top(); // taking maximum element \\n            pq.pop();\\n            res+= top;\\n            if(top%3)pq.push(top/3+1); // pushing Ceil value\\n            else pq.push(top/3);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int p:nums){\\n            pq.push(p);\\n        }\\n        long long res=0;\\n        while(k--){\\n            int top=pq.top(); // taking maximum element \\n            pq.pop();\\n            res+= top;\\n            if(top%3)pq.push(top/3+1); // pushing Ceil value\\n            else pq.push(top/3);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017839,
                "title": "python3-heap",
                "content": "\\u0421hange the sign of each element of the array so that converting to a heap, when using heappop we get the largest element:\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        \\n        nums = [-num for num in nums]\\n        heapify(nums)\\n        \\n        while k:\\n            tmp = heappop(nums)\\n            ans -= tmp\\n            heappush(nums, floor(tmp / 3))\\n            k -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        \\n        nums = [-num for num in nums]\\n        heapify(nums)\\n        \\n        while k:\\n            tmp = heappop(nums)\\n            ans -= tmp\\n            heappush(nums, floor(tmp / 3))\\n            k -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017618,
                "title": "priority-queue-max-heap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery time choose the maximum element from the array and replace it by ceil(element/3) and we can perform this operation k times. So, for this we will use maxheap.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> heap(nums.begin(),nums.end());\\n        long long  sum=0;\\n        while(k!=0){\\n            long long curr=heap.top();\\n            heap.pop();\\n            long long x;\\n            if (curr % 3 == 0)\\n            {\\n                x = ceil(curr / 3);\\n            }\\n            else\\n            {\\n                x = ceil(curr / 3) + 1;\\n            }\\n            heap.push(x);\\n            sum+=curr;\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> heap(nums.begin(),nums.end());\\n        long long  sum=0;\\n        while(k!=0){\\n            long long curr=heap.top();\\n            heap.pop();\\n            long long x;\\n            if (curr % 3 == 0)\\n            {\\n                x = ceil(curr / 3);\\n            }\\n            else\\n            {\\n                x = ceil(curr / 3) + 1;\\n            }\\n            heap.push(x);\\n            sum+=curr;\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017276,
                "title": "shortest-clean-code-in-c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq = {nums.begin(), nums.end()};\\n        long long score = 0;\\n        while(k--)\\n        {\\n            int temp = pq.top();\\n            pq.pop();\\n            score += temp;\\n            pq.push(ceil((temp+2)/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq = {nums.begin(), nums.end()};\\n        long long score = 0;\\n        while(k--)\\n        {\\n            int temp = pq.top();\\n            pq.pop();\\n            score += temp;\\n            pq.push(ceil((temp+2)/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017195,
                "title": "short-concise-max-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i : nums) pq.push(i);\\n        long long ans = 0;\\n        while(k--) {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil((double)a / 3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i : nums) pq.push(i);\\n        long long ans = 0;\\n        while(k--) {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil((double)a / 3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016939,
                "title": "easy-understanding-solution-heap",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-n for n in nums]\\n        res = 0\\n        heap = heapq.heapify(nums)\\n        for _ in range(k):\\n            a = heapq.heappop(nums) * -1\\n            res += a\\n            heapq.heappush(nums, -math.ceil(a/3))\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-n for n in nums]\\n        res = 0\\n        heap = heapq.heapify(nums)\\n        for _ in range(k):\\n            a = heapq.heappop(nums) * -1\\n            res += a\\n            heapq.heappush(nums, -math.ceil(a/3))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016903,
                "title": "java-max-heap-priority-queue-easy",
                "content": "# Please Upvote :D\\n---\\n- Push all the elements to the heap.\\n- Pop the topmost (maximum) element, add it to `score` and alter it (`ceil(x / 3)`).\\n- Push it back.\\n- Do it exactly `k` times.\\n``` java []\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : nums) {\\n            pq.offer(i);\\n        }\\n        \\n        long score = 0;\\n        while (k-- > 0) {\\n            int x = pq.poll();\\n            score += x;\\n            x = (int) Math.ceil(x * 1.0 / 3.0);\\n            pq.offer(x);\\n        }\\n        \\n        return score;\\n    }\\n}\\n\\n// TC: O(n) + O(k * logn) => O(k * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : nums) {\\n            pq.offer(i);\\n        }\\n        \\n        long score = 0;\\n        while (k-- > 0) {\\n            int x = pq.poll();\\n            score += x;\\n            x = (int) Math.ceil(x * 1.0 / 3.0);\\n            pq.offer(x);\\n        }\\n        \\n        return score;\\n    }\\n}\\n\\n// TC: O(n) + O(k * logn) => O(k * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016877,
                "title": "python-3-maxheap",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-i for i in nums]\\n        heapify(nums)\\n        \\n        res = 0\\n        for i in range(k):\\n            t = -heappop(nums)\\n            res += t\\n            heappush(nums, -ceil(t / 3))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-i for i in nums]\\n        heapify(nums)\\n        \\n        res = 0\\n        for i in range(k):\\n            t = -heappop(nums)\\n            res += t\\n            heappush(nums, -ceil(t / 3))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016755,
                "title": "6285-maximal-score-after-applying-k-operations-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\\n        public int compare(Integer a, Integer b) {\\n            return b - a;\\n        }\\n    });\\n    \\n    for (int num : nums) {\\n        pq.add(num);\\n    }\\n        \\n    long score = 0;\\n    \\n    for (int i = 0; i < k; i++) {\\n        // Get the maximum value from the priority queue\\n        int max = pq.poll();\\n        \\n        // Increase the score by the maximum value\\n        score += max;\\n        \\n        // Replace the value with ceil(max / 3)\\n        pq.add((int) Math.ceil(max / 3.0));\\n    }\\n    \\n    return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\\n        public int compare(Integer a, Integer b) {\\n            return b - a;\\n        }\\n    });\\n    \\n    for (int num : nums) {\\n        pq.add(num);\\n    }\\n        \\n    long score = 0;\\n    \\n    for (int i = 0; i < k; i++) {\\n        // Get the maximum value from the priority queue\\n        int max = pq.poll();\\n        \\n        // Increase the score by the maximum value\\n        score += max;\\n        \\n        // Replace the value with ceil(max / 3)\\n        pq.add((int) Math.ceil(max / 3.0));\\n    }\\n    \\n    return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855380,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq(begin(nums), end(nums));\\n        \\n        long long res = 0;\\n        while (k--) {\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n            res += curr;\\n            curr = (curr + 2) / 3;\\n            pq.push(curr);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq(begin(nums), end(nums));\\n        \\n        long long res = 0;\\n        while (k--) {\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n            res += curr;\\n            curr = (curr + 2) / 3;\\n            pq.push(curr);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559538,
                "title": "simple-c-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score=0;\\n        priority_queue<int> pq;\\n        for(int num:nums) pq.push(num);\\n        while(k--){\\n            int top = pq.top();\\n            cout<<top<<endl;\\n            pq.pop();\\n            score+=top;\\n            pq.push(ceil(1.0*top/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score=0;\\n        priority_queue<int> pq;\\n        for(int num:nums) pq.push(num);\\n        while(k--){\\n            int top = pq.top();\\n            cout<<top<<endl;\\n            pq.pop();\\n            score+=top;\\n            pq.push(ceil(1.0*top/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3236185,
                "title": "c-100-faster-heap-priority-queue-code-quality",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ceil(long long num) {\\n        if (num % 3 == 0) return num / 3;\\n        else return (num/3)+1;\\n    }\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> maxHeap;\\n        long long sum = 0;\\n        long long curr;\\n        for (auto &num:nums) {\\n            maxHeap.push(num);\\n        }\\n        while (k>0) {\\n            curr = maxHeap.top();\\n            sum += curr;\\n            maxHeap.pop();\\n            maxHeap.push(ceil(curr));\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ceil(long long num) {\\n        if (num % 3 == 0) return num / 3;\\n        else return (num/3)+1;\\n    }\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> maxHeap;\\n        long long sum = 0;\\n        long long curr;\\n        for (auto &num:nums) {\\n            maxHeap.push(num);\\n        }\\n        while (k>0) {\\n            curr = maxHeap.top();\\n            sum += curr;\\n            maxHeap.pop();\\n            maxHeap.push(ceil(curr));\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055212,
                "title": "c-easy-solution-using-multiset",
                "content": "# Intuition\\nThe largest element has to be found out in each operation.\\n\\n# Approach\\nTake the largest element in the multiset and perform the desired operation as mentioned in the question.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        multiset<int> ms;long long score=0; multiset<int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            ms.insert(INT_MAX-nums[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n                score+=(INT_MAX-*(ms.begin()));\\n                it=ms.begin();\\n                int a1=INT_MAX-*it,temp;\\n                if(a1%3==0)\\n                    temp=a1/3;\\n                else\\n                    temp=a1/3+1;\\n                    ms.erase(it);\\n                    ms.insert(INT_MAX-temp);\\n                }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        multiset<int> ms;long long score=0; multiset<int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            ms.insert(INT_MAX-nums[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n                score+=(INT_MAX-*(ms.begin()));\\n                it=ms.begin();\\n                int a1=INT_MAX-*it,temp;\\n                if(a1%3==0)\\n                    temp=a1/3;\\n                else\\n                    temp=a1/3+1;\\n                    ms.erase(it);\\n                    ms.insert(INT_MAX-temp);\\n                }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043307,
                "title": "c-easy-to-understand-using-priority-queue-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: nums)pq.push(i);\\n        long long ans = 0,x;\\n        while(k--){\\n            x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            pq.push(ceil(x/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: nums)pq.push(i);\\n        long long ans = 0,x;\\n        while(k--){\\n            x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            pq.push(ceil(x/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037504,
                "title": "c-priority-queue-4-lines-only-o-nlogn-90-faster",
                "content": "**Complexity**\\nTime: `O(NlogN)`\\nSpace: `O(N)`\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k, int score = 0) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        while (k--) {\\n            auto top = pq.top(); pq.pop();\\n            score += top;\\n            pq.push(ceil(top / 3.0));\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k, int score = 0) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        while (k--) {\\n            auto top = pq.top(); pq.pop();\\n            score += top;\\n            pq.push(ceil(top / 3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037014,
                "title": "priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i: nums){\\n            pq.push(i);\\n        }\\n        while(k-- && !pq.empty()){\\n            int n=pq.top();\\n            ans=ans+n;\\n            pq.pop();\\n            if((n+2)/3){\\n                pq.push((n+2)/3);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i: nums){\\n            pq.push(i);\\n        }\\n        while(k-- && !pq.empty()){\\n            int n=pq.top();\\n            ans=ans+n;\\n            pq.pop();\\n            if((n+2)/3){\\n                pq.push((n+2)/3);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035144,
                "title": "q2530-accepted-c-using-heap-easiest-simple",
                "content": "CRUX \\n1) We need to attain maximum count within k operations.\\n2) The minor twist is that after each computation of the num[i] used it must be divided by 3 and its ceil should be taken.\\n3) Clearly, Max Heap must be used to select the maximum available option.\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int> maxh(nums.begin(),nums.end()); // Creating Max heap\\n        long long count=0; // Using long long as large numbers are possible\\n        while(k--){\\n            long long temp=maxh.top(); // taking the maximum element in the heap\\n            maxh.pop();\\n            count+=temp;\\n            maxh.push(ceil(temp/3.0));  // Used 3.0 for getting an decimal value if exists\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int> maxh(nums.begin(),nums.end()); // Creating Max heap\\n        long long count=0; // Using long long as large numbers are possible\\n        while(k--){\\n            long long temp=maxh.top(); // taking the maximum element in the heap\\n            maxh.pop();\\n            count+=temp;\\n            maxh.push(ceil(temp/3.0));  // Used 3.0 for getting an decimal value if exists\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031237,
                "title": "c-best-solution-99-faster-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push(nums[i]);\\n        }\\n\\n        long long score = 0;\\n\\n        while(k && !pq.empty()){\\n            int x = pq.top();\\n            score += x;\\n            pq.pop();\\n            if(x%3==0){\\n                pq.push(x/3);\\n            }\\n            else{\\n                pq.push((x/3) + 1);\\n            }\\n            k--;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push(nums[i]);\\n        }\\n\\n        long long score = 0;\\n\\n        while(k && !pq.empty()){\\n            int x = pq.top();\\n            score += x;\\n            pq.pop();\\n            if(x%3==0){\\n                pq.push(x/3);\\n            }\\n            else{\\n                pq.push((x/3) + 1);\\n            }\\n            k--;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030890,
                "title": "priority-queue-approach-max-heap-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        using ll=long long;\\n        priority_queue<ll>pq;\\n        for(auto x:nums)\\n        {\\n            pq.push(x);\\n        }\\n         ll ans=0;\\n        while(k--)\\n        {\\n            auto t=pq.top();\\n            pq.pop();\\n            ans+=t;\\n            ll n=ceil(t*1.0/3*1.0);\\n            pq.push(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        using ll=long long;\\n        priority_queue<ll>pq;\\n        for(auto x:nums)\\n        {\\n            pq.push(x);\\n        }\\n         ll ans=0;\\n        while(k--)\\n        {\\n            auto t=pq.top();\\n            pq.pop();\\n            ans+=t;\\n            ll n=ceil(t*1.0/3*1.0);\\n            pq.push(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030427,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        sort(nums.begin(), nums.end());\\n        priority_queue<int> pq;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.size()==k){\\n                break;\\n            }\\n        } \\n        while(k--){\\n            int temp= pq.top();\\n            pq.pop();\\n            ans+= temp;\\n            if(temp%3==0){\\n                pq.push(temp/3);\\n            }\\n            else{\\n                pq.push((temp/3)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        sort(nums.begin(), nums.end());\\n        priority_queue<int> pq;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.size()==k){\\n                break;\\n            }\\n        } \\n        while(k--){\\n            int temp= pq.top();\\n            pq.pop();\\n            ans+= temp;\\n            if(temp%3==0){\\n                pq.push(temp/3);\\n            }\\n            else{\\n                pq.push((temp/3)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028808,
                "title": "easy-greedy-maxheap",
                "content": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long res = 0;\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b) -> b - a);\\n        for(int i = 0; i < nums.length; i++) queue.add(nums[i]);\\n        \\n        for(int i = 0; i < k; i++){\\n            int a = queue.poll();\\n            res += a;\\n            queue.add((int)Math.ceil(a/3.0));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long res = 0;\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b) -> b - a);\\n        for(int i = 0; i < nums.length; i++) queue.add(nums[i]);\\n        \\n        for(int i = 0; i < k; i++){\\n            int a = queue.poll();\\n            res += a;\\n            queue.add((int)Math.ceil(a/3.0));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028151,
                "title": "c-max-heap-faster-easy-to-understand",
                "content": "* ***Using Max. Heap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a max heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push all the elements into pq\\n        \\n        for(auto num : nums)\\n        {\\n            pq.push(num);\\n        }\\n        \\n        // run the loop untill k > 0\\n        \\n        long long score = 0;\\n        \\n        while(k--)\\n        {\\n            int top = pq.top();\\n            \\n            pq.pop();\\n            \\n            score += top;\\n            \\n            pq.push(ceil(top / 3.0));\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a max heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push all the elements into pq\\n        \\n        for(auto num : nums)\\n        {\\n            pq.push(num);\\n        }\\n        \\n        // run the loop untill k > 0\\n        \\n        long long score = 0;\\n        \\n        while(k--)\\n        {\\n            int top = pq.top();\\n            \\n            pq.pop();\\n            \\n            score += top;\\n            \\n            pq.push(ceil(top / 3.0));\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024412,
                "title": "c-priority-queue-clean-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023550,
                "title": "java-c-sorting-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxKelements(int[] nums, int k) {\\n    long ans = 0;\\n    TreeMap<Integer, Integer> t = new TreeMap<Integer, Integer>();\\n\\n    for(int n : nums){\\n      Integer x = t.get(n);\\n      x = x == null ? 1 : x + 1;\\n      t.put(n, x);\\n    }\\n\\n    while(! t.isEmpty()){\\n      Map.Entry<Integer, Integer> it = t.pollLastEntry();\\n      int n = it.getKey(), val = it.getValue();\\n\\n      if(val >= k){\\n        ans += (long)k * n;\\n        break;\\n      }\\n\\n      k -= val;\\n      ans += (long)val * n; \\n      int N = n/3 + ( n%3 == 0 ? 0 : 1);\\n\\n      if(N != 0){\\n        Integer x = t.get(N);\\n        x = x == null ? val : x + val;\\n        t.put(N, x);\\n      }    \\n    }     \\n\\n    return ans;\\n  }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n  long long maxKelements(vector<int>& nums, int k) {\\n    long ans = 0;\\n    map<int, int> t;\\n    for(auto n : nums) t[n]++;\\n\\n    while(!t.empty()){\\n      int n = t.rbegin()->first, val = t.rbegin()->second;\\n      t.erase(n);\\n\\n      if(val >= k){\\n        ans += (long)k * n;\\n        break;\\n      }\\n\\n      k -= val;\\n      ans += (long)val * n; \\n      int N = n/3 + bool(n%3);\\n      if(N) t[N] += val;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long maxKelements(int[] nums, int k) {\\n    long ans = 0;\\n    TreeMap<Integer, Integer> t = new TreeMap<Integer, Integer>();\\n\\n    for(int n : nums){\\n      Integer x = t.get(n);\\n      x = x == null ? 1 : x + 1;\\n      t.put(n, x);\\n    }\\n\\n    while(! t.isEmpty()){\\n      Map.Entry<Integer, Integer> it = t.pollLastEntry();\\n      int n = it.getKey(), val = it.getValue();\\n\\n      if(val >= k){\\n        ans += (long)k * n;\\n        break;\\n      }\\n\\n      k -= val;\\n      ans += (long)val * n; \\n      int N = n/3 + ( n%3 == 0 ? 0 : 1);\\n\\n      if(N != 0){\\n        Integer x = t.get(N);\\n        x = x == null ? val : x + val;\\n        t.put(N, x);\\n      }    \\n    }     \\n\\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n  long long maxKelements(vector<int>& nums, int k) {\\n    long ans = 0;\\n    map<int, int> t;\\n    for(auto n : nums) t[n]++;\\n\\n    while(!t.empty()){\\n      int n = t.rbegin()->first, val = t.rbegin()->second;\\n      t.erase(n);\\n\\n      if(val >= k){\\n        ans += (long)k * n;\\n        break;\\n      }\\n\\n      k -= val;\\n      ans += (long)val * n; \\n      int N = n/3 + bool(n%3);\\n      if(N) t[N] += val;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023462,
                "title": "easy-to-understand-python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n      h = []\\n      for i in nums:\\n        h.append(i*-1)\\n      heapq.heapify(h)\\n      j = 0\\n      score = 0\\n      while j < k:\\n        x = h[0]\\n        x = x*-1\\n        score+=x\\n        x = ceil(x/3)\\n        heapq.heapreplace(h,x*-1)\\n        j+=1\\n      return score\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n      h = []\\n      for i in nums:\\n        h.append(i*-1)\\n      heapq.heapify(h)\\n      j = 0\\n      score = 0\\n      while j < k:\\n        x = h[0]\\n        x = x*-1\\n        score+=x\\n        x = ceil(x/3)\\n        heapq.heapreplace(h,x*-1)\\n        j+=1\\n      return score\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020751,
                "title": "easy-java-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->Integer.compare(b,a));\\n        long sum=0;\\n        for(int num:nums){\\n            pq.offer(num);\\n        } \\n        while(k-->0){\\n            int tmp=pq.poll();\\n            sum+=tmp;\\n            pq.offer((int)Math.ceil(tmp/3.0));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->Integer.compare(b,a));\\n        long sum=0;\\n        for(int num:nums){\\n            pq.offer(num);\\n        } \\n        while(k-->0){\\n            int tmp=pq.poll();\\n            sum+=tmp;\\n            pq.offer((int)Math.ceil(tmp/3.0));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020151,
                "title": "priority-queue-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use priority queue to update and get\\'s maximum value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn every iteration we should get maximum from priority queue and after erase it and insert new value.\\n\\n# Complexity\\n- Time complexity: O(n * log(n) + k * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int>> q;\\n        for (auto it : nums) {\\n            q.push(it * (-1));\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            auto it = q.top();\\n            q.pop();\\n            ans += it * (-1);\\n            auto xx = (-1) * ceil((double) (it * (-1) / 3.0));\\n            q.push(xx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int>> q;\\n        for (auto it : nums) {\\n            q.push(it * (-1));\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            auto it = q.top();\\n            q.pop();\\n            ans += it * (-1);\\n            auto xx = (-1) * ceil((double) (it * (-1) / 3.0));\\n            q.push(xx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019340,
                "title": "c-priority-queue-tc-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        long long res = 0;\\n        for(int i = 0; i < k; i++) {\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(temp%3 == 0 ? temp/3 : temp/3+1);\\n            res += temp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        long long res = 0;\\n        for(int i = 0; i < k; i++) {\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(temp%3 == 0 ? temp/3 : temp/3+1);\\n            res += temp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019049,
                "title": "easy-priority-queue-java-solution-for-absolute-beginners",
                "content": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        int val; long res = 0L;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> b-a);\\n        for(int num: nums){\\n            pq.add(num);\\n        }\\n        while(k-->0){\\n            val = pq.poll();\\n            res+=val;\\n            pq.add((int)Math.ceil(val/3.0));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        int val; long res = 0L;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> b-a);\\n        for(int num: nums){\\n            pq.add(num);\\n        }\\n        while(k-->0){\\n            val = pq.poll();\\n            res+=val;\\n            pq.add((int)Math.ceil(val/3.0));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018787,
                "title": "100-fastest-easy-to-understand-c-solution-priority-queue",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> pq;\\n        long long ans=0;\\n        for (int i=0; i<nums.size(); i++)pq.push(nums[i]);\\n        while (k--){\\n            long long val= pq.top();\\n            ans+= pq.top();\\n            pq.pop();\\n            pq.push((val/3)+(val%3!=0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> pq;\\n        long long ans=0;\\n        for (int i=0; i<nums.size(); i++)pq.push(nums[i]);\\n        while (k--){\\n            long long val= pq.top();\\n            ans+= pq.top();\\n            pq.pop();\\n            pq.push((val/3)+(val%3!=0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018324,
                "title": "nlogn-klogn-priority-queue-approach-using-java-and-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At each step we want to take the maximum number. And this has to be done k times.\\n- Once this score is taken, that number is reduced to about num / 3.\\n- And again, we need to take the max number in the list. If we keep iterating it would result in an inefficient algo\\n- So using something like priority queue will help us keep track of largest number at any given point\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize PQ\\n- Add all numbers into PQ\\n- for k operations pull the top most(max) number in PQ and add it to score\\n- Now reduce the num to ceil(num/3) and add it back to PQ\\n- Do this for k operations\\n\\n# Complexity\\n- Time complexity: O(nlogn + klogn), Since PQ size is always n and nlogn for adding all num into PQ and klogn for k operations on pq.poll\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### Java\\n```java\\n    // TC: O(nlogn + klogn), SC: O(n)\\n    public long maxKelements(int[] A, int k) {\\n        Queue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        long score = 0;\\n        for (int num : A) pq.offer(num);\\n        while (!pq.isEmpty() && k-- > 0) {\\n            int num = pq.poll();\\n            score += num;\\n            pq.offer((int) Math.ceil(num / 3.0));\\n        }\\n        return score;\\n    }\\n```\\n\\n### Python\\n```python\\nclass Solution:\\n    # TC: O(n + klogn), SC: O(n)\\n\\t# Note: for python, heapify is O(n) while for java there is no built in heapify, hence its O(nlogn)\\n    def maxKelements(self, A: List[int], k: int) -> int:\\n        heap, score = [-num for num in A], 0\\n        heapq.heapify(heap)\\n\\n        for _ in range(k):\\n            num = -1 * heapq.heappop(heap)\\n            score += num\\n            heapq.heappush(heap, -ceil(num / 3))\\n        \\n        return score\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\n    // TC: O(nlogn + klogn), SC: O(n)\\n    public long maxKelements(int[] A, int k) {\\n        Queue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        long score = 0;\\n        for (int num : A) pq.offer(num);\\n        while (!pq.isEmpty() && k-- > 0) {\\n            int num = pq.poll();\\n            score += num;\\n            pq.offer((int) Math.ceil(num / 3.0));\\n        }\\n        return score;\\n    }\\n```\n```python\\nclass Solution:\\n    # TC: O(n + klogn), SC: O(n)\\n\\t# Note: for python, heapify is O(n) while for java there is no built in heapify, hence its O(nlogn)\\n    def maxKelements(self, A: List[int], k: int) -> int:\\n        heap, score = [-num for num in A], 0\\n        heapq.heapify(heap)\\n\\n        for _ in range(k):\\n            num = -1 * heapq.heappop(heap)\\n            score += num\\n            heapq.heappush(heap, -ceil(num / 3))\\n        \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018021,
                "title": "optimised-easiest-approach",
                "content": "# Intuition: We need to always extract the maximum number from the array thus we need a data structure which can help us rearrange the array in such a way that we can be able to access the maximum number with constant time thus priority queue comes into the picture .\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<long long int> pq;\\n        int count=0;\\n        long long int ans=0;\\n        int n=nums.size();\\n        for (int i = 0; i < n; i++) \\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(!pq.empty() && count<k)\\n        {\\n            int temp=pq.top();\\n            ans+=temp;\\n            count++;\\n            pq.pop();\\n            pq.push(ceil(temp/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<long long int> pq;\\n        int count=0;\\n        long long int ans=0;\\n        int n=nums.size();\\n        for (int i = 0; i < n; i++) \\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(!pq.empty() && count<k)\\n        {\\n            int temp=pq.top();\\n            ans+=temp;\\n            count++;\\n            pq.pop();\\n            pq.push(ceil(temp/3.0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017998,
                "title": "priority-queue-c-solution-easy-and-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        for(auto it:nums)pq.push(it);\\n        long long ans=0;\\n        while(k--){\\n            int temp=pq.top();\\n            ans+=temp;\\n            pq.pop();\\n            pq.push(ceil((double)temp/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        for(auto it:nums)pq.push(it);\\n        long long ans=0;\\n        while(k--){\\n            int temp=pq.top();\\n            ans+=temp;\\n            pq.pop();\\n            pq.push(ceil((double)temp/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017642,
                "title": "python3-similar-to-1962-remove-stones-to-minimize-the-total-in-built-max-heap",
                "content": "This problem is similar to [1962. Remove Stones to Minimize the Total](https://leetcode.com/problems/remove-stones-to-minimize-the-total/)\\n\\nHere is the python3 solution using max heap.\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        heapq._heapify_max(nums)\\n        ans=0\\n        for _ in range(k):\\n            ans += nums[0]\\n            heapq._heapreplace_max(nums, (nums[0]+2)//3)\\n        return ans\\n```\\n\\nIf you have any doubt, ask here in comment.",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        heapq._heapify_max(nums)\\n        ans=0\\n        for _ in range(k):\\n            ans += nums[0]\\n            heapq._heapreplace_max(nums, (nums[0]+2)//3)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017336,
                "title": "fast-and-easy-to-understand-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n\\t//Creating the max Priority queue\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<arr.length;++i){\\n\\t\\t//adding the element in priority queue\\n            pq.add(arr[i]);\\n        }\\n        \\n        long ans = 0;\\n        \\n        while(k-->0){\\n\\t\\t//removing the element with max value\\n            long temp = (long)pq.remove();\\n\\t\\t\\t//updating our answer\\n            ans += temp;\\n            \\n\\t\\t\\t//again adding the number but with math.ceil of number/ 3.\\n            temp = ((temp-1)/3)+1 ;\\n            \\n            pq.add((int)temp);\\n        }\\n        \\n\\t\\t//returning the answer\\n\\t\\t\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n\\t//Creating the max Priority queue\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<arr.length;++i){\\n\\t\\t//adding the element in priority queue\\n            pq.add(arr[i]);\\n        }\\n        \\n        long ans = 0;\\n        \\n        while(k-->0){\\n\\t\\t//removing the element with max value\\n            long temp = (long)pq.remove();\\n\\t\\t\\t//updating our answer\\n            ans += temp;\\n            \\n\\t\\t\\t//again adding the number but with math.ceil of number/ 3.\\n            temp = ((temp-1)/3)+1 ;\\n            \\n            pq.add((int)temp);\\n        }\\n        \\n\\t\\t//returning the answer\\n\\t\\t\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017334,
                "title": "python-solution-using-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\n        heap=[-val for val in nums]\\n\\n        heapify(heap)\\n        ans=0\\n        \\n        while k:\\n            mx=-heappop(heap)\\n            ans+=mx\\n            heappush(heap,-math.ceil(mx/3))\\n            k-=1\\n        return ans\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\n        heap=[-val for val in nums]\\n\\n        heapify(heap)\\n        ans=0\\n        \\n        while k:\\n            mx=-heappop(heap)\\n            ans+=mx\\n            heappush(heap,-math.ceil(mx/3))\\n            k-=1\\n        return ans\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017309,
                "title": "java-using-treemap-easy",
                "content": "\\t\\tpublic long maxKelements(int[] nums, int k) {\\n\\t\\t long sum = 0;\\n\\t\\t\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\tfor (int i : nums) {\\n\\t\\t\\t\\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\t\\tsum += map.lastKey();\\n\\t\\t\\t\\tmap.put(map.lastKey(), map.getOrDefault(map.lastKey(),0)-1);\\n\\t\\t\\t\\tdouble val = map.lastKey() / 3d;\\n\\t\\t\\t\\tif (map.get(map.lastKey()) <= 0) {\\n\\t\\t\\t\\t\\tmap.remove(map.lastKey());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdouble nval = Math.ceil(val);\\n\\t\\t\\t\\tmap.put((int) nval, map.getOrDefault((int) nval, 0) + 1);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn sum;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "\\t\\tpublic long maxKelements(int[] nums, int k) {\\n\\t\\t long sum = 0;\\n\\t\\t\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\tfor (int i : nums) {\\n\\t\\t\\t\\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\t\\tsum += map.lastKey();\\n\\t\\t\\t\\tmap.put(map.lastKey(), map.getOrDefault(map.lastKey(),0)-1);\\n\\t\\t\\t\\tdouble val = map.lastKey() / 3d;\\n\\t\\t\\t\\tif (map.get(map.lastKey()) <= 0) {\\n\\t\\t\\t\\t\\tmap.remove(map.lastKey());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdouble nval = Math.ceil(val);\\n\\t\\t\\t\\tmap.put((int) nval, map.getOrDefault((int) nval, 0) + 1);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn sum;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3017278,
                "title": "c-using-priority-queue-max-heap-t-c-o-nlog-n-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n/*\\n\\tT.C. : O(Nlog(N))\\n\\tS.C. : O(N)\\n*/\\n\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int> pq;\\n        \\n        for(int ele : nums) pq.push(ele);\\n        \\n        long long score = 0;\\n        \\n        while(k--){\\n            int top = pq.top();\\n            pq.pop();\\n            score += top;\\n            top = ceil(top/3.0);\\n            pq.push(top);\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n/*\\n\\tT.C. : O(Nlog(N))\\n\\tS.C. : O(N)\\n*/\\n\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue <int> pq;\\n        \\n        for(int ele : nums) pq.push(ele);\\n        \\n        long long score = 0;\\n        \\n        while(k--){\\n            int top = pq.top();\\n            pq.pop();\\n            score += top;\\n            top = ceil(top/3.0);\\n            pq.push(top);\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017275,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long score = 0;\\n        for(auto it : nums) pq.push(it);\\n        while(k--){\\n            int top = pq.top(); \\n            int s;\\n            if(top % 3 == 0) s = top / 3;\\n            else s = top/3 + 1;\\n            score += top;\\n            pq.pop();\\n            pq.push(s);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long score = 0;\\n        for(auto it : nums) pq.push(it);\\n        while(k--){\\n            int top = pq.top(); \\n            int s;\\n            if(top % 3 == 0) s = top / 3;\\n            else s = top/3 + 1;\\n            score += top;\\n            pq.pop();\\n            pq.push(s);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017251,
                "title": "java-very-easy-solution-using-priority-queue",
                "content": "# Approach\\nKeep adding the ceil in Priority Queue and always use the top as it will be max\\n\\n# Complexity\\n- Time complexity:\\nO(K)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b - a);\\n        for(int i : nums) queue.add(i);\\n       \\n        long ans = 0; \\n        \\n        while(k > 0) {\\n            double curr = queue.peek();\\n            double ceil = Math.ceil(curr/3);\\n            ans += (int) curr;\\n            queue.remove();\\n            queue.add((int) ceil);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n\\n// upvote if liked \\uD83D\\uDE01\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b - a);\\n        for(int i : nums) queue.add(i);\\n       \\n        long ans = 0; \\n        \\n        while(k > 0) {\\n            double curr = queue.peek();\\n            double ceil = Math.ceil(curr/3);\\n            ans += (int) curr;\\n            queue.remove();\\n            queue.add((int) ceil);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n\\n// upvote if liked \\uD83D\\uDE01\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017182,
                "title": "easy-java-solution-90-faster",
                "content": "# Complexity\\n- Time complexity: O(n)\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score = 0;\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    for (Integer num : nums) \\n    {\\n      pq.add(num);\\n    }\\n    while(k!=0)\\n    {\\n        int a=pq.poll();\\n        score+=a;\\n        pq.add((int)Math.ceil(a/3.0));\\n        k--;\\n    }\\n    return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score = 0;\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    for (Integer num : nums) \\n    {\\n      pq.add(num);\\n    }\\n    while(k!=0)\\n    {\\n        int a=pq.poll();\\n        score+=a;\\n        pq.add((int)Math.ceil(a/3.0));\\n        k--;\\n    }\\n    return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017174,
                "title": "java-solution-priorityqueue",
                "content": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer>pq = new PriorityQueue<>((a,b)->b-a); // Building Max Heap\\n        long ans = 0;\\n        for(int num:nums){\\n            pq.add(num);\\n        }\\n        long sum =0;\\n        for(int i=0;i<k;i++){\\n            int t = pq.poll();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sum+=(long)t;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 pq.add((t+2)/3); // taking ceil value\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer>pq = new PriorityQueue<>((a,b)->b-a); // Building Max Heap\\n        long ans = 0;\\n        for(int num:nums){\\n            pq.add(num);\\n        }\\n        long sum =0;\\n        for(int i=0;i<k;i++){\\n            int t = pq.poll();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sum+=(long)t;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 pq.add((t+2)/3); // taking ceil value\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017167,
                "title": "js-maxpriorityqueue",
                "content": "```\\nconst maxKelements = function(nums, k) {\\n    const q = new MaxPriorityQueue();\\n    let sum = 0\\n    for(let i of nums){\\n        q.enqueue(i);\\n    }\\n    for(let i = 0; i < k; i++){\\n        let val = q.dequeue().element;\\n        sum += val; \\n        q.enqueue(Math.ceil(val / 3))\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxKelements = function(nums, k) {\\n    const q = new MaxPriorityQueue();\\n    let sum = 0\\n    for(let i of nums){\\n        q.enqueue(i);\\n    }\\n    for(let i = 0; i < k; i++){\\n        let val = q.dequeue().element;\\n        sum += val; \\n        q.enqueue(Math.ceil(val / 3))\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017102,
                "title": "c-optimized-priority-queue-faster-than-100",
                "content": "### ***If you find this helpful, Please Upvote \\uD83D\\uDD3C , Thank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long sum = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto i: nums) pq.push(i);\\n        \\n        // for ceil function, it is imp to use \\'double\\'\\n        double temp;\\n        while(k--) {\\n            temp = pq.top();\\n            pq.pop();\\n            \\n            sum += temp;\\n            temp = ceil(temp/3);\\n            \\n            pq.push(temp);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long sum = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto i: nums) pq.push(i);\\n        \\n        // for ceil function, it is imp to use \\'double\\'\\n        double temp;\\n        while(k--) {\\n            temp = pq.top();\\n            pq.pop();\\n            \\n            sum += temp;\\n            temp = ceil(temp/3);\\n            \\n            pq.push(temp);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016955,
                "title": "python-solution-using-priority-queue-easy-to-understand",
                "content": "# Approach \\n* Firstly, create a priority queue using the queue library then take a variable score to count score. Then simply put elements in priority queue in negative integers. Then, simply do what the questions say you to do, get the highest priority element in positive and add that to score and then put the ceil(h/3) in negative to the priority queue. \\n\\n# Complexity\\n- Time complexity: O(2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport queue\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        karan = queue.PriorityQueue()\\n        score = 0\\n        for i in range(len(nums)):\\n            karan.put((-nums[i]))\\n        for i in range(k):\\n            h = -1 * karan.get()\\n            score += h\\n            h = ceil(h/3)\\n            karan.put(-h)\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport queue\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        karan = queue.PriorityQueue()\\n        score = 0\\n        for i in range(len(nums)):\\n            karan.put((-nums[i]))\\n        for i in range(k):\\n            h = -1 * karan.get()\\n            score += h\\n            h = ceil(h/3)\\n            karan.put(-h)\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016928,
                "title": "easy-simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n           priority_queue<int> pq;\\n        long long count=0;\\n        int t=0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n         while(t!=k){\\n             long long a= pq.top(); \\n             count+=pq.top();\\n             pq.pop();\\n            a=(a%3==0?a/3:a/3+1);\\n             pq.push(a);\\n             \\n             t++;\\n         }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n           priority_queue<int> pq;\\n        long long count=0;\\n        int t=0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n         while(t!=k){\\n             long long a= pq.top(); \\n             count+=pq.top();\\n             pq.pop();\\n            a=(a%3==0?a/3:a/3+1);\\n             pq.push(a);\\n             \\n             t++;\\n         }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016926,
                "title": "python-solution-using-priority-queue",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        score = 0\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, (-num, num))\\n        while k > 0:\\n            max_element = heapq.heappop(pq)[1]\\n            score += max_element\\n            updated_value = max_element // 3 + (max_element % 3 != 0)\\n            heapq.heappush(pq, (-updated_value, updated_value))\\n            k -= 1\\n        return score\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        score = 0\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, (-num, num))\\n        while k > 0:\\n            max_element = heapq.heappop(pq)[1]\\n            score += max_element\\n            updated_value = max_element // 3 + (max_element % 3 != 0)\\n            heapq.heappush(pq, (-updated_value, updated_value))\\n            k -= 1\\n        return score\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016910,
                "title": "java-solution-priorityqueue-easy-and-concise",
                "content": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:nums)\\n            pq.add(x);\\n        long score=0;\\n        while(k-->0){\\n            int a = pq.remove();\\n            score+=a;\\n            pq.add((int)Math.ceil((double)a/3));\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:nums)\\n            pq.add(x);\\n        long score=0;\\n        while(k-->0){\\n            int a = pq.remove();\\n            score+=a;\\n            pq.add((int)Math.ceil((double)a/3));\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016905,
                "title": "c-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a priority queue to sort `nums`, repeat `k` times:\\n- set `top` to top element\\n- remove top element\\n- add `top` to `score`\\n- insert `ceil(top / 3.0)`\\n\\n# Complexity\\n- Time complexity: $$O((n + k) log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq = {nums.begin(), nums.end()};\\n        for (int i = 0; i < k; i++) {\\n            int top = pq.top();\\n            pq.pop();\\n            score += top;\\n            pq.push(ceil(top / 3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq = {nums.begin(), nums.end()};\\n        for (int i = 0; i < k; i++) {\\n            int top = pq.top();\\n            pq.pop();\\n            score += top;\\n            pq.push(ceil(top / 3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016880,
                "title": "easiest-way-to-solve-using-max-heap-java-solution",
                "content": "# Complexity\\n- Time complexity:\\n**O(N*Log(N))**\\n\\n- Space complexity:\\n**O(N)**\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long max = 0;\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : nums)\\n            q.add(i);\\n        while(k != 0) {\\n            double val = q.poll();\\n            max += (int)val;\\n            q.add((int)Math.ceil(val/3));\\n            k--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long max = 0;\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : nums)\\n            q.add(i);\\n        while(k != 0) {\\n            double val = q.poll();\\n            max += (int)val;\\n            q.add((int)Math.ceil(val/3));\\n            k--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016856,
                "title": "c-solution-easy-to-understand-clean-solution-using-priority-queue",
                "content": "# Approach\\nUsed a priority queue data structure to get the maximum at any point during operations.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tlong long maxKelements(vector<int> &nums, int k)\\n\\t{\\n\\t\\tpriority_queue<long long> pq;\\n\\t\\tfor (auto &x : nums)\\n\\t\\t\\tpq.push(x);\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (pq.empty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tans += pq.top();\\n\\t\\t\\tpq.push((pq.top() + 2) / 3);\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tlong long maxKelements(vector<int> &nums, int k)\\n\\t{\\n\\t\\tpriority_queue<long long> pq;\\n\\t\\tfor (auto &x : nums)\\n\\t\\t\\tpq.push(x);\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (pq.empty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tans += pq.top();\\n\\t\\t\\tpq.push((pq.top() + 2) / 3);\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016840,
                "title": "c-priority-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int> p;\\n        for(auto i : nums)\\n        {\\n            p.push(i);\\n        }\\n        long max=0;\\n        for(int i=k; i>0; i--)\\n        {\\n            int c = p.top();\\n            p.pop();\\n            max+=c;\\n            int f=(int)ceil(c/3.0);\\n            p.push(f);\\n        }\\n        return max;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int> p;\\n        for(auto i : nums)\\n        {\\n            p.push(i);\\n        }\\n        long max=0;\\n        for(int i=k; i>0; i--)\\n        {\\n            int c = p.top();\\n            p.pop();\\n            max+=c;\\n            int f=(int)ceil(c/3.0);\\n            p.push(f);\\n        }\\n        return max;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016837,
                "title": "python-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem greedily, each time taking the max number from the array. However taking the max number from an array take 0(n) time and doing this k times makes the time complexity k * 0(n) time. As this approach requires taking the max each time we can use a priotity queue to optimise time complexity.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        #brute force TLE\\n        res = 0\\n        for i in range(k):\\n            m = max(nums)\\n            idx = nums.index(m)\\n            res += m\\n            nums.pop(idx)\\n            nums.append(ceil(m / 3))\\n        return res\\n        \\'\\'\\'\\n        heap = []\\n        heapify(heap)\\n        for i in nums:\\n            heappush(heap, -1 * i)\\n        res = 0\\n        for i in range(k):\\n            max_num = heappop(heap) * -1\\n            res += max_num\\n            heappush(heap, ceil(max_num / 3) * -1)\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        #brute force TLE\\n        res = 0\\n        for i in range(k):\\n            m = max(nums)\\n            idx = nums.index(m)\\n            res += m\\n            nums.pop(idx)\\n            nums.append(ceil(m / 3))\\n        return res\\n        \\'\\'\\'\\n        heap = []\\n        heapify(heap)\\n        for i in nums:\\n            heappush(heap, -1 * i)\\n        res = 0\\n        for i in range(k):\\n            max_num = heappop(heap) * -1\\n            res += max_num\\n            heappush(heap, ceil(max_num / 3) * -1)\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016817,
                "title": "c-priority-queue-max-heap-easy-solution",
                "content": "```\\n#include <cmath>\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    priority_queue <int > pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);    \\n        }\\n    \\n        while(k--)\\n        {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil(a*1.0/3.0));\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#include <cmath>\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    priority_queue <int > pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);    \\n        }\\n    \\n        while(k--)\\n        {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil(a*1.0/3.0));\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3016811,
                "title": "short-clean-priorityqueue-easy-java",
                "content": "\\n```java []\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int num: nums)  pq.add(num);\\n        long sum = 0;\\n        while(k-- > 0){\\n            double val = pq.poll();\\n            sum += val;\\n            pq.add((int)Math.ceil(val/3));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int num: nums)  pq.add(num);\\n        long sum = 0;\\n        while(k-- > 0){\\n            double val = pq.poll();\\n            sum += val;\\n            pq.add((int)Math.ceil(val/3));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016807,
                "title": "trying-to-be-greedy-using-maxheap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long res = 0;\\n        for(auto ele:nums)pq.push(ele);\\n        while(!pq.empty() and k){\\n            auto ele = pq.top();\\n            pq.pop();\\n            \\n            res+=ele;\\n            pq.push((ele/3) + (ele%3!=0)), k--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long res = 0;\\n        for(auto ele:nums)pq.push(ele);\\n        while(!pq.empty() and k){\\n            auto ele = pq.top();\\n            pq.pop();\\n            \\n            res+=ele;\\n            pq.push((ele/3) + (ele%3!=0)), k--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016787,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i : nums) pq.push(i);\\n        while(k--){\\n            int x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            pq.push(x-(2*x/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i : nums) pq.push(i);\\n        while(k--){\\n            int x = pq.top();\\n            pq.pop();\\n            ans += x;\\n            pq.push(x-(2*x/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016734,
                "title": "javascript-maxpriorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n    const pq = new MaxPriorityQueue();\\n    for (const num of nums) {\\n        pq.enqueue(num);\\n    }\\n    \\n    let ans = 0;\\n    for (let i = 0; i < k; i++) {\\n        const val = pq.dequeue().element;\\n        ans += val;\\n        pq.enqueue(Math.ceil(val / 3));\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n    const pq = new MaxPriorityQueue();\\n    for (const num of nums) {\\n        pq.enqueue(num);\\n    }\\n    \\n    let ans = 0;\\n    for (let i = 0; i < k; i++) {\\n        const val = pq.dequeue().element;\\n        ans += val;\\n        pq.enqueue(Math.ceil(val / 3));\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099319,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        priority_queue<int> maxHeap;\\n\\n        for(int i=0;i<n;i++) {\\n            maxHeap.push(nums[i]);\\n        }\\n\\n        long long score = 0;\\n\\n        while(k>0) {\\n            int curr = maxHeap.top();\\n            score += curr;\\n            maxHeap.pop();\\n\\n            int temp = ceil(curr/3.0);\\n\\n            maxHeap.push(temp);\\n\\n            k--;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        priority_queue<int> maxHeap;\\n\\n        for(int i=0;i<n;i++) {\\n            maxHeap.push(nums[i]);\\n        }\\n\\n        long long score = 0;\\n\\n        while(k>0) {\\n            int curr = maxHeap.top();\\n            score += curr;\\n            maxHeap.pop();\\n\\n            int temp = ceil(curr/3.0);\\n\\n            maxHeap.push(temp);\\n\\n            k--;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098662,
                "title": "priority-queue-max-heap-easiest-solution-easy-2-understand-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq;\\n        for(auto it: nums){\\n            pq.push(it);\\n        }\\n        while(k !=0){\\n            k--;\\n            score += pq.top();\\n            int a = ceil(double(pq.top())/3);\\n            pq.pop();\\n            pq.push(a);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        priority_queue<int> pq;\\n        for(auto it: nums){\\n            pq.push(it);\\n        }\\n        while(k !=0){\\n            k--;\\n            score += pq.top();\\n            int a = ceil(double(pq.top())/3);\\n            pq.pop();\\n            pq.push(a);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093154,
                "title": "python-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProcess the largest value first while k > 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can find the largest value using a max heap (invert the min heap by multiplying all values by -1). Add that to the score and if the remaining value (after ceil(num / 3)) is greater than 0 then add that back to the heap. Keep doing this till k > 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + klogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nimport heapq as hq\\nimport math\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = list(map(lambda x: -1*x, nums))\\n        hq.heapify(nums)\\n\\n        score = 0\\n        while k and nums:\\n            cur_val = -1*hq.heappop(nums)\\n            score += cur_val\\n            rem_val = int(math.ceil(cur_val / 3))\\n            if rem_val > 0:\\n                hq.heappush(nums, -1*rem_val)\\n            k -= 1\\n        return score\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq as hq\\nimport math\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = list(map(lambda x: -1*x, nums))\\n        hq.heapify(nums)\\n\\n        score = 0\\n        while k and nums:\\n            cur_val = -1*hq.heappop(nums)\\n            score += cur_val\\n            rem_val = int(math.ceil(cur_val / 3))\\n            if rem_val > 0:\\n                hq.heappush(nums, -1*rem_val)\\n            k -= 1\\n        return score\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072732,
                "title": "two-approaches",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long  ans=0;\\n        // Gives TLE\\n        // while(k--){\\n            // sort(nums.begin(),nums.end());\\n            // ans+=nums[nums.size()-1];\\n            // if(nums[nums.size()-1]%3==0) nums[nums.size()-1]=nums[nums.size()-1]/3;\\n            // else nums[nums.size()-1]=nums[nums.size()-1]/3 +1;\\n        // }\\n            priority_queue<long long>pq;\\n            for(auto it:nums){\\n                pq.push(it);\\n            }\\n            long long score=0;\\n            while(k--){\\n                int mxm=pq.top();\\n                pq.pop();\\n                score+=mxm;\\n                int newval=(mxm/3)+(mxm%3==0?0:1);\\n                pq.push(newval);\\n            }\\n            return score;\\n\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long  ans=0;\\n        // Gives TLE\\n        // while(k--){\\n            // sort(nums.begin(),nums.end());\\n            // ans+=nums[nums.size()-1];\\n            // if(nums[nums.size()-1]%3==0) nums[nums.size()-1]=nums[nums.size()-1]/3;\\n            // else nums[nums.size()-1]=nums[nums.size()-1]/3 +1;\\n        // }\\n            priority_queue<long long>pq;\\n            for(auto it:nums){\\n                pq.push(it);\\n            }\\n            long long score=0;\\n            while(k--){\\n                int mxm=pq.top();\\n                pq.pop();\\n                score+=mxm;\\n                int newval=(mxm/3)+(mxm%3==0?0:1);\\n                pq.push(newval);\\n            }\\n            return score;\\n\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070375,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b-a);\\n        Long sum = 0L;\\n        for(int num: nums){\\n            queue.offer(num);\\n        }\\n        while(k>0){\\n            int curr = queue.poll();\\n            sum+=curr;\\n            queue.offer((int)Math.ceil((double)curr/3));\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b-a);\\n        Long sum = 0L;\\n        for(int num: nums){\\n            queue.offer(num);\\n        }\\n        while(k>0){\\n            int curr = queue.poll();\\n            sum+=curr;\\n            queue.offer((int)Math.ceil((double)curr/3));\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042118,
                "title": "todoline-js-segment-tree-easy-understand",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n\\n    let n = nums.length;\\n    \\n    let tr = new Array(2 * n);\\n    for(let i = 0; i < tr.length; i++) {\\n        tr[i] = [i, 0];\\n    }\\n\\n    const update = function(idx, val) {\\n        let index = n + idx;\\n        tr[index] = [index, val];\\n\\n        index = index >> 1;\\n\\n        while(index > 0) {\\n            let left = tr[index * 2];\\n            let right = tr[index * 2 + 1];\\n            \\n            if (left[1] > right[1]) {\\n                tr[index] = [...left];\\n            } else {\\n                tr[index] = [...right];\\n            }\\n\\n            index = index >> 1;\\n        }\\n    }\\n\\n    const query = function(left, right) {\\n        if (left > right) return [-1, 0];\\n\\n        let res = [-1, 0];\\n        let lIdx = n + left;\\n        let rIdx = n + right;\\n\\n        while(lIdx <= rIdx) {\\n            if (lIdx % 2 == 1) {\\n                let l = tr[lIdx++];\\n                if (l[1] > res[1]) {\\n                    res = [...l];\\n                }\\n            }\\n            if (rIdx % 2 == 0) {\\n                let r = tr[rIdx--];\\n                if (r[1] > res[1]) {\\n                    res = [...r];\\n                }\\n            }\\n            lIdx = lIdx >> 1;\\n            rIdx = rIdx >> 1; \\n        }\\n\\n        res[0] = res[0] - n;\\n        return res;\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        update(i, nums[i]);\\n    }\\n\\n    let ans = 0;\\n\\n    // console.log(tr)\\n    // console.log(query(0, n - 1))\\n\\n    while(k > 0) {\\n        let max = query(0, n -1);\\n        ans += max[1];\\n        let x = Math.ceil(max[1] / 3);\\n        update(max[0], x);\\n        k--;\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Segment Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxKelements = function(nums, k) {\\n\\n    let n = nums.length;\\n    \\n    let tr = new Array(2 * n);\\n    for(let i = 0; i < tr.length; i++) {\\n        tr[i] = [i, 0];\\n    }\\n\\n    const update = function(idx, val) {\\n        let index = n + idx;\\n        tr[index] = [index, val];\\n\\n        index = index >> 1;\\n\\n        while(index > 0) {\\n            let left = tr[index * 2];\\n            let right = tr[index * 2 + 1];\\n            \\n            if (left[1] > right[1]) {\\n                tr[index] = [...left];\\n            } else {\\n                tr[index] = [...right];\\n            }\\n\\n            index = index >> 1;\\n        }\\n    }\\n\\n    const query = function(left, right) {\\n        if (left > right) return [-1, 0];\\n\\n        let res = [-1, 0];\\n        let lIdx = n + left;\\n        let rIdx = n + right;\\n\\n        while(lIdx <= rIdx) {\\n            if (lIdx % 2 == 1) {\\n                let l = tr[lIdx++];\\n                if (l[1] > res[1]) {\\n                    res = [...l];\\n                }\\n            }\\n            if (rIdx % 2 == 0) {\\n                let r = tr[rIdx--];\\n                if (r[1] > res[1]) {\\n                    res = [...r];\\n                }\\n            }\\n            lIdx = lIdx >> 1;\\n            rIdx = rIdx >> 1; \\n        }\\n\\n        res[0] = res[0] - n;\\n        return res;\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        update(i, nums[i]);\\n    }\\n\\n    let ans = 0;\\n\\n    // console.log(tr)\\n    // console.log(query(0, n - 1))\\n\\n    while(k > 0) {\\n        let max = query(0, n -1);\\n        ans += max[1];\\n        let x = Math.ceil(max[1] / 3);\\n        update(max[0], x);\\n        k--;\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024201,
                "title": "pq",
                "content": "**time: `O(NlogN)`; space: `O(N)`**\\n```\\nlong long maxKelements(vector<int>& n, int k)\\n{\\n\\tlong long out{};\\n\\tfor(priority_queue<int> pq(begin(n),end(n)); k--; )\\n\\t{\\n\\t\\tout += pq.top();\\n\\t\\tauto t = ceil(pq.top()/3.0);\\n\\t\\tpq.pop();\\n\\t\\tpq.push(t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maxKelements(vector<int>& n, int k)\\n{\\n\\tlong long out{};\\n\\tfor(priority_queue<int> pq(begin(n),end(n)); k--; )\\n\\t{\\n\\t\\tout += pq.top();\\n\\t\\tauto t = ceil(pq.top()/3.0);\\n\\t\\tpq.pop();\\n\\t\\tpq.push(t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012509,
                "title": "simple-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto &it:nums){\\n            pq.push(it);\\n        }\\n        int x;\\n        while(k-- && !pq.empty()){\\n            x=pq.top();\\n            pq.pop();\\n            ans+=x;\\n            if(ceil(x/3.0)){\\n                pq.push(ceil(x/3.0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto &it:nums){\\n            pq.push(it);\\n        }\\n        int x;\\n        while(k-- && !pq.empty()){\\n            x=pq.top();\\n            pq.pop();\\n            ans+=x;\\n            if(ceil(x/3.0)){\\n                pq.push(ceil(x/3.0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968584,
                "title": "golang-heap-solution",
                "content": "# Code\\n```go\\nfunc maxKelements(nums []int, k int) int64 {\\n\\th := &Heap{}\\n\\tfor _, v := range nums {\\n\\t\\theap.Push(h, v)\\n\\t}\\n\\tscore := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tval := heap.Pop(h).(int)\\n\\t\\tscore += val\\n\\t\\theap.Push(h, int(math.Ceil(float64(val)/3.0)))\\n\\t}\\n\\treturn int64(score)\\n}\\n\\ntype Heap []int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i] > p[j] }\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.(int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\nfunc maxKelements(nums []int, k int) int64 {\\n\\th := &Heap{}\\n\\tfor _, v := range nums {\\n\\t\\theap.Push(h, v)\\n\\t}\\n\\tscore := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tval := heap.Pop(h).(int)\\n\\t\\tscore += val\\n\\t\\theap.Push(h, int(math.Ceil(float64(val)/3.0)))\\n\\t}\\n\\treturn int64(score)\\n}\\n\\ntype Heap []int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i] > p[j] }\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.(int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3934806,
                "title": "best-java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<arr.length; i++){\\n            pq.add(arr[i]);\\n        }\\n\\n        long ans = 0;\\n\\n        while(k>0){\\n            int a = pq.remove();\\n            ans+=a;\\n            pq.add((int)Math.ceil(a*1.0/3));\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] arr, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<arr.length; i++){\\n            pq.add(arr[i]);\\n        }\\n\\n        long ans = 0;\\n\\n        while(k>0){\\n            int a = pq.remove();\\n            ans+=a;\\n            pq.add((int)Math.ceil(a*1.0/3));\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923109,
                "title": "c-using-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>p;\\n        for(int i=0;i<nums.size();i++){\\n            p.push(nums[i]);\\n        }\\n        long long score=0;\\n        while(k--){\\n            double a;\\n            if(!p.empty()){\\n             a=p.top();\\n            }\\n            score+=a;\\n            p.pop();\\n            p.push(ceil(a/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>p;\\n        for(int i=0;i<nums.size();i++){\\n            p.push(nums[i]);\\n        }\\n        long long score=0;\\n        while(k--){\\n            double a;\\n            if(!p.empty()){\\n             a=p.top();\\n            }\\n            score+=a;\\n            p.pop();\\n            p.push(ceil(a/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916997,
                "title": "python-maxheap",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        h = []\\n\\n        for value in nums:\\n            heappush(h, -value)\\n\\n        counter = 0\\n        score = 0\\n        \\n        while counter < k:\\n            number = -heappop(h)\\n            \\n            score += number\\n            \\n            heappush(h, -ceil(number / 3) )\\n            \\n            counter += 1\\n        \\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        h = []\\n\\n        for value in nums:\\n            heappush(h, -value)\\n\\n        counter = 0\\n        score = 0\\n        \\n        while counter < k:\\n            number = -heappop(h)\\n            \\n            score += number\\n            \\n            heappush(h, -ceil(number / 3) )\\n            \\n            counter += 1\\n        \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916607,
                "title": "2530-maximal-score-after-applying-k-operations-python-solution",
                "content": "# Intuition\\nWe should get the maximum `num` at each operation to maximize the score. So, the intuition is to use the max heap to get the maximum `num`.\\n\\n# Approach\\n- Max heapify `nums`.\\n- Pop `num` from the max heap and push it back with `math.ceil(num / 3)`.\\n- Increment the `score` by `num`.\\n- Decrement the `k` by `1`.\\n- Repeat the above steps till k becomes `0`.\\n\\n# Complexity\\n- Time complexity: O(n * log(n) + k * log(n)) = **O((n + k) * log(n))** = **O(logn<sup>(n + k)</sup>)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n\\n        score = 0\\n        heapq.heapify(nums)\\n\\n        while nums and k:\\n            num = -heapq.heappop(nums)\\n            score += num\\n            heapq.heappush(nums, -math.ceil(num / 3))\\n            k -= 1\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n\\n        score = 0\\n        heapq.heapify(nums)\\n\\n        while nums and k:\\n            num = -heapq.heappop(nums)\\n            score += num\\n            heapq.heappush(nums, -math.ceil(num / 3))\\n            k -= 1\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902562,
                "title": "c-priority-queue-beats-99-09",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        ll ans=0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            if(pq.top()==0)\\n            {\\n                break;\\n            }\\n            ans+=(ll)pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            (a%3==0)?a=a/3:a = a/3+1;\\n            pq.push(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        ll ans=0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            if(pq.top()==0)\\n            {\\n                break;\\n            }\\n            ans+=(ll)pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            (a%3==0)?a=a/3:a = a/3+1;\\n            pq.push(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859295,
                "title": "java-easy-priority-queue",
                "content": "\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue(Collections.reverseOrder());\\n        for(int x:nums)pq.add(x);\\n\\n        long ans=0;\\n        while(k>0){\\n            int cur=pq.peek();\\n            pq.remove();\\n            ans+=cur;\\n            double c=(double)cur/3;\\n            pq.add((int)Math.ceil(c));\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue(Collections.reverseOrder());\\n        for(int x:nums)pq.add(x);\\n\\n        long ans=0;\\n        while(k>0){\\n            int cur=pq.peek();\\n            pq.remove();\\n            ans+=cur;\\n            double c=(double)cur/3;\\n            pq.add((int)Math.ceil(c));\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853037,
                "title": "python3-faster-than-94-heapq",
                "content": "\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n        heapq.heapify(nums)\\n        tot = 0\\n        while k:\\n            e = heapq.heappop(nums)\\n            tot += e\\n            heapq.heappush(nums,math.floor(e/3))\\n            k-=1\\n        return -tot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n        heapq.heapify(nums)\\n        tot = 0\\n        while k:\\n            e = heapq.heappop(nums)\\n            tot += e\\n            heapq.heappush(nums,math.floor(e/3))\\n            k-=1\\n        return -tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826720,
                "title": "c-beats-100-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k)\\n    {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(int x: nums){pq.push(x);}\\n        while(k--)\\n        {\\n            int x = pq.top();\\n            pq.pop();\\n            if(x%3==0)\\n            {\\n                pq.push(x/3);\\n                ans+=x;\\n            }\\n            else\\n            {\\n                pq.push(x/3 + 1);\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k)\\n    {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(int x: nums){pq.push(x);}\\n        while(k--)\\n        {\\n            int x = pq.top();\\n            pq.pop();\\n            if(x%3==0)\\n            {\\n                pq.push(x/3);\\n                ans+=x;\\n            }\\n            else\\n            {\\n                pq.push(x/3 + 1);\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800477,
                "title": "90-faster-c-4-line-solution",
                "content": "```\\n     class Solution {\\npublic:\\n     priority_queue<int>q;\\n     long long int ans=0;\\n    long long maxKelements(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size();i++){\\n            q.push(nums[i]);\\n        }\\n        while(k--){\\n            int t=q.top();\\n            ans+=t;  \\n\\t\\t\\tq.pop();\\n            if(t%3!=0){t=t/3+1;}else t=t/3;\\n            q.push(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n     class Solution {\\npublic:\\n     priority_queue<int>q;\\n     long long int ans=0;\\n    long long maxKelements(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size();i++){\\n            q.push(nums[i]);\\n        }\\n        while(k--){\\n            int t=q.top();\\n            ans+=t;  \\n\\t\\t\\tq.pop();\\n            if(t%3!=0){t=t/3+1;}else t=t/3;\\n            q.push(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796282,
                "title": "cpp-simple-enough-solution-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int,vector<int>> pq;\\n        for(auto it:nums) pq.push(it);\\n        \\n        while(k--){\\n            int ele = pq.top();\\n            pq.pop();\\n            ans+=ele;\\n            pq.push(ceil(1.0*ele/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        priority_queue<int,vector<int>> pq;\\n        for(auto it:nums) pq.push(it);\\n        \\n        while(k--){\\n            int ele = pq.top();\\n            pq.pop();\\n            ans+=ele;\\n            pq.push(ceil(1.0*ele/3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786211,
                "title": "9-line-simplest-code-priority-queue-c",
                "content": "# Intuition\\nIts really simple guys using max heao you can solve it within 2 minutes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        long long sum=0;\\n        while(k--)\\n        {\\n            sum+=pq.top();\\n             int x=pq.top();\\n             pq.pop();\\n             pq.push(ceil((double)x/3));\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        long long sum=0;\\n        while(k--)\\n        {\\n            sum+=pq.top();\\n             int x=pq.top();\\n             pq.pop();\\n             pq.push(ceil((double)x/3));\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769231,
                "title": "python3-most-optimized-solution-beats-100",
                "content": "# Intuition\\nThe difficulty here is really just making it efficient, we could do it with native datatypes, i.e getting the biggest number for every iteration, but it isnt fast enough.\\n\\nThat\\'s why we need to use a heap queue (also called priority queue), which uses an underlying binary tree structure where the root is always the smallest element (minheap). But we need a maxheap, since we want the biggest element, right? Think about how we could solve this problem before you continue reading.\\n\\n# Approach\\nTo use a minheap for our purpose, we have to turn every number in our input array into its negative counterpart, that way the biggest number in the array will equal the smallest number in our heap.\\n\\nWhen we pop an element, we convert it back into its positive variant, when we push an element, we turn it into its negative variant.\\n\\nThere is one pretty big thing left for maximum optimization, notice how the restriction $$1 <= nums[i] <= 109$$ grant that the number will always be greater than 1, meaning if we encounter a 1 as our max number we can assume what?\\n\\nCorrect, all upcoming iterations will also be 1, since math.floor(1 / 3) will be 1 as well, meaning we can stop popping and pushing to our heap and instead break the loop early, and then just add the number of iterations remaining to the score directly (to add up all the +1 operations).\\n\\n# Complexity\\n- Time complexity:\\n$$O(k * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimport math\\nimport heapq\\n\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        i = score = 0\\n\\n        while i < k:\\n            biggest = -heapq.heappop(nums)\\n            if biggest == 1:\\n                break\\n\\n            score += biggest\\n            decreased = math.ceil(biggest / 3)\\n            heapq.heappush(nums, -decreased)\\n            i += 1\\n\\n        return score + (k - i)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nimport heapq\\n\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        i = score = 0\\n\\n        while i < k:\\n            biggest = -heapq.heappop(nums)\\n            if biggest == 1:\\n                break\\n\\n            score += biggest\\n            decreased = math.ceil(biggest / 3)\\n            heapq.heappush(nums, -decreased)\\n            i += 1\\n\\n        return score + (k - i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721748,
                "title": "python-simple-python-solution-using-priority-queue-heap",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. Approach 1 Using Priority Queue :-\\n# Runtime: 3578 ms, faster than 5.23% of Python3 online submissions for Maximal Score After Applying K Operations.\\n# Memory Usage: 31.5 MB, less than 39.27% of Python3 online submissions for Maximal Score After Applying K Operations.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef maxKelements(self, nums: List[int], k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tpriority_queue = PriorityQueue()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tpriority_queue.put(-num)\\n\\n\\t\\t\\twhile not priority_queue.empty() and k > 0:\\n\\n\\t\\t\\t\\tmax_number = priority_queue.get()\\n\\n\\t\\t\\t\\tresult = result + -max_number\\n\\n\\t\\t\\t\\tpriority_queue.put(max_number // 3)\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn result\\n\\n# 2. Approach 2 Using Heap :-\\n# Runtime: 1130 ms, faster than 18.32% of Python3 online submissions for Maximal Score After Applying K Operations.\\n# Memory Usage: 31.6 MB, less than 39.27% of Python3 online submissions for Maximal Score After Applying K Operations.\\n\\n\\timport heapq\\n\\n\\tclass Solution:\\n\\t\\tdef maxKelements(self, nums: List[int], k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tmax_heap = []\\n\\n\\t\\t\\tfor num in nums:    \\n\\t\\t\\t\\theapq.heappush(max_heap, -num)\\n\\n\\t\\t\\twhile k > 0:\\n\\n\\t\\t\\t\\tmax_number = heapq.heappop(max_heap)\\n\\n\\t\\t\\t\\tresult = result + -max_number\\n\\n\\t\\t\\t\\theapq.heappush(max_heap , max_number // 3)\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. Approach 1 Using Priority Queue :-\\n# Runtime: 3578 ms, faster than 5.23% of Python3 online submissions for Maximal Score After Applying K Operations.\\n# Memory Usage: 31.5 MB, less than 39.27% of Python3 online submissions for Maximal Score After Applying K Operations.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef maxKelements(self, nums: List[int], k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tpriority_queue = PriorityQueue()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tpriority_queue.put(-num)\\n\\n\\t\\t\\twhile not priority_queue.empty() and k > 0:\\n\\n\\t\\t\\t\\tmax_number = priority_queue.get()\\n\\n\\t\\t\\t\\tresult = result + -max_number\\n\\n\\t\\t\\t\\tpriority_queue.put(max_number // 3)\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn result\\n\\n# 2. Approach 2 Using Heap :-\\n# Runtime: 1130 ms, faster than 18.32% of Python3 online submissions for Maximal Score After Applying K Operations.\\n# Memory Usage: 31.6 MB, less than 39.27% of Python3 online submissions for Maximal Score After Applying K Operations.\\n\\n\\timport heapq\\n\\n\\tclass Solution:\\n\\t\\tdef maxKelements(self, nums: List[int], k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tmax_heap = []\\n\\n\\t\\t\\tfor num in nums:    \\n\\t\\t\\t\\theapq.heappush(max_heap, -num)\\n\\n\\t\\t\\twhile k > 0:\\n\\n\\t\\t\\t\\tmax_number = heapq.heappop(max_heap)\\n\\n\\t\\t\\t\\tresult = result + -max_number\\n\\n\\t\\t\\t\\theapq.heappush(max_heap , max_number // 3)\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3717536,
                "title": "easy-priority-queue-implementation",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long ans = 0;\\n\\n        for(auto it : nums)\\n         pq.push(it);\\n        \\n        while(k--)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            ans += top;\\n            pq.push(ceil(top/3.0)); //we have divided by 3.0 to get a         \\n        }                           //floating value for performing ceil operation\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        long long ans = 0;\\n\\n        for(auto it : nums)\\n         pq.push(it);\\n        \\n        while(k--)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            ans += top;\\n            pq.push(ceil(top/3.0)); //we have divided by 3.0 to get a         \\n        }                           //floating value for performing ceil operation\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680796,
                "title": "java-max-heap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N.LogN), where N is length of nums[] and this complexity comes from \\nputting nums[] values into priority queue\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), keeping a priority queue of size same as nums[]. Also in ex: nums[] = [1] where ceil(1.0 / 3.0) is always 1 and will always be repeating, meaning in cases where we have 1 in nums[]/heap, 1 can never be reduced then.\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Double> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n\\n        for(double val : nums) maxHeap.add(val);\\n\\n        long score = 0;\\n\\n        while(!maxHeap.isEmpty() && k > 0){\\n            k--;\\n            double currVal = maxHeap.poll();\\n            score += (long)currVal;\\n            maxHeap.add(Math.ceil(currVal / 3.0));\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Double> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n\\n        for(double val : nums) maxHeap.add(val);\\n\\n        long score = 0;\\n\\n        while(!maxHeap.isEmpty() && k > 0){\\n            k--;\\n            double currVal = maxHeap.poll();\\n            score += (long)currVal;\\n            maxHeap.add(Math.ceil(currVal / 3.0));\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617996,
                "title": "python-3-2-lines-of-code-o-k-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums:=[-i for i in nums])\\n        return -sum(heapq.heapreplace(nums, floor(nums[0]/3)) for _ in range(k))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums:=[-i for i in nums])\\n        return -sum(heapq.heapreplace(nums, floor(nums[0]/3)) for _ in range(k))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614581,
                "title": "c-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int ans=0;    priority_queue<int>pq;  for(auto i: nums)   pq.push(i);\\n        \\n        while(k--){ \\n            int temp=pq.top();  pq.pop();   ans+=temp;  pq.push(ceil((double)temp/3));\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long int ans=0;    priority_queue<int>pq;  for(auto i: nums)   pq.push(i);\\n        \\n        while(k--){ \\n            int temp=pq.top();  pq.pop();   ans+=temp;  pq.push(ceil((double)temp/3));\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596681,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        int i,n,temp;\\n        n=nums.size();\\n\\n        long long ans;\\n        ans=0;\\n        priority_queue<int> pq;\\n\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }    \\n\\n        for(i=0;i<k;i++)\\n        {\\n            temp=pq.top();\\n            ans+=temp;\\n            pq.pop();\\n            pq.push(ceil(temp/3.0));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        int i,n,temp;\\n        n=nums.size();\\n\\n        long long ans;\\n        ans=0;\\n        priority_queue<int> pq;\\n\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }    \\n\\n        for(i=0;i<k;i++)\\n        {\\n            temp=pq.top();\\n            ans+=temp;\\n            pq.pop();\\n            pq.push(ceil(temp/3.0));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594242,
                "title": "priority-queue-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long  ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=pq.top();\\n            int a=pq.top();\\n            pq.pop();\\n            double b=a/3.0;\\n            pq.push(ceil(b));\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long  ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=pq.top();\\n            int a=pq.top();\\n            pq.pop();\\n            double b=a/3.0;\\n            pq.push(ceil(b));\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580718,
                "title": "c-solution-using-multiset",
                "content": "Comments are made in code.\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& a, int k) {\\n        long long ans=0;\\n        multiset<int>s;\\n        int n=s.size();\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        while(k--){\\n            //store largest element in x.\\n            int x=*(s.rbegin());\\n            //add x to our answer.\\n            ans+=(x);\\n            //erase that x from the multiset.\\n            //find function finds the iterator pointing to x.\\n            //and erase function erases it.\\n            s.erase(s.find(x));\\n            //now insert ceil(x/3)into multiset.\\n            //implementation of ceil function.\\n            if(x%3==0){\\n                s.insert(x/3);\\n            }\\n            else{\\n                s.insert((x/3)+1);\\n            }\\n            //multiset sorts the elements by itself ,so the largest \\n            //element remaining , will come to last.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& a, int k) {\\n        long long ans=0;\\n        multiset<int>s;\\n        int n=s.size();\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        while(k--){\\n            //store largest element in x.\\n            int x=*(s.rbegin());\\n            //add x to our answer.\\n            ans+=(x);\\n            //erase that x from the multiset.\\n            //find function finds the iterator pointing to x.\\n            //and erase function erases it.\\n            s.erase(s.find(x));\\n            //now insert ceil(x/3)into multiset.\\n            //implementation of ceil function.\\n            if(x%3==0){\\n                s.insert(x/3);\\n            }\\n            else{\\n                s.insert((x/3)+1);\\n            }\\n            //multiset sorts the elements by itself ,so the largest \\n            //element remaining , will come to last.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579448,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>q;\\n        int x;\\n        for(int i=0;i<nums.size();i++)\\n           {\\n               q.push(nums[i]);\\n           }\\n          long long ans=0;\\n          for(int i=0;i<k;i++)\\n             {\\n                 ans+=q.top();\\n                 x=q.top();\\n                 q.pop();\\n                 if(x%3==0)\\n                   {\\n                       q.push(x/3);\\n                   }\\n                  else{\\n                      q.push(x/3+1);\\n                  } \\n\\n             } \\n          return ans;   \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>q;\\n        int x;\\n        for(int i=0;i<nums.size();i++)\\n           {\\n               q.push(nums[i]);\\n           }\\n          long long ans=0;\\n          for(int i=0;i<k;i++)\\n             {\\n                 ans+=q.top();\\n                 x=q.top();\\n                 q.pop();\\n                 if(x%3==0)\\n                   {\\n                       q.push(x/3);\\n                   }\\n                  else{\\n                      q.push(x/3+1);\\n                  } \\n\\n             } \\n          return ans;   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549132,
                "title": "javascript-2530-maximal-score-after-applying-k-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nconst maxKelements = function (a, k) {\\n  const pq = new MaxPriorityQueue({ compare: (a, b) => b - a })\\n  for (const e of a) {\\n    pq.enqueue(e)\\n  }\\n\\n  let s = 0\\n  while (k--) {\\n    const e = pq.dequeue()\\n    s += e\\n    pq.enqueue(Math.ceil(e / 3))\\n  }\\n  return s\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxKelements = function (a, k) {\\n  const pq = new MaxPriorityQueue({ compare: (a, b) => b - a })\\n  for (const e of a) {\\n    pq.enqueue(e)\\n  }\\n\\n  let s = 0\\n  while (k--) {\\n    const e = pq.dequeue()\\n    s += e\\n    pq.enqueue(Math.ceil(e / 3))\\n  }\\n  return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544380,
                "title": "c-priorityqueue-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(nlongn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n\\n        // maxheap.\\n        priority_queue<int> hp;\\n\\n        for(auto i: nums) hp.push(i);\\n\\n        long long ans=0;\\n\\n        int temp =0;\\n\\n        while(temp<k)\\n        {\\n            ans += hp.top();\\n\\n            // reenter in the heap.\\n\\n            // multiplying it by 1.0 * will handle:-\\n            //  this case (5/2 => 3) \\n\\n            int res = ceil(1.0*hp.top()/3);\\n            hp.pop();\\n\\n            hp.push(res);\\n            temp++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n\\n        // maxheap.\\n        priority_queue<int> hp;\\n\\n        for(auto i: nums) hp.push(i);\\n\\n        long long ans=0;\\n\\n        int temp =0;\\n\\n        while(temp<k)\\n        {\\n            ans += hp.top();\\n\\n            // reenter in the heap.\\n\\n            // multiplying it by 1.0 * will handle:-\\n            //  this case (5/2 => 3) \\n\\n            int res = ceil(1.0*hp.top()/3);\\n            hp.pop();\\n\\n            hp.push(res);\\n            temp++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542198,
                "title": "pq-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> pq; long long score=0;\\n        for(auto it: nums) pq.push(it);\\n        while(k--){\\n           long long topint=pq.top();\\n           score+=topint;\\n           pq.pop();\\n           pq.push(ceil((double)topint/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long> pq; long long score=0;\\n        for(auto it: nums) pq.push(it);\\n        while(k--){\\n           long long topint=pq.top();\\n           score+=topint;\\n           pq.pop();\\n           pq.push(ceil((double)topint/3));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521518,
                "title": "heap-priorityqueue-but-only-add-top-k-elements-if-n-k-faster-than-98",
                "content": "# Intuition\\nThe problem requires to maintain knowledge of the largest element in the set which can change with each step.\\n\\n# Approach\\nA heap (Priority Queue) can solve this easily.\\n\\nHowever, observe that if nums has more than k elements, only the top k elements will ever be of any use, the others can be discarded. In some cases, this can significantly decrease the size of the queue which results in a speedup.\\n\\nHowever, finding the top k elements requires sorting. Thus, only apply this when the array is at least 100 elements and has more than two times the number of elements than k (these values can be fine tuned, but seem to work well). Otherwise it is faster to just put all of them in the queue.\\n\\n# Complexity\\n\\nLet $$s := min(n, k)$$ (Size of the priority queue)\\nThen the time complexity is $$O(k * log(s))$$\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic long maxKelements(int[] nums, int k) {\\n\\t\\tlong score = 0;\\n\\t\\tPriorityQueue<Integer> queue = new PriorityQueue<Integer>(nums.length, (x, y) -> y - x);\\n\\n\\t\\tif (nums.length > 100 && k < nums.length / 2) {\\n            //We have a lot more numbers than we could possibly need!\\n\\t\\t\\t//Sort and reverse array, then only add top k elements to the queue\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tfor (int i = 0; i < nums.length / 2; ++i) {\\n\\t\\t\\t\\tint temp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[nums.length - i - 1];\\n\\t\\t\\t\\tnums[nums.length - i - 1] = temp;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\t\\tqueue.offer(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\t//Throw everything in the queue\\n\\t\\t\\tfor (int i = 0; i < nums.length; ++i) {\\n\\t\\t\\t\\tqueue.offer(nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\tint top = queue.poll();\\n\\t\\t\\tscore += top;\\n\\t\\t\\tqueue.offer((int) Math.ceil(top / 3.));\\n\\t\\t}\\n\\n\\t\\treturn score;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long maxKelements(int[] nums, int k) {\\n\\t\\tlong score = 0;\\n\\t\\tPriorityQueue<Integer> queue = new PriorityQueue<Integer>(nums.length, (x, y) -> y - x);\\n\\n\\t\\tif (nums.length > 100 && k < nums.length / 2) {\\n            //We have a lot more numbers than we could possibly need!\\n\\t\\t\\t//Sort and reverse array, then only add top k elements to the queue\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tfor (int i = 0; i < nums.length / 2; ++i) {\\n\\t\\t\\t\\tint temp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[nums.length - i - 1];\\n\\t\\t\\t\\tnums[nums.length - i - 1] = temp;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\t\\tqueue.offer(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\t//Throw everything in the queue\\n\\t\\t\\tfor (int i = 0; i < nums.length; ++i) {\\n\\t\\t\\t\\tqueue.offer(nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\tint top = queue.poll();\\n\\t\\t\\tscore += top;\\n\\t\\t\\tqueue.offer((int) Math.ceil(top / 3.));\\n\\t\\t}\\n\\n\\t\\treturn score;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447645,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxKelements(int[] nums, int k) {\\n        long scores = 0;\\n        var pq = new PriorityQueue<int, int>();\\n        foreach(var num in nums)\\n            pq.Enqueue(num, -num);\\n\\n        while(k-- > 0) {\\n            var num = pq.Dequeue();\\n            scores += num;\\n            num = (int)Math.Ceiling((double)num / 3);\\n            pq.Enqueue(num, -num);\\n        }\\n\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxKelements(int[] nums, int k) {\\n        long scores = 0;\\n        var pq = new PriorityQueue<int, int>();\\n        foreach(var num in nums)\\n            pq.Enqueue(num, -num);\\n\\n        while(k-- > 0) {\\n            var num = pq.Dequeue();\\n            scores += num;\\n            num = (int)Math.Ceiling((double)num / 3);\\n            pq.Enqueue(num, -num);\\n        }\\n\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406629,
                "title": "c-pq",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>> pq;\\n        for(int i = 0; i < nums.size(); i++) pq.push(nums[i]);\\n        long long ans = 0;\\n        for(int i = 0; i < k; i++){\\n            int n = pq.top();\\n            pq.pop();\\n            ans += n;\\n            pq.push((n+2) / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>> pq;\\n        for(int i = 0; i < nums.size(); i++) pq.push(nums[i]);\\n        long long ans = 0;\\n        for(int i = 0; i < k; i++){\\n            int n = pq.top();\\n            pq.pop();\\n            ans += n;\\n            pq.push((n+2) / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404333,
                "title": "must-see-c-solution-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k)\\n        {\\n            int num=pq.top();\\n            pq.pop();\\n            k--;\\n            ans=ans+num;\\n            if(num%3==0)\\n            {\\n                num=num/3;\\n            }\\n            else\\n            {\\n                num=(num/3)+1;\\n            }\\n            pq.push(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k)\\n        {\\n            int num=pq.top();\\n            pq.pop();\\n            k--;\\n            ans=ans+num;\\n            if(num%3==0)\\n            {\\n                num=num/3;\\n            }\\n            else\\n            {\\n                num=(num/3)+1;\\n            }\\n            pq.push(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404031,
                "title": "python-three-lines-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        min_heap = [-num for num in nums]\\n        heapq.heapify(min_heap)\\n        return sum(-heapq.heappushpop(min_heap, min_heap[0] // 3) for _ in range(k))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        min_heap = [-num for num in nums]\\n        heapq.heapify(min_heap)\\n        return sum(-heapq.heappushpop(min_heap, min_heap[0] // 3) for _ in range(k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384613,
                "title": "c-solution-using-max-heap",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN), since heapify in max_heap require O(NlogN) time.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        int size = nums.size();\\n        for(int i = 0; i < size; ++i)\\n            pq.push(nums[i]);\\n        long long res = 0;\\n        for(int i = 0; i < k; ++i){\\n            long long curr = (long long)pq.top();\\n            res += curr;\\n            pq.pop();\\n            pq.push(ceil(curr * 1.0 / 3.0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        int size = nums.size();\\n        for(int i = 0; i < size; ++i)\\n            pq.push(nums[i]);\\n        long long res = 0;\\n        for(int i = 0; i < k; ++i){\\n            long long curr = (long long)pq.top();\\n            res += curr;\\n            pq.pop();\\n            pq.push(ceil(curr * 1.0 / 3.0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381408,
                "title": "java-max-heap-easy-to-understand",
                "content": "# PriorityQueue\\n---\\n## Java\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long res=0;\\n        PriorityQueue<Integer> maxHeap=new PriorityQueue<>((a,b)->b-a);\\n        for(int num:nums){\\n            maxHeap.add(num);\\n        }\\n        for(int i=0;i<k;i++){\\n            long first=maxHeap.poll();\\n            res+=first;\\n            // maxHeap.add((int)Math.ceil((double)first/3));\\n            maxHeap.add((int)(first+2)/3);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long res=0;\\n        PriorityQueue<Integer> maxHeap=new PriorityQueue<>((a,b)->b-a);\\n        for(int num:nums){\\n            maxHeap.add(num);\\n        }\\n        for(int i=0;i<k;i++){\\n            long first=maxHeap.poll();\\n            res+=first;\\n            // maxHeap.add((int)Math.ceil((double)first/3));\\n            maxHeap.add((int)(first+2)/3);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365529,
                "title": "simple-and-beginner-friendly-solution",
                "content": "# Intuition :: Must Divide nums[i] by floating value not by integer value.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :: Using Heap.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score=0;\\n        priority_queue<long long> pq(nums.begin(),nums.end());\\n        while(k--){\\n            long long x=pq.top();\\n            pq.pop();\\n            score+=x;\\n            x=ceil(x/3.0);\\n            cout<<x<<\" \";\\n            pq.push(x);\\n        }\\n        return score; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score=0;\\n        priority_queue<long long> pq(nums.begin(),nums.end());\\n        while(k--){\\n            long long x=pq.top();\\n            pq.pop();\\n            score+=x;\\n            x=ceil(x/3.0);\\n            cout<<x<<\" \";\\n            pq.push(x);\\n        }\\n        return score; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355383,
                "title": "java-easy-max-heap-priority-queue-solution",
                "content": "**If you like my solution, Please Upvote!!**\\n\\n# Approach\\n1. It is always optimal to select the greatest element in the array.\\n2. Use a max heap to query for the maximum in O(log n) time.\\n\\n# Complexity\\n- Time complexity:  O(log n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n      \\n      PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n      long score = 0;\\n      \\n      for(int i=0;i<nums.length;i++){\\n          pq.add(nums[i]);\\n      }\\n      while(k>0){\\n          int num = pq.poll();\\n          score += num;\\n          pq.add((int)Math.ceil(num/3.0));\\n          k--;\\n      }\\n      return score;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n      \\n      PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n      long score = 0;\\n      \\n      for(int i=0;i<nums.length;i++){\\n          pq.add(nums[i]);\\n      }\\n      while(k>0){\\n          int num = pq.poll();\\n          score += num;\\n          pq.add((int)Math.ceil(num/3.0));\\n          k--;\\n      }\\n      return score;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350356,
                "title": "c-priority-queue-based-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<ll> p;\\n        for(int no: nums)\\n            p.push(no);\\n        ll res=0;\\n        while(k){\\n            k--;\\n            ll no=p.top();\\n            res+=no;\\n            p.pop();\\n            p.push((no+2)/3);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<ll> p;\\n        for(int no: nums)\\n            p.push(no);\\n        ll res=0;\\n        while(k){\\n            k--;\\n            ll no=p.top();\\n            res+=no;\\n            p.pop();\\n            p.push((no+2)/3);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342539,
                "title": "using-priority-queue-max-heap-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long  long score =  0 ; \\n        priority_queue<int > pq  ; \\n\\n        for ( int  i = 0  ; i <  nums.size() ; i++  ){\\n            pq.push(nums[i])  ;  \\n\\n\\n        }\\n        int x  = 0  ; \\n\\n        while ( !pq.empty() ){\\n            if ( x ==  k ){\\n                break  ; \\n\\n            }\\n            int  y  = pq.top()  ;\\n            score+= y   ;\\n            x++   ; \\n            pq.pop() ; \\n\\n            pq.push(ceil(static_cast<double>(y) / 3.0));\\n            \\n\\n\\n        }\\n\\n        return score  ; \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long  long score =  0 ; \\n        priority_queue<int > pq  ; \\n\\n        for ( int  i = 0  ; i <  nums.size() ; i++  ){\\n            pq.push(nums[i])  ;  \\n\\n\\n        }\\n        int x  = 0  ; \\n\\n        while ( !pq.empty() ){\\n            if ( x ==  k ){\\n                break  ; \\n\\n            }\\n            int  y  = pq.top()  ;\\n            score+= y   ;\\n            x++   ; \\n            pq.pop() ; \\n\\n            pq.push(ceil(static_cast<double>(y) / 3.0));\\n            \\n\\n\\n        }\\n\\n        return score  ; \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321652,
                "title": "cppeasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i : nums) pq.push(i);\\n        long long ans = 0;\\n        while(k>0) {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil((double)a / 3));\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n      /*\\nTHIS IS MY METHOD SOME TEST CASES ARE NNOT RUNNING\\nclass Solution {\\n    int int_max(vector<int>& nums) {\\n        auto it = max_element(nums.begin(), nums.end());\\n        int p = distance(nums.begin(), it);\\n        return p;\\n    }\\n\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        while (k > 0) {\\n            int i = int_max(nums);\\n            score += nums[i];\\n            nums[i] = ceil(nums[i] / 3.0);\\n            k--;\\n        }\\n        return score;\\n    }\\n};\\n*/  \\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i : nums) pq.push(i);\\n        long long ans = 0;\\n        while(k>0) {\\n            int a = pq.top();\\n            ans += a;\\n            pq.pop();\\n            pq.push(ceil((double)a / 3));\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n      /*\\nTHIS IS MY METHOD SOME TEST CASES ARE NNOT RUNNING\\nclass Solution {\\n    int int_max(vector<int>& nums) {\\n        auto it = max_element(nums.begin(), nums.end());\\n        int p = distance(nums.begin(), it);\\n        return p;\\n    }\\n\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long score = 0;\\n        while (k > 0) {\\n            int i = int_max(nums);\\n            score += nums[i];\\n            nums[i] = ceil(nums[i] / 3.0);\\n            k--;\\n        }\\n        return score;\\n    }\\n};\\n*/  \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319268,
                "title": "priority-queue-easy-and-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i:nums) {\\n            pq.push(i);\\n        }\\n        while(k--) {\\n            int top = pq.top();\\n            pq.pop();\\n            ans+=top;\\n            if(top%3==0) pq.push((top/3));\\n            else pq.push(top/3+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        \\n        long long ans=0;\\n        priority_queue<int> pq;\\n        for(auto i:nums) {\\n            pq.push(i);\\n        }\\n        while(k--) {\\n            int top = pq.top();\\n            pq.pop();\\n            ans+=top;\\n            if(top%3==0) pq.push((top/3));\\n            else pq.push(top/3+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316960,
                "title": "c-solution-using-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long opr=0;\\n        priority_queue<int>q(nums.begin(),nums.end());\\n        while(k--)\\n        {\\n            int t=q.top();\\n            q.pop();\\n            opr=opr+t;\\n            q.push(ceil(t/3.0));\\n        }\\n        return opr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long opr=0;\\n        priority_queue<int>q(nums.begin(),nums.end());\\n        while(k--)\\n        {\\n            int t=q.top();\\n            q.pop();\\n            opr=opr+t;\\n            q.push(ceil(t/3.0));\\n        }\\n        return opr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300279,
                "title": "easy-to-understand-java-solution",
                "content": "\\nWhen there is question which involves using the maximumor minimu value the best approach is to use a heap. As it sorts the array and gives out the maximum or minimum value.\\n\\n# Approach\\n- Initialize a heap and add the elements of the array into it\\n- Then use a while loop, pop out the highest element calculate it\\'s ceil value and the put the element back in, and the heap gets sorted by itself. \\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        // we create a heap to store the array elements \\n         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n         for( int i=0;i<nums.length;i++){\\n            pq.add(nums[i]);\\n         }\\n//  we initialize both score and count as long as it\\'s the return value, do not store it as int and typecast it later\\n         long score =0;\\n         long count = 0;\\n        //  for the number of iterations \\n         while(count<k){\\n            //  take the head of the heap\\n             int head = pq.peek();\\n             pq.poll();\\n            //  add it to the total score \\n             score += head;\\n            // then calculating it\\'s ceil value\\n             head = (head/3)+(head%3==0?0:1);\\n            //  adding back into the heap, as it automatically changes according to max heap \\n             pq.add(head);\\n             count++;\\n         }\\n\\n         return score;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        // we create a heap to store the array elements \\n         PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n         for( int i=0;i<nums.length;i++){\\n            pq.add(nums[i]);\\n         }\\n//  we initialize both score and count as long as it\\'s the return value, do not store it as int and typecast it later\\n         long score =0;\\n         long count = 0;\\n        //  for the number of iterations \\n         while(count<k){\\n            //  take the head of the heap\\n             int head = pq.peek();\\n             pq.poll();\\n            //  add it to the total score \\n             score += head;\\n            // then calculating it\\'s ceil value\\n             head = (head/3)+(head%3==0?0:1);\\n            //  adding back into the heap, as it automatically changes according to max heap \\n             pq.add(head);\\n             count++;\\n         }\\n\\n         return score;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297492,
                "title": "swift-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxKelements(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var k = k\\n        var result = 0.0\\n        var maxHeap = Heap<Int>(sort: { $0 > $1 })\\n        \\n        for element in nums {\\n            maxHeap.insert(element)\\n        }\\n        \\n        while k > 0 {\\n            if let element = maxHeap.remove() {\\n                let val = ceil(Double(element)/3)\\n                result += Double(element)\\n                maxHeap.insert(Int(val))\\n                k -= 1\\n            }\\n        }\\n        \\n        return Int(result)\\n    }\\n}\\n\\n\\npublic struct Heap<T> {\\n    \\n    var nodes = [T]()\\n    \\n    private var orderCriteria: (T, T) -> Bool\\n    \\n    \\n    public init(sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n    }\\n    \\n    public init(array: [T], sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n        configureHeap(from: array)\\n    }\\n    \\n    \\n    private mutating func configureHeap(from array: [T]) {\\n        nodes = array\\n        for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n            shiftDown(i)\\n        }\\n    }\\n    \\n    public var isEmpty: Bool {\\n        return nodes.isEmpty\\n    }\\n    \\n    public var count: Int {\\n        return nodes.count\\n    }\\n    \\n    @inline(__always) internal func parentIndex(ofIndex i: Int) -> Int {\\n        return (i - 1) / 2\\n    }\\n    \\n    \\n    @inline(__always) internal func leftChildIndex(ofIndex i: Int) -> Int {\\n        return 2*i + 1\\n    }\\n    \\n    \\n    @inline(__always) internal func rightChildIndex(ofIndex i: Int) -> Int {\\n        return 2*i + 2\\n    }\\n    \\n    public func peek() -> T? {\\n        return nodes.first\\n    }\\n    \\n    public mutating func insert(_ value: T) {\\n        nodes.append(value)\\n        shiftUp(nodes.count - 1)\\n    }\\n    \\n    \\n    public mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n        for value in sequence {\\n            insert(value)\\n        }\\n    }\\n    \\n    public mutating func replace(index i: Int, value: T) {\\n        guard i < nodes.count else { return }\\n        \\n        remove(at: i)\\n        insert(value)\\n    }\\n    \\n    \\n    @discardableResult public mutating func remove() -> T? {\\n        guard !nodes.isEmpty else { return nil }\\n        \\n        if nodes.count == 1 {\\n            return nodes.removeLast()\\n        } else {\\n            \\n            let value = nodes[0]\\n            nodes[0] = nodes.removeLast()\\n            shiftDown(0)\\n            return value\\n        }\\n    }\\n    \\n    \\n    @discardableResult public mutating func remove(at index: Int) -> T? {\\n        guard index < nodes.count else { return nil }\\n        \\n        let size = nodes.count - 1\\n        if index != size {\\n            nodes.swapAt(index, size)\\n            shiftDown(from: index, until: size)\\n            shiftUp(index)\\n        }\\n        return nodes.removeLast()\\n    }\\n    \\n    \\n    internal mutating func shiftUp(_ index: Int) {\\n        var childIndex = index\\n        let child = nodes[childIndex]\\n        var parentIndex = self.parentIndex(ofIndex: childIndex)\\n        \\n        while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n            nodes[childIndex] = nodes[parentIndex]\\n            childIndex = parentIndex\\n            parentIndex = self.parentIndex(ofIndex: childIndex)\\n        }\\n        \\n        nodes[childIndex] = child\\n    }\\n    \\n    internal mutating func shiftDown(from index: Int, until endIndex: Int) {\\n        let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n        let rightChildIndex = leftChildIndex + 1\\n        \\n        var first = index\\n        if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n            first = leftChildIndex\\n        }\\n        if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n            first = rightChildIndex\\n        }\\n        if first == index { return }\\n        \\n        nodes.swapAt(index, first)\\n        shiftDown(from: first, until: endIndex)\\n    }\\n    \\n    internal mutating func shiftDown(_ index: Int) {\\n        shiftDown(from: index, until: nodes.count)\\n    }\\n    \\n}\\n\\n// MARK: - Searching\\nextension Heap where T: Equatable {\\n    \\n    public func index(of node: T) -> Int? {\\n        return nodes.firstIndex(where: { $0 == node })\\n    }\\n    \\n    @discardableResult public mutating func remove(node: T) -> T? {\\n        if let index = index(of: node) {\\n            return remove(at: index)\\n        }\\n        return nil\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxKelements(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var k = k\\n        var result = 0.0\\n        var maxHeap = Heap<Int>(sort: { $0 > $1 })\\n        \\n        for element in nums {\\n            maxHeap.insert(element)\\n        }\\n        \\n        while k > 0 {\\n            if let element = maxHeap.remove() {\\n                let val = ceil(Double(element)/3)\\n                result += Double(element)\\n                maxHeap.insert(Int(val))\\n                k -= 1\\n            }\\n        }\\n        \\n        return Int(result)\\n    }\\n}\\n\\n\\npublic struct Heap<T> {\\n    \\n    var nodes = [T]()\\n    \\n    private var orderCriteria: (T, T) -> Bool\\n    \\n    \\n    public init(sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n    }\\n    \\n    public init(array: [T], sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n        configureHeap(from: array)\\n    }\\n    \\n    \\n    private mutating func configureHeap(from array: [T]) {\\n        nodes = array\\n        for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n            shiftDown(i)\\n        }\\n    }\\n    \\n    public var isEmpty: Bool {\\n        return nodes.isEmpty\\n    }\\n    \\n    public var count: Int {\\n        return nodes.count\\n    }\\n    \\n    @inline(__always) internal func parentIndex(ofIndex i: Int) -> Int {\\n        return (i - 1) / 2\\n    }\\n    \\n    \\n    @inline(__always) internal func leftChildIndex(ofIndex i: Int) -> Int {\\n        return 2*i + 1\\n    }\\n    \\n    \\n    @inline(__always) internal func rightChildIndex(ofIndex i: Int) -> Int {\\n        return 2*i + 2\\n    }\\n    \\n    public func peek() -> T? {\\n        return nodes.first\\n    }\\n    \\n    public mutating func insert(_ value: T) {\\n        nodes.append(value)\\n        shiftUp(nodes.count - 1)\\n    }\\n    \\n    \\n    public mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n        for value in sequence {\\n            insert(value)\\n        }\\n    }\\n    \\n    public mutating func replace(index i: Int, value: T) {\\n        guard i < nodes.count else { return }\\n        \\n        remove(at: i)\\n        insert(value)\\n    }\\n    \\n    \\n    @discardableResult public mutating func remove() -> T? {\\n        guard !nodes.isEmpty else { return nil }\\n        \\n        if nodes.count == 1 {\\n            return nodes.removeLast()\\n        } else {\\n            \\n            let value = nodes[0]\\n            nodes[0] = nodes.removeLast()\\n            shiftDown(0)\\n            return value\\n        }\\n    }\\n    \\n    \\n    @discardableResult public mutating func remove(at index: Int) -> T? {\\n        guard index < nodes.count else { return nil }\\n        \\n        let size = nodes.count - 1\\n        if index != size {\\n            nodes.swapAt(index, size)\\n            shiftDown(from: index, until: size)\\n            shiftUp(index)\\n        }\\n        return nodes.removeLast()\\n    }\\n    \\n    \\n    internal mutating func shiftUp(_ index: Int) {\\n        var childIndex = index\\n        let child = nodes[childIndex]\\n        var parentIndex = self.parentIndex(ofIndex: childIndex)\\n        \\n        while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n            nodes[childIndex] = nodes[parentIndex]\\n            childIndex = parentIndex\\n            parentIndex = self.parentIndex(ofIndex: childIndex)\\n        }\\n        \\n        nodes[childIndex] = child\\n    }\\n    \\n    internal mutating func shiftDown(from index: Int, until endIndex: Int) {\\n        let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n        let rightChildIndex = leftChildIndex + 1\\n        \\n        var first = index\\n        if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n            first = leftChildIndex\\n        }\\n        if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n            first = rightChildIndex\\n        }\\n        if first == index { return }\\n        \\n        nodes.swapAt(index, first)\\n        shiftDown(from: first, until: endIndex)\\n    }\\n    \\n    internal mutating func shiftDown(_ index: Int) {\\n        shiftDown(from: index, until: nodes.count)\\n    }\\n    \\n}\\n\\n// MARK: - Searching\\nextension Heap where T: Equatable {\\n    \\n    public func index(of node: T) -> Int? {\\n        return nodes.firstIndex(where: { $0 == node })\\n    }\\n    \\n    @discardableResult public mutating func remove(node: T) -> T? {\\n        if let index = index(of: node) {\\n            return remove(at: index)\\n        }\\n        return nil\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297260,
                "title": "using-maxheap",
                "content": "# Approach\\nWe use Greedy cause we want the largest element for every iteration\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n*/\\n\\nvar maxKelements = function(nums, k) {\\n    let score=0,pq = new MaxPriorityQueue(nums);\\n    for(let num of nums) pq.enqueue(num);\\n    while(k-->0){\\n        let {priority:prior, element:num}=pq.dequeue();\\n        score+=num;\\n        num=Math.ceil(num/3);\\n        pq.enqueue(num);\\n    }\\n    return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n*/\\n\\nvar maxKelements = function(nums, k) {\\n    let score=0,pq = new MaxPriorityQueue(nums);\\n    for(let num of nums) pq.enqueue(num);\\n    while(k-->0){\\n        let {priority:prior, element:num}=pq.dequeue();\\n        score+=num;\\n        num=Math.ceil(num/3);\\n        pq.enqueue(num);\\n    }\\n    return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293206,
                "title": "c-priority-queue-easy-solution",
                "content": "\\n\\n# *Code*\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        long long score = 0;\\n        priority_queue<int> que(nums.begin(), nums.end());\\n        while(k--)\\n        {\\n            int temp = que.top();\\n            que.pop();\\n            score += temp;\\n            que.push(ceil(temp/3.0));\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n***Do Upvote !*** \\uD83D\\uDE03",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        long long score = 0;\\n        priority_queue<int> que(nums.begin(), nums.end());\\n        while(k--)\\n        {\\n            int temp = que.top();\\n            que.pop();\\n            score += temp;\\n            que.push(ceil(temp/3.0));\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277350,
                "title": "maxheap-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we require the maximum score at each step we want to extract the max element\\nso for this we can use sorting or maxheap\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long maxKelements(int[] nums, int k) \\n    {\\n        long score=0;\\n\\n\\n        PriorityQueue<Long> maxheap=new PriorityQueue<>(Collections.reverseOrder());\\n\\n\\n        for(int i:nums)\\n        maxheap.offer((long)(i));\\n\\n\\n        while(!maxheap.isEmpty() && k-->0)\\n        {\\n            long ele=maxheap.poll();\\n            score += ele;\\n\\n            maxheap.offer((long) Math.ceil ( ele/3.0 )  );\\n        }\\n\\n\\n        return score;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long maxKelements(int[] nums, int k) \\n    {\\n        long score=0;\\n\\n\\n        PriorityQueue<Long> maxheap=new PriorityQueue<>(Collections.reverseOrder());\\n\\n\\n        for(int i:nums)\\n        maxheap.offer((long)(i));\\n\\n\\n        while(!maxheap.isEmpty() && k-->0)\\n        {\\n            long ele=maxheap.poll();\\n            score += ele;\\n\\n            maxheap.offer((long) Math.ceil ( ele/3.0 )  );\\n        }\\n\\n\\n        return score;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274468,
                "title": "why-use-priority-queue-when-c-already-gives-you-heap-operations",
                "content": "# Approach\\nThe solution to this problem is pretty straightforward. If you don\\'t know about heaps yet, check [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure)).\\n\\nIn short, it is a data structure with the following characteristics:\\n- Can be implemented with an array. Converting an unsorted array to a heap takes `O(n)`.\\n- Inserting an element takes `O(log n)`.\\n- Inspecting the maximum element takes `O(1)`.\\n- Removing the maximum element takes `O(log n)`.\\n- Duplicates are allowed.\\n\\nWith that, we can solve the problem with the following procedure:\\n- convert `nums` to a heap\\n- set `score` to 0\\n- repeat the following for `k` times:\\n    - extract the maximum value from `nums` as `x`\\n    - add `x` to `score`\\n    - put `ceil(x/3)` back to `nums` \\n- return `score`\\n\\nSurprisingly, most people use a `priority_queue` to store those numbers, which is a complete waste of space. Plus, inserting the elements one by one from `nums` to the priority queue takes `O(log n)` time.\\n\\nC++ has already implemented some heap operations such as `make_heap`, `push_heap`, and `pop_heap`. With that we are able to solve the problem with `O(1)` additional space.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        // nums is unsorted, so we have to convert it to a heap\\n        make_heap(nums.begin(), nums.end());\\n        // now nums[0] is the maximum value\\n        long long score = 0;\\n        // this loop runs for k times\\n        while (k--) {\\n            // move the maximum value to the end of the array\\n            pop_heap(nums.begin(), nums.end());\\n            int M = nums[n-1];\\n            score += M;\\n            // now replace nums[n-1] with ceil(M/3)\\n            nums[n-1] = (M + 2) / 3;\\n            // push_heap inserts the last element to the heap\\n            push_heap(nums.begin(), nums.end());\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n# Result\\n260ms, beats 98%",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        // nums is unsorted, so we have to convert it to a heap\\n        make_heap(nums.begin(), nums.end());\\n        // now nums[0] is the maximum value\\n        long long score = 0;\\n        // this loop runs for k times\\n        while (k--) {\\n            // move the maximum value to the end of the array\\n            pop_heap(nums.begin(), nums.end());\\n            int M = nums[n-1];\\n            score += M;\\n            // now replace nums[n-1] with ceil(M/3)\\n            nums[n-1] = (M + 2) / 3;\\n            // push_heap inserts the last element to the heap\\n            push_heap(nums.begin(), nums.end());\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261719,
                "title": "python-a-few",
                "content": "```python3\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # TLE\\n        from math import ceil\\n        maximum = 0\\n        while nums.sort() or k:\\n            maximum, k = maximum + nums[-1], k - 1\\n            nums.append(ceil(nums.pop() / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 7999 ms\\n        from math import ceil\\n        import bisect\\n\\n        maximum = int(bool(nums.sort()))\\n        while k and (n := nums.pop()):\\n            maximum, k = maximum + n, k - 1\\n            bisect.insort(nums, ceil(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 6717 ms\\n        from math import ceil\\n        import bisect\\n        from collections import Counter\\n\\n        maximum, counts = 0, sorted(Counter(nums).items())\\n        while k > 0:\\n            n, ctr = counts.pop()\\n            maximum, k = maximum + n * min(k, ctr), k - ctr\\n            bisect.insort_left(counts, (ceil(n / 3), ctr))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1975 ms\\n        from math import ceil\\n        from sortedcontainers import SortedList\\n\\n        nums = SortedList(nums)\\n        maximum = nums.pop()\\n        nums.add(ceil(maximum / 3))\\n        while (k := k - 1) and (n := nums.pop()):\\n            maximum += n\\n            nums.add(ceil(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1362 ms\\n        from math import ceil\\n        from collections import Counter\\n        from sortedcontainers import SortedDict\\n        counts, maximum = SortedDict(Counter(nums)), 0\\n        while k:\\n            n, ctr = counts.popitem()\\n            n_taken = min(ctr, k)\\n            maximum += n * n_taken\\n            counts[ceil(n / 3)] = counts.get(ceil(n / 3), 0) + n_taken\\n            k -= n_taken\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1294 ms\\n        from math import floor\\n        from collections import Counter\\n        import heapq\\n\\n        heap, maximum = list(Counter(map(int.__neg__, nums)).items()), 0\\n        heapq.heapify(heap)\\n        while k > 0:\\n            n, ctr = heapq.heappop(heap)\\n            maximum -= n * min(k, ctr)\\n            heapq.heappush(heap, (floor(n / 3), ctr))\\n            k -= ctr\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 979 ms\\n        from math import floor\\n        import heapq\\n        heap, maximum = [-n for n in nums], 0\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            n = heapq.heappop(heap)\\n            maximum -= n\\n            heapq.heappush(heap, floor(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 931 ms\\n        import heapq\\n        heap, maximum = [-n for n in nums], 0\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            maximum -= heap[0]\\n            heapq.heapreplace(heap, heap[0] // 3)\\n        return maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # TLE\\n        from math import ceil\\n        maximum = 0\\n        while nums.sort() or k:\\n            maximum, k = maximum + nums[-1], k - 1\\n            nums.append(ceil(nums.pop() / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 7999 ms\\n        from math import ceil\\n        import bisect\\n\\n        maximum = int(bool(nums.sort()))\\n        while k and (n := nums.pop()):\\n            maximum, k = maximum + n, k - 1\\n            bisect.insort(nums, ceil(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 6717 ms\\n        from math import ceil\\n        import bisect\\n        from collections import Counter\\n\\n        maximum, counts = 0, sorted(Counter(nums).items())\\n        while k > 0:\\n            n, ctr = counts.pop()\\n            maximum, k = maximum + n * min(k, ctr), k - ctr\\n            bisect.insort_left(counts, (ceil(n / 3), ctr))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1975 ms\\n        from math import ceil\\n        from sortedcontainers import SortedList\\n\\n        nums = SortedList(nums)\\n        maximum = nums.pop()\\n        nums.add(ceil(maximum / 3))\\n        while (k := k - 1) and (n := nums.pop()):\\n            maximum += n\\n            nums.add(ceil(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1362 ms\\n        from math import ceil\\n        from collections import Counter\\n        from sortedcontainers import SortedDict\\n        counts, maximum = SortedDict(Counter(nums)), 0\\n        while k:\\n            n, ctr = counts.popitem()\\n            n_taken = min(ctr, k)\\n            maximum += n * n_taken\\n            counts[ceil(n / 3)] = counts.get(ceil(n / 3), 0) + n_taken\\n            k -= n_taken\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 1294 ms\\n        from math import floor\\n        from collections import Counter\\n        import heapq\\n\\n        heap, maximum = list(Counter(map(int.__neg__, nums)).items()), 0\\n        heapq.heapify(heap)\\n        while k > 0:\\n            n, ctr = heapq.heappop(heap)\\n            maximum -= n * min(k, ctr)\\n            heapq.heappush(heap, (floor(n / 3), ctr))\\n            k -= ctr\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 979 ms\\n        from math import floor\\n        import heapq\\n        heap, maximum = [-n for n in nums], 0\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            n = heapq.heappop(heap)\\n            maximum -= n\\n            heapq.heappush(heap, floor(n / 3))\\n        return maximum\\n\\n    def maxKelements(self, nums: List[int], k: int) -> int:  # 931 ms\\n        import heapq\\n        heap, maximum = [-n for n in nums], 0\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            maximum -= heap[0]\\n            heapq.heapreplace(heap, heap[0] // 3)\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255070,
                "title": "max-heap-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n * logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(var n:nums) pq.add((long)n);\\n        long ans = 0;\\n        for(int i = 0;i < k;i++){\\n            long t = pq.poll();\\n            ans += t;\\n            pq.add((long)Math.ceil(t / 3.0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(var n:nums) pq.add((long)n);\\n        long ans = 0;\\n        for(int i = 0;i < k;i++){\\n            long t = pq.poll();\\n            ans += t;\\n            pq.add((long)Math.ceil(t / 3.0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250203,
                "title": "c-use-double-and-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> q;\\n        for (auto& n : nums) q.push(n);\\n        long long ans = 0;\\n        while (k-- > 0){\\n            double n = q.top();\\n            q.pop();\\n            ans += n;\\n            q.push(ceil(n / 3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int> q;\\n        for (auto& n : nums) q.push(n);\\n        long long ans = 0;\\n        while (k-- > 0){\\n            double n = q.top();\\n            q.pop();\\n            ans += n;\\n            q.push(ceil(n / 3));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213017,
                "title": "best-solution-till-now-max-heap-priority-queue",
                "content": "# Intuition\\njust use max heap to store greatest element\\n# Approach\\napply operation k times and aware of the precision PUSH (double)arr[i]/3; otherwise you will get WA\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n       long long ans=0;\\n       //declare max heap\\n       priority_queue<int>pq;\\n       for(auto x:nums)pq.push(x);\\n       while(k--)\\n       {\\n         long long top=pq.top();\\n         ans+=top;\\n         pq.pop();\\n         pq.push(ceil((double)top/3));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n       long long ans=0;\\n       //declare max heap\\n       priority_queue<int>pq;\\n       for(auto x:nums)pq.push(x);\\n       while(k--)\\n       {\\n         long long top=pq.top();\\n         ans+=top;\\n         pq.pop();\\n         pq.push(ceil((double)top/3));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191312,
                "title": "c-priority-queue-and-ceil-by-hand",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n\\n        long long ans = 0;\\n        while (k-- > 0)\\n        {\\n            int num = pq.top();\\n            pq.pop();\\n\\n            ans += num;\\n            pq.push((num + 3 - 1) / 3);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) \\n    {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n\\n        long long ans = 0;\\n        while (k-- > 0)\\n        {\\n            int num = pq.top();\\n            pq.pop();\\n\\n            ans += num;\\n            pq.push((num + 3 - 1) / 3);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181742,
                "title": "python-with-heap",
                "content": "# Intuition\\nUse heap to get the largest number then re-insert the ceil one\\n\\n# Code\\n```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums1,ret=[-i for i in nums],0\\n        heapify(nums1)\\n        while k>0:\\n            num=-heappop(nums1)\\n            ret+=num\\n            heappush(nums1,-((num+2)//3))    \\n            k-=1\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        nums1,ret=[-i for i in nums],0\\n        heapify(nums1)\\n        while k>0:\\n            num=-heappop(nums1)\\n            ret+=num\\n            heappush(nums1,-((num+2)//3))    \\n            k-=1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176767,
                "title": "using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long ans=0;\\n        for( int x : nums)pq.push(x);\\n        int i =0;\\n        while(i!=k)\\n        {\\n            long long a = pq.top();\\n            ans+= a;\\n            pq.pop();\\n            pq.push(ceil((double)a/(double)3));\\n            i++;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        long long ans=0;\\n        for( int x : nums)pq.push(x);\\n        int i =0;\\n        while(i!=k)\\n        {\\n            long long a = pq.top();\\n            ans+= a;\\n            pq.pop();\\n            pq.push(ceil((double)a/(double)3));\\n            i++;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167571,
                "title": "waste-fellow-solution-you-will-be-in-love-with-the-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInserting the values in max priority queue and then adding the highest values or top values and again inserting the ceil value after dividing it by 3 and we will do the operations upto k times\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int len=nums.size();\\n        priority_queue<int>maxh;\\n        for(int i=0;i<len;i++)\\n        maxh.push(nums[i]);\\n        long long int sum=0;\\n        while(k>0)\\n        {\\n            int a=maxh.top();\\n            maxh.pop();\\n            sum+=a;\\n            maxh.push(ceil(a/3.0));\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        int len=nums.size();\\n        priority_queue<int>maxh;\\n        for(int i=0;i<len;i++)\\n        maxh.push(nums[i]);\\n        long long int sum=0;\\n        while(k>0)\\n        {\\n            int a=maxh.top();\\n            maxh.pop();\\n            sum+=a;\\n            maxh.push(ceil(a/3.0));\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163806,
                "title": "python-easy-to-read-and-understand-heap",
                "content": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, -1*num)\\n        \\n        sums = 0\\n        while k > 0:\\n            val = heapq.heappop(pq)\\n            sums += -1*val\\n            new_val = math.ceil(-1*val/3)\\n            heapq.heappush(pq, -1*new_val)\\n            k -= 1\\n        \\n        return sums",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxKelements(self, nums: List[int], k: int) -> int:\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, -1*num)\\n        \\n        sums = 0\\n        while k > 0:\\n            val = heapq.heappop(pq)\\n            sums += -1*val\\n            new_val = math.ceil(-1*val/3)\\n            heapq.heappush(pq, -1*new_val)\\n            k -= 1\\n        \\n        return sums",
                "codeTag": "Java"
            },
            {
                "id": 3157793,
                "title": "java-priorityqueue-and-explanations",
                "content": "# Approach\\n1. Use a priorityQueue with reverse comparator to add nums\\n2. For K steps: add queue.poll() to score and put back the ceiling (poll/3).\\n3. Return the answer;\\n\\n# Complexity\\n- Time complexity:$$O(nlogn + klogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long score = 0;\\n        PriorityQueue<Integer> ordered = new PriorityQueue<>((a,b) -> Integer.compare(b, a));\\n        for (int num : nums) {\\n            ordered.add(num);\\n        }\\n        while( k > 0) {\\n            score += ordered.peek();\\n            ordered.add((int)Math.ceil((double) ordered.poll() / 3));\\n            k--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        long score = 0;\\n        PriorityQueue<Integer> ordered = new PriorityQueue<>((a,b) -> Integer.compare(b, a));\\n        for (int num : nums) {\\n            ordered.add(num);\\n        }\\n        while( k > 0) {\\n            score += ordered.peek();\\n            ordered.add((int)Math.ceil((double) ordered.poll() / 3));\\n            k--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1747291,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1860259,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747470,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747273,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747601,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1955720,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1765198,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1763924,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1763921,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1749756,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747291,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1860259,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747470,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747273,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1747601,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1955720,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1765198,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1763924,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1763921,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1749756,
                "content": [
                    {
                        "username": "Abhinav_Shaw",
                        "content": "was making a silly mistake while using function ceil function and integers \\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Should be easy?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "tanishkgpt",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        long long ans=0;\\n        while(k>0){\\n            sort(nums.begin(),nums.end());\\n            reverse(nums.begin(),nums.end());\\n            ans+=nums[0];\\n            nums[0]=ceil(nums[0] / 3);\\n            k-=1;\\n        }\\n        return ans;\\n    }\\n};\\nWhy is my code wrong?"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "This approach will give a TLE.which occured in my case XD."
                    },
                    {
                        "username": "saurabhyadav388",
                        "content": "nums[0]/3 would give you greatest integer value less than it,which would lead to wrong ceil output;\\nfor example:\\nlet num[0]=10;\\nnum[0]/3=>10/3= 3\\nceil(num[0]/3)=>ceil(3)=3\\n\\nbut it should be ,\\nceil(10/3)=>ceil(3.33)=4\\n\\ntry:\\nceil((double(c)/3))"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/3016941/ceil-function-not-working-explained-intuition-explained-beginner-friendly/?orderBy=newest_to_oldest\n\nCheck this solution for what to manipulate in ceil function.\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Me who used ordered Map instead of Priority Queue : )"
                    },
                    {
                        "username": "Kaushh",
                        "content": "Can someone tell me the time complexity for the problem? the priority queue solution one?\n"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "O(klogN)"
                    },
                    {
                        "username": "kharodshrut0079",
                        "content": "Why is there a wrong answer coming for one of the hidden testcases?\n\n'class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        long long sum = 0; \n        while(k){\n            long long max = 0; int itr=0;\n            for(int i=0; i<nums.size(); i++){\n                if(nums[i]>=max){max = nums[i]; itr = i;}\n            }\n            sum+= max;\n            float temp = (float)nums[itr]/3;\n            cout<<temp<<endl;\n            nums[itr] = ceil(temp);\n            k--;\n        }\n        return sum;\n    }\n};"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "public class KOperationToMaxScore {\\n \\n    public long maxKelements(int[] nums, int k) {\\n        \\n    int n=nums.length;\\n        Arrays.sort(nums);\\n        LinkedList<Integer> ll =  new LinkedList<>();\\n        long score = 0;\\n       for(Integer x: nums){ ll.add(x);};\\n         \\n        while(k>0){\\n            int max =ll.get(n-1);\\n            score = score + max;\\n            //printll System.out.println(ll);\\n            max = (int) Math.ceil(max/3.0);\\n            k--;\\n            ll.add(n-1,max);\\n             ll.removeLast();\\n           //printll System.out.println(ll);\\n            while((n-2)>0 && k>0&& max > 0 && max>=ll.get(n-2)){\\n                score= score + max;\\n             max = (int) Math.ceil(max/3.0);\\n             ll.add(n-1,max);\\n             ll.removeLast();\\n             k--;\\n          //printll         System.out.println(ll); \\n            }\\n        int insPos = findPos(ll,max);\\n        //printll System.out.println(insPos);\\n        ll.add(insPos, max);\\n        ll.removeLast();\\n        //System.out.println(ll);\\n        \\n            \\n            \\n            \\n        }\\n        return score;\\n    }\\n        \\n        \\n    \\n    int findPos(LinkedList<Integer>ll,int value){\\n       int n = ll.size();\\n       int left = 0, right=n-1;\\n       int mid = left+(right-left)/2;\\n       while(left<right ){\\n           \\n           //if()\\n           mid = left+(right-left)/2;\\n           //if(left==mid) return mid;\\n           if(right==left+1){\\n               if(value>ll.get(left)){\\n                   return right;\\n               }\\n               return left;\\n           }\\n           \\n           Integer valCur = ll.get(mid);\\n           if(valCur==value) return mid;\\n           if(value>valCur){\\n               left = mid;\\n           }\\n           else{\\n               right = mid;\\n           }\\n           \\n       }\\n       return left;\\n       \\n    }\\n    public static void main(String[] args){\\n       // int nums[]={1,10,3,3,3};\\n        int[] nums={756902131,995414896,95906472,149914376,387433380,848985151};\\n\\n        int k=6;\\n        long maxKelements = new KOperationToMaxScore().maxKelements(nums,k);\\n        System.out.println(maxKelements);\\n    }\\n}\\n"
                    },
                    {
                        "username": "kgebreselassie",
                        "content": "My solution for with testcases brings the expected result. However, it fails with leetcode. Maybe garbage collection problem?"
                    },
                    {
                        "username": "bhaveshb26",
                        "content": "I Dont know why I am getting wrong answer. The approach I used is using  max heap and getting max element and push it again in the heap by applying ceil/3"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "The think is right. The problem must come from implementation. Did you pop the max element?  "
                    }
                ]
            },
            {
                "id": 1748752,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1748571,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1748233,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1748171,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1748144,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1748081,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1747814,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1747779,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1747573,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            },
            {
                "id": 1747476,
                "content": [
                    {
                        "username": "h2k4082k",
                        "content": "        hp=Counter(nums)\\n        score=0\\n        while True:\\n            key = max(hp.keys())\\n            if hp[key] >= k: return key*k + score\\n            if hp[key] < k:\\n                val = hp[key]\\n                score += val*key\\n                hp.pop(key)\\n                hp[ceil(key/3)] = val\\n                k -= val \\nCan anyone please help me with problem in this code. It gives wrong answer but I can\\'t figure out where i am going wrong... "
                    },
                    {
                        "username": "eve_coder_Hitarth",
                        "content": "[756902131,995414896,95906472,149914376,387433380,848985151]\\n6\\n____________________________________________________________________________\\ncode is failing this test case....................tried priority queue code\\n-------------------------------------------------------------------------------\\n\\nclass Solution {\\n\\tpublic:\\n\\t\\tlong long maxKelements(vector<int>& nums, int k) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tfor(auto i:nums) pq.push(i);\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tint temp=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tcount+=temp;\\n\\t\\t\\t\\tpq.push(ceil((double)temp/3));\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n__________________________________________________________________________________\\nI wrote on my own another code, code looking ok, but failing same test case..\\n-------------------------------------------------------------------------------------\\nclass Solution {\\nprivate:\\n    long long ceil(long long a){\\n        if(a%3>0){ long long a = ((a/3)+1);     return a;     } \\n        else{ \\n            long long a = a/3;\\n            return a;      \\n        }\\n    }\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        if(nums.size()==1){ long long ans=nums[0];  return ans;}\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long score=0;\\n        int sc=0;\\n        for(int i=0;i<nums.size()-1,sc!=k;){\\n            score = score + nums[i];\\n            nums[i]=ceil(nums[i]);\\n            sc++;\\n            \\n            if(nums[i]>nums[i+1]){\\n                continue;\\n            }\\n            else i++;\\n        }\\n        return score;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "gurshaansing",
                        "content": "don\\'t use ceil function instead use this code\\nif(num%3==0)\\n       pq.push(num/3);\\nelse\\n       pq.push(num/3+1); \\n"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "why not sorting ??\\nclass Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n long long score = 0 ;\\n\\n        sort(nums.begin() , nums.end());\\n          // 1 10 3 3 3 \\n        // 1 3 3 3 4\\n        //         i\\n        // 0 1 2 3 4 \\n        int i= nums.size()-1;\\n        \\n        while(k!=0){\\n            score+=nums[i]; // score =  0+10 = \\n            //cout<<\"score after\"<<k<<\"th pass\"<<score<<endl;\\n            nums[i]=ceil(double(nums[i])/3);\\n            // if(nums[i]% 3 ==0 ) nums[i] =nums[i]/3;\\n            // else nums[i] = (nums[i]/3)+1; \\n           // cout<<nums[i];\\n            //   1 3 3 3 4\\n            if(i-1>=0 && nums[i-1] > nums[i]) i--;\\n            k--;\\n        }\\n         return score;\\n    }\\n};\\nit fails for some test cases !!\\ncan anyone please help!\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "check mine post replies here only "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "use priority queue and take top element and pop it,append in result. then push ceil(ele/3) in queue.\\nrepeat this process k-times and return result."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I think we can solve this problem using Dynamic Programming as well just like we used to solve subset sum problem (by keeping condition k>0). "
                    },
                    {
                        "username": "itsV_768",
                        "content": "Please tell me why am getting TLE \\n\\nthis is my own code  , please give some learning to  me am a Newbie\\n\\n\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    \\n        long score =0; \\n        while(k>0){\\n            int maxElementInd = maxElementIndex(nums);\\n            score  += nums[maxElementInd];\\n            double number=(double) nums[maxElementInd]/3;\\n            nums[maxElementInd] = (int) Math.ceil(number);\\n            k--;\\n        }\\n        return score;\\n    }\\n    static int maxElementIndex(int []arr){\\n        int max=arr[0];\\n        int index=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) Yeah :) "
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  thanks bhaiya , as k may be N in worst case so  TC will N^2 , that is not good according to the Constraints we have , \\nam i right? "
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "You are getting TLE because time complexity of your solution is O(k.N) since for every iteration of while loop you are finding maximum element that takes O(N) time and you are doing this K times so Time complexity of your code will be O(k.N)."
                    },
                    {
                        "username": "its_Babloo",
                        "content": "class Solution {\\npublic:\\n    long long maxKelements(vector<int>& nums, int k) {\\n        priority_queue<long long >q;\\n        long long score=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n        }\\n    \\n        while(k--){\\n            int top=q.top();\\n             score+=top;\\n            q.pop();\\n            q.push(ceil((double)top/3));\\n           \\n        }\\n        \\n        return score;\\n    }\\n};\\n\\nfloat is a 32-bit IEEE 754 single precision Floating Point Number \\u2013 1 bit for the sign, 8 bits for the exponent, and 23* for the value. float has 7 decimal digits of precision. double is a 64-bit IEEE 754 double precision Floating Point Number \\u2013 1 bit for the sign, 11 bits for the exponent, and 52* bits for the value.\\n\\nUSE DOUBLE INSTEAD OF FLOAT;"
                    },
                    {
                        "username": "satyam47",
                        "content": "~~~\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.rbegin(),nums.rend());\n        long long score=0;\n        int i=0;\n        while(k--)\n        {\n            score+=nums[i];\n            double x=(double)nums[i]/3;\n            nums[i]=ceil(x);\n            //sorting for getting maximum element\n            sort(nums.rbegin(),nums.rend());\n        }\n        return score;\n    }\n}; \n~~~\n\nI used sorting for every iteration to get largest element every time but got <b>TLE</b>\n at <b>32/39</b>"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "[@itsV_768](/itsV_768) ok\\n"
                    },
                    {
                        "username": "itsV_768",
                        "content": "[@JeetuGupta](/JeetuGupta)  hey please look at my comment please big brother"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Yeah, because time complexity of your solution is O(k.NlogN), use PriorityQueue"
                    },
                    {
                        "username": "vanshgupta_25",
                        "content": "why in this sorting doesnot work"
                    },
                    {
                        "username": "JeetuGupta",
                        "content": "Sorting will sort the array/vector initially but after performing one operation if you insert ciel[largest_num/3], the array will become unsorted because we don\\'t know the exact position of that element."
                    },
                    {
                        "username": "deleted_user",
                        "content": "var maxKelements = function(nums, k) {\n    \n    let pq = new PriorityQueue((a,b) => b-a);\n\n    for(let each of nums) {\n        pq.add(each);\n    };\n\n    let score = 0;\n\n    var left = k;\n    while(pq.size() && left > 0){\n        let pol = pq.poll();\n        score += pol;\n        var ceil = Math.ceil(pol/3);\n        pq.add(ceil);\n        left--;\n    }\n\n    return score;\n\n};\nWhy is this getting time limit in javascript?\n\n37 / 39 testcases passed"
                    }
                ]
            }
        ]
    }
]