[
    {
        "title": "Merge BSTs to Create Single BST",
        "question_content": "You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:\n\n\tSelect two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].\n\tReplace the leaf node in trees[i] with trees[j].\n\tRemove trees[j] from trees.\n\nReturn the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.\nA BST (binary search tree) is a binary tree where each node satisfies the following property:\n\n\tEvery node in the node's left subtree has a value&nbsp;strictly less&nbsp;than the node's value.\n\tEvery node in the node's right subtree has a value&nbsp;strictly greater&nbsp;than the node's value.\n\nA leaf is a node that has no children.\n&nbsp;\nExample 1:\n\nInput: trees = [[2,1],[3,2,5],[5,4]]\nOutput: [3,2,5,1,null,4]\nExplanation:\nIn the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\nDelete trees[0], so trees = [[3,2,5,1],[5,4]].\nIn the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[3,2,5,1,null,4]].\nThe resulting tree, shown above, is a valid BST, so return its root.\nExample 2:\n\nInput: trees = [[5,3,8],[3,2,6]]\nOutput: []\nExplanation:\nPick i=0 and j=1 and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[5,3,8,2,6]].\nThe resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n\nExample 3:\n\nInput: trees = [[5,4],[3]]\nOutput: []\nExplanation: It is impossible to perform any operations.\n\n&nbsp;\nConstraints:\n\n\tn == trees.length\n\t1 <= n <= 5 * 104\n\tThe number of nodes in each tree is in the range [1, 3].\n\tEach node in the input may have children but no grandchildren.\n\tNo two roots of trees have the same value.\n\tAll the trees in the input are valid BSTs.\n\t1 <= TreeNode.val <= 5 * 104.",
        "solutions": [
            {
                "id": 1330387,
                "title": "just-do-what-it-says",
                "content": "Not a hard problem - just long and a bit frustrating. I failed the hidden test case when we have only one tree...\\n\\n> Update: see an alternative below that combines trees in an arbitrary order.\\n\\n#### Approach 1: Build from root\\nThis solution identifies the topmost root, and then traverses from it, joining leaves with matching roots.\\n\\n1. Populate a hashmap {value: root} . All root values are guaranteed to be unique.\\n2. Count values among all trees.\\n3. Identify a root of the combined tree; it\\'s value must be counted only once.\\n4. Traverse from the root:\\n\\t- Check BST validity, like in [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n\\t- Join leaves with roots, matching leaf and root value using the map.\\n5. If the combined tree is valid, and it includes all roots - return the root of the combined tree.\\n\\n**C++**\\n```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\\n\\n#### Approach 2: Join all leaves\\nAs before, we map values to tree roots. Then, we collect *all* leaves that have a matching root.\\n\\nFinally, we combine leaves with matching roots, removing those roots from the map. In the end, one root (of the entire tree) should remain in the map.\\n\\nOne caveat here is that we need to make sure that the final tree includes all nodes. Because we combine trees in no specific order, we can have another disconnected tree with a loop.\\n\\n**C++**\\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330156,
                "title": "python-clean-in-order-traversal-solution-o-n-o-n",
                "content": "**Idea**\\n\\nWhen asked to validate BST, we naturally think about in-order traversal ([98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)). The question is how to do in-order traversal when we are given many separate trees.\\n\\nFirst of all, we want to find a root node to start the traversal from, and we can do so by finding the node without any incoming edge (`indeg = 0`). If there\\'s zero or more than one roots, we cannot create a single BST.\\n\\nTo traverse through nodes, we need to go from one BST to another. We achieve this with the help of a value-to-node map (`nodes`).\\n\\nThere are also two edges cases we need to check:\\n* There is no cycle\\n* We traverse through all nodes\\n\\nPlease see code below for more details =)\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486253,
                "title": "java-easy-to-understand",
                "content": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330145,
                "title": "python3-bfs-with-comments",
                "content": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407162,
                "title": "c-simple-and-clean-solution-with-easy-detailed-explanation",
                "content": "**Explanation:**\\n1. First, for easy search and access, we map all our roots in an unordered_map roots: [value->root].\\n    We also put all leafs in a set `leaves` to be able to find our new root.\\n2. The result root will be the one which is not found in any trees leaves, because otherwise in the resulting tree there will be two nodes with the same value, and that\\'s impossible as we need each node to be strictly greater/less than parent.\\nSo `getRoot` function checks which root doesn\\'t appear in the leaves set.\\nThen we can remove the new root from the roots map.\\n3. Now, all we have to do is recursively find leaves that are in the roots node and merge trees.\\n\\tWe create a `tmp` node to keep the current node.\\n\\tIf we found a node that appears in the roots map, tmp = roots[root->val]. Otherwise, it stays `root`.\\n\\tWe can remove it from roots map and recursively do the same for left node and right node.\\n4. Last, is to check that our result is a valid BST and we used all trees given.\\n```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```\\n**like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330182,
                "title": "c-using-hash-maps-commented-explained",
                "content": "* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344318,
                "title": "c-90-faster-using-hashmap-explained",
                "content": "1. The root of merged tree will be that root node whose value is not equal to leaf node of any other tree and it has to be unique.\\n2. Build the tree by combining the leafs with matching roots.\\n3. Check if the all the BSTs are combined.\\n4. Check if tree formed is a valid BST.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330172,
                "title": "java-two-hashmaps",
                "content": "1. Use Map to store root value to root node\\n2. Use set to mark the deleted trees\\n3. Traverse the list of roots and check if left and right nodes can be replaced\\n4. Check if the new root forms valid BST\\n\\n**Special case**: root1 set root2 as child and root2 trying to set root1 as child\\nUse a map to maintain the new parent of tree when it is modified and check if we are trying to set the parent as child when traversing the trees\\n```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086103,
                "title": "just-find-the-root-simple-bfs-solution",
                "content": "![image](https://assets.leetcode.com/users/images/eda8df4e-9fc2-4522-927b-d4a3875085d4_1674391548.905983.png)\\n\\nJust You have to Find the root!\\nRoot cannot be the child of any node so simply by hashing and hashset you can find it.\\n\\n-> If more than two root occurs or no root occurs than simply return {} empty list \\n\\nElse start building the solution from top and keep strech it to the bottom ans at last just check if the final tree is BST or not (Validating a BST)\\n\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n     unordered_set<int>st;\\n        unordered_map<int,TreeNode*>hash;\\n        unordered_set<TreeNode*>temp;\\n        for(auto it:trees){\\n            hash[it->val]=it;\\n            temp.insert(it);\\n            if(it->left)st.insert(it->left->val);\\n             if(it->right)st.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        int cnt=0;\\n        for(auto it:trees){\\n           if(st.find(it->val)==st.end()){\\n               cnt++;\\n               root=it;\\n               if(cnt>1)return {};\\n           } \\n        }\\n        temp.erase(root);\\n        queue<TreeNode*>que;\\n        if(root==NULL)return {};\\n        que.push(root);\\n        while(que.size()){\\n            int size=que.size();\\n            while(size--){\\n                TreeNode* node=que.front();\\n                que.pop();\\n                if(node->left==NULL&&node->right==NULL){\\n                   \\n                    if(temp.find(hash[node->val])!=temp.end()){\\n                        node->left=hash[node->val]->left;\\n                        node->right=hash[node->val]->right;\\n                        temp.erase(hash[node->val]);\\n                    }\\n                }\\n                if(node->left)que.push(node->left);\\n                if(node->right)que.push(node->right);\\n            }\\n        }\\n        if(temp.size())return {};\\n          if(check(root,INT_MIN,INT_MAX))return root;\\n          return {};\\n    }\\n};\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1989069,
                "title": "c-easy-and-simple-solution-merge-bsts-to-create-single-bst",
                "content": "**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358113,
                "title": "c-most-intuitive",
                "content": "The most important thing to understand is the fact that the final root node will be the one which is not found in any trees leaves. After figuring this out, we just need to recursively merge the dependecies, and finally check if everything has been merged and if the resuting tree is a BST or not. \\n\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537226,
                "title": "just-do-what-is-says-explained-the-approach-in-detail-time-complexity-o-n",
                "content": "# Approach : \\nTime complexity : $$O(n)$$\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored. \\n\\n![image.png](https://assets.leetcode.com/users/images/8e5bc7c9-bfa8-4373-bffb-f8ea7caeec58_1684390579.3647506.png)\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\n### Joining Part   : \\n\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\n##### So in the Above example : \\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\n##### Below example : \\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\n![image.png](https://assets.leetcode.com/users/images/199f02d4-47d5-4197-8bc1-65a03c88ce56_1684390990.772047.png)\\n\\n\\n###### Similarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\n\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Code\\n```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n###### Please upvote \\uD83E\\uDD79 !",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367650,
                "title": "split-problem-into-multiple-subproblems-and-solution-is-ready",
                "content": "This problem can be broken down into 4 subproblems - \\n1. How to find leave nodes & root nodes in constant time out of n BST\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child\\n4. Find if given tree is BST or not. \\n\\nLets start 1 by 1 - \\n1. How to traverse leave nodes & root nodes in constant time out of n BST - \\n\\t* Why we need constant time search - \\n\\t\\t* For each BST\\'s root node we wanted to verify if root node is part of any BST\\'s leaf node or not. \\n\\t\\t* to find a BST whoes root node is not a leaf node in any one of the BSTs\\n\\t* We can leverage Map here keep track of both type queries\\n\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs -\\n\\t* We can use above Map to perform this query. For each root node in List we can query in **leaves** Map if no leaves exists then it can become my combined BST root. \\n\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child -\\n\\t* if left child(by value we will compare) is present in **roots** map then replace left child with this node from **roots** map\\n\\t* if right child (by value we will compare) is present in **roots** map then replace right child with this node from **roots** map.\\n\\t* recurse above 2 steps for each left & right child\\n\\t\\n4. Find if given tree is BST or not. \\n\\t* Multiple ways to do it. Either in-order traversal or comparing left & right with min/max. You can surely find answer for this on internet.\\n\\nBelow code snippet can be improved further but is just to give an idea how we can implement all 4 subproblems and stich them togather.\\n\\n```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333876,
                "title": "java-o-n-using-two-hashmaps-optimized-40ms-explained-with-comments",
                "content": "Reference : https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330172/Java-or-two-HashMaps\\n\\n```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330943,
                "title": "c-hash-map-detailed-comments",
                "content": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358695,
                "title": "don-t-think-too-much-c-time-o-n-space-o-n",
                "content": "# Intuition : Go in flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo what we do with separate nodes to make binary search tree.\\n\\n\\n# Approach : Brute force\\n<!-- Describe your approach to solving the problem. -->\\n> 1. Check the size of trees array if its 1 then just check that tree is `validBST` or not and return root;\\n> 2. Collect all the node in map except root of each tree in `val -> nodeAddress`.\\n> 3. Now create `root variable` with value `null` and loop through all tree heads. if that head value exist in map then update that values address with head address. \\n> 4. if not in map then store in `created root variable and check root should be assigned exactly 1 time if not then return null`.\\n> 5. Its time to make tree from root since we have collected correct value with node address in map.\\n> 6. Go through `makeTree` DFS function with root if left & right of node is null and that is exist in map  then update that address and `count++`.\\n> 7. if count and size of map is not same then return null.\\n> 8. Now, check `root is validBST or not` with [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n---\\n# Note : Corner cases steps\\n- Step 1 for only 1 tree in array\\n- Step 4 for completely diffrent trees that never match\\n- Step 7 loop between trees like tree1: [1, 2] and tree2: [2, 1]\\n\\n\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433286,
                "title": "java-o-n-solution",
                "content": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331994,
                "title": "two-dfs",
                "content": "Let us call the input trees small trees, and the final BST the big tree.\\n\\nOne insight is that there can only be one such small tree that can be the topmost small tree in the final big tree . Because in the final big tree, except the topmost small tree, all other trees\\' root values appear in some leaves of other small trees. So if there exists a final big tree, then there is one and only one small tree whose root value is unique. This is a necessary condition. \\n\\nWe use two DFS. The 1st DFS writes down all leaves\\' occurrences, and use this info the decide which small tree is the topmost one. Then we use the second DFS to traverse and stitch the final tree at the same time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330153,
                "title": "python-there-is-at-most-one-way-to-merge",
                "content": "**Explanation**\\n\\nThe fact that this is a strict BST, and we want all values to be distinct, makes our job much, much easier. This means that for each value v we find in any tree, there are two options:\\n1. v appears exactly once ever, or\\n2. v appears exactly twice: once as a root, and once as a leaf.\\n\\nThis means there is at most one way to merge the trees together. We want to process all of our trees, storing root values and child values in dictionaries and checking conflicts (values that are duplicated, but not in one of the two cases above). At the end, we try to merge all of our trees by repeatedly selecting any root and moving it to its final destination. We return true if we succeeded (i.e. if we have a valid BST, of the correct expected size).\\n\\n**Complexity**\\nTime and space complexity: `O(n)`. The code is also quite fast, since we try to break as quickly as possible if we see that we can\\'t merge the trees.\\n\\n**Python**\\n\\n```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```\\n\\nEdit: Most of the code is broken up into useful chunks of helper functions. This code also works with arbitrary BST\\'s of any size. Since the problem statement is currently a bit unclear about whether a 3-node, one-leaf BST is a valid input, the current code should still AC if the problem does get modified.\\n\\nAlso, a big thanks to @yaroslav-repeta for critiques on the code style.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561451,
                "title": "python-solution-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709355,
                "title": "100-test-cases-passed-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347222,
                "title": "c-simple-hashmap-explained-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824005,
                "title": "c-one-map-for-root-one-set-for-leaf",
                "content": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }\\n        TreeNode* root = nullptr;\\n        for(auto it : trees) {\\n            if(leafmap.find(it->val) == leafmap.end())\\n                root = it;\\n        }\\n        if(helper(root, INT_MIN, INT_MAX)) {\\n            if(rootmap.size() == 1)\\n                return root;\\n        }\\n        return nullptr;\\n    }\\n    \\n    bool helper(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return true;\\n        if(root->val >= high || root->val <= low)\\n            return false;    \\n        if(root->left) {\\n            int cur = root->left->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->left = rootmap[cur];\\n                rootmap.erase(cur);\\n            }\\n        }\\n        \\n        if(root->right) {\\n            int cur = root->right->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->right = rootmap[cur];\\n                rootmap.erase(cur);\\n            }            \\n        }\\n        \\n         if(!helper(root->left, low, root->val))\\n            return false;\\n        \\n        if(!helper(root->right, root->val, high))\\n            return false;\\n        \\n     \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1805468,
                "title": "c",
                "content": "\\'\\'\\'\\'class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }\\n        for(auto c:temp)\\n        {\\n            temp2.push_back(c);\\n        }\\n        if(temp2.size()==0)return nullptr;\\n      TreeNode* root1=  convertToBST(temp2,0,temp2.size()-1);\\n        return root1;\\n        \\n    }\\n    void inorder(TreeNode* root,set<int>& temp)\\n    {\\n          if(root==NULL)return;\\n         inorder(root->left,temp);\\n        temp.insert(root->val);\\n        inorder(root->right,temp);\\n        \\n    }\\n    TreeNode* convertToBST(vector<int>& temp2,int low,int high)\\n    {\\n        if(low>high)\\n            return nullptr;\\n        int mid=(low+high)/2;\\n        TreeNode* root=new TreeNode(temp2[mid]);\\n        TreeNode* ltree=convertToBST(temp2,low,mid-1);\\n        TreeNode* rtree=convertToBST(temp2,mid+1,high);\\n        root->left=ltree;\\n        root->right=rtree;\\n        return root;\\n    }\\n};\\'\\'\\'\\'\\'\\n\\nPlease suggest ,what i am doing wrong here",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757102,
                "title": "python-a-tale-of-2-dicts-simple-dfs",
                "content": "Check for multiple root trees when done merging with DFS.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689069,
                "title": "using-two-hashmaps-roots-and-leaves",
                "content": "Idea is to use two hashmaps - \\n1. to store all the roots\\n2. to store all the leaf openings\\n\\nAfter this we can just scan through our trees and find if there are any openings. If we do, connect them together. We then also update our hashmaps by removing the opening as well as the root that got merged.\\n\\nFinally, we check whether the final remaining roots are only 1, and a valid BST. We also match the sizes as there were some test cases that had created cycles.\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411216,
                "title": "c-simple-approach-proof-based-explanation-code",
                "content": "\\n\\n**Important Observations**\\n1) **If any two leaves have same value, we can\\'t have a valid BST.**\\n\\tProof: Let say, two nodes, namely, node1 & node2 have same value.\\n\\t\\t\\t  WLOG, let node2 is in left subtree of node1. \\n\\t\\t\\t\\t  => node2->val < node1->val, \\n\\t\\t\\t\\t  {because left tree should contains nodes with strictly lesser value, according to the definition given in the question statement}\\n\\t\\t\\t\\t  => Thus, node2->val != node1->val (**Contradiction**)\\n\\n2) **There should be exactly one root, which does not have corresponding leaf node to merge with.**\\n\\tProof by contradiction: It we have two such roots, then we will have two head nodes of our merged BST, which is not possible.\\n\\t\\n\\n**Algorithm**\\n\\n1) Map root and leaf pointers to their values.\\n2) Find Head Node, and merge in arbitary order.\\n3) Check Validness of the BST\\n\\n\\n**Time Complexity**\\nO(m), where m is max tree node value. Here m<= 5*10^4.  \\nBut we can optimise it to O(n), where n is the number of tree nodes. Just use unordered_map instead of vectors root & leaf.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1359112,
                "title": "concise-c-beats-99-single-map-single-dfs-roo-leaf-merge",
                "content": "Major observations:\\n1. Apart from unquie root values, we also need **unique leaf values**, otherwise we dont have unique node to mount the root to, and also this would break the bst contraints for **strict** ordering.\\n2. If a **root does not map to a leaf, it must be the root of final tree**\\n3. If multiple roots dont map to leaves, then we have disjoint trees/graphs\\n4. the **count of nodes in the final valid bst must be equal to the total unique node cnt**( this will eliminate loops, non valid bst, and even disjoint sets)\\n\\nSolution:\\n1. Create map of leaf node val to its reference( have used double pointer in code as we cant store references in map. Parent node pointer could also be used here). Basically during  merge, we need to update the child node pointers in trees to new pointers.\\n2. Now traverse the root nodes one by one and merge them to leaf nodes\\n3. Traverse the merged bst to validate the number of nodes\\n4. Use the above observations to find invalid usecases\\n\\n````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341795,
                "title": "python-simple-simulation-o-n-easy-to-understand-with-explanations",
                "content": "This description of this problem lists the steps to simulate the merging process. The only thing we need to do is to implement the whole process. Notably there are some edge cases, and also a few quick ways to check if there exists a valid solution. \\n\\nFrom the begining, we know that:\\n1. The final result is a BST, which can NOT have duplicated values across its nodes.\\n2. The are `n` trees initially and we can only merge nodes for `n-1` times, which means each node can at most be merged for `1` time.\\n\\nThe above information indicates that:\\n1. In the original trees, the maximum ocurring frequency of a duplicated value is 2, otherwise there must be duplicates in the final BST. \\n2. The number of 2-duplicated pairs must be exactly `n-1`, becasue each merging solves a duplicate.\\n\\nThe above 2 conditions can help us quickly rule out invalid cases and return `null` before the simulation process. Moreover, we need to figure out which nodes will be paired together and merged before the simulation process as well, so we traverse over all nodes in the original trees and create a mapping from each value to `a list of its locations` (the index of the tree it belongs to and its position in that tree). The information we need looks like: \\n```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\\nThe maximum length of such a list is 2, and the number of lists of length 2 is exactly `n-1`, as explained above.  For those nodes to be merged (whose value has a location list of length 2), one node must be `root` and the other must be `left/right` leaf of a tree, following the described merging process.\\n\\nSo the next step is to merge those nodes one by one, where we use a `deleted` array to mark which trees will be deleted after the merging process. since we will merge `n-1` tree, there will be only one remaining tree root undeleted in `trees`, which can be the final result only if it leads a valid `BST`. We then use inorder traversal to check if the tree rooted by the undeleted root is a valid BST and return the root if so. \\n\\nNotably, there is an edge case, e.g., in test case 465: \\n`[[1,null,3],[3,1],[4,2]]`\\nThe first 2 input trees forms a cycle and both will be deleted in the merging process. The algorithm will return `[[4,2]]`, which is indeed a valid BST but does not contain all origianl nodes. We can avoid this edge case by comparing the number of nodes in the final result to the number of original nodes after merging and deletion. \\n\\nThe complete code is as below: \\n\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "solutionTags": [],
                "code": "```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332841,
                "title": "easy-c-implementation-stimulation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332725,
                "title": "c-merge-using-dictionaries",
                "content": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332564,
                "title": "javascript-dfs-adding-trees-on-the-go",
                "content": "**Idea**\\nBuild the tree from the top down.\\n**Issues**\\nThere are a couple edge cases that need to be considered. Namely, problems arise when:\\n* There are cycles, for example   [2,null,3] , [3,2,null]\\n* Some mini trees are not used at all\\n* The resulting tree is not a BST\\n\\n**Implementation**\\nOne dfs will determine the indegrees of each node and will place pointers in each node to their parent, such that replacing can be easy, even when currently at the node itself. The node with the indegree===0, is the main root, from which a second dfs will form the resulting tree. Finally, after each edge case has been dealt with, the root node will be returned.\\n\\n```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331418,
                "title": "python-3-bfs-updating-lower-and-upper-bound-2844-ms",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}\\n        leaves = set()\\n        start = set()\\n        for tree in trees:\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n            root[tree.val] = tree\\n            start.add(tree.val)\\n        \\n        start = start.difference(leaves)\\n        \\n        if len(start) != 1: return None\\n        res = root[list(start)[0]]\\n        \\n        cnt = 1\\n        n = len(trees)\\n        q = deque([(res, float(\\'-inf\\'), float(\\'inf\\'))])\\n        \\n        while q and cnt < n:\\n            node, low, high = q.popleft()\\n            if node.left and node.left.val in root:\\n                h = min(high, node.val)\\n                tmp = root[node.left.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.left = tmp\\n                    q.append((node.left, low, h))\\n                    cnt += 1\\n            if node.right and node.right.val in root:\\n                l = max(low, node.val)\\n                tmp = root[node.right.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.right = tmp\\n                    q.append((node.right, l, high))\\n                    cnt += 1\\n        \\n        return res if cnt == n else None",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}",
                "codeTag": "Java"
            },
            {
                "id": 1330973,
                "title": "java-solution-using-hashmap-readable-code",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330285,
                "title": "beginner-friendly-c-solution-using-two-hash-maps-explained-commented",
                "content": "This may not be an optimal solution. But a solution easy to understand. \\n* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081370,
                "title": "map-tree-conditions-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA binary search tree that is valid is a graph of contracts of node relations. As such, we can use graphs and sets of tree node relations and utilize them to determine validity. Validity needs to agree on a node level, and as a whole tree, and so we use a map for trees and a map for leaves, along with a set for each as well. This then lets us uniquely determine the valid binary search tree, for which there must be only one organization for the result based on the problem description. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a set of leaf values, tree values, a map of trees, a max tree and min tree value variable as needed for the problem, a min prob value and max prob value as needed for the problem. \\n\\nLoop such that \\n- For tree in trees \\n    - map tree value to tree in tree map \\n    - add tree value to tree values set \\n    - for each of the tree children \\n        - if leaf add to the leaves the child values \\n    - update max tree, min tree as needed related to tree.val \\n\\nBuild a root set as the difference of tree values set and leaves value set \\nSet root as \\n- None if len of root set is != 1 (non-unique valid bst) \\n- tree_map at root_set.pop() if len of root set is 1 \\n\\nValid conditions checked as follows \\n- If root is None\\n    - return None  \\n- elif root.left and root.right is None \\n    - return root if length of trees is 1 else None \\n- elif root.left and not root.right and root.val is not max_tree \\n    - return None    \\n- elif root.right and not root.left and root.val is not min_tree \\n    - return None \\n\\nIf root is None, no tree. If both left and right are None, no tree unless only one tree. If left and not right or right and not left and the root value is not the max or min tree respectively -> also none \\n\\nConsider child states as (low value limit, high value limit, parent node, side of placement of parent node). This then lets you understand each child state in relation to parent state, and allows for handedness. A left child will always use a parent value as the high limit, and a right child will always use the parent value as the low limit. \\n\\nIn all other cases, we now need to traverse \\n- Make a leaf map, set left to 0 and right to 1 \\n- If root.left add to leaf map at root.left.val the tree state of (min_prob, root.val, root, left) \\n- If root.right, add to leaf map at root.right.val the tree state of (root.val, max_prob, root, right) \\n- delete tree map at root value \\n- While you have a tree map \\n    - set tree exists to False \\n    - loop for leaf and leaf (child) state in leaf map items \\n        - if leaf in tree map  \\n            - set new_tree to tree_map at leaf \\n            - delete leaf_map at leaf \\n            - Each of the new_tree\\'s children must satisfy that they are in bounds of the leaf state (low < children value < high) and children value not in leaf map \\n            - For each child, if not satisfactory, return None. Otherwise, set leaf map at child value to appropriate leaf state\\n            - based on sidedness of child state, set parent on side to new tree \\n            - mark tree exists as True if a leaf was satisfied \\n            - delete tree map at new tree value \\n            - break out of loop \\n        - if leaf not in tree map, continue until leaf in tree map \\n    - if tree exists is False return None as no leaf was satisfied \\n- if loop completes, return root             \\n\\n# Complexity\\n- Time complexity : O(T) \\n    - O(T) loop trees at start \\n    - O(T) build root set \\n    - validity check in O(1) lets lower bound at O(2T) \\n    - O(T) loop tree map \\n        - O(L) leaf map items (at most 2 or 3 items each loop) \\n            - early check available inside \\n        - early check available oustide L loop\\n    - Total value is O(cT) where c is a constant -> O(T) \\n\\n- Space complexity : O(L + T) \\n    - Leaf set of size L \\n    - Tree values of size L \\n    - Tree map of size T -> T \\n    - Leaf map of size L -> LS (held at constant size by deletes / adds) \\n    - Total size is L + T \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050610,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027705,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009835,
                "title": "simple-easy-well-explained",
                "content": "Yess it\\'s just all about heavy and careful implimentation\\nfirst we need to mark all child and parent  here as we will mark parent by value of left and right child iff exists\\nso we will have a map\\n```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\\nand for binary tree we need to have range of values each node covers \\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\\nand now just begin\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958516,
                "title": "well-commented",
                "content": "\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917823,
                "title": "structured-code",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809888,
                "title": "beats-cpp-c-fastest-easy-to-unerstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach :\\nTime complexity : O(n)\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored.\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\nJoining Part :\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\nSo in the Above example :\\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\nBelow example :\\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\nSimilarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$  -->\\n\\n\\n> - Space complexity:O(N)\\n\\n---\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387203,
                "title": "just-implement-the-statements-given-in-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# UpVote\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239742,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142584,
                "title": "c-hash-dfs-depth-first-search-leetcode-98-validate-binary-search-tree",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115463,
                "title": "swift-bfs",
                "content": "**BFS Approach (accepted answer)**\\n```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040147,
                "title": "simple-hash-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first have to map every child\\'s value with it\\'s parent tree pointer so that again iterating we can join these .\\nWe also have to check if formed tree is BSt or not by taking it\\'s preOrder and see if it is in increasing order or not also we have to count nodes before and after tree making as if we will have cycles then we will not include those nodes in final tree according to algorithm .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901518,
                "title": "depth-first-search-to-merge-binary-tree-python",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Indentify your root tree from where merging will being .\\n2. Now from remaining trees , apply helper function to merge.\\n3. If final tree is valid BST then return tree else return None.\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884454,
                "title": "c-hashmap-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807443,
                "title": "python3",
                "content": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735280,
                "title": "c-hashmaps-with-explanation",
                "content": "This approach basically compares the leaves of every first tree with the root value of second tree stored in map and then append that second tree with the leaves of firsr tree.\\n```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/b9d98b12-ff5a-4f5f-aa16-f692b4a2ebc4_1666513935.780494.png)\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716508,
                "title": "c-traverse-each-bst-leaf-node-with-help-of-a-hashtable-no-dfs-o-n-space-and-time",
                "content": "Some of the observations:\\n1. each BST root has unique value\\n2. let\\'s denote given BSTs with 1/2/3 nodes as BST-1/2/3. BST-1 cannot be used as leaf because no other root can attach to it. Only BST-2 and BST-3 leaf nodes can be used to attach another root.\\n3. in case two or more leaf nodes are equal, the result is invalid. Since merging with BSTs does not eliminate leaf from final tree, a tree with two or more equal nodes cannot be BST.\\n4. be careful with `cyclic merge`: a BST when merged to a parent tree, its leaf contains root value of the parent. For example [[10,5,12],[5,3,8],[3,null,10]]\\n\\nHere is the algorithm:\\nWe initialize a hashtable with given BSTs. Iterate on each leaf node, merge another BST and remove it from the hashtable when found. Equal leaf nodes at most can do 1 merge, as the non-first such leaf will not find the value from hashtable. `cyclic merge` components will disappear wholly from the hashtable. In the end, the hashtable might contain:\\n0 trees: `cyclic merge` exists and the whole BST disappeared, return NULL.\\n1 trees: `cyclic merge` might exist, or not. e.g., [[3,1],[1,3],[5,2,6]]. apply validBST() to count number of nodes in the result tree, when valid it should be total - (tree count - 1). \\n2 or more trees: cannot be merged as a single tree, return NULL;\\n```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580139,
                "title": "c-dfs-solution-beats-90",
                "content": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573783,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467078,
                "title": "java-build-it-with-detailed-comments",
                "content": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459260,
                "title": "c-hashmap-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446115,
                "title": "scala-i-believe-it-works-but-memory-limit-needs-to-be-adjusted",
                "content": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421173,
                "title": "97-tc-passed-intuitive-approach",
                "content": "**Only 3% cases are not passed.\\n If anyone can improve this code then you are most welcome.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327830,
                "title": "c-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293703,
                "title": "c-topological-sort-based-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195014,
                "title": "java-simple-solution-using-hashmap-and-dfs",
                "content": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }\\n            \\n            if (trees.get(i).right != null) {\\n                child.put(trees.get(i).right.val, trees.get(i).right);\\n                numberOfNode++;\\n            }\\n        }\\n        \\n        TreeNode node = null;\\n        for (int i=0; i<trees.size(); i++) {\\n            if (child.containsKey(trees.get(i).val)) {\\n                numberOfNode--;\\n                TreeNode first = child.get(trees.get(i).val);\\n                first.left = trees.get(i).left;\\n                first.right = trees.get(i).right;\\n            }\\n            else {\\n                if (node == null) {\\n                    node = trees.get(i);\\n                }\\n                else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return (isValid(node, Integer.MIN_VALUE, Integer.MAX_VALUE) && numberOfNode == outputNumberOfNodes) ? node : null;\\n    }\\n    \\n    public boolean isValid(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        \\n        outputNumberOfNodes++;\\n        if ((root.val <= min || root.val >= max)) {\\n            return false;\\n        }\\n        \\n        return (isValid(root.left, min, root.val) && isValid(root.right, root.val, max));\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2185575,
                "title": "python-observation-dfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### Observation + DFS\\nFirst of all, let\\'s observe the constraints that might give hints to the solution. \\n* All of roots are unique. It means we can quickly locate which `root` to replace child with using hashmap, otherwise for the same value of child, we might have multiple choices.\\n* We need to do `n - 1` operations. It means the `roots` ends up with the only one root left which is the final root for the BST since we need remove one root from `roots` each time.\\n* The final number of `roots` is 1 means for each `roots[i]` except the final root, there is always a `roots[j]` such that either of children of `roots[j]` equals to the value of `roots[i]`. This is the most important key to crack this problem. So we can say the BST is not valid if this condition is not met.\\n* All of roots are valid BST. It means we can pick root from `roots` greedly as long as the value of either children is equals to the root.\\n\\nSo we can summary that the algorithm is that\\n1. Store the value of each root from `roots` in hashmap.\\n2. Iterate left and right child of each root and remove the corresponding root from `roots`\\n3. Return None if more than 1 root left in `roots`.\\n4. The left one is the final root we need to return\\n5. Replace the children of final root recursively.\\n\\nI started with interative way, and found it too difficult to write. The easiest way is to recursively replace the root, left and right children, then return the root.\\n\\nFianlly, pass in the range to the dfs as well, which is used to evaluate the BST property.\\n\\n```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089038,
                "title": "simple-java-o-n-with-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993949,
                "title": "c-with-comment-and-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1984182,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960168,
                "title": "python-clean-code",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "solutionTags": [
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958073,
                "title": "python-100-faster-use-dict-with-detailed-comment",
                "content": "**Idea**\\nFirst we build a leaf-value-to-root dict. If we found two leaves with the same value, return None.\\nThen we iterate the trees, if a tree has same value with other leaf(by checking if tree.val is in the dict), it can be merged into it. Otherwise it\\'s our root tree!\\nAfter we finish merging, check if the tree is a valid bst and node count is right.\\nDone.\\n\\n**Some Questions**\\n* Should we check if there are circles in the tree?\\n\\t* technically, yes. However, we have already make sure that won\\'t happen.\\n\\t* think these two cases: [[1,null,3],[3,1],[4,2]] and [[1,null,3],[3,1]]\\n\\t\\t* if circle appears, we will get an incomplete tree after the merging process, node counting will help us check it out.\\n\\t\\t* if circle appears during the merge, it won\\'t be the root node, so we don\\'t need to worry about infinite recursion during node counting\\n\\n**Complexity**\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842567,
                "title": "c-solution",
                "content": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1834916,
                "title": "intuitive-c-hashing-bst",
                "content": "It is simple for the trees that have only one node. they will not effect the overall tree after merging all the trees. But we just need to check if there is a possible place for them to be merged. If not, we return NULL.\\n\\nThe second observation is after merging 2 trees, one leaf node gets removed and count of trees also reduces by 1. \\n\\nThe third observation is after removing single noded trees, all the leave nodes must be unique. why? if it is not. there will be 2 instances of the node with same count in the final tree. \\n\\nWe create the final tree and check if the final tree is valid or not ( both BST properties and whether the final tree contains all the unique keys given as input)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1819537,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780958,
                "title": "java-simple-bfs",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            rootVals.put(t.val, t);\\n        }\\n        \\n        bfs(root);\\n        \\n        if (!isValidBST(root) || rootVals.size() != 1) {\\n            return null;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode findRoot(List<TreeNode> trees) {\\n        TreeNode root = null;\\n        Map<Integer, Integer> valCnts = new HashMap<>();\\n        for (TreeNode t : trees) {\\n            valCnts.put(t.val, valCnts.getOrDefault(t.val, 0) + 1);\\n            if (t.left != null) {\\n                valCnts.put(t.left.val, valCnts.getOrDefault(t.left.val, 0) + 1);\\n            }\\n            if (t.right != null) {\\n                valCnts.put(t.right.val, valCnts.getOrDefault(t.right.val, 0) + 1);\\n            }\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            if (valCnts.get(t.val) == 1) {\\n                if (root == null) {\\n                    root = t;\\n                } else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private void bfs(TreeNode root) {\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode parent = q.poll();\\n                if (parent.left != null && rootVals.containsKey(parent.left.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.left.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.left = toConnect;\\n                    q.offer(parent.left);\\n                }\\n                if (parent.right != null && rootVals.containsKey(parent.right.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.right.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.right = toConnect;\\n                    q.offer(parent.right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private boolean isValidBST(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val <= min || root.val >= max) {\\n            return false;\\n        }\\n        \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780098,
                "title": "javascript-hashmaps-root-to-value-mapping",
                "content": "A few things to keep in mind:\\n* **All root values are unique.**\\n* **To create a valid BST, all root values (except the final root) must map to exactly one leaf value (there cannot be multiple leaf values which are the same)**\\n----\\n1. Map roots to their matching leaves. Also keep track of the total count of nodes.\\n  This total count would have counted every single node once, so after joining into a valid BST, exactly n - 1 nodes would have been counted twice. \\n  So, we subtract n - 1 from our nodes count.\\n2. Get the root which doesn\\'t map to any leaf node, this is the final root.\\n3. Merge all the leaves -> roots together.\\n4. Validate the final tree. \\n----\\n**Time Complexity: O(n) 516ms\\nSpace Complexity: O(n) 79.1MB**\\n\\n```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728235,
                "title": "go-inorder-traversal",
                "content": "Each BST can be considered a node in the merged tree, where leaves are edges toward other BSTs. With this viewpoint, construction of the tree (from the BSTs) is possible only if there is a single node (BST) which does not have an in-degree of zero.\\n\\nAt this point there may still not be a valid solution: two BSTs may point to each-other (`[2,1]`, `[1,2]`). To keep track of this, we mark each node as seen in a map.\\n\\nFinally, to validate the tree at the same time as its being constructed, merge BSTs in-order.\\n\\nFor this exercise I tried working with pointers to pointers just to practice. It could easily be replaced with more simple `if n.Left != nil` statements.\\n\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668572,
                "title": "java-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668267,
                "title": "easy-hash-map-bfs-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654034,
                "title": "javascript-solution",
                "content": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653163,
                "title": "python-translation-of-votrubac-s-just-do-what-it-says",
                "content": "Giving full credit to: https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330387/Just-do-what-it-says\\n\\n```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598315,
                "title": "java-solution-using-hashtables-and-priority-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564445,
                "title": "java-easy-solution-0-ms-faster-than-100-00",
                "content": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "solutionTags": [],
                "code": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1561096,
                "title": "javascript-map-and-stack-100-faster",
                "content": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474222,
                "title": "sime-easy-to-understand-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441258,
                "title": "c-greedy-like-solution",
                "content": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437247,
                "title": "open-only-to-read-approach-tle-473-474-test-case-passed",
                "content": "Problem: https://leetcode.com/problems/merge-bsts-to-create-single-bst/\\nApproach:\\nTime Complexity: O(n)  \\nAuxillary Space: O(n)\\n**Note: This approach was not able to pass all test cases but its optimzation will if you are able to optimize it do let me know. Thank you !** \\nHere first we traverse the trees vector and for each particular bst we try to merge it with another bst which has same root->val equal to one of the leaves value.\\nNow we try to combining the current root leave by new bst by assigning left and right of new root then  we also check for valid bst for its child.\\nIt may be possible that the after merging the new subtree it is not following the property of bst.\\n\\n**Merging:**\\nHere while traversing through a tree we are checking if its current not is not a root of other tree.\\nIf found we assign new root child to current node and mark the node which is merged in merge vector so that we don\\'t process it again and update that root value in mp.\\nWhenever merging is successful we increment counter, as we have valid answer only when all n-1 nodes are merged.\\n\\n**Checking Valid Bst:**\\n* We first assume that our root value can be in between range lower and higher (INT_MIN and INT_MAX for root).\\nThen at each step we check the root value is in range.\\nThen we check this recursively for each child.\\n* For left subtree all the values in it should be less than root value so the lower is equal to INT_MIN but higher is equal to root value.\\n* For right child subtree all the values in it should be more than the root value so the lower is equal to root value and higher is equal to INT_MAX.\\n\\n**Helper datastructures:**\\n* Here one map which store root value and its corresponding index in trees vector. (mp)\\n* A vector is used to track which bst are merged and avoid their processing. (merge)\\n* A counter variable which is used to count the number of bst which are merged. (count)\\n* A bool variable if at any instance if after merging the tree is not following bst property the it should inform this and stop further recursive calls. (flag) \\n\\n**Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416434,
                "title": "simple-efficient-c-greedy-verification",
                "content": "1) Each of (1-3)-BSTs produced by any valid decomposition of a valid BST is bound to have unique roots and unique children. Therefore, the original BST can be reconstructed by greedily replacing leaves with input/intermediate BSTs.\\n2) Verify that we ended up with one valid BST containing all unique input nodes once.\\n\\nO(bst_count)\\n\\n```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414959,
                "title": "python-stack-o-n",
                "content": "it is a good problem on the tree construction.\\nso, this question states that we need to add the root of another tree to the current tree if it have any leaf node whose value is equal to the value of root.\\nthis also tell us that there is only one root that occur once , inorder to make only one bst . if there are more than one root present that occur only once than we can not make the single bst or tree.\\nthe second thing that we want to take care is that if the tree formed has used all the root or not.\\nthe third thing is that the tree formed is valid or not .\\nAPPORACH ->\\nso for taking the care of first case we use two list frequency and the root dict.\\nif the value of the any node is one we will increase the value of unique nodes(a varible that will store it) and take its corrosponding root as  our tree\\'s root that we will return at the end . but if that varible storing the unique root is not equal to 1  then we can not make the single tree.\\nfor the second case we will use the varible that will have the number of roots , and decrement the count by 1.\\ncode->\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410066,
                "title": "python3-recursive-tree-building-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345851,
                "title": "python-using-dictionaries-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport collections\\ndef inorder(root, par, treeNode):\\n    if root==None:\\n        return []\\n    l = inorder(root.left, root, treeNode)\\n    r = inorder(root.right, root, treeNode)\\n    if len(l)==0 and len(r)==0:\\n        return [(root.val, treeNode, par, True)]\\n    return l+[(root.val, treeNode, par, False)]+r\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}\\n        minMaxVal = {}\\n        rootToLeaf = collections.defaultdict(list)\\n        for t in trees:\\n            x = inorder(t, None, t)\\n            for a, b, c, d in x:\\n                if d and c!=None:\\n                    if a in leafToNode:\\n                        return None\\n                    leafToNode[a] = [b, c]\\n                    rootToLeaf[t].append(a)\\n            minMaxVal[t] = [x[0][0], x[-1][0]]\\n        ans = None\\n        for t in trees:\\n            if t.val in leafToNode:\\n                treeNode, par = leafToNode[t.val]\\n                if t.val<par.val:\\n                    if minMaxVal[t][1]>=par.val:\\n                        return None\\n                    else:\\n                        par.left = t\\n                else:\\n                    if minMaxVal[t][0]<=par.val:\\n                        return None\\n                    else:\\n                        par.right = t\\n                if t.val>treeNode.val:\\n                    if minMaxVal[t][0]<=treeNode.val: return None\\n                    minMaxVal[treeNode][1] = max(minMaxVal[t][1], minMaxVal[treeNode][1])\\n                else:\\n                    if minMaxVal[t][1]>=treeNode.val: return None\\n                    minMaxVal[treeNode][0] = min(minMaxVal[t][0], minMaxVal[treeNode][0])\\n                for leaf in rootToLeaf[t]:\\n                    if leaf in leafToNode:\\n                        leafToNode[leaf][0] = treeNode\\n                del leafToNode[t.val]\\n            elif ans==None:\\n                ans = t\\n            else:\\n                return None\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}",
                "codeTag": "Java"
            },
            {
                "id": 1344093,
                "title": "slower-but-simpler-we-can-do-naive-merging-and-compare-with-sorting",
                "content": "If BSTs can be merged, it will end up being a valid BST, which means that we can do a in-order traversal to get the sorted elements.\\nTherefore, we can simply try our best to merge, and see if the final in-order traversal result matches the sorted values.\\n\\n- With a valid final BST, all the values will be unique.\\n- We still need to implement merging correctly, but we don\\'t have to maitain extra info during merging, e.g. the min_left value of a node.\\n- Since we do extra sorting, the time complexity will be O(NlgN) instead of O(N).\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339875,
                "title": "c-1932-merge-bsts-to-create-single-bst",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339448,
                "title": "need-help-on-this-tle",
                "content": "What i am trying to do is map root value to address for easy access. Then, for every root, i dfs to its leaves and try to find if map contains a root with value same as the leaf. If yes, i merge and continue dfs on the updated tree. However, i have noticed in cases like\\n[5,4] [6,5] [7,6] [8,7], my code keeps on iterating the tree on every addition in vain. What can i do to stop it? I read tuts here, but i am having problem grasping them and i am more concerned about the problem of my solution since that is what came in my head. THANKYOU\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338716,
                "title": "python3-build-tree-and-check-for-order",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336378,
                "title": "literally-do-what-it-says-clear-python-solution",
                "content": "Simple solution, but with one small trick.\\n\\nWhat we do is just select a root, then verify it\\'s a BST or not using standard way;\\nIf it can form a BST, we\\'ll construct this BST (you can also construct the BST during verification as we will only verify once).\\nWhen we verify or construct BST, we use a reverse query {root value->tree index} from td to quickly find the corresponding tree.\\nThe trick is how to select the root node.\\n\\nAs mentioned in question, if we want to merge all BST to one BST, all root nodes of small BSTs must **appear twice** (as someone else\\'s leaf node) except one node, this node is the root of merged BST.\\n\\nWe use a counter dict **cnt**, which remembers how many times a node appears, then we just need find the node with cnt[val]==1.\\nLeaf node will also have cnt[val]==1 as it\\'s not someone\\'s parent, but it\\'s not a root node from trees[i].\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336000,
                "title": "wrong-answer",
                "content": "For the input - [[2,null,3],[1,null,3],[3,2]]\\nWhy isn\\'t the following a correct answer - [1,null,3,2,null,null,3] ? It\\'s a valid BST.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1335819,
                "title": "python-stack-99-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335528,
                "title": "c-solution-but-messy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334278,
                "title": "easy-to-understand-java-solution-bfs-looping",
                "content": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334013,
                "title": "easy-java-with-comments-36ms",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333368,
                "title": "python-it-is-not-the-best-solution-but-at-least-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332382,
                "title": "python-3-short-and-simple-with-comments",
                "content": "**Key insight about binary search trees**\\n1) There cannot be repeated values\\n2) We can build a binary seach tree recursively keeping track of the lower bound and upper bound of values while connecting nodes\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}                   # Map of val -> tree that we will extract all nodes from\\n        c = Counter()\\n        for t in trees: \\n            if t.left: c[t.left.val] += 1\\n            if t.right: c[t.right.val] += 1\\n        if any(v > 1 for v in c.values()): return None  # BST has no repeated values\\n        \\n        roots = [t for t in trees if t.val not in c]    # Root value cannot be a leaf value because BST has no repeated values\\n        if len(roots) != 1: return None                 # We can only have one root\\n        root = m.pop(roots[0].val)                      # Remove root from map\\n        \\n        def build(n, lb, rb):                           # Recursive function to build out tree\\n            if (n.left and n.left.val < lb) or (n.right and n.right.val > rb): return False  \\n            if n.left and n.left.val in m: \\n                n.left = m.pop(n.left.val)\\n                if not build(n.left, lb, n.val): return False\\n            if n.right and n.right.val in m: \\n                n.right = m.pop(n.right.val)\\n                if not build(n.right, n.val, rb): return False\\n            return True\\n        \\n        if not build(root, -inf, inf) or m: return None # If build ever returns False or there are still nodes in m, somethings not right\\n        return root",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}",
                "codeTag": "Java"
            },
            {
                "id": 1332164,
                "title": "go-poorly-implemented-answer-verification-causes-correct-solution-to-time-out",
                "content": "I found it took ~4s to verify the correctness of my returned tree for a huge test case, while the actually runtime of my code only took less than a second. As a result, my solution exceeded time limit.\\n\\nHad to translate my Go code to Python to pass all test cases.\\n\\nPlease fix!\\n\\nGo:\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331256,
                "title": "c-hash-map-commented-code",
                "content": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330874,
                "title": "c-bottom-up-approach-post-order-traversal-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(!bst){\\n            return root;\\n        }\\n        if(root->val<=left or root->val>=right){\\n            bst=false;\\n            return root;\\n        }\\n        root->left=merge(root->left,actual_root,left,root->val);\\n        root->right=merge(root->right,actual_root,root->val,right);\\n        if(!root->left and !root->right){\\n            if(mapping.find(root->val)!=mapping.end() and mapping.at(root->val)!=root and mapping.at(root->val)!=actual_root){\\n                root=mapping[root->val];\\n                mapping.erase(root->val);\\n                return merge(root,actual_root,left,right);\\n            }\\n            \\n        }\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto&it:trees){\\n            mapping[it->val]=it;\\n        }\\n        TreeNode*ans=nullptr;\\n        for(auto&it:mapping){\\n            merge(it.second,it.second);\\n            ans=it.second;\\n            if(!bst){\\n                return nullptr;\\n            }\\n        }\\n        if(mapping.size()>1){\\n            return nullptr;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1330811,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1330540,
                "title": "o-n-time-and-space-find-bst-root-and-build-it-recursively-python",
                "content": "### Approach\\nThree main steps:\\n1. All root values should be at leaf of some tree in given trees, except exactly one. This one is the root of the BST we want to build. We can find this BST root with the help of a few map data structures that will take O(n) space.\\n2. Start building the BST recursively from the BST root. Mark the merged trees as deleted, which will also help detect any cycles.\\n3. Check to make sure that all trees except the BST root are marked as deleted and the BST we built is valid.\\n\\n### Time and Space Complexity\\n* `O(n)` time\\n\\t* We have to do a constant number of passes over the given trees list, each pass taking `O(1)` time\\n* `O(n)` space\\n\\t* We use 3 maps and a set each taking `O(n)` space, \\n\\t* We also use `O(n)` stack space to build the BST recursively\\n```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1330363,
                "title": "c-using-map-with-explanation",
                "content": "### Intuition\\nFor true to be valid, following conditions must be true:\\n* tree must have only 1 root.\\n* tree must be BST.\\n* tree must include all the nodes.\\n\\n### Solution\\n- maintain a map with node values to node for all child nodes. This map will help up find parent, given any value.\\n- find root, root won\\'t have any parent.\\n- iterate though the trees and update parent of each tree.\\n- finally validate that root is a bst and contains all nodes.\\n\\n### Complexity\\n- Time:` O(|trees|)`\\n- Space: `O(|trees|)`\\n\\n### Code\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1716619,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2003145,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2000607,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if String Is Decomposable Into Value-Equal Substrings",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]