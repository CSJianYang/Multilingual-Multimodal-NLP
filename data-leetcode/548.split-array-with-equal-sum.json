[
    {
        "title": "Rotate Image",
        "question_content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n&nbsp;\nConstraints:\n\n\tn == matrix.length == matrix[i].length\n\t1 <= n <= 20\n\t-1000 <= matrix[i][j] <= 1000",
        "solutions": [
            {
                "id": 18872,
                "title": "a-common-method-to-rotate-the-image",
                "content": "here give a common method to solve the image rotation problems.\\n    \\n    /*\\n     * clockwise rotate\\n     * first reverse up to down, then swap the symmetry \\n     * 1 2 3     7 8 9     7 4 1\\n     * 4 5 6  => 4 5 6  => 8 5 2\\n     * 7 8 9     1 2 3     9 6 3\\n    */\\n    void rotate(vector<vector<int> > &matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    \\n    /*\\n     * anticlockwise rotate\\n     * first reverse left to right, then swap the symmetry\\n     * 1 2 3     3 2 1     3 6 9\\n     * 4 5 6  => 6 5 4  => 2 5 8\\n     * 7 8 9     9 8 7     1 4 7\\n    */\\n    void anti_rotate(vector<vector<int> > &matrix) {\\n        for (auto vi : matrix) reverse(vi.begin(), vi.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "here give a common method to solve the image rotation problems.\\n    \\n    /*\\n     * clockwise rotate\\n     * first reverse up to down, then swap the symmetry \\n     * 1 2 3     7 8 9     7 4 1\\n     * 4 5 6  => 4 5 6  => 8 5 2\\n     * 7 8 9     1 2 3     9 6 3\\n    */\\n    void rotate(vector<vector<int> > &matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    \\n    /*\\n     * anticlockwise rotate\\n     * first reverse left to right, then swap the symmetry\\n     * 1 2 3     3 2 1     3 6 9\\n     * 4 5 6  => 6 5 4  => 2 5 8\\n     * 7 8 9     9 8 7     1 4 7\\n    */\\n    void anti_rotate(vector<vector<int> > &matrix) {\\n        for (auto vi : matrix) reverse(vi.begin(), vi.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18884,
                "title": "seven-short-solutions-1-to-7-lines",
                "content": "While these solutions are Python, I think they're understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix `matrix`, so I'll use the usual `A`. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far.\\n\\n---\\n\\n**Most Pythonic - `[::-1]` and `zip`** - 44 ms\\n\\nThe most pythonic solution is a simple one-liner using `[::-1]` to flip the matrix upside down and then `zip` to transpose it. It assigns the result back into `A`, so it's \"in-place\" in a sense and the OJ accepts it as such, though some people might not.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = zip(*A[::-1])\\n\\n---\\n\\n**Most Direct** - 52 ms\\n\\nA 100% in-place solution. It even reads and writes each matrix element only once and doesn't even use an extra temporary variable to hold them. It walks over the *\"top-left quadrant\"* of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I'm moving the four elements in parallel and that `[~i]` is way nicer than `[n-1-i]`.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \\\\\\n                             A[~j][i], A[~i][~j], A[j][~i], A[i][j]\\n\\n---\\n\\n**Clean Most Pythonic** - 56 ms\\n\\nWhile the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it's a bit dirty. To fix this, we can just apply `list` to every row:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = map(list, zip(*A[::-1]))\\n\\n---\\n\\n**List Comprehension** - 60 ms\\n\\nIf you don't like `zip`, you can use a nested list comprehension instead:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))]\\n\\n---\\n\\n**Almost as Direct** - 40 ms\\n\\nIf you don't like the little repetitive code of the above \"Most Direct\" solution, we can instead do each four-cycle of elements by using three swaps of just two elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    for _ in '123':\\n                        A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i\\n                    i = ~j\\n\\n---\\n\\n**Flip Flip** - 40 ms\\n\\nBasically the same as the first solution, but using `reverse` instead of `[::-1]` and transposing the matrix with loops instead of `zip`. It's 100% in-place, just instead of only moving elements around, it also moves the rows around.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A.reverse()\\n            for i in range(len(A)):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n\\n---\\n\\n**Flip Flip, all by myself** - 48 ms\\n\\nSimilar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n            for row in A:\\n                for j in range(n/2):\\n                    row[j], row[~j] = row[~j], row[j]",
                "solutionTags": [
                    "Python"
                ],
                "code": "While these solutions are Python, I think they're understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix `matrix`, so I'll use the usual `A`. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far.\\n\\n---\\n\\n**Most Pythonic - `[::-1]` and `zip`** - 44 ms\\n\\nThe most pythonic solution is a simple one-liner using `[::-1]` to flip the matrix upside down and then `zip` to transpose it. It assigns the result back into `A`, so it's \"in-place\" in a sense and the OJ accepts it as such, though some people might not.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = zip(*A[::-1])\\n\\n---\\n\\n**Most Direct** - 52 ms\\n\\nA 100% in-place solution. It even reads and writes each matrix element only once and doesn't even use an extra temporary variable to hold them. It walks over the *\"top-left quadrant\"* of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I'm moving the four elements in parallel and that `[~i]` is way nicer than `[n-1-i]`.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \\\\\\n                             A[~j][i], A[~i][~j], A[j][~i], A[i][j]\\n\\n---\\n\\n**Clean Most Pythonic** - 56 ms\\n\\nWhile the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it's a bit dirty. To fix this, we can just apply `list` to every row:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = map(list, zip(*A[::-1]))\\n\\n---\\n\\n**List Comprehension** - 60 ms\\n\\nIf you don't like `zip`, you can use a nested list comprehension instead:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))]\\n\\n---\\n\\n**Almost as Direct** - 40 ms\\n\\nIf you don't like the little repetitive code of the above \"Most Direct\" solution, we can instead do each four-cycle of elements by using three swaps of just two elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    for _ in '123':\\n                        A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i\\n                    i = ~j\\n\\n---\\n\\n**Flip Flip** - 40 ms\\n\\nBasically the same as the first solution, but using `reverse` instead of `[::-1]` and transposing the matrix with loops instead of `zip`. It's 100% in-place, just instead of only moving elements around, it also moves the rows around.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A.reverse()\\n            for i in range(len(A)):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n\\n---\\n\\n**Flip Flip, all by myself** - 48 ms\\n\\nSimilar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n            for row in A:\\n                for j in range(n/2):\\n                    row[j], row[~j] = row[~j], row[j]",
                "codeTag": "Java"
            },
            {
                "id": 18879,
                "title": "ac-java-in-place-solution-with-explanation-easy-to-understand",
                "content": "The idea was firstly transpose the matrix and then flip it symmetrically. For instance, \\n\\n    1  2  3             \\n    4  5  6\\n    7  8  9\\n\\nafter transpose, it will be swap(matrix[i][j], matrix[j][i])\\n\\n    1  4  7\\n    2  5  8\\n    3  6  9\\n\\nThen flip the matrix horizontally.  (swap(matrix[i][j], matrix[i][matrix.length-1-j])\\n\\n    7  4  1\\n    8  5  2\\n    9  6  3\\n\\nHope this helps.\\n\\n    public class Solution {\\n        public void rotate(int[][] matrix) {\\n            for(int i = 0; i<matrix.length; i++){\\n                for(int j = i; j<matrix[0].length; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[j][i];\\n                    matrix[j][i] = temp;\\n                }\\n            }\\n            for(int i =0 ; i<matrix.length; i++){\\n                for(int j = 0; j<matrix.length/2; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[i][matrix.length-1-j];\\n                    matrix[i][matrix.length-1-j] = temp;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[][] matrix) {\\n            for(int i = 0; i<matrix.length; i++){\\n                for(int j = i; j<matrix[0].length; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[j][i];\\n                    matrix[j][i] = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3440564,
                "title": "animation-understand-in-30-seconds",
                "content": "*upvoting the answer will motivate me to create more animations! Thanks.*\\n\\n# Approach\\n2 Steps to rotate image\\n- Transpose the matrix\\n- Swap the columns \\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/0ab215cd-9cd8-4872-90a7-901fb660dc67_1682068950.8864057.gif)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        for(int i=0;i<row; i++){\\n            for(int j=0; j<=i;j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        for(int i=0;i<row; i++){\\n            for(int j=0; j<=i;j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19002,
                "title": "4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space",
                "content": "    void rotate(vector<vector<int>>& matrix) {\\n            int n = matrix.size();\\n            int a = 0;\\n            int b = n-1;\\n            while(a<b){\\n                for(int i=0;i<(b-a);++i){\\n                    swap(matrix[a][a+i], matrix[a+i][b]);\\n                    swap(matrix[a][a+i], matrix[b][b-i]);\\n                    swap(matrix[a][a+i], matrix[b-i][a]);\\n                }\\n                ++a;\\n                --b;\\n            }\\n        }",
                "solutionTags": [],
                "code": "    void rotate(vector<vector<int>>& matrix) {\\n            int n = matrix.size();\\n            int a = 0;\\n            int b = n-1;\\n            while(a<b){\\n                for(int i=0;i<(b-a);++i){\\n                    swap(matrix[a][a+i], matrix[a+i][b]);\\n                    swap(matrix[a][a+i], matrix[b][b-i]);\\n                    swap(matrix[a][a+i], matrix[b-i][a]);\\n                }\\n                ++a;\\n                --b;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 842087,
                "title": "easy-python-from-scratch-2-steps",
                "content": "\\t# reverse\\n\\tl = 0\\n\\tr = len(matrix) -1\\n\\twhile l < r:\\n\\t\\tmatrix[l], matrix[r] = matrix[r], matrix[l]\\n\\t\\tl += 1\\n\\t\\tr -= 1\\n\\t# transpose \\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\t\\t\\t\\nWe want to rotate\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]\\n->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]]\\n\\nWe can do this in two steps.\\nReversing the matrix does this:\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]] \\n-> \\n[7, 8, 9],\\n[4, 5, 6], \\n[1, 2, 3]\\n\\nTransposing means: rows become columns, columns become rows.\\n\\n[7, 8, 9], \\n[4, 5, 6], \\n[1, 2, 3]\\n ->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]\\nIf you like this explanation, please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# reverse\\n\\tl = 0\\n\\tr = len(matrix) -1\\n\\twhile l < r:\\n\\t\\tmatrix[l], matrix[r] = matrix[r], matrix[l]\\n\\t\\tl += 1\\n\\t\\tr -= 1\\n\\t# transpose \\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\t\\t\\t\\nWe want to rotate\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]\\n->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]]\\n\\nWe can do this in two steps.\\nReversing the matrix does this:\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]] \\n-> \\n[7, 8, 9],\\n[4, 5, 6], \\n[1, 2, 3]\\n\\nTransposing means: rows become columns, columns become rows.\\n\\n[7, 8, 9], \\n[4, 5, 6], \\n[1, 2, 3]\\n ->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]\\nIf you like this explanation, please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "codeTag": "Unknown"
            },
            {
                "id": 19123,
                "title": "6-lines-of-code-and-with-o-1-space-in-c",
                "content": "First we transpose the matrix and then reverse every row:\\n \\n   \\n    void rotate(vector<vector<int>>& m) {\\n            int n = m.size();\\n            \\n            for(int i=0; i<n; i++)\\n                for(int j=0; j<i; j++)\\n                    swap(m[i][j], m[j][i]);\\n            \\n            for(int i=0; i<n; i++)\\n                reverse(m[i].begin(), m[i].end());\\n        }",
                "solutionTags": [],
                "code": "First we transpose the matrix and then reverse every row:\\n \\n   \\n    void rotate(vector<vector<int>>& m) {\\n            int n = m.size();\\n            \\n            for(int i=0; i<n; i++)\\n                for(int j=0; j<i; j++)\\n                    swap(m[i][j], m[j][i]);\\n            \\n            for(int i=0; i<n; i++)\\n                reverse(m[i].begin(), m[i].end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1175496,
                "title": "js-python-java-c-easy-4-way-swap-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick here is to realize that cells in our matrix (**M**) can be swapped out in groups of four in a self-contained manner. This will allow us to keep our **space complexity** down to **O(1)**.\\n\\nThe remaining difficulty lies in setting up our **nested for loops** to accomplish the entirety of these four-way swaps. If we consider each ring of data as a larger iteration, we can notice that each successive ring shortens in the length of its side by **2**. This means that we will need to perform this process to a maximum **depth** of **floor(n / 2)** times. We can use floor here because the center cell of an odd-sided matrix will not need to be swapped.\\n\\nFor each ring, we\\'ll need to perform a number of iterations equal to the length of the side minus 1, since we will have already swapped the far corner as our first iteration. As noticed earlier, the length of the side of a ring is shortened by **2** for each layer of depth we\\'ve achieved (**len = n - 2 * i - 1**).\\n\\nInside the nested for loops, we need to perform a four-way swap between the linked cells. In order to save on some processing, we can store the value of the opposite side of **i** (**opp = n - 1 - i**) as that value will be reused many times over.\\n\\n![Visual 1](https://i.imgur.com/LbkYex3.png)\\n\\nOnce the nested loops are finished, **M** has been successfully transformed in-place.\\n\\n - _**Time Complexity: O(N^2)** where N is the length of each side of the matrix_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.4MB** (beats 94% / 92%).\\n```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.2MB** (beats 95% / 84%).\\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.0MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18895,
                "title": "clear-java-solution",
                "content": "    public class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        for (int i=0; i<n/2; i++) \\n            for (int j=i; j<n-i-1; j++) {\\n                int tmp=matrix[i][j];\\n                matrix[i][j]=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=tmp;\\n            }\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        for (int i=0; i<n/2; i++) \\n            for (int j=i; j<n-i-1; j++) {\\n                int tmp=matrix[i][j];\\n                matrix[i][j]=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 247174,
                "title": "easy-java-solution-with-explanation-processing-the-matrix-from-outer-to-inner",
                "content": "The basic idea is that we process the matrix from outer to inner. First we process the outer circle of the matrix, and then the inner circle until the side length of the last inner cirlce is smaller than 2(meaning there is only one center element left). For each circle, we exchange elements clockwise and after we finish one circle, we can continue processing the next.\\n\\nFor example, given a ```4*4``` matrix, we first process the outer circle(side length of 4), then process the inner circle(side length of 2).\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n\\t\\t// l is the side length of the matrix we are processing\\n        for(int l = n; l > 1; l -= 2){\\n\\t\\t    // lo is the start index of the matrix we are processing\\n            int lo = (n-l)/2;\\n\\t\\t\\t// hi is the end index of the matrix we are processing\\n            int hi = lo + l -1;\\n            for(int i = 0; i < l-1; i++){\\n\\t\\t\\t    // move number on one side to the other side clockwise\\n                int temp = matrix[hi-i][lo];\\n                matrix[hi-i][lo] = matrix[hi][hi-i];\\n                matrix[hi][hi-i] = matrix[lo+i][hi];\\n                matrix[lo+i][hi] = matrix[lo][lo+i];\\n                matrix[lo][lo+i] = temp;\\n            }\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```4*4```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n\\t\\t// l is the side length of the matrix we are processing\\n        for(int l = n; l > 1; l -= 2){\\n\\t\\t    // lo is the start index of the matrix we are processing\\n            int lo = (n-l)/2;\\n\\t\\t\\t// hi is the end index of the matrix we are processing\\n            int hi = lo + l -1;\\n            for(int i = 0; i < l-1; i++){\\n\\t\\t\\t    // move number on one side to the other side clockwise\\n                int temp = matrix[hi-i][lo];\\n                matrix[hi-i][lo] = matrix[hi][hi-i];\\n                matrix[hi][hi-i] = matrix[lo+i][hi];\\n                matrix[lo+i][hi] = matrix[lo][lo+i];\\n                matrix[lo][lo+i] = temp;\\n            }\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173266,
                "title": "best-c-2-solution-in-place-matrix-optimized-solution-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Two approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Matrix + Math with Extra space.  TC : O(N^2),  SC : O(N^2).\\n2. Solved using Matrix + Math . In-place.  TC : O(N^2),  SC : O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(N^2), temp matrix space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp[j][n-1-i] = matrix[i][j];\\n\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(N^2), temp matrix space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp[j][n-1-i] = matrix[i][j];\\n\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367514,
                "title": "python-beats-96-with-image-helps-u-understand",
                "content": "![image](https://assets.leetcode.com/users/disinuo/image_1566823308.png)\\n\\n\\nSee an image as multiple **layers**\\n* `int((n+1)/2)` layers in total need to be rotated\\n* The outer most Layer is the 0th, then 1st, ...\\n* Layer i, its sideLength is `(n-2*i)`\\n* Each Layer has `4` sides\\n* Layer i\\'s each side has (sideLength-1) nodes (=`( n-2*i-1) `nodes), as ImageB\\n\\t* Each node has 3 \"brothers\" on the other 3 sides\\n* So we go layer by layer,  iteratively update each node with same color in ImageB\\n```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def rotate_pos_clockwise(i,j):\\n            return j,self.n-1-i\\n        \\n        n = len(matrix)\\n        self.n = n\\n        if(n<=1): return\\n        for i in range((n+1)//2):\\n            for j in range(i,n-i-1):\\n                up_val = matrix[i][j]\\n                i_right,j_right = rotate_pos_clockwise(i,j)\\n                i_bottom,j_bottom = rotate_pos_clockwise(i_right,j_right)\\n                i_left,j_left = rotate_pos_clockwise(i_bottom,j_bottom)\\n                matrix[i][j] = matrix[i_left][j_left]\\n                matrix[i_left][j_left] = matrix[i_bottom][j_bottom]\\n                matrix[i_bottom][j_bottom] = matrix[i_right][j_right]\\n                matrix[i_right][j_right] = up_val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def rotate_pos_clockwise(i,j):\\n            return j,self.n-1-i\\n        \\n        n = len(matrix)\\n        self.n = n\\n        if(n<=1): return\\n        for i in range((n+1)//2):\\n            for j in range(i,n-i-1):\\n                up_val = matrix[i][j]\\n                i_right,j_right = rotate_pos_clockwise(i,j)\\n                i_bottom,j_bottom = rotate_pos_clockwise(i_right,j_right)\\n                i_left,j_left = rotate_pos_clockwise(i_bottom,j_bottom)\\n                matrix[i][j] = matrix[i_left][j_left]\\n                matrix[i_left][j_left] = matrix[i_bottom][j_bottom]\\n                matrix[i_bottom][j_bottom] = matrix[i_right][j_right]\\n                matrix[i_right][j_right] = up_val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 808240,
                "title": "c-100-faster-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        //first we take transpose of the matrix\\n        for(int i = 0; i < n; ++i){\\n            for(int j = i; j < n; ++j){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        //then we take mirror image about the middle vertical line\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        //first we take transpose of the matrix\\n        for(int i = 0; i < n; ++i){\\n            for(int j = i; j < n; ++j){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        //then we take mirror image about the middle vertical line\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18965,
                "title": "comprehensible-python-solution",
                "content": "```\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if i < j:\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for l in matrix:\\n            l.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if i < j:\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for l in matrix:\\n            l.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18888,
                "title": "1-line-in-python",
                "content": "    class Solution(object):\\n        def rotate(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :rtype: void Do not return anything, modify matrix in-place instead.\\n            \"\"\"\\n            matrix[::] = zip(*matrix[::-1])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def rotate(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :rtype: void Do not return anything, modify matrix in-place instead.\\n            \"\"\"\\n            matrix[::] = zip(*matrix[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 2503184,
                "title": "python-easily-understood-faster-than-99-less-than-99",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `math`\\n\\nIn this question, we just need to swap the values of selected elements\\n\\nCase 1: len(matrix) is even\\n![image](https://assets.leetcode.com/users/images/5412682f-9466-4ec3-a267-3d737323aa24_1661836267.2469985.png)\\n\\nCase 2: len(matrix) is odd\\n![image](https://assets.leetcode.com/users/images/187731dc-60cb-4ccf-b606-e8c9fb369856_1661836327.3667648.png)\\n\\nThe start element of each round swaping are in red background.\\n<br/>\\nCode:\\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```\\n\\n**Time Complexity**: `O(n^2)`\\n**Space Complexity**: `O(1)`\\n<br/>\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 159431,
                "title": "javascript-solution-with-example",
                "content": "```\\nconst rotate = function(matrix){\\n  matrix = matrix.reverse()\\n  for(let i in matrix)\\n    for(let j =0; j<i; j++) [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]\\n  return matrix\\n}\\n```\\nHere is the input\\n```\\nlet matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\n```\\nFirst we reverse the matrix\\n```\\n[\\n  [7,8,9],\\n  [4,5,6],\\n  [1,2,3]\\n]\\n```\\nAnd then we transpose the matrix, please notice the nested loop, basically we exchange these two parts:\\nPart1\\n```\\n[\\n  [ , , ],\\n  [4, , ],\\n  [1,2, ]\\n]\\n```\\nPart2\\n```\\n[\\n  [ ,8,9],\\n  [ , ,6],\\n  [ , , ]\\n]\\n```\\nAnd here you go\\n```\\n[\\n  [7,4,1]\\n  [8,5,2]\\n  [9,6,3]\\n]\\n```",
                "solutionTags": [],
                "code": "```\\nconst rotate = function(matrix){\\n  matrix = matrix.reverse()\\n  for(let i in matrix)\\n    for(let j =0; j<i; j++) [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]\\n  return matrix\\n}\\n```\n```\\nlet matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\n```\n```\\n[\\n  [7,8,9],\\n  [4,5,6],\\n  [1,2,3]\\n]\\n```\n```\\n[\\n  [ , , ],\\n  [4, , ],\\n  [1,2, ]\\n]\\n```\n```\\n[\\n  [ ,8,9],\\n  [ , ,6],\\n  [ , , ]\\n]\\n```\n```\\n[\\n  [7,4,1]\\n  [8,5,2]\\n  [9,6,3]\\n]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643965,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n  for(let i=0;i<matrix.length;i++){\\n      for(let j=i+1;j<matrix[i].length;j++){\\n          let temp = matrix[i][j]\\n          matrix[i][j] = matrix[j][i]\\n          matrix[j][i] = temp\\n      }\\n  }\\n  for(let i=0;i<matrix.length;i++){\\n      matrix[i].reverse()\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n  for(let i=0;i<matrix.length;i++){\\n      for(let j=i+1;j<matrix[i].length;j++){\\n          let temp = matrix[i][j]\\n          matrix[i][j] = matrix[j][i]\\n          matrix[j][i] = temp\\n      }\\n  }\\n  for(let i=0;i<matrix.length;i++){\\n      matrix[i].reverse()\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430066,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Transpose the matrix\\n2. Reverse each row\\n```javascript\\nvar rotate = function(matrix) {\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=i;j<matrix[0].length;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=0;j<matrix[0].length/2;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rotate = function(matrix) {\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=i;j<matrix[0].length;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=0;j<matrix[0].length/2;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176736,
                "title": "easy-python-solution-99-runtime",
                "content": "Initially this problem seems easy, then it seems hard, then is seems easy once you figure out the trick. \\n\\nThe trick is...\\n\\n**rotating an image 90 degrees is equal to turning the columns into rows then reversing them**\\n\\n```class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n\\t\\t\\n        n = len(matrix)\\n        \\n\\t\\t# iterate through matrix\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\n\\t\\t\\t    # transpose the matrix, turning rows into columns and vice versa\\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\\n\\t\\t\\t\\n\\t\\t\\t# reverse the resulting rows\\n            matrix[i].reverse()\\n\\n\\n```\\n\\nTop 99% EZ! If you learned something please drop me an upvote and let me know in the comment section if you have any questions.\\n\\nCredits to @shubhamverma2604 for the base soln.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n\\t\\t\\n        n = len(matrix)\\n        \\n\\t\\t# iterate through matrix\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\n\\t\\t\\t    # transpose the matrix, turning rows into columns and vice versa\\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\\n\\t\\t\\t\\n\\t\\t\\t# reverse the resulting rows\\n            matrix[i].reverse()\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19098,
                "title": "a-simple-and-in-place-solution-in-java",
                "content": "    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length <= 1) {\\n            return;\\n        }\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int head = 0;\\n            int tail = n - 1;\\n            while (head < tail) {\\n                int temp = matrix[i][head];\\n                matrix[i][head] = matrix[i][tail];\\n                matrix[i][tail] = temp;\\n                head++;\\n                tail--;\\n            }\\n        }\\n    }\\nFor example, if the matrix is:<br>\\n1 2 3<br>\\n4 5 6<br>\\n7 8 9<br>\\nthen after the first for loop, it becomes: <br>\\n1 4 7<br>\\n2 5 8<br>\\n3 6 9<br>\\nthen after the second for loop, it becomes: <br>\\n7 4 1<br>\\n8 5 2<br>\\n9 6 3<br>",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length <= 1) {\\n            return;\\n        }\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int head = 0;\\n            int tail = n - 1;\\n            while (head < tail) {\\n                int temp = matrix[i][head];\\n                matrix[i][head] = matrix[i][tail];\\n                matrix[i][tail] = temp;\\n                head++;\\n                tail--;\\n            }\\n        }\\n    }\\nFor example, if the matrix is:<br>\\n1 2 3<br>\\n4 5 6<br>\\n7 8 9<br>\\nthen after the first for loop, it becomes: <br>\\n1 4 7<br>\\n2 5 8<br>\\n3 6 9<br>\\nthen after the second for loop, it becomes: <br>\\n7 4 1<br>\\n8 5 2<br>\\n9 6 3<br>",
                "codeTag": "Unknown"
            },
            {
                "id": 3476226,
                "title": "beats-100-explanation-2-steps-only",
                "content": "# Intuition\\nBy observation, we see that the first column of the original matrix is the reverse of the first row of the rotated matrix, so that\\u2019s why we transpose the matrix and then reverse each row, and since we are making changes in the matrix itself space complexity gets reduced to O(1).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2 Step simple approach\\n\\nStep 1: Transpose the matrix. (transposing means changing columns to rows and rows to columns)\\n\\nStep 2: Reverse each row of the matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity: O(N^2) + O(N^2). One O(N*N) is for transposing the matrix and the other is for reversing the matrix.\\n\\n- Space Complexity: O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n            // Step 1 - Find transpose of matrix\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp= matrix[i][j];\\n                matrix[i][j]= matrix[j][i];\\n                matrix[j][i]= temp;\\n            }\\n        }\\n        // step 2 - Reverse each row of matrix \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp= matrix[i][j];\\n                matrix[i][j]= matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j]= temp;\\n\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4002d75c-7ec2-411c-9c5b-dca797ad8505_1683005885.6359031.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n            // Step 1 - Find transpose of matrix\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp= matrix[i][j];\\n                matrix[i][j]= matrix[j][i];\\n                matrix[j][i]= temp;\\n            }\\n        }\\n        // step 2 - Reverse each row of matrix \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp= matrix[i][j];\\n                matrix[i][j]= matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j]= temp;\\n\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401356,
                "title": "rotate-90-clockwise-anti-clockwise-and-rotate-180-degree",
                "content": "```\\nclass Solution {\\n    //1 + 2 = clockwise rotation\\n    //1 + 3 = anti-clockwise rotation\\n    //2 + 3 = 180 degree rotation\\n    int n;\\n    public void rotate(int[][] matrix) {\\n        n = matrix.length;\\n        transpose(matrix);\\n        reverseColumns(matrix);\\n    }\\n    \\n    //1 transpose\\n    private void transpose(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n    \\n    //2 reverse elements in each row\\n    private void reverseColumns(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n - 1 - j];\\n                matrix[i][n - 1 - j] = temp;\\n            }\\n        }\\n    }\\n    \\n    //3 reverse elements in each columns\\n    private void reverseRows(int[][] matrix) {\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n / 2; i++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - i][j];\\n                matrix[n - 1 - i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1 + 2 = clockwise rotation\\n    //1 + 3 = anti-clockwise rotation\\n    //2 + 3 = 180 degree rotation\\n    int n;\\n    public void rotate(int[][] matrix) {\\n        n = matrix.length;\\n        transpose(matrix);\\n        reverseColumns(matrix);\\n    }\\n    \\n    //1 transpose\\n    private void transpose(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n    \\n    //2 reverse elements in each row\\n    private void reverseColumns(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n - 1 - j];\\n                matrix[i][n - 1 - j] = temp;\\n            }\\n        }\\n    }\\n    \\n    //3 reverse elements in each columns\\n    private void reverseRows(int[][] matrix) {\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n / 2; i++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - i][j];\\n                matrix[n - 1 - i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337825,
                "title": "cpp-solution-faster-than-100-solns-better-memory-than-99-95",
                "content": "Transpose the matrix initially, and then reverse rows of the matrix.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\tvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i; j<n; j++)\\n            {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i; j<n; j++)\\n            {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1175659,
                "title": "short-easy-solutions-w-clear-explanation-diagrams",
                "content": "\\u2714\\uFE0F ***Solution - I (Swap Group of 4s)***\\n\\nWe can observe that after 90\\xB0 rotation, we have essentially swapped each group of 4 cells in clockwise direction. The swapping occurs as -\\n\\n<span><p align=center><img src = https://assets.leetcode.com/users/images/873f1aad-ba3e-4177-b9e8-af30a0809202_1619338999.1282618.png height = 400 /></p></span>\\n\\nNow, we can iterate over each row of matrix. For each first half of the rows, we will have `n / 2` groups of 4 cells which need to be swapped cyclically (Note: not `n` groups which will result in 180\\xB0 rotation). We will swap them cyclically till first half rows of the matrix (not all the rows which wrongly rewrite over previous swaps).\\n\\nThe swap groups would be like these -\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/d4bb47e5-f9ad-4f9b-b20e-639bb70bb323_1619339168.4737794.png width = 400 /></p>\\n\\nThe colors denote the collection of group of cells from each row. For eg. The first outer iteration would involve the cells - `[ [1,2,3], [7,7,7], [5,6,7], [1,1,1] ]`. In the inner iteration, each of the cell in one of these subarrays would be swapped clockwise with the corresponding cell in the next subarray\\n\\nThe only difficult thing that remains now is manipulating the variables in our loop to swap the correct group of 4 cells. It can be derived by working out a few examples. I would suggest to try it on your own before seeing the solution below.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Swap Ring-by-Ring)***\\n\\nWe can also choose to swap one ring after another which personally seems more intuitive solution that the first one. Here, we will swap all the cells of outer ring, then the inner ring till the inner-most ring.\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/e2c3496c-9e15-430b-8614-5d83fe9d8eac_1619344342.7277594.png width = 450 /></p>\\n\\n\\nIn the above image, the color denote different rings being swapped one after another, the subscript **`1.x, 2.x, 3.x...`** (where `1<=x<=4`) denotes a group of 4 cells. Each group of 4 cells will be swapped clockwise one after another starting from outermost ring to innermost ring.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```\\n\\n\\n\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n  \\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355993,
                "title": "solution-swift-rotate-image",
                "content": "```swift\\nclass Solution {\\n    func rotate(_ mat: inout [[Int]]) {\\n        let len = mat.count\\n        for i in 0..<len {\\n            for n in i..<len {\\n                let tmp = mat[i][n]\\n                mat[i][n] = mat[n][i]\\n                mat[n][i] = tmp\\n            }\\n            for n in 0..<(len / 2) {\\n                let tmp = mat[i][n], l = len\\n                mat[i][n] = mat[i][l - 1 - n]\\n                mat[i][l - 1 - n] = tmp\\n            }\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var arr = [[1,2,3],[4,5,6],[7,8,9]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[7,4,1],[8,5,2],[9,6,3]])\\n    }\\n    \\n    func test1() {\\n        var arr = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func rotate(_ mat: inout [[Int]]) {\\n        let len = mat.count\\n        for i in 0..<len {\\n            for n in i..<len {\\n                let tmp = mat[i][n]\\n                mat[i][n] = mat[n][i]\\n                mat[n][i] = tmp\\n            }\\n            for n in 0..<(len / 2) {\\n                let tmp = mat[i][n], l = len\\n                mat[i][n] = mat[i][l - 1 - n]\\n                mat[i][l - 1 - n] = tmp\\n            }\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var arr = [[1,2,3],[4,5,6],[7,8,9]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[7,4,1],[8,5,2],[9,6,3]])\\n    }\\n    \\n    func test1() {\\n        var arr = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714590,
                "title": "c-easy-to-understand-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Step 1: Swapping through the diagonal\\n    \\n    1 2 3               1 4 7\\n    4 5 6       ----->  2 5 8\\n    7 8 9               3 6 9\\n    \\n    Step 2: Swapping through the mid column\\n        \\n    1 4 7               7 4 1\\n    2 5 8       ----->  8 5 2\\n    7 8 9               9 6 3\\n    \\n    */\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(int)n/2;j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, please **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Step 1: Swapping through the diagonal\\n    \\n    1 2 3               1 4 7\\n    4 5 6       ----->  2 5 8\\n    7 8 9               3 6 9\\n    \\n    Step 2: Swapping through the mid column\\n        \\n    1 4 7               7 4 1\\n    2 5 8       ----->  8 5 2\\n    7 8 9               9 6 3\\n    \\n    */\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(int)n/2;j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540098,
                "title": "multiple-c-solutions",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Method 01\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++;re--;cs++;ce--;\\n        }\\n    }\\n};\\n```\\n\\n# Method 02\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n# Method 03\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size();\\n        \\n        //First transpose the matrix once!\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n               swap(M[i][j], M[j][i]);\\n            }\\n        }\\n        \\n        //Reverse every column!\\n        for(int i=0; i<n; i++){\\n            reverse(M[i].begin(), M[i].end());\\n        }\\n    }\\n};\\n```\\n---\\n***Please upvote if you find helpful! Thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++;re--;cs++;ce--;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size();\\n        \\n        //First transpose the matrix once!\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n               swap(M[i][j], M[j][i]);\\n            }\\n        }\\n        \\n        //Reverse every column!\\n        for(int i=0; i<n; i++){\\n            reverse(M[i].begin(), M[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175498,
                "title": "rotate-image-js-python-java-c-easy-4-way-swap-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick here is to realize that cells in our matrix (**M**) can be swapped out in groups of four in a self-contained manner. This will allow us to keep our **space complexity** down to **O(1)**.\\n\\nThe remaining difficulty lies in setting up our **nested for loops** to accomplish the entirety of these four-way swaps. If we consider each ring of data as a larger iteration, we can notice that each successive ring shortens in the length of its side by **2**. This means that we will need to perform this process to a maximum **depth** of **floor(n / 2)** times. We can use floor here because the center cell of an odd-sided matrix will not need to be swapped.\\n\\nFor each ring, we\\'ll need to perform a number of iterations equal to the length of the side minus 1, since we will have already swapped the far corner as our first iteration. As noticed earlier, the length of the side of a ring is shortened by **2** for each layer of depth we\\'ve achieved (**len = n - 2 * i - 1**).\\n\\nInside the nested for loops, we need to perform a four-way swap between the linked cells. In order to save on some processing, we can store the value of the opposite side of **i** (**opp = n - 1 - i**) as that value will be reused many times over.\\n\\n![Visual 1](https://i.imgur.com/LbkYex3.png)\\n\\nOnce the nested loops are finished, **M** has been successfully transformed in-place.\\n\\n - _**Time Complexity: O(N^2)** where N is the length of each side of the matrix_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.4MB** (beats 94% / 92%).\\n```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.2MB** (beats 95% / 84%).\\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.0MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513245,
                "title": "java-tc-o-n-2-sc-o-1-two-optimal-ways-of-solving-this-question",
                "content": "**Rotate the matrix on horizontal axis (swap rows) and then transpose to get the result**\\n\\n```java\\n/**\\n * Rotate the matrix on horizontal axis (swap rows) and then transpose to get\\n * the result.\\n *\\n * Time Complexity:\\n * O(N/2) -> for rotating along horizontal axis (swap rows). Only rows reference will be visited not the whole rows.\\n * O(N*N - N) -> Transpose of the matrix. All elements will be visited once except the diagonal. Diagonal has N elements.\\n * \\n * Total time complexity = O(N/2 + N*N - N) ~ O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n *\\n * Note for anticlockwise, change the order. Transpose first and then rotate on\\n * horizontal axis.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        // Rotate the original matrix on horizontal axis. (swap rows)\\n        for (int i = 0; i < n / 2; i++) {\\n            int[] tempRow = matrix[i]; // Only reference will be saved\\n            matrix[i] = matrix[n - i - 1];\\n            matrix[n - i - 1] = tempRow;\\n        }\\n\\n        // Transpose the rotated matrix\\n        for (int i = 0; i < n - 1; i++) { // Selecting a row\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n**In the following solution, find the box starting at the diagonal and then rotate each group of four elements in that box**\\n\\n```java\\n/**\\n * Find the box starting at the diagonal and then rotate each group of four\\n * elements in that box.\\n *\\n * Find each box\\'s boundary. For example:\\n * rowTop,  colRight,   rowBottom,  colLeft\\n * 0,       n-1,        n-1,        0\\n * 1,       n-1-1,      n-1-1,      1\\n * 2,       n-1-2,      n-1-2,      2\\n * ...\\n * i,       n-1-i,      n-1-i,      i\\n *\\n * Now find the indexes and their destination index:\\n * (i, j) will move to (j, n-1-i)\\n * (j, n-1-i) will move to (n-1-i, n-1-j)\\n * (n-1-i, n-1-j) will move to (n-i-j, i)\\n * (n-i-j, i) will move to (i, j)\\n *\\n * Time Complexity: O(N^2) --> All cells are visited once.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            for (int j = i; j < n - 1 - i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\\n                matrix[j][n - 1 - i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Rotate the matrix on horizontal axis (swap rows) and then transpose to get\\n * the result.\\n *\\n * Time Complexity:\\n * O(N/2) -> for rotating along horizontal axis (swap rows). Only rows reference will be visited not the whole rows.\\n * O(N*N - N) -> Transpose of the matrix. All elements will be visited once except the diagonal. Diagonal has N elements.\\n * \\n * Total time complexity = O(N/2 + N*N - N) ~ O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n *\\n * Note for anticlockwise, change the order. Transpose first and then rotate on\\n * horizontal axis.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        // Rotate the original matrix on horizontal axis. (swap rows)\\n        for (int i = 0; i < n / 2; i++) {\\n            int[] tempRow = matrix[i]; // Only reference will be saved\\n            matrix[i] = matrix[n - i - 1];\\n            matrix[n - i - 1] = tempRow;\\n        }\\n\\n        // Transpose the rotated matrix\\n        for (int i = 0; i < n - 1; i++) { // Selecting a row\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Find the box starting at the diagonal and then rotate each group of four\\n * elements in that box.\\n *\\n * Find each box\\'s boundary. For example:\\n * rowTop,  colRight,   rowBottom,  colLeft\\n * 0,       n-1,        n-1,        0\\n * 1,       n-1-1,      n-1-1,      1\\n * 2,       n-1-2,      n-1-2,      2\\n * ...\\n * i,       n-1-i,      n-1-i,      i\\n *\\n * Now find the indexes and their destination index:\\n * (i, j) will move to (j, n-1-i)\\n * (j, n-1-i) will move to (n-1-i, n-1-j)\\n * (n-1-i, n-1-j) will move to (n-i-j, i)\\n * (n-i-j, i) will move to (i, j)\\n *\\n * Time Complexity: O(N^2) --> All cells are visited once.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            for (int j = i; j < n - 1 - i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\\n                matrix[j][n - 1 - i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591169,
                "title": "explained-javascript-solution-with-examples",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n \\n        let n = matrix.length //this is optional \\n        \\n\\t\\t//[1,2,3],>>>>    [1,4,7]\\n\\t\\t//[4,5,6],>>>>    [2,5,8]\\n\\t\\t//[7,8,9]>>>>     [3,6,9]\\n\\t\\t//rows become columns and columns become rows  Look at above ^^ \\n        for(let i = 0; i<n; i++){\\n            for(let j = i; j< n; j++){\\n                let temp = matrix[i][j]\\n                matrix[i][j] = matrix[j][i]\\n                matrix [j][i] = temp\\n            }\\n        }\\n\\t\\t\\n\\t\\t//[1,4,7],>>>>    [7,4,1]\\n\\t\\t//[2,5,8],>>>>    [8,5,2]\\n\\t\\t//[3,6,9]>>>>     [9,6,2]\\n        //swap first and last ele from each row in this case; we swap 1 and 7 and it becomes 7 and 1 Look Above ^^\\n        for(let i = 0; i< n; i++){\\n           for(let j = 0; j<(n/2); j++){\\n                let temp = matrix[i][j]\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n-1-j]\\n\\t\\t\\t    matrix[i][n-1-j] = temp \\n        }\\n    }\\n};\\n\\n\\n//for the second part you can use the reverse method instead of another j loop. \\n//instead of \\n for(let i = 0; i< n; i++){\\n     for(let j = 0; j<(n/2); j++){ // we divide by 2 to get the middle of the array\\n           let temp = matrix[i][j]\\n\\t\\t\\t matrix[i][j] = matrix[i][n-1-j]\\n\\t\\t     matrix[i][n-1-j] = temp \\n        }\\n    }\\n\\n//you can do this:\\nfor(let i = 0; i< n; i++){\\n     matrix[i].reverse() \\n} \\n```\\n\\n\\nTime Complexity : O(n*n), where n is side of array, A single traversal of the matrix is needed.\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n \\n        let n = matrix.length //this is optional \\n        \\n\\t\\t//[1,2,3],>>>>    [1,4,7]\\n\\t\\t//[4,5,6],>>>>    [2,5,8]\\n\\t\\t//[7,8,9]>>>>     [3,6,9]\\n\\t\\t//rows become columns and columns become rows  Look at above ^^ \\n        for(let i = 0; i<n; i++){\\n            for(let j = i; j< n; j++){\\n                let temp = matrix[i][j]\\n                matrix[i][j] = matrix[j][i]\\n                matrix [j][i] = temp\\n            }\\n        }\\n\\t\\t\\n\\t\\t//[1,4,7],>>>>    [7,4,1]\\n\\t\\t//[2,5,8],>>>>    [8,5,2]\\n\\t\\t//[3,6,9]>>>>     [9,6,2]\\n        //swap first and last ele from each row in this case; we swap 1 and 7 and it becomes 7 and 1 Look Above ^^\\n        for(let i = 0; i< n; i++){\\n           for(let j = 0; j<(n/2); j++){\\n                let temp = matrix[i][j]\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n-1-j]\\n\\t\\t\\t    matrix[i][n-1-j] = temp \\n        }\\n    }\\n};\\n\\n\\n//for the second part you can use the reverse method instead of another j loop. \\n//instead of \\n for(let i = 0; i< n; i++){\\n     for(let j = 0; j<(n/2); j++){ // we divide by 2 to get the middle of the array\\n           let temp = matrix[i][j]\\n\\t\\t\\t matrix[i][j] = matrix[i][n-1-j]\\n\\t\\t     matrix[i][n-1-j] = temp \\n        }\\n    }\\n\\n//you can do this:\\nfor(let i = 0; i< n; i++){\\n     matrix[i].reverse() \\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319666,
                "title": "easy-c-solution-o-n-n-time-complexity",
                "content": "1. do inplace transpose on the matrix \\n2. reverse the transposed matrix\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        //transpose of given matrix\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);   \\n           }\\n       }\\n        //reverse of transpose matric\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        //transpose of given matrix\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 19148,
                "title": "c-2ms-solution-o-1-extra-space",
                "content": "    void rotate(int **matrix, int n) {\\n        for (int i=0; i<n/2; ++i)\\n        {\\n            for (int j=i; j<n-1-i; ++j)\\n            {\\n                int z = matrix[i][j];\\n                matrix[i][j] = matrix[n-j-1][i];\\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];\\n                matrix[j][n-i-1] = z;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int **matrix, int n) {\\n        for (int i=0; i<n/2; ++i)\\n        {\\n            for (int j=i; j<n-1-i; ++j)\\n            {\\n                int z = matrix[i][j];\\n                matrix[i][j] = matrix[n-j-1][i];\\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];\\n                matrix[j][n-i-1] = z;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19108,
                "title": "8-lines-java-solution",
                "content": "Hi guys!\\n\\nThe idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp.\\n\\nHere's a pretty concise code below.\\n\\n----------\\n\\n    public class Solution {\\n        public void rotate(int[][] M) {\\n            for (int i = 0; i < (M.length+1)/2; i++) {\\n                for (int j = 0; j < M.length/2; j++) {\\n                    int tmp = M[i][j];\\n                    M[i][j] = M[M.length-j-1][i];\\n                    M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                    M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                    M[j][M.length-i-1] = tmp;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[][] M) {\\n            for (int i = 0; i < (M.length+1)/2; i++) {\\n                for (int j = 0; j < M.length/2; j++) {\\n                    int tmp = M[i][j];\\n                    M[i][j] = M[M.length-j-1][i];\\n                    M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                    M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                    M[j][M.length-i-1] = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2503236,
                "title": "js-javascript-clean-code-with-explanation",
                "content": "```\\n// Reverse on Diagonal and then Reverse Left to Right \\n\\t\\n//\\t1 2 3      1 4 7      7 4 1\\n//\\t4 5 6  =>  2 5 8  =>  8 5 2 \\n//\\t7 8 9      3 6 9      9 6 3\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n\\t\\n\\tfunction transpose() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tconst temp = matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i] = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction rotate() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = 0; j < n / 2; j++) {\\n\\t\\t\\t\\tconst temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n - 1 - j];\\n\\t\\t\\t\\tmatrix[i][n - 1 - j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\ttranspose(matrix);\\n\\trotate(matrix);\\n};\\n```\\n\\n**If you find this solution useful, please upvote. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n// Reverse on Diagonal and then Reverse Left to Right \\n\\t\\n//\\t1 2 3      1 4 7      7 4 1\\n//\\t4 5 6  =>  2 5 8  =>  8 5 2 \\n//\\t7 8 9      3 6 9      9 6 3\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n\\t\\n\\tfunction transpose() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tconst temp = matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i] = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction rotate() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = 0; j < n / 2; j++) {\\n\\t\\t\\t\\tconst temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n - 1 - j];\\n\\t\\t\\t\\tmatrix[i][n - 1 - j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\ttranspose(matrix);\\n\\trotate(matrix);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502471,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nWe break the problem from rotating the whole matrix to *rotating the outside ring around the matirx*.\\nThen we do the same for innner rings formed.\\n* For each ring/circle, we exchange elements clockwise and after we finish one circle, we can continue processing the next.\\n\\nThe process continues till the last ring has either 0 ```[for even length matrix]``` or 1```[for odd length matrix]``` elements left in centre.\\n![image](https://assets.leetcode.com/users/images/aaa68b08-0530-4cd6-9a09-77c618c92f13_1661824549.8225694.png)\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\n    void roro(vector<vector<int>>& matrix, int i, int k, int n){\\n        for (int j=0; j<k; j++){\\n            int t = matrix[i][i+j];\\n            matrix[i][i+j] = matrix[n-i-1-j][i];\\n            matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j];\\n            matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1];\\n            matrix[i+j][n-i-1] = t;\\n        }\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i = 0, n = matrix.size();\\n        int k = n-1;\\n        while (k>0){\\n            roro(matrix,i,k,n);\\n            i++;\\n            k-=2;\\n        }\\n        return;\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def roro(i,k):\\n            for j in range(0,k):\\n                t = matrix[i][i+j]\\n                matrix[i][i+j] = matrix[n-i-1-j][i]\\n                matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j]\\n                matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1]\\n                matrix[i+j][n-i-1] = t\\n        i=0\\n        n=len(matrix)\\n        k=n-1\\n        while k>0:\\n            roro(i,k)\\n            i+=1\\n            k-=2\\n        return\\n```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n![image](https://assets.leetcode.com/users/images/1f7f95f0-aace-4d52-b7b7-30c6145153b3_1661823856.8571475.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```[for even length matrix]```\n```[for odd length matrix]```\n```\\nclass Solution {\\npublic:\\n\\n    void roro(vector<vector<int>>& matrix, int i, int k, int n){\\n        for (int j=0; j<k; j++){\\n            int t = matrix[i][i+j];\\n            matrix[i][i+j] = matrix[n-i-1-j][i];\\n            matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j];\\n            matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1];\\n            matrix[i+j][n-i-1] = t;\\n        }\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i = 0, n = matrix.size();\\n        int k = n-1;\\n        while (k>0){\\n            roro(matrix,i,k,n);\\n            i++;\\n            k-=2;\\n        }\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def roro(i,k):\\n            for j in range(0,k):\\n                t = matrix[i][i+j]\\n                matrix[i][i+j] = matrix[n-i-1-j][i]\\n                matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j]\\n                matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1]\\n                matrix[i+j][n-i-1] = t\\n        i=0\\n        n=len(matrix)\\n        k=n-1\\n        while k>0:\\n            roro(i,k)\\n            i+=1\\n            k-=2\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763842,
                "title": "best-solution-in-java-beats-100-java-solutions-in-run-time-and-99-66-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet imagine it like a Square Matrix where we can apply Transpose Theory\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nat very first reverse the column for clockwise rotation\\n\\nthen simply apply transpose of the matrix\\n\\nExtra\\n(Note :- reverse the row for anti-clockwise rotation)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        //Column Reverse\\n        for(int i = 0; i < n; i++){\\n            int a = 0;\\n            int b = n-1;\\n            while(a <= b){\\n               int temp = matrix[a][i];\\n                matrix[a][i] = matrix[b][i];\\n                 matrix[b][i] = temp;\\n                 a++;\\n                 b--;\\n            }\\n            \\n        }\\n           \\n        //Transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j =i+1; j< n; j++){\\n                int temp =  matrix[i][j];\\n                 matrix[i][j] =  matrix[j][i];;\\n                 matrix[j][i] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        //Column Reverse\\n        for(int i = 0; i < n; i++){\\n            int a = 0;\\n            int b = n-1;\\n            while(a <= b){\\n               int temp = matrix[a][i];\\n                matrix[a][i] = matrix[b][i];\\n                 matrix[b][i] = temp;\\n                 a++;\\n                 b--;\\n            }\\n            \\n        }\\n           \\n        //Transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j =i+1; j< n; j++){\\n                int temp =  matrix[i][j];\\n                 matrix[i][j] =  matrix[j][i];;\\n                 matrix[j][i] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519805,
                "title": "c-java-python-javascript-2-approach-brute-and-optimized-fully-explained",
                "content": "# Intuition\\nThe task is to rotate the given matrix by 90 degrees clockwise. We can achieve this by performing two steps: transposing the matrix and then reversing each row of the transposed matrix.\\n\\n# Approach\\n1. Transposing the matrix:\\n   - Iterate over the rows of the matrix from 0 to n-1.\\n   - For each row, iterate over the columns from 0 to i (exclusive).\\n   - Swap the element at position (i, j) with the element at position (j, i). This effectively transposes the matrix in-place.\\n\\n2. Reversing each row of the transposed matrix:\\n   - Iterate over each row of the matrix.\\n   - Use the `reverse` function to reverse the elements in that row. This reverses each row in-place.\\n\\n# Complexity\\n#### 1. Brute Force\\n- Time Complexity: O(n^2), where n is the size of the matrix.\\n- Space Complexity: O(n^2)\\n#### 2. Optimal Approach\\n- Time complexity: O(n^2), where n is the size of the matrix, as we iterate over each element in the matrix twice (once for transposing and once for reversing).\\n- Space complexity: O(1) as we perform the operations in-place without using any additional space.\\n\\n**Brute Force Approach:**\\n\\nC++:\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector < vector < int >> rotated(n, vector < int > (n, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        matrix=rotated;\\n    }\\n};\\n```\\nJava:\\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] rotated = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        // Copy rotated matrix back to the original matrix\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        rotated = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                rotated[j][n - i - 1] = matrix[i][j]\\n        # Copy rotated matrix back to the original matrix\\n        for i in range(n):\\n            matrix[i] = rotated[i][:]\\n```\\n\\nJavaScript:\\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    const rotated = Array(n).fill(null).map(() => Array(n).fill(0));\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n        }\\n    }\\n    // Copy rotated matrix back to the original matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = rotated[i].slice();\\n    }\\n}\\n```\\n\\n**Optimal Approach:**\\n\\nC++:\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        //reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\nJava:\\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // Reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        # Transposing the matrix\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        # Reversing each row of the matrix\\n        for i in range(n):\\n            left = 0\\n            right = n - 1\\n            while left < right:\\n                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\\n                left += 1\\n                right -= 1\\n```\\n\\nJavaScript:\\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    \\n    // Transposing the matrix\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    // Reversing each row of the matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i].reverse();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector < vector < int >> rotated(n, vector < int > (n, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        matrix=rotated;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] rotated = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        // Copy rotated matrix back to the original matrix\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        rotated = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                rotated[j][n - i - 1] = matrix[i][j]\\n        # Copy rotated matrix back to the original matrix\\n        for i in range(n):\\n            matrix[i] = rotated[i][:]\\n```\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    const rotated = Array(n).fill(null).map(() => Array(n).fill(0));\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n        }\\n    }\\n    // Copy rotated matrix back to the original matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = rotated[i].slice();\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        //reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // Reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        # Transposing the matrix\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        # Reversing each row of the matrix\\n        for i in range(n):\\n            left = 0\\n            right = n - 1\\n            while left < right:\\n                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\\n                left += 1\\n                right -= 1\\n```\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    \\n    // Transposing the matrix\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    // Reversing each row of the matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i].reverse();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502288,
                "title": "daily-leetcoding-challenge-august-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-image/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Rotate Groups of Four Cells\n\n  \n**Approach 2:** Reverse on Diagonal and then Reverse Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-image/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1965396,
                "title": "my-c-solution",
                "content": "So I first drew a 3x3 matrix to see how the elements were shifting as the image was rotated. As I drew, I saw the a pattern where we could first transpose the matrix (swap elements along diagonal) and then just mirror the obtained matrix to get the final matrix. We could apply it in reverse order too, only thing which would change is that instead of swapping across leading diagonal (from top left to bottom right), we would have to first mirror the image and then swap elements along the second diagonal (from top right to bottom left).\\n\\nMy code is as follows:\\n```\\nclass Solution {\\npublic:\\n    void swap(int& a, int& b)\\n    {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n        return;\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix)\\n    {\\n        if (matrix.size() <= 1)\\n            return;\\n        for (int i = 0; i <= matrix.size() - 2; ++i)\\n        {\\n            for (int j = i+1; j <= matrix.size() - 1; ++j)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.size(); ++i)\\n        {\\n            int low = 0;\\n            int high = matrix.size() - 1;\\n            while (low < high)\\n            {\\n                swap(matrix[i][low], matrix[i][high]);\\n                ++low;\\n                --high;\\n            }\\n        }\\n        return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(int& a, int& b)\\n    {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n        return;\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix)\\n    {\\n        if (matrix.size() <= 1)\\n            return;\\n        for (int i = 0; i <= matrix.size() - 2; ++i)\\n        {\\n            for (int j = i+1; j <= matrix.size() - 1; ++j)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.size(); ++i)\\n        {\\n            int low = 0;\\n            int high = matrix.size() - 1;\\n            while (low < high)\\n            {\\n                swap(matrix[i][low], matrix[i][high]);\\n                ++low;\\n                --high;\\n            }\\n        }\\n        return;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298719,
                "title": "a-java-one-pass-solution-with-detailed-explanation",
                "content": "The solution is from:\\n\\nhttps://leetcode.com/problems/rotate-image/discuss/18895/Clear-Java-solution\\n\\nThe basic idea is:\\n\\n1. Separate the matrix to multiple cycles, go through the cycles from outer to inner\\n2. For each cycle (with 4 arrays connected), go through the top array\\n3. For each elements of the array, calculate the new position and move the value. Note that for each element, we need to move the value for 4 times (for the 4 arrays).\\n\\nThe code:\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return;\\n        int n = matrix.length;\\n        for(int i = 0;i < n / 2;i++) {\\n            for(int j = i;j < n - i - 1;j++) {\\n                int tmp = matrix[i][j];\\n                matrix[i][j] = matrix[n - j - 1][i];\\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\\n                matrix[j][n - i - 1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSome explanations:\\n\\n1. Why do we use (n / 2) as the count of i?\\n\\ni means the count of all the cycles. Since the length of the matrix is n, obviously we have (n / 2) cycles.\\n\\n2. Why do we use i and (n - i - 1) as the range of j?\\n\\nj means the count of the elements of the top array of current cycle. Since the cycle becomes smaller and smaller according to the increasing of i, the start of j is i. Since the cycle is always symmetrical, the end of j is (n - i - 1). Note that we use  (n - i - 1) but not (n - i) because we need to ignore the latest one of each line (which should be handled as first one in next loop).\\n\\n3. How to understand the calculation of the positions in the inner loop?\\n\\nSince the cycle is always symmetrical, the rule is:\\n\\nFor any assignment expression, the positions A[x1][y1] and B[x2][y2] between the \"=\" operator must be:\\n\\n1. **x1 == y2**\\n2. **y1 and x2 are symmetrical**\\n\\ne.g.\\n\\n```\\nmatrix[i][j] = matrix[n - j - 1][i];\\n```\\n\\nBoth x1 and y2 are equal (i), and y1(j) and x2(n - j - 1) are symmetrical. The same for other assignments.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return;\\n        int n = matrix.length;\\n        for(int i = 0;i < n / 2;i++) {\\n            for(int j = i;j < n - i - 1;j++) {\\n                int tmp = matrix[i][j];\\n                matrix[i][j] = matrix[n - j - 1][i];\\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\\n                matrix[j][n - i - 1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nmatrix[i][j] = matrix[n - j - 1][i];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18948,
                "title": "c-code-with-more-detail-explaination",
                "content": "    class Solution {\\n    public:\\n        void rotate(vector<vector<int>>& matrix) {\\n            /**\\n             * clock rotate : rotate[j][n-1-i]=a[i][j]\\n             **/\\n            reverse(matrix.begin(), matrix.end());   /** a[n-1-i][j]=a[i][j] **/\\n            for(int i=0; i<matrix.size(); i++){   /** a[i][j]=a[j][i] **/\\n                for(int j=i+1; j<matrix[i].size(); j++)\\n                    swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(vector<vector<int>>& matrix) {\\n            /**\\n             * clock rotate : rotate[j][n-1-i]=a[i][j]\\n             **/\\n            reverse(matrix.begin(), matrix.end());   /** a[n-1-i][j]=a[i][j] **/\\n            for(int i=0; i<matrix.size(); i++){   /** a[i][j]=a[j][i] **/\\n                for(int j=i+1; j<matrix[i].size(); j++)\\n                    swap(matrix[i][j], matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1449492,
                "title": "rotate-matrix-clockwise-or-anti-clockwise-100-faster-c",
                "content": "```\\n\\n// code to rotate the matrix to clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }  \\n\\t\\t\\n\\t\\t// OR code for transpose\\n\\t\\t//for (int i = 0; i < n; i++)\\n\\t\\t\\t// for (int j = i; j < n; j++)\\n\\t\\t\\t\\t //swap(matrix[i][j], matrix[j][i]);\\n        \\n        // row reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[i][j], matrix[i][k]);\\n                k--;\\n            }\\n        }\\n        \\n        // or row reverse code \\n        \\n        // for(int i = 0; i<n; i++){\\n        //     reverse(matrix[i].begin(), matrix[i].end());\\n        // } \\n    }\\n};\\n//  please upvote if u like\\n```\\n\\n```\\n// code to rotate the matrix to anti-clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        // column reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[j][i], matrix[k][i]);\\n                k--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n//  please upvote if u like\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\n// code to rotate the matrix to clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }  \\n\\t\\t\\n\\t\\t// OR code for transpose\\n\\t\\t//for (int i = 0; i < n; i++)\\n\\t\\t\\t// for (int j = i; j < n; j++)\\n\\t\\t\\t\\t //swap(matrix[i][j], matrix[j][i]);\\n        \\n        // row reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[i][j], matrix[i][k]);\\n                k--;\\n            }\\n        }\\n        \\n        // or row reverse code \\n        \\n        // for(int i = 0; i<n; i++){\\n        //     reverse(matrix[i].begin(), matrix[i].end());\\n        // } \\n    }\\n};\\n//  please upvote if u like\\n```\n```\\n// code to rotate the matrix to anti-clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        // column reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[j][i], matrix[k][i]);\\n                k--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n//  please upvote if u like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175596,
                "title": "pyhton-simple-solution-explained",
                "content": "The idea behind if all elements can be divided into groups of `4` and swapped in loops. There are `2` slightly different  cases we need to handle: case of odd `n`, for example:\\n`1,2,3     ->        7,4,1`\\n\\n`4,5,6     ->    8,5,2`\\n\\n`7,8,9     ->    9,6,3`\\n\\nIn this case we need to change groups `1 -> 7 -> 9 - > 3 -> 1`, `2 -> 4 -> 8 -> 6 -> 2` and `5 -> 5`. \\n\\nIn the case of even `n`, for example:\\n\\n`05,01,09,11 -> 15,13,02,05`\\n\\n`02,04,08,10 -> 14,03,04,01`\\n\\n`13,03,06,07 -> 12,06,08,09`\\n\\n`15,14,12,16 -> 16,07,10,11`\\n\\nWe need to change `4` groups of numbers `05 -> 15 -> 16 -> 11 -> 05`, `01 -> 13 -> 12 -> 10 -> 01`, `02 -> 14 -> 07 -> 09 -> 02`, `04 -> 03 -> 06 -> 08 -> 04`.\\n\\nActually, these two cases can be written in one condition if we carefully choose ranges in which we iterate.\\n\\n#### Complexity\\nTime complexity will be `O(n^2)`, space complexity is `O(1)`, because we do not use any additional space.\\n\\n```\\nclass Solution:\\n    def rotate(self, M):\\n        n = len(M) - 1\\n        for i in range((n+2)//2):\\n            for j in range((n+1)//2):\\n                M[i][j], M[j][n-i], M[n-i][n-j], M[n-j][i] = M[n-j][i], M[i][j], M[j][n-i], M[n-i][n-j]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, M):\\n        n = len(M) - 1\\n        for i in range((n+2)//2):\\n            for j in range((n+1)//2):\\n                M[i][j], M[j][n-i], M[n-i][n-j], M[n-j][i] = M[n-j][i], M[i][j], M[j][n-i], M[n-i][n-j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830030,
                "title": "small-python-solution",
                "content": "For understanding through an analogy, we can this of a point in cartesian co-ordinates (x, y). When this point is rotated by 90 degrees clockwise about the origin, it\\'s new co-ordinates become (y, -x). You can derive this by using the rotation matrix. the interesting is to note is that you can write this rotation matrix ([0 1][-1 0]) as the multiplication of two matrices ([0 1][1 0]) and ([-1 0][0 1]). So, from here you can see that you need to make a mirror of all the points about x axis first and then interchange the co-ordinates for all the points. In matrix terms, the first would be reversing the rows and second would be to do the transpose.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i, len(matrix)):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i, len(matrix)):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506228,
                "title": "golang-easy-to-understand-faster-than-100",
                "content": "**Approach** :-\\n\\n- Find the transpose of the matrix\\n- Flip the transpose to get the final result\\n\\nfinding the transpose of a square matrix is pretty easy, just swap the value of the i, j with value at j, i and vice verse for every i,j.\\nExample for i = 1 and j = 2\\nmatrix[1][2] and matrix[2][1] will swap their values.\\nIt\\'s like flipping the matrix across it\\'s diagonal.\\nSo something like \\n||||\\n| --- | --- | --- |\\n| 1 | 2 | 3|\\n| 4 | 5 | 6 |\\n| 7 | 8 | 9 |\\n\\nbecomes \\n||||\\n| --- | --- | --- |\\n| 1 | 4 | 7|\\n| 2 | 5 | 8 |\\n| 3 | 6 | 9 |\\n\\nFor flipping the matrix, we can use two pointer technique to was values across each end for every row.\\n|  |  | |\\n| --- | --- | --- |\\n| 7 | 4 | 1|\\n| 8 | 5 | 2 |\\n| 9 | 6 | 3 |\\n\\nWe can combine both the process i.e. for each row, we will first find it\\'s transpose and then flip it instantly.\\n```\\nfunc rotate(matrix [][]int)  {\\n    n, m := len(matrix), len(matrix[0])\\n    for i:= 0; i < n; i++ {\\n        // Transpose of row\\n        for j := i; j < m; j++ {\\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        }\\n        // flipping the row\\n        for j, k := 0, m-1; j < k; j, k = j+1, k-1{\\n            matrix[i][j], matrix[i][k] = matrix[i][k], matrix[i][j]\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity** - (n^2)\\n**Space Complexity** - (1)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(matrix [][]int)  {\\n    n, m := len(matrix), len(matrix[0])\\n    for i:= 0; i < n; i++ {\\n        // Transpose of row\\n        for j := i; j < m; j++ {\\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        }\\n        // flipping the row\\n        for j, k := 0, m-1; j < k; j, k = j+1, k-1{\\n            matrix[i][j], matrix[i][k] = matrix[i][k], matrix[i][j]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201238,
                "title": "c-simple-explained-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n* Transpose of the matrix => swap row elements to column and vica versa.\\n\\n* Now to the traversed array, reverse each row of the matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // Step1 -> transpose the matrix\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        // Step2 -> reverse the row\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```\\nTC -> `O(n^n)`\\nSC -> `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // Step1 -> transpose the matrix\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        // Step2 -> reverse the row\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503306,
                "title": "c-solution-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<vector<int>> grid=matrix;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              matrix[j][n-1-i]=grid[i][j]; //if u will observe u can see matrix following the pattern  [j][n-1-i]=[i][j]\\n            }\\n        }\\n        \\n    }\\n};\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.\\n// Memory Usage: 7.3 MB, less than 33.50% of C++ online submissions for Rotate Image.\\n\\n\\n\\n// without using extra space\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                \\n               swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n        \\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<vector<int>> grid=matrix;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              matrix[j][n-1-i]=grid[i][j]; //if u will observe u can see matrix following the pattern  [j][n-1-i]=[i][j]\\n            }\\n        }\\n        \\n    }\\n};\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.\\n// Memory Usage: 7.3 MB, less than 33.50% of C++ online submissions for Rotate Image.\\n\\n\\n\\n// without using extra space\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                \\n               swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n        \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502920,
                "title": "simple-clean-code-c",
                "content": "***Rotation by 90\\' clockwise =  Transpose + reverse every row***\\n\\n```\\n   for(int i =0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){      // j starts from i so that positions aren\\'t swapped twice\\n             swap(matrix[i][j],matrix[j][i]);       // we are just traversing the upper matrix and the diagonal\\n            }\\n        }\\n        for(int i =0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   for(int i =0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){      // j starts from i so that positions aren\\'t swapped twice\\n             swap(matrix[i][j],matrix[j][i]);       // we are just traversing the upper matrix and the diagonal\\n            }\\n        }\\n        for(int i =0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502753,
                "title": "clean-and-minimal-python-solution",
                "content": "```python\\nclass Solution:\\n    def rotate(self, arr: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        arr.reverse()\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rotate(self, arr: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        arr.reverse()\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909427,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737976,
                "title": "python-visual-explanation-complexity-analysis",
                "content": "I hope my graphic helps you to understand how transposing + folding = rotating the matrix :)\\n\\nTime Complexity:\\nO(r * c) (transpose) + O(r * c) (rotate) = 2O(r * c) => **O(r * c)**\\nwhere r is number of row, and c is number of col\\n\\nSpace Complexity:\\n**O(1)** because you are doing in place :)\\n\\n![image](https://assets.leetcode.com/users/images/355c441b-70a6-41ac-bee7-774cf98aee93_1643766894.2391593.png)\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        rLen, cLen = len(matrix), len(matrix[0])\\n        \\n        #Transposing\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                if r > c:\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n\\n        #Folding\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                center = cLen // 2\\n                if c < center:\\n                    matrix[r][c], matrix[r][cLen - c - 1] = matrix[r][cLen - c - 1], matrix[r][c]\\n        \\n        return matrix\\n```\\n\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        rLen, cLen = len(matrix), len(matrix[0])\\n        \\n        #Transposing\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                if r > c:\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n\\n        #Folding\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                center = cLen // 2\\n                if c < center:\\n                    matrix[r][c], matrix[r][cLen - c - 1] = matrix[r][cLen - c - 1], matrix[r][c]\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674827,
                "title": "c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we took 4pointers: ***row start(rs), row end(re), column start(cs), column end(ce).***\\n- Every time while loop runs, it takes the outer border elements to their fixed position.\\n- Then we move to inner borders.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- This solution is more simple than the previous one.\\n- Here we transpose the matrix, it will make every row element to column element.\\n- Then we simply reverse every row.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++; re--; cs++; ce--;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++; re--; cs++; ce--;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175774,
                "title": "java-easy-transpose-readable-solution",
                "content": "Generally in rotate Question the key thing is to take transpose first.\\n\\nAfter taking transpose\\nIf they have told you to rotate in:\\n1. **Anti Clockwise:** `Reverse the rows`\\n2. **Clockwise :** `Reverse the columns`\\n\\nAlways draw diagram for better clearity after taking transpose how my matrix will look then you will easily able to figure out.\\n```\\nMatrix                       Transpose                            Result\\n1 2 3                          1 4 7                               7  4  1\\n4 5 6                          2 5 8                               8  5  2\\n7 8 9                          3 6 9                               9  6  3\\n```\\n\\n**CODE:**\\n```\\n    public void rotate(int[][] matrix) {\\n        \\n        //1.Transpose\\n        for(int r=0;r<matrix.length;r++){\\n            for(int c=0;c<r;c++){\\n               int temp=martrix[r][c];\\n               matrix[r][c]=matrix[c][r];\\n               matrix[c][r]=temp;\\n            }\\n        }\\n        \\n       \\n        int fc=0; // fc: first column\\n        int lc=matrix[0].length-1; //lc : last column\\n        \\n        while(fc<lc){\\n           //swap first column with last column\\n            for(int r=0;r<matrix.length;r++){\\n                 int temp=matrix[r][fc];\\n                 matrix[r][fc]=matrix[r][lc];\\n                 matrix[r][lc]=temp;\\n            }\\n            \\n            fc++;\\n            lc--;\\n        }\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(1)`\\n\\n**Note:** To take Transpose Matrix should be square matrix (n * n). So confirm to your interview that matrix is square before solving. Else you may get Rejection even after solving problem is most optimsed way*\\n#Don\\'t assume anything by yourself in interview\\n\\nPlease **Upvote** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMatrix                       Transpose                            Result\\n1 2 3                          1 4 7                               7  4  1\\n4 5 6                          2 5 8                               8  5  2\\n7 8 9                          3 6 9                               9  6  3\\n```\n```\\n    public void rotate(int[][] matrix) {\\n        \\n        //1.Transpose\\n        for(int r=0;r<matrix.length;r++){\\n            for(int c=0;c<r;c++){\\n               int temp=martrix[r][c];\\n               matrix[r][c]=matrix[c][r];\\n               matrix[c][r]=temp;\\n            }\\n        }\\n        \\n       \\n        int fc=0; // fc: first column\\n        int lc=matrix[0].length-1; //lc : last column\\n        \\n        while(fc<lc){\\n           //swap first column with last column\\n            for(int r=0;r<matrix.length;r++){\\n                 int temp=matrix[r][fc];\\n                 matrix[r][fc]=matrix[r][lc];\\n                 matrix[r][lc]=temp;\\n            }\\n            \\n            fc++;\\n            lc--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175641,
                "title": "rotate-image-easy-solution-w-clear-explanation-diagrams",
                "content": "\\u2714\\uFE0F ***Solution - I (Swap Group of 4s)***\\n\\nWe can observe that after 90\\xB0 rotation, we have essentially swapped each group of 4 cells in clockwise direction. The swapping occurs as -\\n\\n<span><p align=center><img src = https://assets.leetcode.com/users/images/873f1aad-ba3e-4177-b9e8-af30a0809202_1619338999.1282618.png height = 400 /></p></span>\\n\\nNow, we can iterate over each row of matrix. For each first half of the rows, we will have `n / 2` groups of 4 cells which need to be swapped cyclically (Note: not `n` groups which will result in 180\\xB0 rotation). We will swap them cyclically till first half rows of the matrix (not all the rows which wrongly rewrite over previous swaps).\\n\\nThe swap groups would be like these -\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/d4bb47e5-f9ad-4f9b-b20e-639bb70bb323_1619339168.4737794.png width = 400 /></p>\\n\\nThe colors denote the collection of group of cells from each row. For eg. The first outer iteration would involve the cells - `[ [1,2,3], [7,7,7], [5,6,7], [1,1,1] ]`. In the inner iteration, each of the cell in one of these subarrays would be swapped clockwise with the corresponding cell in the next subarray\\n\\nThe only difficult thing that remains now is manipulating the variables in our loop to swap the correct group of 4 cells. It can be derived by working out a few examples. I would suggest to try it on your own before seeing the solution below.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Swap Ring-by-Ring)***\\n\\nWe can also choose to swap one ring after another which personally seems more intuitive solution that the first one. Here, we will swap all the cells of outer ring, then the inner ring till the inner-most ring.\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/e2c3496c-9e15-430b-8614-5d83fe9d8eac_1619344342.7277594.png width = 450 /></p>\\n\\n\\nIn the above image, the color denote different rings being swapped one after another, the subscript **`1.x, 2.x, 3.x...`** (where `1<=x<=4`) denotes a group of 4 cells. Each group of 4 cells will be swapped clockwise one after another starting from outermost ring to innermost ring.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```\\n\\n\\n\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n  \\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303940,
                "title": "c-faster-than-100-00",
                "content": "```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n\\tint c=0;\\n\\tint n=matrixSize-1;\\n\\n\\tfor( c=0 ; c <= n ; c++, n=--) {\\n\\t\\tfor( int i=c, j=n ; i<n; i++, j--) {\\n\\t\\t   \\tint tmp = matrix[c][j];\\n\\t\\t\\tmatrix[c][j] = matrix[i][c];\\n\\t\\t\\tmatrix[i][c] = matrix[n][i];\\n\\t\\t\\tmatrix[n][i] = matrix[j][n];\\n\\t\\t\\tmatrix[j][n] = tmp;\\n     \\t}\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n\\tint c=0;\\n\\tint n=matrixSize-1;\\n\\n\\tfor( c=0 ; c <= n ; c++, n=--) {\\n\\t\\tfor( int i=c, j=n ; i<n; i++, j--) {\\n\\t\\t   \\tint tmp = matrix[c][j];\\n\\t\\t\\tmatrix[c][j] = matrix[i][c];\\n\\t\\t\\tmatrix[i][c] = matrix[n][i];\\n\\t\\t\\tmatrix[n][i] = matrix[j][n];\\n\\t\\t\\tmatrix[j][n] = tmp;\\n     \\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2838216,
                "title": "very-simple-java-solution-with-explanation-0ms-faster",
                "content": "*Common way to rotate a 2D matrix in 90 degree*\\n1. First transpose the given 2D matrix. **Transpose of a matrix is found by interchanging its rows into columns or columns into rows.**\\n ![image](https://assets.leetcode.com/users/images/03f41759-b146-4ae6-a47e-90f616e29816_1669096889.8690052.png)### [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\\n2. Now we are simple reversing the each row. \\n\\n\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // to rotate the matrix = transpose + reverse\\n        \\n        //first we are transposing the 2D array\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=i; j<matrix[i].length; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //here we are reversing each row\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\n**If you like the solution please upvote and comment. If there is any doubt please feel free to ask in the comment section I will respond to it.**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // to rotate the matrix = transpose + reverse\\n        \\n        //first we are transposing the 2D array\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=i; j<matrix[i].length; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //here we are reversing each row\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19168,
                "title": "share-my-inplace-solution",
                "content": "        class Solution {\\n    public:\\n        //fold for the middle, fold for the diagnal\\n        void rotate(vector<vector<int> > &matrix) {\\n            //find middle\\n            int mid = matrix.size()/2;\\n            int n = matrix.size();\\n            //swap, i swap with matrix.size()-1-i\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < n; j++){\\n                    swap(matrix[i][j], matrix[n-1-i][j]);\\n                }\\n            }\\n            //swap, i,j swap with j,i\\n            for(int i = 0; i < n; i++){\\n                for(int j = i; j < n; j++){\\n                    swap(matrix[i][j], matrix[j][i]);\\n                }\\n            }\\n        }\\n    };\\n\\nFold matrix once to the middle line. Fold matrix one more time along the diagonal line.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        //fold for the middle, fold for the diagnal\\n        void rotate(vector<vector<int> > &matrix) {\\n            //find middle\\n            int mid = matrix.size()/2;\\n            int n = matrix.size();\\n            //swap, i swap with matrix.size()-1-i\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < n; j++){\\n                    swap(matrix[i][j], matrix[n-1-i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3913807,
                "title": "1-line-python-code-beats-97-75-34-ms-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasically what we are doing is rotating the given array.There are many ways to do it since we are using pytohn i used a function called zip which is an inbuilt python function.\\n\\nzip basically takes multiple arguments and groups together the each of the elemnents from the arguments into a tuple i.e, the first elements of each argument are groped into a tuple then the next and so on.\\n\\nthen we use ```\\'*\\'```a variable argument passing operator(the name might not be acurate).\\nthis operator gives out one argument at a time from a group of arguments(int his case lists from a 2d list).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we need to modify the elements of the array directly i.e, we need to change the data in the location pointed by the array.I am using slicing to do the job for me.\\n\\nThen we pass the lists in given 2d list ```matrix``` to the ```zip``` function in reverse order since we dont want to get a transpose,we want to rotate it clock-wise.\\n\\nLastly the resultant tuple returned by zip is given to ```list()``` function.   \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix[:]=list(zip(*matrix[::-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\'*\\'```\n```matrix```\n```zip```\n```list()```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix[:]=list(zip(*matrix[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503830,
                "title": "easy-java-soluion-100-faster",
                "content": "Basic swapping and re-arrangement.. Do a dry run on code to understand the operations!!\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < (n + 1) / 2; i ++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n                matrix[j][n - 1 - i] = matrix[i][j];\\n                matrix[i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < (n + 1) / 2; i ++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n                matrix[j][n - 1 - i] = matrix[i][j];\\n                matrix[i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852607,
                "title": "easy-solution-using-constant-space-beats-100-c",
                "content": "# Intuition\\nLet\\'s start swapping the elements.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will swap the elements 3 times anti-clockwise.\\n\\n1  2  3\\n4  5  6\\n7  8  9\\n\\nswap 1 with 7,\\n\\n7  2  3\\n4  5  6\\n1  8  9\\n\\nswap 1 with 9,\\n\\n7  2  3\\n4  5  6\\n9  8  1\\n\\nswap 1 with 3,\\n\\n7  2  1\\n4  5  6\\n9  8  3\\n\\nWe can see that the corners of this matrix are rotated simiarily we will rotate all other elements.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // If you like the solution PLS UPVOTE\\n        int s=0;\\n        int e=matrix.size()-1;\\n         while(s<e){\\n            for(int i=0;i<e-s;i++){\\n                swap(matrix[s][s+i],matrix[e-i][s]);\\n                swap(matrix[e-i][s],matrix[e][e-i]);\\n                swap(matrix[e][e-i],matrix[s+i][e]);\\n             }\\n            s++;\\n            e--;\\n  \\n        }\\n        \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/34c73989-5abd-4c3f-8124-8b74daf153c9_1691247839.2683234.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // If you like the solution PLS UPVOTE\\n        int s=0;\\n        int e=matrix.size()-1;\\n         while(s<e){\\n            for(int i=0;i<e-s;i++){\\n                swap(matrix[s][s+i],matrix[e-i][s]);\\n                swap(matrix[e-i][s],matrix[e][e-i]);\\n                swap(matrix[e][e-i],matrix[s+i][e]);\\n             }\\n            s++;\\n            e--;\\n  \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503263,
                "title": "awesome-logic-with-top-bottom-left-right",
                "content": "# Python3 Solution\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        left,right=0,len(matrix)-1\\n        while left<right:\\n            for i in range(right-left):\\n                top,bottom=left,right\\n                topleft=matrix[top][left+i]\\n                matrix[top][left+i]=matrix[bottom-i][left]\\n                matrix[bottom-i][left]=matrix[bottom][right-i]\\n                matrix[bottom][right-i]=matrix[top+i][right]\\n                matrix[top+i][right]=topleft\\n            left+=1\\n            right-=1\\n        return matrix\\n ````\\n # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        left,right=0,len(matrix)-1\\n        while left<right:\\n            for i in range(right-left):\\n                top,bottom=left,right\\n                topleft=matrix[top][left+i]\\n                matrix[top][left+i]=matrix[bottom-i][left]\\n                matrix[bottom-i][left]=matrix[bottom][right-i]\\n                matrix[bottom][right-i]=matrix[top+i][right]\\n                matrix[top+i][right]=topleft\\n            left+=1\\n            right-=1\\n        return matrix\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3150138,
                "title": "solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We swap the arrays in the matrix.\\n2. Then reverse the matrix.\\n3. We have taken the anti-clockwise approach.\\n\\n# Complexity\\n- Time complexity:**100%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:**94.39%**\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n         int l=0,s=m-1;\\n       while(l<s){\\n          int[] temp2=matrix[l];\\n          matrix[l]=matrix[s];\\n          matrix[s]=temp2;\\n          l++;\\n          s--;\\n       }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<m;j++){\\n                int temp=  matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                  matrix[j][i]=temp;\\n            }\\n        }\\n      \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n         int l=0,s=m-1;\\n       while(l<s){\\n          int[] temp2=matrix[l];\\n          matrix[l]=matrix[s];\\n          matrix[s]=temp2;\\n          l++;\\n          s--;\\n       }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<m;j++){\\n                int temp=  matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                  matrix[j][i]=temp;\\n            }\\n        }\\n      \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502783,
                "title": "c-java-2-method",
                "content": "**Solution 1: Optimized approach**\\n\\nIntuition: By observation, we see that the first column of the original matrix is the reverse of the first row of the rotated matrix, so that\\u2019s why we transpose the matrix and then reverse each row, and since we are making changes in the matrix itself space complexity gets reduced to O(1).\\n\\nApproach:\\n\\nStep1: Transpose of the matrix. (transposing means changing columns to rows and rows to columns)\\n\\nStep2: Reverse each row of the matrix.\\n\\n**Time Complexity**:` O(N*N) + O(N*N)`.One O(N*N) for transposing the matrix and the other for reversing the matrix.\\n\\n**Space Complexity**: `O(1)`.\\n\\n**C++ Code**\\n```\\nvoid rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  //transposing the matrix\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < i; j++) {\\n      swap(matrix[i][j], matrix[j][i]);\\n    }\\n  }\\n  //reversing each row of the matrix\\n  for (int i = 0; i < n; i++) {\\n    reverse(matrix[i].begin(), matrix[i].end());\\n  }\\n}\\n```\\n\\n**Java Code:**\\n```\\n static void rotate(int[][] matrix) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length / 2; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n```\\n\\n**Solution 2:Brute force**\\n\\n**Approach:** Take another dummy matrix of n*n, and then take the first row of the matrix and put it in the last column of the dummy matrix, take the second row of the matrix, and put it in the second last column of the matrix and so.\\n\\n**Time Complexity**: `O(N*N) `to linearly iterate and put it into some other matrix.\\n\\n**Space Complexity**: `O(N*N)` to copy it into some other matrix.\\n\\n**C++ Code**\\n```\\nvector < vector < int >> rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  vector < vector < int >> rotated(n, vector < int > (n, 0));\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < n; j++) {\\n      rotated[j][n - i - 1] = matrix[i][j];\\n    }\\n  }\\n  return rotated;\\n}\\n```\\n\\n**Java Code**\\n```\\nstatic int[][] rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        return rotated;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvoid rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  //transposing the matrix\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < i; j++) {\\n      swap(matrix[i][j], matrix[j][i]);\\n    }\\n  }\\n  //reversing each row of the matrix\\n  for (int i = 0; i < n; i++) {\\n    reverse(matrix[i].begin(), matrix[i].end());\\n  }\\n}\\n```\n```\\n static void rotate(int[][] matrix) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length / 2; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n```\n```\\nvector < vector < int >> rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  vector < vector < int >> rotated(n, vector < int > (n, 0));\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < n; j++) {\\n      rotated[j][n - i - 1] = matrix[i][j];\\n    }\\n  }\\n  return rotated;\\n}\\n```\n```\\nstatic int[][] rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        return rotated;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021558,
                "title": "c-one-iteration-solution-small-and-easy-code",
                "content": "The digonal elements before the mid element will be swapped in a circular fashion as shown in the image attached. The ordinary approach of transpose and reverse take extra time to reverse but here it\\'s swap which is constant time instrution. So, better time complexity.\\n\\n![image](https://assets.leetcode.com/users/images/458671c2-1f0b-47f1-937c-80ae7c7285d0_1652075441.6591158.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0,j=0; i<n; i++,j++)\\n        {\\n            for(int k=i; k<n-i-1; k++)\\n            {\\n                swap(matrix[i][k], matrix[k][n-i-1]);\\n                swap(matrix[i][k], matrix[n-i-1][n-k-1]);\\n                swap(matrix[i][k], matrix[n-k-1][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0,j=0; i<n; i++,j++)\\n        {\\n            for(int k=i; k<n-i-1; k++)\\n            {\\n                swap(matrix[i][k], matrix[k][n-i-1]);\\n                swap(matrix[i][k], matrix[n-i-1][n-k-1]);\\n                swap(matrix[i][k], matrix[n-k-1][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209450,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in range(n//2):\\n            for j in range((n+1)//2):\\n                matrix[i][j], matrix[j][~i], matrix[~i][~j], matrix[~j][i] = matrix[~j][i], matrix[i][j], matrix[j][~i], matrix[~i][~j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in range(n//2):\\n            for j in range((n+1)//2):\\n                matrix[i][j], matrix[j][~i], matrix[~i][~j], matrix[~j][i] = matrix[~j][i], matrix[i][j], matrix[j][~i], matrix[~i][~j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19044,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    1,2,3    7,8,9    7,4,1\\n    4,5,6 => 4,5,6 => 8,5,2 \\n    7,8,9    1,2,3    9,6,3\\n    (1)swap row i and row n-1-i\\n    (2)swap elements in symmetrical position\\n\\n \\n\\n    class Solution {\\n        public:\\n            void rotate(vector<vector<int>>& matrix) {\\n                int n = matrix.size();\\n                if (n < 2)\\n                    return;\\n                    \\n                int i = 0, j = 0, temp = 0;\\n                int mid = (n - 1) / 2;\\n                \\n                for (i = 0; i <= mid; i++)\\n                {\\n                    for (j = 0; j < n; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[n-1-i][j];\\n                        matrix[n-1-i][j] =temp;\\n                    }\\n                }\\n                \\n                for (i = 1; i < n; i++)\\n                {\\n                    for (j = 0; i > j; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[j][i];\\n                        matrix[j][i] = temp;\\n                    }\\n                }\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            void rotate(vector<vector<int>>& matrix) {\\n                int n = matrix.size();\\n                if (n < 2)\\n                    return;\\n                    \\n                int i = 0, j = 0, temp = 0;\\n                int mid = (n - 1) / 2;\\n                \\n                for (i = 0; i <= mid; i++)\\n                {\\n                    for (j = 0; j < n; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[n-1-i][j];\\n                        matrix[n-1-i][j] =temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 19095,
                "title": "java-python-2-in-place-solutions-direct-rotate-vs-reverse-transpose",
                "content": "Rotate the image directly by definition, just need to figure out the one one relation between the coordinates.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        for l in xrange(n / 2):\\n            r = n - 1 - l\\n            for p in xrange(l, r):\\n                q = n - 1 - p\\n                cache = matrix[l][p]\\n                matrix[l][p] = matrix[q][l]\\n                matrix[q][l] = matrix[r][q]\\n                matrix[r][q] = matrix[p][r]\\n                matrix[p][r] = cache\\n\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 88.46%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            for (int p = i; p < j; ++p) {\\n                int q = n - 1 - p;\\n                int cache = matrix[i][p];\\n                matrix[i][p] = matrix[q][i];\\n                matrix[q][i] = matrix[j][q];\\n                matrix[j][q] = matrix[p][j];\\n                matrix[p][j] = cache;\\n            }\\n        }\\n    }\\n    // Runtime: 0ms\\n\\n\\n\\nThe reverse and transpose method needs a little bit of thinking, but once figure out, the code is rather concise.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        matrix.reverse()\\n        for i in xrange(n):\\n            for j in xrange(i + 1, n):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n    # 75.44%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Reverse\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            int[] cache = matrix[i];\\n            matrix[i] = matrix[j];\\n            matrix[j] = cache;\\n        }\\n        // Transpose\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int cache = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = cache;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "Rotate the image directly by definition, just need to figure out the one one relation between the coordinates.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        for l in xrange(n / 2):\\n            r = n - 1 - l\\n            for p in xrange(l, r):\\n                q = n - 1 - p\\n                cache = matrix[l][p]\\n                matrix[l][p] = matrix[q][l]\\n                matrix[q][l] = matrix[r][q]\\n                matrix[r][q] = matrix[p][r]\\n                matrix[p][r] = cache\\n\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 88.46%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            for (int p = i; p < j; ++p) {\\n                int q = n - 1 - p;\\n                int cache = matrix[i][p];\\n                matrix[i][p] = matrix[q][i];\\n                matrix[q][i] = matrix[j][q];\\n                matrix[j][q] = matrix[p][j];\\n                matrix[p][j] = cache;\\n            }\\n        }\\n    }\\n    // Runtime: 0ms\\n\\n\\n\\nThe reverse and transpose method needs a little bit of thinking, but once figure out, the code is rather concise.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        matrix.reverse()\\n        for i in xrange(n):\\n            for j in xrange(i + 1, n):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n    # 75.44%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Reverse\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            int[] cache = matrix[i];\\n            matrix[i] = matrix[j];\\n            matrix[j] = cache;\\n        }\\n        // Transpose\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int cache = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = cache;\\n            }\\n        }\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2781038,
                "title": "c-0ms-100-beats-6-line-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First take the transpose of the matrix \\n2) Then reverse each row of the matrix  \\n\\n\\n# Code\\n```\\n    void rotate(vector<vector<int>>& m) {\\n        //Taking transpose of the matrix\\n        for(int i=0;i<m.size();i++)   \\n            for(int j = 0 ;j<i ; j++)\\n              swap(m[i][j] , m[j][i]);\\n        \\n        //reversing each row of the matrix\\n        for(int i=0 ; i<m.size();i++)      \\n            reverse(m[i].begin(), m[i].end());\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n    void rotate(vector<vector<int>>& m) {\\n        //Taking transpose of the matrix\\n        for(int i=0;i<m.size();i++)   \\n            for(int j = 0 ;j<i ; j++)\\n              swap(m[i][j] , m[j][i]);\\n        \\n        //reversing each row of the matrix\\n        for(int i=0 ; i<m.size();i++)      \\n            reverse(m[i].begin(), m[i].end());\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174994,
                "title": "rotate-matrix-in-c-2-methods-0ms-faster-than-100-simple-short",
                "content": "```\\n// Method - 1\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    \\n    // changing symmetrically from middle row\\n    for(int i = 0; i < n/2; i++) {\\n        for(int j = 0; j < n; j++) {\\n            swap(matrix[i][j], matrix[n-1-i][j]);\\n        }\\n    }\\n    \\n    // taking transpose\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i; j < n; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Method - 2\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    for (int i = 0; i < (n + 1) / 2; i ++) {\\n        for (int j = 0; j < n / 2; j++) {\\n            int temp = matrix[n - 1 - j][i];\\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n            matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n            matrix[j][n - 1 - i] = matrix[i][j];\\n            matrix[i][j] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n// Method - 1\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    \\n    // changing symmetrically from middle row\\n    for(int i = 0; i < n/2; i++) {\\n        for(int j = 0; j < n; j++) {\\n            swap(matrix[i][j], matrix[n-1-i][j]);\\n        }\\n    }\\n    \\n    // taking transpose\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i; j < n; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n}\\n```\n```\\n// Method - 2\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    for (int i = 0; i < (n + 1) / 2; i ++) {\\n        for (int j = 0; j < n / 2; j++) {\\n            int temp = matrix[n - 1 - j][i];\\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n            matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n            matrix[j][n - 1 - i] = matrix[i][j];\\n            matrix[i][j] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510692,
                "title": "c-easy-clean-solution-fastest-0ms-all-5-methods-detailed",
                "content": "**NOTE:** We are rotating a matrix by 90 degrees CLOCKWISE.\\n\\n#### Method1: First find Transpose and then Reverse Individual Rows\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n\\t// then reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n}\\n```\\n\\n#### Method2: First Reverse matrix and then find Transpose\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n\\t// then find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n}\\n```\\n\\n#### Method3: First Reverse Individual Rows and then find Reverse Transpose\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n\\t// then find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n}\\n```\\n\\n#### Method4: First find Reverse Transpose then Reverse Matrix\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n\\t// then find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n}\\n```\\n\\n#### Method5: Reverse in Group of Four\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\t// IDEA: 1st row will become nth column, reverse of nth column will become\\n\\t// nth row, nth row will become 1st column and reverse of 1st column will\\n\\t// become 1st row. This is done for boundary of whole matrix, then keep \\n\\t// repeating above for inner boundaries of matrix.\\n\\tint n = M.size();\\n\\t// p: padding, r: row, c: column\\n\\t// Try to visualise below with a testcase to better understand the algo\\n\\tfor (int p = 0, r = p; r < n - p - 1; r++, p++)\\n\\t\\tfor (int c = p; c < n - p - 1; c++) {\\n\\t\\t\\tswap(M[r][c], M[c][n - 1 - r]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - r][n - 1 - c]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][r]);\\n\\t\\t}\\n}\\n```\\n\\n##### For detailed explaination/ visualization, see solutions provided by Leetcode OJ.\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [],
                "code": "```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n\\t// then reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n\\t// then find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n\\t// then find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n\\t// then find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\t// IDEA: 1st row will become nth column, reverse of nth column will become\\n\\t// nth row, nth row will become 1st column and reverse of 1st column will\\n\\t// become 1st row. This is done for boundary of whole matrix, then keep \\n\\t// repeating above for inner boundaries of matrix.\\n\\tint n = M.size();\\n\\t// p: padding, r: row, c: column\\n\\t// Try to visualise below with a testcase to better understand the algo\\n\\tfor (int p = 0, r = p; r < n - p - 1; r++, p++)\\n\\t\\tfor (int c = p; c < n - p - 1; c++) {\\n\\t\\t\\tswap(M[r][c], M[c][n - 1 - r]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - r][n - 1 - c]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][r]);\\n\\t\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332466,
                "title": "15-lines-written-explaination",
                "content": "The idea behind this relies on some math but I\\'ll try my best with an ELI5 answer. \\n\\n**TLDR: Solve this by row reversing then transposing the matrix or transpose the matrix then reverse the columns**\\n\\nWhen you perform a 90 degree rotation the \"diagonal\" swaps directions.\\n\\n```\\n[(X), 2, 3]          [7, 4, (X)]\\n[4, (X), 6]    =>    [8, (X), 2]     90 degree rotation\\n[7, 8, (X)]          [(X), 6, 3]\\n```\\nSo to swap the diagonal you must either reverse by row or by column. If you imagine the matrix as a physical paper, swapping the row or column would be like flipping the paper over. So the diagonal is now swapped but the paper is now flipped on its back. So to flip the paper back to the proper face, you must perform a transpose. \\n\\nTo over simplify why you must transpose is because in 2D, a matrix transpose is like a form of geometric translation which is what a rotation is; however, a transpose is not enough to rotate a matrix as the values do not map to the correct positions. Reversing the row or column simply \"corrects\" the rotation. \\n\\n```\\n[(X), 2, 3]          [7, 8, (X)]\\n[4, (X), 6]    =>    [4, (X), 6]     Reverse the rows to swap \"diagonal\" direction\\n[7, 8, (X)]          [(X), 2, 3]\\n```\\n\\n```\\n[(X), 8, 9]          [7, 4, 1]\\n[4, (X), 6]    =>    [8, 5, 2]     Transposing along the diagonal will complete the rotation (assuming you row reversed first)\\n[1, 2, (X)]          [9, 6, 3]\\n```\\n\\nFinally, you must know that: **MATRIX MULTIPLICATION IS NOT COMMUTATIVE!**\\nOrder matters meaning,\\n```\\n(row reverse) x (transpose) =/= (transpose) x (row reverse) \\n\\nBut FYI, these two operations are the same\\n(row reverse) x (transpose) == (transpose) x (column reverse)\\n```\\nSo you can solve this by first reversing rows then transposing or transposing then reverse columns. You can choose however you like.\\n```\\nvar rotate = function(matrix) {\\n    let length = matrix.length\\n    \\n    matrix.reverse()\\n    \\n\\t// transpose\\n    for (let i = 0; i < length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let temp = matrix[i][j]\\n            matrix[i][j] = matrix[j][i]\\n            matrix[j][i] = temp\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[(X), 2, 3]          [7, 4, (X)]\\n[4, (X), 6]    =>    [8, (X), 2]     90 degree rotation\\n[7, 8, (X)]          [(X), 6, 3]\\n```\n```\\n[(X), 2, 3]          [7, 8, (X)]\\n[4, (X), 6]    =>    [4, (X), 6]     Reverse the rows to swap \"diagonal\" direction\\n[7, 8, (X)]          [(X), 2, 3]\\n```\n```\\n[(X), 8, 9]          [7, 4, 1]\\n[4, (X), 6]    =>    [8, 5, 2]     Transposing along the diagonal will complete the rotation (assuming you row reversed first)\\n[1, 2, (X)]          [9, 6, 3]\\n```\n```\\n(row reverse) x (transpose) =/= (transpose) x (row reverse) \\n\\nBut FYI, these two operations are the same\\n(row reverse) x (transpose) == (transpose) x (column reverse)\\n```\n```\\nvar rotate = function(matrix) {\\n    let length = matrix.length\\n    \\n    matrix.reverse()\\n    \\n\\t// transpose\\n    for (let i = 0; i < length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let temp = matrix[i][j]\\n            matrix[i][j] = matrix[j][i]\\n            matrix[j][i] = temp\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093828,
                "title": "python-3-recursive-peel-off-the-layers-explained-with-graph",
                "content": "Each recursive call just peels off one matrix layer, and the next call explores the \\'inner\\' matrix layer. For example, visually the matrix looks like the below picture. We work on one layer at a time.\\n\\nIn each recursive all, we refer to the way from the LeetCode approach 1 (Rotate Groups of Four Cells): https://leetcode.com/problems/rotate-image/solution/. And we just need to iterate from the first element through to the second last elment in the first row.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a78a7f44-35f0-47ab-9b29-f4011a11e0f5_1614901732.2911437.png)\\n\\n\\n~~~\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        def helper(top_left, bottom_right):\\n            if bottom_right <= top_left:\\n                return\\n            for i in range(top_left, bottom_right):\\n                tmp = matrix[top_left][i]\\n                matrix[top_left][i] = matrix[n-i][top_left]\\n                matrix[n-i][top_left] = matrix[n-top_left][n-i]\\n                matrix[n-top_left][n-i] = matrix[n-(n-i)][n-top_left]\\n                matrix[n-(n-i)][n-top_left] = tmp\\n            helper(top_left+1, bottom_right-1)\\n        \\n        n = len(matrix)-1\\n        helper(0, n)\\n~~~\\n\\n#Runtime: 32 ms, faster than 85.71% of Python3 online submissions for Rotate Image.\\n#Memory Usage: 14.1 MB, less than 96.08% of Python3 online submissions for Rotate Image.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Recursion"
                ],
                "code": "Each recursive call just peels off one matrix layer, and the next call explores the \\'inner\\' matrix layer. For example, visually the matrix looks like the below picture. We work on one layer at a time.\\n\\nIn each recursive all, we refer to the way from the LeetCode approach 1 (Rotate Groups of Four Cells): https://leetcode.com/problems/rotate-image/solution/. And we just need to iterate from the first element through to the second last elment in the first row.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a78a7f44-35f0-47ab-9b29-f4011a11e0f5_1614901732.2911437.png)\\n\\n\\n~~~\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        def helper(top_left, bottom_right):\\n            if bottom_right <= top_left:\\n                return\\n            for i in range(top_left, bottom_right):\\n                tmp = matrix[top_left][i]\\n                matrix[top_left][i] = matrix[n-i][top_left]\\n                matrix[n-i][top_left] = matrix[n-top_left][n-i]\\n                matrix[n-top_left][n-i] = matrix[n-(n-i)][n-top_left]\\n                matrix[n-(n-i)][n-top_left] = tmp\\n            helper(top_left+1, bottom_right-1)\\n        \\n        n = len(matrix)-1\\n        helper(0, n)\\n~~~\\n\\n#Runtime: 32 ms, faster than 85.71% of Python3 online submissions for Rotate Image.\\n#Memory Usage: 14.1 MB, less than 96.08% of Python3 online submissions for Rotate Image.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 904069,
                "title": "simple-c-solution-video-explanation",
                "content": "https://www.youtube.com/watch?v=Pvhjc9bo5s0\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reversal of all rows\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\\nmore videos - https://www.youtube.com/channel/UCUbuXuBGfWonCur5MBAsTdA",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reversal of all rows\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752218,
                "title": "swift-homemade-sweet-sour-solution-100",
                "content": "**Time: O(n), Space: O(1)**\\n```\\nfunc rotate(_ matrix: inout [[Int]]) {\\n\\t// Step 1: Flip vertically\\n\\tmatrix.reverse()\\n\\n\\t// Step 2: Flip diagonally\\n\\tfor i in 0..<matrix.count {\\n\\t\\tfor j in 0..<i {\\n\\t\\t\\tlet temp = matrix[i][j]\\n\\t\\t\\tmatrix[i][j] = matrix[j][i]\\n\\t\\t\\tmatrix[j][i] = temp\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc rotate(_ matrix: inout [[Int]]) {\\n\\t// Step 1: Flip vertically\\n\\tmatrix.reverse()\\n\\n\\t// Step 2: Flip diagonally\\n\\tfor i in 0..<matrix.count {\\n\\t\\tfor j in 0..<i {\\n\\t\\t\\tlet temp = matrix[i][j]\\n\\t\\t\\tmatrix[i][j] = matrix[j][i]\\n\\t\\t\\tmatrix[j][i] = temp\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678211,
                "title": "easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint",
                "content": "# Hint 1- You can use transpose of a matrix.\\n# Intuition\\nThe first thought was to make a new 2D vector, but it was mentioned in question to make the changes in the given matrix.\\n\\n# Hint 2- You can use reverse of a matrix by row wise.\\n# Approach\\nApproach is in 2 steps-\\n- First to transpose the matrix.\\n- Second to reverse the matrix row-wise.\\n- boom you got the desired output.\\n![photo6104660841891739043.jpg](https://assets.leetcode.com/users/images/3af79aaf-5de1-4bc5-84a9-d2e1c951171c_1687631454.8280246.jpeg)\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // transpose\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=i+1;j<matrix[0].size();j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        // now reverse the matrix\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            int k=0;\\n            int j=matrix.size()-1;\\n            while(k<j)\\n            {\\n                swap(matrix[i][k],matrix[i][j]);\\n                k++;\\n                j--;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```\\n# Please show support by upvoting!!",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // transpose\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=i+1;j<matrix[0].size();j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        // now reverse the matrix\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            int k=0;\\n            int j=matrix.size()-1;\\n            while(k<j)\\n            {\\n                swap(matrix[i][k],matrix[i][j]);\\n                k++;\\n                j--;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094147,
                "title": "best-o-n-2-solution",
                "content": "\\n# Approach\\nStep1 :- Transpose of the matrix.\\nStep2 :- Reverse each row of the matrix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) \\n            for (int j = i + 1; j < n; j++) \\n                swap(matrix[i][j], matrix[j][i]);\\n\\n        // Reversing each row of the matrix\\n        for (int k = 0; k < n; k++) \\n            reverse(matrix[k].begin(), matrix[k].end());\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) \\n            for (int j = i + 1; j < n; j++) \\n                swap(matrix[i][j], matrix[j][i]);\\n\\n        // Reversing each row of the matrix\\n        for (int k = 0; k < n; k++) \\n            reverse(matrix[k].begin(), matrix[k].end());\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802641,
                "title": "100-faster-than-others-upvote-if-you-like",
                "content": "# Intuition\\nfirst find transpose then reverse each row \\n\\n>\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(m[i].begin(),m[i].end());\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(m[i].begin(),m[i].end());\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330930,
                "title": "easy-0-ms-100-fully-explained-java-c-js-c-4-different-approaches",
                "content": "# **JAVA SOLUTION (1st Approach) :**\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // Reverse each row in a for-loop...\\n        for (int row = 0; row < matrix.length/2; row++) {\\n            int[] rotate = matrix[row];\\n            matrix[row] = matrix[matrix.length - row - 1];\\n            matrix[matrix.length - row - 1] = rotate;\\n        }\\n        // Visit each row...\\n        for (int row = 0; row < matrix.length - 1; row++) {\\n            for (int col = row+1; col < matrix.length; col++) {     //Initialize col as row + 1.\\n                // Swap each pair of symmetric elements...\\n                int rotate = matrix[row][col];\\n                matrix[row][col] = matrix[col][row];\\n                matrix[col][row] = rotate;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n# **C++ SOLUTION (2nd Approach) :**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        // Visit each row...\\n       for(int row = 0; row < matrix.size(); row++)\\n           //Initialize col as row + 1.\\n           for(int col = row +1; col < matrix.size(); col++)\\n               // Swap each pair of symmetric elements...\\n               swap(matrix[row][col], matrix[col][row]);\\n        \\n        // Reverse each row in a for-loop...\\n        for(int row = 0; row < matrix.size(); row++)\\n            reverse(matrix[row].begin(),matrix[row].end());\\n    }\\n};\\n```\\n\\n# **JAVASCRIPT SOLUTION (3rd Approach) :**\\n```\\nvar rotate = function(matrix) {\\n    let rotate = 0;\\n    for(row = 0; row < matrix.length/2; row++){\\n        for(col = row; col < matrix.length - 1 - row; col++){\\n            rotate = matrix[row][col];\\n            matrix[row][col] = matrix[matrix.length - 1 - col][row];\\n            matrix[matrix.length-1-col][row] = matrix[matrix.length-1-row][matrix.length-1-col];\\n            matrix[matrix.length-1-row][matrix.length-1-col] = matrix[col][matrix.length-1-row];\\n            matrix[col][matrix.length-1-row] = rotate;\\n        }\\n    }\\n};\\n```\\n\\n# **C LANGUAGE (4th Approach) :**\\n```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }\\n    }\\n    // Reverse process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        int beg = 0;\\n        int end = matrixSize - 1;\\n        while(beg < end) {\\n            int tmp = matrix[row][beg];\\n            matrix[row][beg] = matrix[row][end];\\n            matrix[row][end] = tmp;\\n            beg++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n**4 different approaches are here and the solutions are 0 ms 100% faster...\\nPlease upvote if you find any help with this code...\\nI am working hard for you guys...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // Reverse each row in a for-loop...\\n        for (int row = 0; row < matrix.length/2; row++) {\\n            int[] rotate = matrix[row];\\n            matrix[row] = matrix[matrix.length - row - 1];\\n            matrix[matrix.length - row - 1] = rotate;\\n        }\\n        // Visit each row...\\n        for (int row = 0; row < matrix.length - 1; row++) {\\n            for (int col = row+1; col < matrix.length; col++) {     //Initialize col as row + 1.\\n                // Swap each pair of symmetric elements...\\n                int rotate = matrix[row][col];\\n                matrix[row][col] = matrix[col][row];\\n                matrix[col][row] = rotate;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        // Visit each row...\\n       for(int row = 0; row < matrix.size(); row++)\\n           //Initialize col as row + 1.\\n           for(int col = row +1; col < matrix.size(); col++)\\n               // Swap each pair of symmetric elements...\\n               swap(matrix[row][col], matrix[col][row]);\\n        \\n        // Reverse each row in a for-loop...\\n        for(int row = 0; row < matrix.size(); row++)\\n            reverse(matrix[row].begin(),matrix[row].end());\\n    }\\n};\\n```\n```\\nvar rotate = function(matrix) {\\n    let rotate = 0;\\n    for(row = 0; row < matrix.length/2; row++){\\n        for(col = row; col < matrix.length - 1 - row; col++){\\n            rotate = matrix[row][col];\\n            matrix[row][col] = matrix[matrix.length - 1 - col][row];\\n            matrix[matrix.length-1-col][row] = matrix[matrix.length-1-row][matrix.length-1-col];\\n            matrix[matrix.length-1-row][matrix.length-1-col] = matrix[col][matrix.length-1-row];\\n            matrix[col][matrix.length-1-row] = rotate;\\n        }\\n    }\\n};\\n```\n```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }\\n    }\\n    // Reverse process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        int beg = 0;\\n        int end = matrixSize - 1;\\n        while(beg < end) {\\n            int tmp = matrix[row][beg];\\n            matrix[row][beg] = matrix[row][end];\\n            matrix[row][end] = tmp;\\n            beg++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600966,
                "title": "all-matrix-rotations-90-180-270-for-both-square-and-rectangular-matrix",
                "content": "```\\n/*\\nVariant I - Rotate Square matrix by 90 deg clockwise\\n\\n1,2,3           7,4,1\\n4,5,6   =====>  8,5,2\\n7,8,9           9,6,3\\n*/\\n\\nfunction rotateSqMatrixClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n};\\n\\n/*\\nVariant II - Rotate Square matrix by 90 deg anti-clockwise // 270deg clockwise\\n\\n1,2,3           3,6,9\\n4,5,6   =====>  2,5,8\\n7,8,9           1,4,7\\n*/\\nfunction rotateSqMatrixAntiClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n};\\n\\n/*\\n\\nVariant III - Rotate Square matrix by 180 deg\\n\\n1,2,3           9,8,7\\n4,5,6   =====>  6,5,4\\n7,8,9           3,2,1\\n\\n*/\\n\\nfunction rotateSqMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\n/*\\n\\nVariant IV - Rotate Rectangular matrix by by 90 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            9, 5, 1\\n 5, 6, 7, 8   =====>  10, 6, 2\\n 9,10,11,12           11, 7, 3\\n                      12, 8, 4\\n*/\\n\\nfunction roateMatrixClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[j][m-i-1] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant V - Rotate Rectangular matrix by by 90 deg anti-clockwise / 270 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            4, 8,12\\n 5, 6, 7, 8   =====>   3, 7,11\\n 9,10,11,12            2, 6,10\\n                       1, 5, 9\\n*/\\nfunction roateMatrixAntiClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[n-j-1][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant VI - Rotate Rectangular matrix by by 180 deg / 270 deg clockwise (can be done in place)\\n\\n 1, 2, 3, 4            12,11,10, 9\\n 5, 6, 7, 8   =====>    8, 7, 6, 5\\n 9,10,11,12             4, 3, 2, 1\\n\\n*/\\nfunction rotateMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\nfunction transposeMatrix(matrix){\\n    for(let i=0; i < matrix.length; i++){\\n        for(let j=i; j < matrix[0].length; j++){\\n            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixCols(matrix){\\n    // reverse matrix columns\\n    let n = matrix[0].length;\\n    for(let i=0; i < matrix.length; i++){\\n        let left = 0, right = n-1;\\n        while(left < right){\\n            [matrix[i][left],matrix[i][right]] = [matrix[i][right],matrix[i][left]];\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixRows(matrix){\\n    let top = 0, down = matrix.length-1;\\n    while(top < down){\\n        [matrix[top],matrix[down]] = [matrix[down],matrix[top]];\\n        top++;\\n        down--;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/*\\nVariant I - Rotate Square matrix by 90 deg clockwise\\n\\n1,2,3           7,4,1\\n4,5,6   =====>  8,5,2\\n7,8,9           9,6,3\\n*/\\n\\nfunction rotateSqMatrixClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n};\\n\\n/*\\nVariant II - Rotate Square matrix by 90 deg anti-clockwise // 270deg clockwise\\n\\n1,2,3           3,6,9\\n4,5,6   =====>  2,5,8\\n7,8,9           1,4,7\\n*/\\nfunction rotateSqMatrixAntiClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n};\\n\\n/*\\n\\nVariant III - Rotate Square matrix by 180 deg\\n\\n1,2,3           9,8,7\\n4,5,6   =====>  6,5,4\\n7,8,9           3,2,1\\n\\n*/\\n\\nfunction rotateSqMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\n/*\\n\\nVariant IV - Rotate Rectangular matrix by by 90 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            9, 5, 1\\n 5, 6, 7, 8   =====>  10, 6, 2\\n 9,10,11,12           11, 7, 3\\n                      12, 8, 4\\n*/\\n\\nfunction roateMatrixClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[j][m-i-1] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant V - Rotate Rectangular matrix by by 90 deg anti-clockwise / 270 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            4, 8,12\\n 5, 6, 7, 8   =====>   3, 7,11\\n 9,10,11,12            2, 6,10\\n                       1, 5, 9\\n*/\\nfunction roateMatrixAntiClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[n-j-1][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant VI - Rotate Rectangular matrix by by 180 deg / 270 deg clockwise (can be done in place)\\n\\n 1, 2, 3, 4            12,11,10, 9\\n 5, 6, 7, 8   =====>    8, 7, 6, 5\\n 9,10,11,12             4, 3, 2, 1\\n\\n*/\\nfunction rotateMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\nfunction transposeMatrix(matrix){\\n    for(let i=0; i < matrix.length; i++){\\n        for(let j=i; j < matrix[0].length; j++){\\n            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixCols(matrix){\\n    // reverse matrix columns\\n    let n = matrix[0].length;\\n    for(let i=0; i < matrix.length; i++){\\n        let left = 0, right = n-1;\\n        while(left < right){\\n            [matrix[i][left],matrix[i][right]] = [matrix[i][right],matrix[i][left]];\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixRows(matrix){\\n    let top = 0, down = matrix.length-1;\\n    while(top < down){\\n        [matrix[top],matrix[down]] = [matrix[down],matrix[top]];\\n        top++;\\n        down--;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399685,
                "title": "c-brute-force-optimal-solution-time-o-n-2-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(N^2)\\n        int len=matrix.size();\\n        vector<vector<int>> B;\\n        B=matrix;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                B[j][len-i-1]=matrix[i][j];\\n            }\\n        }\\n        matrix=B;  \\n    }     \\n};\\n```\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(N^2)\\n        int len=matrix.size();\\n        vector<vector<int>> B;\\n        B=matrix;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                B[j][len-i-1]=matrix[i][j];\\n            }\\n        }\\n        matrix=B;  \\n    }     \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699959,
                "title": "easy-c-approach-beats-100-clear-explanation-for-each-line",
                "content": "My approach is to find the transpose of the given matrix and then reverse each individual vector with in 2d vector.\\nlet us take one example and be clear.\\nsuppose Given input matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\nstep 1: find the transpose of the matrix.\\n after tranposing it looks something like this.\\n [\\n [1,4,7],\\n [2,5,8],\\n [3,6,9]\\n ]\\n step 2: reverse individual vectors with in 2d vector.\\n [\\n [7,4,1],\\n [8,5,2],\\n [9,6,3]\\n ]\\n This is our required answer.. \\n My code is as follows\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++) //finding the transpose of the matrix\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(i<j)\\n                {\\n                    int temp=matrix[i][j];\\n                    matrix[i][j]=matrix[j][i];\\n                    matrix[j][i]=temp;\\n                }  \\n            }\\n        }\\n\\t\\t//done with transpose of the matrix\\n\\t\\t//now we need to reverse the individual vector\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end()); //reverse individual vector using inbuilt reverse function\\n        }\\n    }\\n};```\\nsince it\\'s inplace no need to return array and also return type is void.\\nPlease upvote if you like my approach.\\nIf you have any doubts regarding this approach kindly mention in the comment section.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++) //finding the transpose of the matrix\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(i<j)\\n                {\\n                    int temp=matrix[i][j];\\n                    matrix[i][j]=matrix[j][i];\\n                    matrix[j][i]=temp;\\n                }  \\n            }\\n        }\\n\\t\\t//done with transpose of the matrix\\n\\t\\t//now we need to reverse the individual vector\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end()); //reverse individual vector using inbuilt reverse function\\n        }\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3706134,
                "title": "java-striver-easy-understanding",
                "content": "##### 1. Brute Force\\n* **Time Complexity:** O(n^2), where n is the size of the matrix.\\n* **Space Complexity:** O(n^2)\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - 1 - i] = matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\\n\\n##### 1. Optimal Approach\\n* **Time Complexity:** O(n^2), where n is the size of the matrix.\\n* **Space Complexity:** O(1)\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // transpose the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - 1 - i] = matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // transpose the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161165,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int s = matrix[0].size();\\n        for(int i = 0; i < s; i++){\\n            for(int j = i; j < s-1-i && s-1-i > i; j++){\\n                swap(matrix[i][j],matrix[j][s-1-i]);\\n                swap(matrix[i][j],matrix[s-1-j][i]);\\n                swap(matrix[s-1-j][i],matrix[s-1-i][s-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for i in range(n):\\n            for j in range(n // 2):\\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\\n```\\n\\n```Java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int l = 0;\\n        int r = matrix.length - 1;\\n        \\n        while ( l < r )\\n        {\\n            for(int i = 0; i < r - l; i++)\\n            {\\n                int top = l;\\n                int bottom = r;\\n                int topLeft = matrix[top][l + i];\\n\\n                matrix[top][l + i] = matrix[bottom - i][l];\\n\\n                matrix[bottom - i][l] = matrix[bottom][r - i];\\n\\n                matrix[bottom][r - i] = matrix[top + i][r];\\n\\n                matrix[top + i][r] = topLeft;\\n                \\n            }\\n            \\n            r -= 1;\\n            l += 1;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int s = matrix[0].size();\\n        for(int i = 0; i < s; i++){\\n            for(int j = i; j < s-1-i && s-1-i > i; j++){\\n                swap(matrix[i][j],matrix[j][s-1-i]);\\n                swap(matrix[i][j],matrix[s-1-j][i]);\\n                swap(matrix[s-1-j][i],matrix[s-1-i][s-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for i in range(n):\\n            for j in range(n // 2):\\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\\n```\n```Java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int l = 0;\\n        int r = matrix.length - 1;\\n        \\n        while ( l < r )\\n        {\\n            for(int i = 0; i < r - l; i++)\\n            {\\n                int top = l;\\n                int bottom = r;\\n                int topLeft = matrix[top][l + i];\\n\\n                matrix[top][l + i] = matrix[bottom - i][l];\\n\\n                matrix[bottom - i][l] = matrix[bottom][r - i];\\n\\n                matrix[bottom][r - i] = matrix[top + i][r];\\n\\n                matrix[top + i][r] = topLeft;\\n                \\n            }\\n            \\n            r -= 1;\\n            l += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661652,
                "title": "python-3-easy-fast-low-memory",
                "content": "Runtime:` 52 ms`, faster than `63.58%` of Python3 online submissions for Rotate Image.\\nMemory Usage: `13.8 MB`, less than `98.10%` of Python3 online submissions for Rotate Image.\\n```\\nclass Solution:\\n    def rotate(self, a):\\n        \"\"\"\\n        Needed:\\n        \\n        1 2 3\\n        4 5 6\\n        7 8 9\\n        ->\\n        7 4 1\\n        8 5 2\\n        9 6 3\\n\\n        \"\"\"\\n        a.reverse()\\n        for i in range(len(a)):\\n            for j in range(i):\\n                a[i][j], a[j][i] = a[j][i], a[i][j]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime:` 52 ms`, faster than `63.58%` of Python3 online submissions for Rotate Image.\\nMemory Usage: `13.8 MB`, less than `98.10%` of Python3 online submissions for Rotate Image.\\n```\\nclass Solution:\\n    def rotate(self, a):\\n        \"\"\"\\n        Needed:\\n        \\n        1 2 3\\n        4 5 6\\n        7 8 9\\n        ->\\n        7 4 1\\n        8 5 2\\n        9 6 3\\n\\n        \"\"\"\\n        a.reverse()\\n        for i in range(len(a)):\\n            for j in range(i):\\n                a[i][j], a[j][i] = a[j][i], a[i][j]",
                "codeTag": "Java"
            },
            {
                "id": 2505735,
                "title": "golang-one-line-swap-solution",
                "content": "The observation is that after a 90 degree rotation, the number from row `r` and column `c` will end up in row `c` and column `n-1-r`. Also rotating the matrix 4 times will result the number to end up in the original place, so the positions create cycles of size 4. Thus, if there is a cycle `a -> b -> c -> d -> a`, in Golang we can swap these values in one line like so `a, b, c, d = b, c, d, a`. \\n\\nAlso we need to make sure we rotate every cycle exactly once, so we need to start rotating the cycles from the upper left quarter of the matrix. If `n` is odd, we need to be careful to skip either middle column or middle row.\\n\\n```\\nfunc rotate(matrix [][]int)  {\\n    n := len(matrix)\\n    for r := 0; r < n/2; r++ {\\n        for c := 0; c < (n+1)/2; c++ {\\n            matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c], matrix[n-1-c][r] = \\n                matrix[n-1-c][r], matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(matrix [][]int)  {\\n    n := len(matrix)\\n    for r := 0; r < n/2; r++ {\\n        for c := 0; c < (n+1)/2; c++ {\\n            matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c], matrix[n-1-c][r] = \\n                matrix[n-1-c][r], matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505342,
                "title": "super-simple-wicked-fast-100",
                "content": "**Logic?**\\n\\n*If we see carefully, we will find that the matrix rotated 90 degrees is equivalent to **transpose of matrix with each elements of the rows reversed.***\\n\\n*Here is a visual representation of the same:*\\n\\n![image](https://assets.leetcode.com/users/images/790783a0-3f56-4673-b2a9-345705a9a383_1661870004.0681448.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        //For any matrix to be rotatable it must be a square matrix\\n        // i.e. no. of rows == no. of cols == size\\n        \\n        int size = matrix.size(); \\n        \\n        //Transposing the matrix\\n        for(int i = 0; i<size; i++){\\n            \\n            for(int j=i; j<size; j++){\\n                \\n                // Simple swapping algorithm\\n                \\n                int temp = matrix[i][j];\\n                \\n                matrix[i][j] = matrix[j][i];\\n                \\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //Reversing the Matrix\\n        //You can simply use reverse(matrix[i].begin(), matrix[i].end()) inside for loop also\\n        for(int row = 0; row<size; row++){\\n            \\n            int left = 0, right = size-1;\\n            \\n            while(left<right){\\n                \\n                int temp = matrix[row][left];\\n                \\n                matrix[row][left] = matrix[row][right];\\n                \\n                matrix[row][right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n            \\n    }\\n        \\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/684ec26b-4fee-45e0-a1d5-5d06a45aeb36_1661870059.9929965.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        //For any matrix to be rotatable it must be a square matrix\\n        // i.e. no. of rows == no. of cols == size\\n        \\n        int size = matrix.size(); \\n        \\n        //Transposing the matrix\\n        for(int i = 0; i<size; i++){\\n            \\n            for(int j=i; j<size; j++){\\n                \\n                // Simple swapping algorithm\\n                \\n                int temp = matrix[i][j];\\n                \\n                matrix[i][j] = matrix[j][i];\\n                \\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //Reversing the Matrix\\n        //You can simply use reverse(matrix[i].begin(), matrix[i].end()) inside for loop also\\n        for(int row = 0; row<size; row++){\\n            \\n            int left = 0, right = size-1;\\n            \\n            while(left<right){\\n                \\n                int temp = matrix[row][left];\\n                \\n                matrix[row][left] = matrix[row][right];\\n                \\n                matrix[row][right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n            \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239285,
                "title": "100-percent-faster-solution-easiest-approach",
                "content": "![image](https://assets.leetcode.com/users/images/953acdf5-f890-4a19-8467-30f1911d44b6_1656994043.1496904.png)\\n```\\nvoid pop_front(std::vector<int> &v){ //pop function to delete first element in the vector\\n        if(v.size() > 0){\\n        v.erase(v.begin());\\n        }\\n    }\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<int> kow;\\n        int n = matrix.size();\\n        if(n == 1){\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                kow.push_back(matrix[i][j]); //storing all values in a vector\\n            }\\n        }\\n        for(int j = n - 1; j >= 0; j--){\\n            for(int i = 0; i < n; i++){\\n                matrix[i][j] = kow.front(); //start from last column top and go till bottom of last column and then continue this  same procedure of going from top to bottom from last but first column to zeroth column.\\n                pop_front(kow); //delete the first element after every insertion\\n            }\\n        }\\n    }\\n```\\n**Please upvote my Solution!!! Do let me know your doubts through comment section below, I will be happy to reply back!!!**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid pop_front(std::vector<int> &v){ //pop function to delete first element in the vector\\n        if(v.size() > 0){\\n        v.erase(v.begin());\\n        }\\n    }\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<int> kow;\\n        int n = matrix.size();\\n        if(n == 1){\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                kow.push_back(matrix[i][j]); //storing all values in a vector\\n            }\\n        }\\n        for(int j = n - 1; j >= 0; j--){\\n            for(int i = 0; i < n; i++){\\n                matrix[i][j] = kow.front(); //start from last column top and go till bottom of last column and then continue this  same procedure of going from top to bottom from last but first column to zeroth column.\\n                pop_front(kow); //delete the first element after every insertion\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563254,
                "title": "python-numpy-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tmatrix[:] = np.rot90(matrix, axes=(1, 0))\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tmatrix[:] = np.rot90(matrix, axes=(1, 0))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1230540,
                "title": "transpose-then-reverse-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = i ; j<n ; j++)\\n            {\\n                swap(matrix[i][j] , matrix[j][i]); // Tanspose the matrix first\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            reverse(matrix[i].begin() , matrix[i].end()); // Reverse each row now\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = i ; j<n ; j++)\\n            {\\n                swap(matrix[i][j] , matrix[j][i]); // Tanspose the matrix first\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            reverse(matrix[i].begin() , matrix[i].end()); // Reverse each row now\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175497,
                "title": "rotate-image-easy-short-and-simple-explanation",
                "content": "Approach:-\\n![image](https://assets.leetcode.com/users/images/6a92ca14-9a43-4718-863f-dca4c0a6dc40_1619337250.152098.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& ar) {\\n        int n=ar.size();\\n        reverse(ar.begin(),ar.end()); //Reversing the matrix from top to bottom\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++) //!NOTE   j=i+1\\n                swap(ar[i][j],ar[j][i]); //Swapping the elements along the symmetry\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& ar) {\\n        int n=ar.size();\\n        reverse(ar.begin(),ar.end()); //Reversing the matrix from top to bottom\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++) //!NOTE   j=i+1\\n                swap(ar[i][j],ar[j][i]); //Swapping the elements along the symmetry\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749742,
                "title": "java-easy-understand-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic void rotate(int[][] matrix) {\\n\\n\\t\\t// transpose the matrix\\n\\t\\tfor(int i=0;i<=matrix.length-1;i++){            \\n\\t\\t\\tfor(int j=i;j<matrix[0].length;j++){\\n\\t\\t\\t\\tint temp=matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]=matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i]=temp;\\n\\t\\t\\t}         \\n\\t\\t}\\n\\n\\t\\t// reverse every row in the matrix \\n\\t\\tfor(int row=0;row<matrix.length;row++){\\n\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=matrix[0].length-1;\\n\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tint temp=matrix[row][i];\\n\\t\\t\\t\\tmatrix[row][i]=matrix[row][j];\\n\\t\\t\\t\\tmatrix[row][j]=temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic void rotate(int[][] matrix) {\\n\\n\\t\\t// transpose the matrix\\n\\t\\tfor(int i=0;i<=matrix.length-1;i++){            \\n\\t\\t\\tfor(int j=i;j<matrix[0].length;j++){\\n\\t\\t\\t\\tint temp=matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]=matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i]=temp;\\n\\t\\t\\t}         \\n\\t\\t}\\n\\n\\t\\t// reverse every row in the matrix \\n\\t\\tfor(int row=0;row<matrix.length;row++){\\n\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=matrix[0].length-1;\\n\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tint temp=matrix[row][i];\\n\\t\\t\\t\\tmatrix[row][i]=matrix[row][j];\\n\\t\\t\\t\\tmatrix[row][j]=temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19058,
                "title": "an-clean-and-easy-java-code-with-1ms",
                "content": "    public void rotate(int[][] matrix) {\\n        if (matrix == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint row = matrix.length;\\n\\t\\tint col = matrix.length;\\n        \\n\\t\\t//step 1:switch column\\n\\t    int low =0,high = col-1;\\n\\t    while(low < high){\\n\\t    \\tint[] temp = matrix[low];\\n\\t    \\tmatrix[low] = matrix[high];\\n\\t    \\tmatrix[high] = temp;\\n\\t    \\tlow++;\\n\\t    \\thigh--;\\n\\t    }\\n\\t    \\n\\t    //step 2:\\u5bf9\\u79f0\\u5143\\u7d20\\u4ea4\\u6362\\n\\t    for(int i=0; i<row; i++){\\n\\t    \\tfor(int j=0; j<i; j++){\\n\\t    \\t\\tint temp = matrix[i][j];\\n\\t    \\t\\tmatrix[i][j] = matrix[j][i];\\n\\t    \\t\\tmatrix[j][i] = temp;\\n\\t    \\t}\\n\\t    }\\n    }",
                "solutionTags": [],
                "code": "    public void rotate(int[][] matrix) {\\n        if (matrix == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint row = matrix.length;\\n\\t\\tint col = matrix.length;\\n        \\n\\t\\t//step 1:switch column\\n\\t    int low =0,high = col-1;\\n\\t    while(low < high){\\n\\t    \\tint[] temp = matrix[low];\\n\\t    \\tmatrix[low] = matrix[high];\\n\\t    \\tmatrix[high] = temp;\\n\\t    \\tlow++;\\n\\t    \\thigh--;\\n\\t    }\\n\\t    \\n\\t    //step 2:\\u5bf9\\u79f0\\u5143\\u7d20\\u4ea4\\u6362\\n\\t    for(int i=0; i<row; i++){\\n\\t    \\tfor(int j=0; j<i; j++){\\n\\t    \\t\\tint temp = matrix[i][j];\\n\\t    \\t\\tmatrix[i][j] = matrix[j][i];\\n\\t    \\t\\tmatrix[j][i] = temp;\\n\\t    \\t}\\n\\t    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19131,
                "title": "short-python-in-place-solution-50ms",
                "content": "    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of lists of integers\\n        def rotate(self, matrix):\\n            matrix.reverse()\\n            for i in range(len(matrix)):\\n                for j in range(i):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of lists of integers\\n        def rotate(self, matrix):\\n            matrix.reverse()\\n            for i in range(len(matrix)):\\n                for j in range(i):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
                "codeTag": "Java"
            },
            {
                "id": 18966,
                "title": "in-place-solution",
                "content": "The simple solution which requires additional space is :\\n\\n    class Solution {\\n    public:\\n        void rotate(vector<vector<int> > &matrix) {\\n            auto result = matrix;\\n        \\n            for (int i = 0; i < matrix.size(); i++) {\\n                for (int j = 0; j < matrix.size(); j++) {\\n                    result[j][matrix.size() - i - 1] = matrix[i][j];\\n                }\\n            }\\n            matrix = result;\\n        }\\n    };\\n\\nDoes anyone have an in-place solution?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(vector<vector<int> > &matrix) {\\n            auto result = matrix;\\n        \\n            for (int i = 0; i < matrix.size(); i++) {\\n                for (int j = 0; j < matrix.size(); j++) {\\n                    result[j][matrix.size() - i - 1] = matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3404972,
                "title": "rotate-image-c-solution-brute-optimal",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force : -\\n\\nCreate an answer matrix. Take every element from the matrix and place it in correct position in the answer matrix. \\nConsider the 4*4 matrix filled with integers.\\n[0][0] -> [0][3]\\n[0][1] -> [1][3]\\n[0][2] -> [2][3]\\n[0][3] -> [3][3]\\n[1][0] -> [0][2]\\n[1][1] -> [1][2]\\n[1][2] -> [2][2]\\n[1][3] -> [3][2]\\nsimilary for other rows of the matrix.\\nThe formula that comes out to be is placing i  to n - i - 1\\nTime Complexity : O( n * n) \\nSpace Complexity : O(n * n)\\n\\nOptimized Approach :-\\nObserve Carefully, the first column of the matrix is actually the first row of the matrix but stored in the reverse order. Just transpose the matrix in order to get the desired matrix and then reverse it \\nElements of the diagonals stay as it is but the other element has to be placed\\n\\nTime complexity:- O(n * n)\\nSpace Complexity : O(1)\\n\\n# Code\\n```\\nBrute Force :- \\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                temp[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\nOptimized approach :-\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            for(int j = i + 1; j < n ; j++){\\n                swap(matrix[i][j] , matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(matrix[i].begin() , matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nBrute Force :- \\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                temp[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\nOptimized approach :-\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            for(int j = i + 1; j < n ; j++){\\n                swap(matrix[i][j] , matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(matrix[i].begin() , matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400567,
                "title": "java-beats-100-0ms-runtime-o-1-space-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int columnLeft = 0;\\n        int columnRight = matrix.length - 1;\\n        int rowTop = 0;\\n        int rowBottom = matrix.length - 1;\\n\\n        while(columnLeft <= columnRight) {\\n            int p1 = columnLeft;\\n            int p2 = rowBottom;\\n            int p3 = columnRight;\\n            int p4 = rowTop;\\n\\n            for(int i = 1; i <= columnRight - columnLeft; i++) {\\n                int temp = matrix[rowTop][p1];\\n                matrix[rowTop][p1] = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = temp;\\n\\n                int temp2 = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = temp2; \\n\\n                int temp3 = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = matrix[p4][columnRight];\\n                matrix[p4][columnRight] = temp3;\\n\\n                p1++;\\n                p2--;\\n                p3--;\\n                p4++;\\n            }\\n            rowTop++;\\n            rowBottom--;\\n            columnLeft++;\\n            columnRight--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int columnLeft = 0;\\n        int columnRight = matrix.length - 1;\\n        int rowTop = 0;\\n        int rowBottom = matrix.length - 1;\\n\\n        while(columnLeft <= columnRight) {\\n            int p1 = columnLeft;\\n            int p2 = rowBottom;\\n            int p3 = columnRight;\\n            int p4 = rowTop;\\n\\n            for(int i = 1; i <= columnRight - columnLeft; i++) {\\n                int temp = matrix[rowTop][p1];\\n                matrix[rowTop][p1] = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = temp;\\n\\n                int temp2 = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = temp2; \\n\\n                int temp3 = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = matrix[p4][columnRight];\\n                matrix[p4][columnRight] = temp3;\\n\\n                p1++;\\n                p2--;\\n                p3--;\\n                p4++;\\n            }\\n            rowTop++;\\n            rowBottom--;\\n            columnLeft++;\\n            columnRight--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146840,
                "title": "easy-python3-solution-beats-94-run-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        lst=[]\\n        for i in zip(*matrix):\\n            lst.append(i[::-1])\\n        matrix[:]=lst\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        lst=[]\\n        for i in zip(*matrix):\\n            lst.append(i[::-1])\\n        matrix[:]=lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129882,
                "title": "rotate-image-best-approach-an-interview-question-for-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBefore Solution I would like to tell I got this question in one of my coding interview question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust transpose and observe the elements and swap the elements accordingly...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(N*2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n=len(matrix)\\n        #Transposing the Matrix\\n        for i in range(0,n):\\n            for j in range(i,n):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n        #shifting the elements accodingly...\\n        for i in range(0,n):\\n            for j in range(0,n//2):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[i][n-1-j]\\n                matrix[i][n-j-1]=temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n=len(matrix)\\n        #Transposing the Matrix\\n        for i in range(0,n):\\n            for j in range(i,n):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n        #shifting the elements accodingly...\\n        for i in range(0,n):\\n            for j in range(0,n//2):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[i][n-1-j]\\n                matrix[i][n-j-1]=temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117819,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://takeuforward.org/data-structure/rotate-image-by-90-degree/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i+1;j<matrix[0].size();j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n        }\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i+1;j<matrix[0].size();j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107117,
                "title": "0ms-easy-sol-expl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nj**ust apply transpose of a matrix\\nthen it\\'s column\\'s element will become just oppostive of required/rotated matrix so..\\n**we just take mirror image of that matrix (ref of middle line)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n  = m.size();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                swap(m[i][j], m[j][i]);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            reverse(m[i].begin(), m[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n  = m.size();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                swap(m[i][j], m[j][i]);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            reverse(m[i].begin(), m[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056560,
                "title": "8-lines-java-solution-100-fast",
                "content": "\\n# Approach\\nHi guys!\\n\\nThe idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp.\\n\\nHere\\'s a pretty concise code below.\\n![image.png](https://assets.leetcode.com/users/images/0052bc79-2f43-40c0-b05b-75d86e73bea6_1673831118.5476995.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public void rotate(int[][] M) {\\n        for (int i = 0; i < (M.length+1)/2; i++) {\\n            for (int j = 0; j < M.length/2; j++) {\\n                int tmp = M[i][j];\\n                M[i][j] = M[M.length-j-1][i];\\n                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                M[j][M.length-i-1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public void rotate(int[][] M) {\\n        for (int i = 0; i < (M.length+1)/2; i++) {\\n            for (int j = 0; j < M.length/2; j++) {\\n                int tmp = M[i][j];\\n                M[i][j] = M[M.length-j-1][i];\\n                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                M[j][M.length-i-1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998901,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n    }\\n}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n    }\\n}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928296,
                "title": "easy-to-understand-0ms-runtime-100-beat",
                "content": "# Intuition \\nUsing Concept of transpose.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst swap across diagonal then swap vertical imaginary mid line\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<i;j++){\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size()/2;j++){\\n                swap(m[i][n-1-j],m[i][j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<i;j++){\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size()/2;j++){\\n                swap(m[i][n-1-j],m[i][j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617602,
                "title": "easy-to-understand-typescript-solution-with-explanation",
                "content": "Sometimes, the obvious and easy way comes up our mind maybe is not efficient enough for computer. But the most elegant and efficient way for computer is not straightforward and intuitive. Hence, think outside of box. \\n\\nFor computer, the hard part is to transfer row to column, or column to row. But transpose a matrix is fairly easy. Take this as the first step, and try to find the pattern of final result.\\n\\n1. transpose the matrix\\n2. reverse each role\\n3. here comes the result: rotate the image by\\xA090 ****degrees (clockwise)\\n\\n![image](https://assets.leetcode.com/users/images/82e6b6d4-c06f-419c-a434-a0818b11f836_1664014035.099017.png)\\n\\n```ts\\nfunction rotate(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = i; j < matrix.length; j++) {\\n\\t\\t\\t// Transpose\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    // Reverse\\n    matrix.forEach(arr => arr.reverse());\\n};\\n```\\nWhat if the question ask anticlockwise? Just transpose the matrix by another diagonal.\\n```ts\\nfunction rotate2(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix.length - 1; j++) {\\n            [matrix[i][j], matrix[n-j-1][n-i-1]] = [matrix[n-j-1][n-i-1], matrix[i][j]];\\n        }\\n    }\\n    \\n    matrix.forEach(arr => arr.reverse());\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Matrix"
                ],
                "code": "```ts\\nfunction rotate(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = i; j < matrix.length; j++) {\\n\\t\\t\\t// Transpose\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    // Reverse\\n    matrix.forEach(arr => arr.reverse());\\n};\\n```\n```ts\\nfunction rotate2(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix.length - 1; j++) {\\n            [matrix[i][j], matrix[n-j-1][n-i-1]] = [matrix[n-j-1][n-i-1], matrix[i][j]];\\n        }\\n    }\\n    \\n    matrix.forEach(arr => arr.reverse());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503805,
                "title": "python-concise-and-clean-explained",
                "content": "![image](https://assets.leetcode.com/users/images/75941bf9-ef24-49aa-a34d-297163b40eef_1661845284.5558674.png)\\n\\nWe run over the perimeter and rotate the matrix.\\n\\nWe can make 3 swaps when we are standing on a single cell. For example cell `0,0` (value 1 in picture) will swap first wil `0, 2` (3). \\nThen `0,2` will have the final value - 1.\\nThen we can swap 0,0 with `2,2` (value 9 in picture). The reason is because `0,0` holds 3 now.\\nAnd finally we swap `0,0` which holds 9 now, with `2,0` (Value 7 in the picture).\\n\\nNow the cells `(0,0), (0, 2), (2,2) and (2,0)` are rotated.\\n\\nContinue this procedure for all the cells.\\n\\nNote: we are given `nxn` matrix, and every perimeter has 2 rows and 2 columns. Hence we simply need to run over n/2 perimeters.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        row = 0\\n        col = 0\\n        \\n        for _ in range(n//2):\\n            col_boundary = n - col - 1\\n            while col < col_boundary:\\n                # Swap 4 sides\\n                \\n                # Right side of the rotation\\n                matrix[row][col], matrix[col][n-1-row] = matrix[col][n-1-row], matrix[row][col]\\n                \\n                # Bottom side of the rotation\\n                matrix[row][col], matrix[n-1-row][n-1-col] = matrix[n-1-row][n-1-col], matrix[row][col]\\n                \\n                # Left side of the rotation\\n                matrix[row][col], matrix[n-1-col][row]  = matrix[n-1-col][row], matrix[row][col]\\n                \\n                col += 1\\n            \\n            row += 1\\n            col = row\\n```\\n\\n# Transpose, Reverse\\nYou can also transpose and then reverse the matrix.\\n\\nWhenever we rotate the matrix, rows becomes columns, hence transpose. And the order should be swapped (reversed).\\n\\nThis is a much more elegant solution.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def transpose():\\n            for r in range(m):\\n                for c in range(r + 1, n):\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n                    \\n        def reverse():\\n            for r in range(m):\\n                for c in range(n//2):\\n                    matrix[r][c], matrix[r][~c] = matrix[r][~c], matrix[r][c]\\n        \\n        transpose()\\n        reverse()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        row = 0\\n        col = 0\\n        \\n        for _ in range(n//2):\\n            col_boundary = n - col - 1\\n            while col < col_boundary:\\n                # Swap 4 sides\\n                \\n                # Right side of the rotation\\n                matrix[row][col], matrix[col][n-1-row] = matrix[col][n-1-row], matrix[row][col]\\n                \\n                # Bottom side of the rotation\\n                matrix[row][col], matrix[n-1-row][n-1-col] = matrix[n-1-row][n-1-col], matrix[row][col]\\n                \\n                # Left side of the rotation\\n                matrix[row][col], matrix[n-1-col][row]  = matrix[n-1-col][row], matrix[row][col]\\n                \\n                col += 1\\n            \\n            row += 1\\n            col = row\\n```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def transpose():\\n            for r in range(m):\\n                for c in range(r + 1, n):\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n                    \\n        def reverse():\\n            for r in range(m):\\n                for c in range(n//2):\\n                    matrix[r][c], matrix[r][~c] = matrix[r][~c], matrix[r][c]\\n        \\n        transpose()\\n        reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503307,
                "title": "c-simple-solution-very-easy-to-understand",
                "content": "TC=O(n^2)\\nSC=O(n^2)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=n-1,k=0;i>=0,k<n;i--,k++){\\n            for(int j=0;j<n;j++){\\n                v[j][k]=matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                matrix[i][j]=v[i][j];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=n-1,k=0;i>=0,k<n;i--,k++){\\n            for(int j=0;j<n;j++){\\n                v[j][k]=matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                matrix[i][j]=v[i][j];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160796,
                "title": "c-both-clockwise-and-anti-clockwise-rotation-easy-approach-reverse-and-swap",
                "content": "**Please Upvote if you found this helpful.**\\n\\nFor Clockwise Rotation\\n\\n```\\nvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j= i+1; j< matrix[i].size(); j++)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        return;\\n    }\\n```\\nFor Anti-clockwise Rotation\\n```\\nvoid rotateImage(vector<vector<int>> &matrix)                  \\n{\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        reverse(matrix[i].begin(), matrix[i].end());\\n    }\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        for(int j= i+1; j< matrix[i].size(); j++)\\n        {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    return;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j= i+1; j< matrix[i].size(); j++)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        return;\\n    }\\n```\n```\\nvoid rotateImage(vector<vector<int>> &matrix)                  \\n{\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        reverse(matrix[i].begin(), matrix[i].end());\\n    }\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        for(int j= i+1; j< matrix[i].size(); j++)\\n        {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2121639,
                "title": "detailed-step-wise-solution-c-for-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        /*  take diagonal from top left to botton right, \\n            * then swap the symmetry \\n            * 1 2 3     1 4 7   \\n            * 4 5 6  => 2 5 8  \\n            * 7 8 9     3 6 9    \\n        */\\n            \\n        for(int i=0; i<n; i++) {\\n            for(int j=i; j<n; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        /*  now swap 1st element with last of current row. \\n            * repeat till middle of current row.\\n            * 1 4 7     7 4 1 \\n            * 2 5 8  => 8 5 2\\n            * 3 6 9     9 6 3\\n        */\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n/2; j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        /*  take diagonal from top left to botton right, \\n            * then swap the symmetry \\n            * 1 2 3     1 4 7   \\n            * 4 5 6  => 2 5 8  \\n            * 7 8 9     3 6 9    \\n        */\\n            \\n        for(int i=0; i<n; i++) {\\n            for(int j=i; j<n; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        /*  now swap 1st element with last of current row. \\n            * repeat till middle of current row.\\n            * 1 4 7     7 4 1 \\n            * 2 5 8  => 8 5 2\\n            * 3 6 9     9 6 3\\n        */\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n/2; j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948933,
                "title": "c-0ms-very-easy-to-understand-only-5-6-line-code",
                "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n          int n=matrix.size();\\n       \\n       for(int i=0;i<n;i++)\\n           for(int j=0;j<i;j++)\\n               swap(matrix[i][j],matrix[j][i]);\\n        \\n        for(int i=0;i<n;i++)\\n            reverse(matrix[i].begin(),matrix[i].end());\\n    }\\n};\\n\\n\\n\\n*please upvote if u feel good to this code*",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n          int n=matrix.size();\\n       \\n       for(int i=0;i<n;i++)\\n           for(int j=0;j<i;j++)\\n               swap(matrix[i][j],matrix[j][i]);\\n        \\n        for(int i=0;i<n;i++)\\n            reverse(matrix[i].begin(),matrix[i].end());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1656258,
                "title": "c-easy-approach-transpose-of-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        //Transpose of Matrix(1st row -> 1st column,2nd row -> 2nd Column)\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        //Reverse the columns to get the matrix with 90 degree rotation\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n/2;j++)\\n            {\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        //Transpose of Matrix(1st row -> 1st column,2nd row -> 2nd Column)\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1539790,
                "title": "super-easy-solution-python-beats-90-time-85-memory",
                "content": "If we carefully look to input and output, one can observe simple trick:\\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]] \\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\\nElements from every subarray just appends to all other arrays. Starting from the last we can just append elements to all subarrays and pop current element:\\n[[1,2,3],[4,5,6],[7,8,9]] \\n[[1,2,3,7],[4,5,6],[8,9]] \\n[[1,2,3,7],[4,5,6,8],[9]] \\n[[1,2,3,7,4],[5,6,8],[9]] \\n[[1,2,3,7,4],[6,8,5],[9]] \\n[[2,3,7,4,1],[8,5],[9,6]] \\n[[3,7,4,1],[8,5,2],[9,6]] \\n[[7,4,1],[8,5,2],[9,6,3]] \\nUpvote, please, if this solution was useful and fun!)\\n```\\n        n = len(matrix)\\n        for i in range(n-1,-1,-1):\\n            p = 0\\n            for j in matrix[i][0:n]:\\n                matrix[p].append(j)\\n                matrix[i].pop(0)\\n                p += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        n = len(matrix)\\n        for i in range(n-1,-1,-1):\\n            p = 0\\n            for j in matrix[i][0:n]:\\n                matrix[p].append(j)\\n                matrix[i].pop(0)\\n                p += 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538687,
                "title": "c-100-faster-simple-solution",
                "content": "Entirely logic based solution. The idea is to divide matrix into several parts. \\nFirst we deal with the outermost rows and columns. Then we start moving inwards, thus making the matrix shorter over every step.\\n\\nWe only deal with 2 rows and 2 columns at any given time. \\n\\n3 swaps are required for a 90\\xBA turn. For example,\\nIn a 3x3 matrix (0-indexed) :\\nmatrix[0,0] <-> matrix[2,0]\\nmatrix[2,0] <-> matrix[2,2]\\nmatrix[2,2] <-> matrix[0,2]\\n\\nDoing the above will turn the outer-most rows and columns in a 3x3 matrix by 90\\xBA. The same logic can be generalised and applied for any **n x n** matrix.\\n\\nFor even number of columns, like 2x2, 4x4, 6x6, etc., the matrix can be easily segregated into parts containing 2 rows and 2 columns. For odd number of columns, the inner-most element need not be rotated, and hence, we are again left with a virtually even column matrix.\\n\\n**swapNum** is defined only for fast swapping using pointers. You can do it with library swap function also.\\n\\n**temp** is used to find parts of matrix. For example, in a 4x4 matrix, \\n* first part contains :\\n\\t* rows -> 1 and 4 (all elements)\\n\\t* columns -> 1 and 4 (all elements)\\n* second part contains :\\n\\t* rows -> 2 and 3 (only elements of column 2 and 3)\\n\\t* columns -> 2 and 3 (only elements of rows 2 and 3)\\n\\nComment below if you have any doubts !!!\\n\\n```\\nclass Solution {\\npublic:\\n    void swapNum(int* a, int* b){\\n        *a += *b;\\n        *b = *a - *b;\\n        *a -= *b;\\n    }\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        int i = 0;\\n        int j = matrix.size() - 1;\\n        int k = 0;\\n        \\n        int count = 0;\\n        \\n        int temp = matrix.size()/2;\\n        \\n        while(temp--){\\n            for(int i = count; i < matrix.size()-1-count; i++){\\n                swapNum(&matrix[i][k], &matrix[j-k][i]);\\n                swapNum(&matrix[j-k][i], &matrix[j-i][j-k]);\\n                swapNum(&matrix[j-i][j-k], &matrix[k][j-i]);\\n            }\\n            count++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swapNum(int* a, int* b){\\n        *a += *b;\\n        *b = *a - *b;\\n        *a -= *b;\\n    }\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        int i = 0;\\n        int j = matrix.size() - 1;\\n        int k = 0;\\n        \\n        int count = 0;\\n        \\n        int temp = matrix.size()/2;\\n        \\n        while(temp--){\\n            for(int i = count; i < matrix.size()-1-count; i++){\\n                swapNum(&matrix[i][k], &matrix[j-k][i]);\\n                swapNum(&matrix[j-k][i], &matrix[j-i][j-k]);\\n                swapNum(&matrix[j-i][j-k], &matrix[k][j-i]);\\n            }\\n            count++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214233,
                "title": "c-transpose-and-2-pointer-easy-approach-100-faster",
                "content": "class Solution {\\npublic:\\n    \\n    //We can solve this question in just 2 steps.\\n    //1.take the transpose of the matrix \\n    //2.swap every column using 2 pointer approach.\\n    \\n    1 2 3               1 4 7            7 4 1\\n    4 5 6    ==>        2 5 8   ==>      8 5 2\\n    7 8 9               3 6 9            9 6 3\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i,j;\\n        \\n        for(i =0;i<row;i++){\\n            for(j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //upper for loop will transpose the matrix.\\n        \\n        for(i=0,j=col-1 ; i<=j ; i++,j--){ //i and j are pointing to first and last column.\\n            for(int k=0;k<row;k++){\\n                swap(matrix[k][i],matrix[k][j]);\\n            }\\n        }\\n        //this for loop will swap the columns\\n    }\\n\\t//Upvote if you find it useful\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    //We can solve this question in just 2 steps.\\n    //1.take the transpose of the matrix \\n    //2.swap every column using 2 pointer approach.\\n    \\n    1 2 3               1 4 7            7 4 1\\n    4 5 6    ==>        2 5 8   ==>      8 5 2\\n    7 8 9               3 6 9            9 6 3\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i,j;\\n        \\n        for(i =0;i<row;i++){\\n            for(j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1175448,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& image) {\\n\\t\\t// transpose matrix\\n        for (int i = 0; i < image.size(); ++i) {\\n            for (int j = i; j < image.size(); ++j)\\n                swap(image[i][j], image[j][i]);\\n        }\\n\\t\\tfor(int i=0;i<image.size();i++)\\n             reverse(image[i].begin(),image[i].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& image) {\\n\\t\\t// transpose matrix\\n        for (int i = 0; i < image.size(); ++i) {\\n            for (int j = i; j < image.size(); ++j)\\n                swap(image[i][j], image[j][i]);\\n        }\\n\\t\\tfor(int i=0;i<image.size();i++)\\n             reverse(image[i].begin(),image[i].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078277,
                "title": "easy-to-understand-java-and-c-solution",
                "content": "1.) using java\\n```\\nclass Solution {\\n    public void transpose(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr[0].length; j++) {\\n                arr[i][j] ^= arr[j][i];\\n                arr[j][i] ^= arr[i][j];\\n                arr[i][j] ^= arr[j][i];\\n            }\\n        }\\n    }\\n    \\n    public void swaping(int[][] arr) {\\n        for (int j = 0; j < arr.length / 2; j++) {\\n            for (int i = 0; i < arr[0].length; i++) {\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n                arr[i][arr.length - j - 1] ^= arr[i][j];\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n            }\\n        }\\n    }\\n    \\n    public void rotate(int[][] matrix) {\\n        transpose(matrix);\\n        swaping(matrix);\\n    }\\n}\\n```\\n2.) another way using java\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix.length == 0)\\n            return;\\n        for (int i=0;i<matrix.length;i++)\\n            for (int j=i+1;j<matrix.length;j++)\\n            {\\n                matrix[i][j] = matrix[i][j] + matrix[j][i];\\n                matrix[j][i] = matrix[i][j] - matrix[j][i];\\n                matrix[i][j] = matrix[i][j] - matrix[j][i];\\n            }\\n        \\n        int si = 0, ei = matrix.length-1;\\n        while (si < ei){\\n            for (int i = 0; i < matrix.length; i++)\\n            {\\n                matrix[i][si] = matrix[i][si] + matrix[i][ei];\\n                matrix[i][ei] = matrix[i][si] - matrix[i][ei];\\n                matrix[i][si] = matrix[i][si] - matrix[i][ei];\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n}\\n```\\n3.) similarly using c++\\n```\\nauto SpeeUp = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        if (n == 0)\\n            return;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        int si = 0, ei = n-1;\\n        while (si < ei) {\\n            for (int i = 0; i < n; i++) {\\n                int temp = matrix[i][si];\\n                matrix[i][si] = matrix[i][ei];\\n                matrix[i][ei] = temp;\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void transpose(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr[0].length; j++) {\\n                arr[i][j] ^= arr[j][i];\\n                arr[j][i] ^= arr[i][j];\\n                arr[i][j] ^= arr[j][i];\\n            }\\n        }\\n    }\\n    \\n    public void swaping(int[][] arr) {\\n        for (int j = 0; j < arr.length / 2; j++) {\\n            for (int i = 0; i < arr[0].length; i++) {\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n                arr[i][arr.length - j - 1] ^= arr[i][j];\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n            }\\n        }\\n    }\\n    \\n    public void rotate(int[][] matrix) {\\n        transpose(matrix);\\n        swaping(matrix);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix.length == 0)\\n            return;\\n        for (int i=0;i<matrix.length;i++)\\n            for (int j=i+1;j<matrix.length;j++)\\n            {\\n                matrix[i][j] = matrix[i][j] + matrix[j][i];\\n                matrix[j][i] = matrix[i][j] - matrix[j][i];\\n                matrix[i][j] = matrix[i][j] - matrix[j][i];\\n            }\\n        \\n        int si = 0, ei = matrix.length-1;\\n        while (si < ei){\\n            for (int i = 0; i < matrix.length; i++)\\n            {\\n                matrix[i][si] = matrix[i][si] + matrix[i][ei];\\n                matrix[i][ei] = matrix[i][si] - matrix[i][ei];\\n                matrix[i][si] = matrix[i][si] - matrix[i][ei];\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nauto SpeeUp = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        if (n == 0)\\n            return;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        int si = 0, ei = n-1;\\n        while (si < ei) {\\n            for (int i = 0; i < n; i++) {\\n                int temp = matrix[i][si];\\n                matrix[i][si] = matrix[i][ei];\\n                matrix[i][ei] = temp;\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 602304,
                "title": "cpp-unable-to-submit-anything-initial-code-broken",
                "content": "Empty solution code:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n    }\\n};\\n```\\n\\ngenerates compile error\\n```\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type&amp; __x)\\n      ^\\n1 error generated.\\n```\\n\\n**Can someone fix this?**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n    }\\n};\\n```\n```\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type&amp; __x)\\n      ^\\n1 error generated.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404955,
                "title": "first-reverse-then-transpose",
                "content": "This is a 2 step solution: first reverse, then transpose. Please keep this in mind since it just illustrates the most simple approach to this problem.\\n\\nReversing a matrix simply means that you need to swap the order of rows. E.g. if you have matrix of 3 row/col, then swap first with last. If you have matrix of 4 rows/cols, then swap first with fourth, second with the third. The idea is simple, it\\'s the same as you reverse an array. Threat your matrix as an array in this case.\\n\\nThe next step is tranposing. Transposing means swaping rows with columns. \\nSo if you have your reversed matrix as \\n  ```\\n  [7, 8, 9],\\n  [4, 5, 6],\\n  [1, 2, 3]\\n  ```\\n  then you need to swap rows with columns, so first row becomes first column, second row becomes second column and so on:\\n  ```\\n  [7, 4, 1],\\n  [8, 5, 2],\\n  [9, 6, 3]\\n  ```\\n  \\nAnd that\\'s it! As simple as that! Took me some time to figure out.\\n\\nsome C# code (can be any other language with slight corrections):\\n```csharp\\n\\tpublic class Solution\\n\\t{\\n\\t\\tpublic void Rotate(int[][] matrix)\\n\\t\\t{\\n\\t\\t\\t// reverse\\n\\t\\t\\tArray.Reverse(matrix);\\n\\n\\t\\t\\t// transpose\\n\\t\\t\\tfor (var i = 0; i < matrix.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (var j = 0; j < i; ++j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar tmp = matrix[i][j];\\n\\t\\t\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\t\\t\\tmatrix[j][i] = tmp;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n  [7, 8, 9],\\n  [4, 5, 6],\\n  [1, 2, 3]\\n  ```\n```\\n  [7, 4, 1],\\n  [8, 5, 2],\\n  [9, 6, 3]\\n  ```\n```csharp\\n\\tpublic class Solution\\n\\t{\\n\\t\\tpublic void Rotate(int[][] matrix)\\n\\t\\t{\\n\\t\\t\\t// reverse\\n\\t\\t\\tArray.Reverse(matrix);\\n\\n\\t\\t\\t// transpose\\n\\t\\t\\tfor (var i = 0; i < matrix.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (var j = 0; j < i; ++j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar tmp = matrix[i][j];\\n\\t\\t\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\t\\t\\tmatrix[j][i] = tmp;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271648,
                "title": "solution-runs-in-4ms-with-c-and-a-brief-explanation-of-the-most-voted-solution",
                "content": "The most voted solution [\"A common method to rotate the image\"](https://leetcode.com/problems/rotate-image/discuss/18872/A-common-method-to-rotate-the-image) is really wonderful, but it seems that many people don\\'t know how it works. So I will show my view.\\n\\nBriefly, the action **\"first reverse up to down, then swap the symmetry\"** is same to `matrix[j][n - 1 - i] = matrixOld[i][j]`, where n means the length of the matrix.\\n\\nSo you can even solve this problem like this (run in 4ms with C++):\\n\\n```\\nvoid rotate(vector<vector<int> > & matrix) {\\n\\tvector<vector<int> > matrixOld = matrix; // To save the old matrix.\\n\\tint n = matrix.size();\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tmatrix[j][n - 1 - i] = matrixOld[i][j];\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nNow let me show how I get this.\\n\\nFirst we need to know that to rotate an image, we actually rotate each points of this image. \\nFor a given point **x(a, b)**. If we rotate it **\\u03B8** degrees around the coordinate origin **(0, 0)**, we get **x\\'(a\\', b\\')** where **a\\' = a * cos\\u03B8 - b * sin\\u03B8** and **b\\' = a * sin\\u03B8 + b * cos\\u03B8**. You can get this theory easily from [Wikipedia](https://en.wikipedia.org/wiki/Rotation_matrix). In this problem, **\\u03B8 = -90 degrees** so **a\\' = b** and **b\\' = -a** **[1]**.\\n\\nHowever, in this problem, the matrix does not rotate around the coordinate origin, but the point **((n - 1) / 2, (n - 1) / 2)** (index starts from 0). To deal with it, we merge two coordinates and set **offset = (n - 1) / 2** as the figure bellow shows. \\n\\n![image](https://assets.leetcode.com/users/zeroonecode/image_1554810183.png)\\n\\nFor a given point in both coordinates, represented by **x(a, b)** and **x(i, j)**, we get **a = j - offset** and **b = -i + offset** **[2]**.\\n\\nSubstituting **a**, **b**, **a\\'**, **b\\'** in **[1]** by **[2]**, we get:\\n**j\\' - offset = -i + offset** and **-i\\' + offset = -(j - offset)** =>\\n**j\\' = 2 * offset - i** and **i\\' = j**\\n\\nSince **offset = (n - 1) / 2**, substituting **offset** by **n**, we achieve **i\\' = j** and **j\\' = n - 1 - i**.",
                "solutionTags": [],
                "code": "```\\nvoid rotate(vector<vector<int> > & matrix) {\\n\\tvector<vector<int> > matrixOld = matrix; // To save the old matrix.\\n\\tint n = matrix.size();\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tmatrix[j][n - 1 - i] = matrixOld[i][j];\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18939,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Rotate Image** https://leetcode.com/problems/rotate-image/?tab=Description\\n\\n**Transpose and Reverse Rows**\\n1. Take the transpose and then reverse each row. https://discuss.leetcode.com/topic/9744/ac-java-in-place-solution-with-explanation-easy-to-understand\\n2. Reverse the matrix by the order of the rows. Then take a transpose. Check the code to transpose - notice we swap only the upper or lower diagonal. https://discuss.leetcode.com/topic/6796/a-common-method-to-rotate-the-image\\n3. How do we get solutions 1 and 2? Imagine a matrix of 3 by 3 on a table. Then imagine toppling it clockwise.That will tell you that clockwise rotation is really the transpose followed by reversing the order of columns. This is shown in the attached image. The same intuition can be used to derive anti-clockwise rotation. https://goo.gl/photos/yNqeCLumMLFEXBKs6 \\n\\n```\\nclass Solution(object):\\n    def transpose(self, matrix):\\n        M,N = len(matrix), len(matrix[0])\\n        cols = 1\\n        for i in range(M):\\n            for j in range(cols):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n            cols += 1\\n        return\\n    \\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        if matrix == []:\\n            return matrix\\n        self.transpose(matrix)\\n        for r in matrix:\\n            r.reverse()\\n        return\\n```\\n\\n**Swap four corners**\\n* Last algorithm is where we swap the four corners. The trick to cleanly swap the four corners is to fix [0,0]. Then swap [0,2] with [0,0]. Then swap [2,2] with [0,0]. Then swap [2,0] with [0,0]. Again check the image.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def transpose(self, matrix):\\n        M,N = len(matrix), len(matrix[0])\\n        cols = 1\\n        for i in range(M):\\n            for j in range(cols):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n            cols += 1\\n        return\\n    \\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        if matrix == []:\\n            return matrix\\n        self.transpose(matrix)\\n        for r in matrix:\\n            r.reverse()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19086,
                "title": "c-5-line-in-place-solution",
                "content": "        \\n    void rotate(vector<vector<int>>& matrix) {\\n        for (unsigned int i=0; i<matrix.size(); i++) // transpose\\n            for (unsigned int j=0; j<i; j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n        for (auto& row: matrix)  // reverse\\n            reverse(row.begin(), row.end());\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    void rotate(vector<vector<int>>& matrix) {\\n        for (unsigned int i=0; i<matrix.size(); i++) // transpose\\n            for (unsigned int j=0; j<i; j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n        for (auto& row: matrix)  // reverse\\n            reverse(row.begin(), row.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19160,
                "title": "share-my-java-solution-192ms",
                "content": "public class Solution {\\n\\n    public void rotate(int[][] matrix) {\\n\\n        if(matrix.length == 0 || matrix.length == 1){\\n            return;\\n        }\\n\\n        int temp = 0;\\n        int n = matrix.length - 1;\\n\\n        for(int i = 0; i < matrix.length - 1; i++){\\n            for(int j = 0; j + i < n; j++){\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[n-j][n-i];\\n                matrix[n-j][n-i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i< matrix.length / 2; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[n-i][j];\\n                matrix[n-i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\nAlgorithm:   m[i][j]  <->  m[n-j][n-i] \\n //First swap diagonally\\n                   m[i][j]  <->  matrix[n-i][j] \\n//  Second swap vertically",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public void rotate(int[][] matrix) {\\n\\n        if(matrix.length == 0 || matrix.length == 1){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3157091,
                "title": "easy-c-code-using-reverse-and-swap-function-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n    \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n    //   for(int j=0;j<n;j++){\\n    //       for(int i=0;i<n;i++){\\n    //            swap(matrix[j][n-i-1],matrix[j][i]);\\n    //             //  cout<<matrix[i][j]<<\" \";\\n        \\n    //       }\\n    //     }\\n    for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    // swap(matrix[0][0],matrix[0][2]);\\n// for(int i=0;i<n;i++){\\n//     for(int j=0;j<n;j++){\\n//                 cout<<matrix[i][j]<<\" \";\\n//     }\\n//     cout<<endl;\\n// }\\n// for(int i=0;i<n;i++){\\n//     swap(matrix[i][0],matrix[n-i-1][0]);\\n// }\\n\\n        // swap(matrix[i][j],matrix[i][n-j-1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n    \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n    //   for(int j=0;j<n;j++){\\n    //       for(int i=0;i<n;i++){\\n    //            swap(matrix[j][n-i-1],matrix[j][i]);\\n    //             //  cout<<matrix[i][j]<<\" \";\\n        \\n    //       }\\n    //     }\\n    for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    // swap(matrix[0][0],matrix[0][2]);\\n// for(int i=0;i<n;i++){\\n//     for(int j=0;j<n;j++){\\n//                 cout<<matrix[i][j]<<\" \";\\n//     }\\n//     cout<<endl;\\n// }\\n// for(int i=0;i<n;i++){\\n//     swap(matrix[i][0],matrix[n-i-1][0]);\\n// }\\n\\n        // swap(matrix[i][j],matrix[i][n-j-1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3083188,
                "title": "c-4-lines",
                "content": "# Code\\n```\\npublic class Solution {\\n    public void Rotate(int[][] matrix) {\\n        var max = matrix.Length - 1;\\n        for(var i = 0; i < matrix.Length / 2; i++) \\n            for(var j = i; j < max - i; j++)\\n                (matrix[i][j], matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i]) = (matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i], matrix[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void Rotate(int[][] matrix) {\\n        var max = matrix.Length - 1;\\n        for(var i = 0; i < matrix.Length / 2; i++) \\n            for(var j = i; j < max - i; j++)\\n                (matrix[i][j], matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i]) = (matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i], matrix[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807607,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid rotate(vector<vector<int>>& matrix) {\\n\\t\\t\\treverse(matrix.begin(), matrix.end());\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=i+1; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tswap(matrix[i][j], matrix[j][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n,,,",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid rotate(vector<vector<int>>& matrix) {\\n\\t\\t\\treverse(matrix.begin(), matrix.end());\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=i+1; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tswap(matrix[i][j], matrix[j][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2786897,
                "title": "python-reverse-and-swap-symmetry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can reverse the image clockwise\\n- and then swap it\\'s symmetry\\n\\n```\\n 1 2 3     7 8 9     7 4 1\\n 4 5 6  => 4 5 6  => 8 5 2\\n 7 8 9     1 2 3     9 6 3\\nOriginal   Reverse   Swap\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Reverse the image clockwise by reversing the matrix\\n    - Built-in python **reverse** operator\\n- Swapping image symmetry\\n    - we can do this by looping through the matrix right half triangle\\n    - **7** **8** **9**\\n      4 **5** **6**\\n      1 2 **3** \\n    - and then swapping the inverse of its coordinates\\n    - ```\\n      matrix[0][2], matrix[2][0] = matrix[2][0], matrix[0][2]\\n      ```\\n# Complexity\\n- Time complexity: $$O(h*w)$$ *(area of image)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(matrix not included)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i+1, len(matrix[i])):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```\\nCredits: https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n 1 2 3     7 8 9     7 4 1\\n 4 5 6  => 4 5 6  => 8 5 2\\n 7 8 9     1 2 3     9 6 3\\nOriginal   Reverse   Swap\\n```\n```\\n      matrix[0][2], matrix[2][0] = matrix[2][0], matrix[0][2]\\n      ```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i+1, len(matrix[i])):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687641,
                "title": "c-easy-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683680,
                "title": "c-transpose-reverse-with-step-by-step-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        /*\\n\\t\\t//exampe 1\\n\\t\\t1 2 3\\n\\t\\t4 5 6\\n\\t\\t7 8 9 \\n\\t\\t\\n        //transpose\\n        1 4 7\\n        2 5 8\\n        3 6 9\\n            \\n        //reverse\\n        7 4 1 \\n        8 5 2\\n        9 6 3\\n        */\\n\\t\\t\\n        int n = matrix.size();\\n\\t\\t\\n\\t\\t//transpose\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = r; c < n; ++c) {\\n                swap(matrix[r][c], matrix[c][r]);\\n            }\\n        }\\n        //reverse\\n        for (int r = 0; r < n; ++r) {\\n            reverse(matrix[r].begin(), matrix[r].end());\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        /*\\n\\t\\t//exampe 1\\n\\t\\t1 2 3\\n\\t\\t4 5 6\\n\\t\\t7 8 9 \\n\\t\\t\\n        //transpose\\n        1 4 7\\n        2 5 8\\n        3 6 9\\n            \\n        //reverse\\n        7 4 1 \\n        8 5 2\\n        9 6 3\\n        */\\n\\t\\t\\n        int n = matrix.size();\\n\\t\\t\\n\\t\\t//transpose\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = r; c < n; ++c) {\\n                swap(matrix[r][c], matrix[c][r]);\\n            }\\n        }\\n        //reverse\\n        for (int r = 0; r < n; ++r) {\\n            reverse(matrix[r].begin(), matrix[r].end());\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506123,
                "title": "0-ms-simple-java-code",
                "content": "```\\nclass Solution {\\n  public void rotate(int[][] matrix) {\\n    for (int i = 0, j = matrix.length - 1; i < j; ++i, --j) {\\n      int[] temp = matrix[i];\\n      matrix[i] = matrix[j];\\n      matrix[j] = temp;\\n    }\\n\\n    for (int i = 0; i < matrix.length; ++i)\\n      for (int j = i + 1; j < matrix.length; ++j) {\\n        final int temp = matrix[i][j];\\n        matrix[i][j] = matrix[j][i];\\n        matrix[j][i] = temp;\\n      }\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public void rotate(int[][] matrix) {\\n    for (int i = 0, j = matrix.length - 1; i < j; ++i, --j) {\\n      int[] temp = matrix[i];\\n      matrix[i] = matrix[j];\\n      matrix[j] = temp;\\n    }\\n\\n    for (int i = 0; i < matrix.length; ++i)\\n      for (int j = i + 1; j < matrix.length; ++j) {\\n        final int temp = matrix[i][j];\\n        matrix[i][j] = matrix[j][i];\\n        matrix[j][i] = temp;\\n      }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504047,
                "title": "rust-three-solutions-with-comments",
                "content": "There are several different pairs of transformations that result in a 90 degree rotation of the matrix. One is mirroring vertically, and then transposing:\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.reverse();\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nwhich I think is the most elegant and efficient, since the `.reverse()` operation is just n / 2 swaps of fat pointers. Another method is transposing and then mirroring horizontally:\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n    }\\n}\\n```\\n\\nwhich is less efficient since we have to do n * n / 2 swaps in the mirroring operation. And as an exercise, I also did the variation with horizontal mirroring followed by mirroring over the anti-diagonal, and I did it with functional-style Rust. Not at all as clean as the solutions above, but the idea here was to create chained iterators with the endpoints of all the relevant diagonals (corners do not need to be reversed), and then walk toward the middle of each diagonal, swapping elements as we go. Nice to use chained iterators and `successors`. :)\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n        let m = matrix.len();\\n        (1..m - 1)\\n            .map(|i| ((i, 0), (m - 1, m - i - 1)))\\n            .chain((0..m - 1).map(|j| ((0, j), (m - j - 1, m - 1))))\\n            .for_each(|coords| {\\n                std::iter::successors(Some(coords), |((r1, c1), (r2, c2))| {\\n                    Some(((*r1 + 1, *c1 + 1), (r2.wrapping_sub(1), c2.wrapping_sub(1))))\\n                })\\n                .take_while(|((r1, _), (r2, _))| *r1 < *r2)\\n                .for_each(|((r1, c1), (r2, c2))| {\\n                    let t = matrix[r1][c1];\\n                    matrix[r1][c1] = matrix[r2][c2];\\n                    matrix[r2][c2] = t;\\n                })\\n            })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.reverse();\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n        let m = matrix.len();\\n        (1..m - 1)\\n            .map(|i| ((i, 0), (m - 1, m - i - 1)))\\n            .chain((0..m - 1).map(|j| ((0, j), (m - j - 1, m - 1))))\\n            .for_each(|coords| {\\n                std::iter::successors(Some(coords), |((r1, c1), (r2, c2))| {\\n                    Some(((*r1 + 1, *c1 + 1), (r2.wrapping_sub(1), c2.wrapping_sub(1))))\\n                })\\n                .take_while(|((r1, _), (r2, _))| *r1 < *r2)\\n                .for_each(|((r1, c1), (r2, c2))| {\\n                    let t = matrix[r1][c1];\\n                    matrix[r1][c1] = matrix[r2][c2];\\n                    matrix[r2][c2] = t;\\n                })\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503386,
                "title": "simplest-0ms",
                "content": "Simply make transpose of matrix and then swap the first n/2 columns of matrix with last n/2 columns.\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        transpose(matrix);\\n\\n        swap(matrix);\\n        \\n    }\\n    \\n    private static void swap(int[][] arr){\\n        int n = arr.length;\\n        int times = (n / 2) - 1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            for(int j=0; j<=times; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[i][n-1-j];\\n                arr[i][n-1-j] = temp;\\n            }\\n        }\\n    }\\n\\n    private static void transpose(int[][] arr){\\n        for(int i=0; i<=arr.length-1; i++){\\n            for(int j=i+1; j<=arr[i].length-1; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[j][i];\\n                arr[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        transpose(matrix);\\n\\n        swap(matrix);\\n        \\n    }\\n    \\n    private static void swap(int[][] arr){\\n        int n = arr.length;\\n        int times = (n / 2) - 1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            for(int j=0; j<=times; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[i][n-1-j];\\n                arr[i][n-1-j] = temp;\\n            }\\n        }\\n    }\\n\\n    private static void transpose(int[][] arr){\\n        for(int i=0; i<=arr.length-1; i++){\\n            for(int j=i+1; j<=arr[i].length-1; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[j][i];\\n                arr[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503281,
                "title": "explained-and-easy-code-100-faster",
                "content": "please upvote if you like\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        //we are finding transpose of the matrix i.e.,changing rows to column and column to rows\\n        //[1 2 3]   [1 4 7]\\n        //[4 5 6] = [2 5 8]\\n        //[7 8 9]   [3 6 9]\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n               int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n                \\n            }\\n            \\n        }\\n        //now if we observe properly we only need to interchange columns i.e., first col interchnge with last \\n        //col....and so on until mid of the matrix\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][n-1-j];\\n                matrix[i][n-1-j]=temp;\\n            }\\n        }\\n        //yipeee!! we rotated the matrix by 90 degree\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        //we are finding transpose of the matrix i.e.,changing rows to column and column to rows\\n        //[1 2 3]   [1 4 7]\\n        //[4 5 6] = [2 5 8]\\n        //[7 8 9]   [3 6 9]\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n               int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n                \\n            }\\n            \\n        }\\n        //now if we observe properly we only need to interchange columns i.e., first col interchnge with last \\n        //col....and so on until mid of the matrix\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][n-1-j];\\n                matrix[i][n-1-j]=temp;\\n            }\\n        }\\n        //yipeee!! we rotated the matrix by 90 degree\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502986,
                "title": "20-ms-python-solution-mixed-nesting-algo",
                "content": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        n = len(matrix)\\n        for i in range(1,n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        return matrix\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        n = len(matrix)\\n        for i in range(1,n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502646,
                "title": "java-simple-and-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    \\n    public static void transpose(int [][]arr){\\n        \\n       for(int i=0;i<arr.length;i++){\\n           for(int j=0;j<i;j++){\\n               int temp=arr[i][j];\\n               arr[i][j]=arr[j][i];\\n               arr[j][i]=temp;\\n           }\\n       } \\n        \\n    }\\n      public static void reverse(int [][]arr){\\n       \\n       for(int r=0;r<arr.length;r++){\\n           int l=0,right=arr.length-1;\\n          while(l<right){\\n             int temp=arr[r][l];\\n              arr[r][l]=arr[r][right];\\n              arr[r][right]=temp;\\n              l++;\\n              right--;\\n              \\n          } \\n           \\n       }   \\n          \\n}\\n    public void rotate(int[][] matrix) {\\n        \\n        \\n       transpose(matrix);\\n        reverse(matrix);\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static void transpose(int [][]arr){\\n        \\n       for(int i=0;i<arr.length;i++){\\n           for(int j=0;j<i;j++){\\n               int temp=arr[i][j];\\n               arr[i][j]=arr[j][i];\\n               arr[j][i]=temp;\\n           }\\n       } \\n        \\n    }\\n      public static void reverse(int [][]arr){\\n       \\n       for(int r=0;r<arr.length;r++){\\n           int l=0,right=arr.length-1;\\n          while(l<right){\\n             int temp=arr[r][l];\\n              arr[r][l]=arr[r][right];\\n              arr[r][right]=temp;\\n              l++;\\n              right--;\\n              \\n          } \\n           \\n       }   \\n          \\n}\\n    public void rotate(int[][] matrix) {\\n        \\n        \\n       transpose(matrix);\\n        reverse(matrix);\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420546,
                "title": "just-in-two-steps-detailed-explanation-c-easy-approach",
                "content": "We Will Do It Just in two steps\\n**if you want to rotate the matrix 90**\\n\\t  **first -> transpose the matrix**(switch the row and column indices of the matrix )\\n\\t  **second ->reverse the columns of the matrix**(the first column will be the last on and so..)\\n \\t\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n    //first transpose the matrix\\n    for(int i=0; i<matrix.size(); i++){\\n        for(int j=i; j<matrix[0].size(); j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n    //second switch columns\\n    int i , j , k;\\n    for(i=0; i<matrix.size();i++){\\n        k = matrix[0].size()-1;\\n        for(j=0; j<matrix[0].size()/2;j++){\\n            swap(matrix[i][j],matrix[i][k--]);\\n        }\\n    }\\n}\\n//UPVOTE if it useful \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n    //first transpose the matrix\\n    for(int i=0; i<matrix.size(); i++){\\n        for(int j=i; j<matrix[0].size(); j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2183110,
                "title": "o-n-2-t-c-o-1-s-c-python-easy",
                "content": "**Please do upvote if you find this useful and don\\'t forget to comment if you have any doubts or suggestions**\\nSo we have to rotate each element by 90deg , so generally what we have to do is\\n topleft-> top right, \\n topright->bottom right,\\n bottom right-> bottomleft\\n bottom left -> top left\\n So basically we will maintain 4 pointers top,right,left,bottom to solve this.\\n And swap them accordingly .\\n We will start l from 0 and r from last element,\\n similarly with t and b.\\n \\n ```\\n class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l,r=0,len(matrix)-1\\n        while l<r:\\n            for i in range(r-l):\\n                t,b=l,r\\n                temp=matrix[t][l+i]\\n                matrix[t][l+i]=matrix[b-i][l]\\n                matrix[b-i][l]=matrix[b][r-i]\\n                matrix[b][r-i]=matrix[t+i][r]\\n                matrix[t+i][r]=temp\\n            l+=1\\n            r-=1\\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l,r=0,len(matrix)-1\\n        while l<r:\\n            for i in range(r-l):\\n                t,b=l,r\\n                temp=matrix[t][l+i]\\n                matrix[t][l+i]=matrix[b-i][l]\\n                matrix[b-i][l]=matrix[b][r-i]\\n                matrix[b][r-i]=matrix[t+i][r]\\n                matrix[t+i][r]=temp\\n            l+=1\\n            r-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049385,
                "title": "c-100-simple-solution-using-just-2-flips-step-by-step-visualization",
                "content": "- The keypoint is to understand how image rotation can be decomposed into simple operations like **vertical flip, horizontal flip and diagonal flips.**\\n- For this problem, we want to rotate image clock-wise by 90 degree. I approach this problem by first tracing each element and observe where they will be ended at.\\n<img src=\"https://assets.leetcode.com/users/images/6460e971-88f9-4ba5-88f5-571e67cce49a_1652831756.4832702.png\" alt=\"drawing\" width=\"400\"/> \\n\\n- Then I figure out rotating 90-deg clockwise is same as:\\n    - First, **diagonally flip** (transpose) image along upper-left and lower-right diagonal.\\n    - Second, **horizontally flip** (mirror flip) along central.\\n <img src=\"https://assets.leetcode.com/users/images/2463e3a8-c726-482a-85d4-e03cae89d728_1652831552.283336.png\" alt=\"drawing\" width=\"600\"/> \\n\\n**Solution:**\\n```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int height = matrix.size();\\n        int width = matrix[0].size();\\n        int temp;\\n        \\n        // flip diagonally (upper-left -> lower-right)\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = i+1; j < width; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n                \\n        // flip horizontally\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = 0; j < width/2; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][width-1-j];\\n                matrix[i][width-1-j] = temp;\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int height = matrix.size();\\n        int width = matrix[0].size();\\n        int temp;\\n        \\n        // flip diagonally (upper-left -> lower-right)\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = i+1; j < width; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n                \\n        // flip horizontally\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = 0; j < width/2; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][width-1-j];\\n                matrix[i][width-1-j] = temp;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1990884,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\nfun rotate(matrix: Array): Unit {\\nvar vik=Array(matrix.size){IntArray(matrix.size)}\\nfor(i in 0..matrix.size-1)\\n{\\nvar x=matrix.size-1\\nfor(j in 0..matrix.size-1)\\n{\\nvik[i][j]=matrix[x][i]\\nx--\\n}\\n}\\nfor(i in 0..matrix.size-1)\\n{\\n\\n        for(j in 0..matrix.size-1)\\n        {\\n            matrix[i][j]=vik[i][j]\\n        }\\n    }\\n    \\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```\\n```\n```\\n```\n```\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\nfun rotate(matrix: Array): Unit {\\nvar vik=Array(matrix.size){IntArray(matrix.size)}\\nfor(i in 0..matrix.size-1)\\n{\\nvar x=matrix.size-1\\nfor(j in 0..matrix.size-1)\\n{\\nvik[i][j]=matrix[x][i]\\nx--\\n}\\n}\\nfor(i in 0..matrix.size-1)\\n{\\n\\n        for(j in 0..matrix.size-1)\\n        {\\n            matrix[i][j]=vik[i][j]\\n        }\\n    }\\n    \\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862584,
                "title": "python-easy-solution",
                "content": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            \\n            for j in range(i+1 , len(matrix[i])):\\n                \\n                matrix[i][j] , matrix[j][i] = matrix[j][i] , matrix[i][j] \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            \\n            for j in range(i+1 , len(matrix[i])):\\n                \\n                matrix[i][j] , matrix[j][i] = matrix[j][i] , matrix[i][j] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1668284,
                "title": "c-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i,j,n=matrix.size();\\n        // Transposing first\\n        for(i=0; i<n; i++) {\\n            for(j=i; j<n; j++) {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\t\\t// Reverse each row\\n        for(int i=0; i<n;i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\n**If you like the solution, please upvote**\\n**For queries, pls comment**",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i,j,n=matrix.size();\\n        // Transposing first\\n        for(i=0; i<n; i++) {\\n            for(j=i; j<n; j++) {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\t\\t// Reverse each row\\n        for(int i=0; i<n;i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620798,
                "title": "simple-python-solution-with-explanation-96-15",
                "content": "\\tdef rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        self.transpose(matrix)\\n        self.reflect(matrix)\\n####     Made a function for transposing the matrix.\\n####     Here one thing to note is that the matrix will always be n x n\\n####     Will loop first through the length of the matrix\\n####    Then will start the loop from i+1 to the lenght because the i,i element will remain the same in transpose. So we don\\'t need that we need i,j element so that we can transpose it to j,i\\n\\tdef transpose(self, matrix):\\n         for i in range(len(matrix)):\\n                for j in range(i+1, len(matrix)):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n    \\n    # Now we need to reverse the elements in each row i.e relecting the matrix.\\n    def reflect(self,matrix):\\n        \\n        for i in range(len(matrix)): # Looping through the length of the matrix i.e row in our case\\n            for j in range(len(matrix) // 2): # This line is the heart of the code. Because here I won\\'t be iterating through the length. We just need to interchange the element except the middle element.\\n\\t\\t\\t\\tmatrix[i][j],  matrix[i][-j-1] = matrix[i][-j-1], matrix[i][j]\\n#### Let us say that the matrix is of 5 x 5 then for this loop the interation will just go for j<2. Why just 2 iterations?\\n#### Because here we just need to replace the element at the first and second index to the element at the last and the second last index respectively.\\n#### Same will happen with matrix of any number of length.\\n   ![image](https://assets.leetcode.com/users/images/838e8f04-5442-4922-ac7d-6173891834cb_1639107696.2475529.png)\\n\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        self.transpose(matrix)\\n        self.reflect(matrix)\\n####     Made a function for transposing the matrix.\\n####     Here one thing to note is that the matrix will always be n x n\\n####     Will loop first through the length of the matrix\\n####    Then will start the loop from i+1 to the lenght because the i,i element will remain the same in transpose. So we don\\'t need that we need i,j element so that we can transpose it to j,i\\n\\tdef transpose(self, matrix):\\n         for i in range(len(matrix)):\\n                for j in range(i+1, len(matrix)):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n    \\n    # Now we need to reverse the elements in each row i.e relecting the matrix.\\n    def reflect(self,matrix):\\n        \\n        for i in range(len(matrix)): # Looping through the length of the matrix i.e row in our case\\n            for j in range(len(matrix) // 2): # This line is the heart of the code. Because here I won\\'t be iterating through the length. We just need to interchange the element except the middle element.\\n\\t\\t\\t\\tmatrix[i][j],  matrix[i][-j-1] = matrix[i][-j-1], matrix[i][j]\\n#### Let us say that the matrix is of 5 x 5 then for this loop the interation will just go for j<2. Why just 2 iterations?\\n#### Because here we just need to replace the element at the first and second index to the element at the last and the second last index respectively.\\n#### Same will happen with matrix of any number of length.\\n   ![image](https://assets.leetcode.com/users/images/838e8f04-5442-4922-ac7d-6173891834cb_1639107696.2475529.png)\\n\\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1610865,
                "title": "java-easy-solution-100-0ms",
                "content": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =i+1;j<matrix.length;j++){\\n                swap(matrix,i,j);\\n            }\\n        }\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int  j=0;j<matrix.length/2;j++){\\n                swap1(matrix,i,j,matrix.length-1-j);\\n            }\\n        }\\n    }\\n    //for swapping rows\\n    public static void swap(int [][] arr,int i ,int j){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[j][i];\\n        arr[j][i]=temp;\\n    }\\n    //for swapping coloumns\\n    public static void swap1(int arr[][],int i ,int j,int k){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[i][k];\\n        arr[i][k]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =i+1;j<matrix.length;j++){\\n                swap(matrix,i,j);\\n            }\\n        }\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int  j=0;j<matrix.length/2;j++){\\n                swap1(matrix,i,j,matrix.length-1-j);\\n            }\\n        }\\n    }\\n    //for swapping rows\\n    public static void swap(int [][] arr,int i ,int j){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[j][i];\\n        arr[j][i]=temp;\\n    }\\n    //for swapping coloumns\\n    public static void swap1(int arr[][],int i ,int j,int k){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[i][k];\\n        arr[i][k]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598546,
                "title": "javascript-short-simple-two-loops",
                "content": "```\\nvar rotate = function(matrix) {\\n    matrix.reverse();\\n\\n    for (let i = 1; i < matrix.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            //console.log((JSON.stringify(matrix)).split(\"],[\").join(\"]\\\\n[\")); //helps to visualize matrix in console\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(matrix) {\\n    matrix.reverse();\\n\\n    for (let i = 1; i < matrix.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            //console.log((JSON.stringify(matrix)).split(\"],[\").join(\"]\\\\n[\")); //helps to visualize matrix in console\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513571,
                "title": "easy-java-solution",
                "content": "\\n``` java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n       for(int i=0; i<matrix.length; i++){\\n           for(int j=i; j<matrix[0].length; j++){\\n               int temp = matrix[i][j];\\n               matrix[i][j] = matrix[j][i];\\n               matrix[j][i] = temp;\\n           }\\n       }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```javascript []\\nvar rotate = function(matrix) {\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=i; j<matrix[0].length; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=0; j<matrix[0].length/2; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n       for(int i=0; i<matrix.length; i++){\\n           for(int j=i; j<matrix[0].length; j++){\\n               int temp = matrix[i][j];\\n               matrix[i][j] = matrix[j][i];\\n               matrix[j][i] = temp;\\n           }\\n       }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```javascript []\\nvar rotate = function(matrix) {\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=i; j<matrix[0].length; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=0; j<matrix[0].length/2; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418320,
                "title": "transpose-and-reverse-two-pointers-python-97-faster",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        for row in range(len(matrix)):\\n            for col in range(row, len(matrix)):\\n                matrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]\\n\\n        for i in range(len(matrix)):\\n            pt_a, pt_b = 0, len(matrix)-1\\n            while pt_a <= pt_b:\\n                matrix[i][pt_a], matrix[i][pt_b] = matrix[i][pt_b], matrix[i][pt_a]\\n                pt_a += 1\\n                pt_b -= 1\\n        \\n```\\n\\nComplexity: O(M) + O(1) \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        for row in range(len(matrix)):\\n            for col in range(row, len(matrix)):\\n                matrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]\\n\\n        for i in range(len(matrix)):\\n            pt_a, pt_b = 0, len(matrix)-1\\n            while pt_a <= pt_b:\\n                matrix[i][pt_a], matrix[i][pt_b] = matrix[i][pt_b], matrix[i][pt_a]\\n                pt_a += 1\\n                pt_b -= 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400011,
                "title": "c-faster-than-100-runtime-0ms",
                "content": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);\\n         }\\n     }  \\n        \\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);\\n         }\\n     }  \\n        \\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238431,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n\\t\\t/* What below loop does is - gets transpose of the matrix - \\n\\t\\tmeans rows value are interchanged with column values .\\n\\t\\t1 2 3        1 4 7\\n\\t\\t4 5 6  -->   2 5 8\\n\\t\\t7 8 9        3 6 9\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){ // j<=i - this statement here is imp - otherwise you will end up with the original matrix\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n                \\n            }\\n        }\\n        /* Now our matrix is transposed -\\n\\t\\tso we will reverse each row individually\\n\\t\\t1 4 7           7 4 1\\n\\t\\t2 5 8    -->    8 5 2\\n\\t\\t3 6 9           9 6 3\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){  // j<n/2 otherwise while reversing we will end up with the original row - so reverse till half of the row\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n-1-j];\\n                matrix[i][n-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nThanks for reading - do give it a thumbs up if you like the answer. :)",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n\\t\\t/* What below loop does is - gets transpose of the matrix - \\n\\t\\tmeans rows value are interchanged with column values .\\n\\t\\t1 2 3        1 4 7\\n\\t\\t4 5 6  -->   2 5 8\\n\\t\\t7 8 9        3 6 9\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){ // j<=i - this statement here is imp - otherwise you will end up with the original matrix\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n                \\n            }\\n        }\\n        /* Now our matrix is transposed -\\n\\t\\tso we will reverse each row individually\\n\\t\\t1 4 7           7 4 1\\n\\t\\t2 5 8    -->    8 5 2\\n\\t\\t3 6 9           9 6 3\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){  // j<n/2 otherwise while reversing we will end up with the original row - so reverse till half of the row\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n-1-j];\\n                matrix[i][n-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175516,
                "title": "c-the-simplest-easiest-4-line-solution-0-ms-faster-than-100",
                "content": "**My original solution:**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            vector<int> row = matrix[i];\\n            for(int j = i; j < matrix.size(); j++)\\n            {\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = row[j];\\n            }\\n        }\\n    }\\n};\\n```\\n**Fix - This solution can be reduced to only four lines:**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i<matrix.size();i++)\\n            for(int j=i; j<matrix.size();j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            vector<int> row = matrix[i];\\n            for(int j = i; j < matrix.size(); j++)\\n            {\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = row[j];\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i<matrix.size();i++)\\n            for(int j=i; j<matrix.size();j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818138,
                "title": "fast-python-solution",
                "content": "```\\nclass Solution:\\n    def rotate(self, matrix: list) -> None:\\n        l = len(matrix)\\n        for i in range(len(matrix) // 2):\\n            for j in range(i, len(matrix[i]) - i - 1):\\n                temp = matrix[i][j]\\n                matrix[i][j] = matrix[l - 1 - j][i]\\n                matrix[l - 1 - j][i] = matrix[l - 1 - i][l - 1 - j]\\n                matrix[l - 1 - i][l - 1 - j] = matrix[j][l - 1 - i]\\n                matrix[j][l - 1 - i] = temp\\n\\n```\\n![image](https://assets.leetcode.com/users/images/e1b453a2-96c1-4a26-b9ce-1cb67b8924b8_1598700034.229171.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: list) -> None:\\n        l = len(matrix)\\n        for i in range(len(matrix) // 2):\\n            for j in range(i, len(matrix[i]) - i - 1):\\n                temp = matrix[i][j]\\n                matrix[i][j] = matrix[l - 1 - j][i]\\n                matrix[l - 1 - j][i] = matrix[l - 1 - i][l - 1 - j]\\n                matrix[l - 1 - i][l - 1 - j] = matrix[j][l - 1 - i]\\n                matrix[j][l - 1 - i] = temp\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758295,
                "title": "java-100-fast-explanation",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n**MAIN IDEA**\\n1. Take the transpose of the matrix\\n2. Flip the matrix horizontally (using 2 pointer approach)\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n= matrix.length;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i; j<n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Swapping along the diagonal\\n\\t\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]= matrix[j][i];\\n\\t\\t\\t\\t matrix[j][i]= temp; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Now we will flip horizontally\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0; j<n/2 ;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//We need to swap the first and the last elements\\n\\t\\t\\t\\tint temp= matrix[i][j];\\n\\t\\t\\t\\t matrix[i][j]= matrix[i][n-j-1];\\n\\t\\t\\t\\t matrix[i][n-j-1]=temp;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n= matrix.length;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i; j<n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Swapping along the diagonal\\n\\t\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]= matrix[j][i];\\n\\t\\t\\t\\t matrix[j][i]= temp; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Now we will flip horizontally\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0; j<n/2 ;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//We need to swap the first and the last elements\\n\\t\\t\\t\\tint temp= matrix[i][j];\\n\\t\\t\\t\\t matrix[i][j]= matrix[i][n-j-1];\\n\\t\\t\\t\\t matrix[i][n-j-1]=temp;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570087,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1574669,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1698940,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1566321,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1573752,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1575708,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1565939,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1567522,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570119,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1569197,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570087,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1574669,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1698940,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1566321,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1573752,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1575708,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1565939,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1567522,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570119,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1569197,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1932668,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1942813,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1723264,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1710940,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1852123,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1573988,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1885991,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1881597,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1878170,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1859951,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1804263,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1763899,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1735337,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1573171,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1571116,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1571117,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1575018,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2076529,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2068058,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2067082,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2066350,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2060526,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2058753,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2051921,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2051704,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2046428,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2045329,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2033440,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2031322,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2019878,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2005086,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1988601,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1987609,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1986431,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1986230,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1961027,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1940169,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1935825,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1935574,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1934566,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1902983,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1899218,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1889231,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1876738,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1869698,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1853670,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1848988,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1834477,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1829524,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1820118,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1811982,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1811208,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1804563,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1804441,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1799393,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1795661,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1794789,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1778106,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1776376,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1775182,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1773692,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1766237,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1761685,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1752631,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1745521,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1733352,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1713584,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1709996,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1703028,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1699491,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort List",
        "question_content": "<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>\n",
        "solutions": [
            {
                "id": 1795126,
                "title": "c-merge-sort-2-pointer-easy-to-understand",
                "content": "# 148. Sort List\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)    **Link to LeetCode Repository**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n```\\n1. Using 2pointer / fast-slow pointer find the middle node of the list.\\n2. Now call mergeSort for 2 halves.\\n3. Merge the Sort List (divide and conqueror Approach)\\n```\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //If List Contain a Single or 0 Node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        \\n        ListNode *temp = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(fast !=  NULL && fast -> next != NULL)\\n        {\\n            temp = slow;\\n            slow = slow->next;          //slow increment by 1\\n            fast = fast ->next ->next;  //fast incremented by 2\\n            \\n        }   \\n        temp -> next = NULL;            //end of first left half\\n        \\n        ListNode* l1 = sortList(head);    //left half recursive call\\n        ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n        return mergelist(l1, l2);         //mergelist Function call\\n            \\n    }\\n    \\n    //MergeSort Function O(n*logn)\\n    ListNode* mergelist(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ptr = new ListNode(0);\\n        ListNode *curr = ptr;\\n        \\n        while(l1 != NULL && l2 != NULL)\\n        {\\n            if(l1->val <= l2->val)\\n            {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }\\n            else\\n            {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n        \\n        curr = curr ->next;\\n        \\n        }\\n        \\n        //for unqual length linked list\\n        \\n        if(l1 != NULL)\\n        {\\n            curr -> next = l1;\\n            l1 = l1->next;\\n        }\\n        \\n        if(l2 != NULL)\\n        {\\n            curr -> next = l2;\\n            l2 = l2 ->next;\\n        }\\n        \\n        return ptr->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\n```\\n1. Using 2pointer / fast-slow pointer find the middle node of the list.\\n2. Now call mergeSort for 2 halves.\\n3. Merge the Sort List (divide and conqueror Approach)\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //If List Contain a Single or 0 Node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        \\n        ListNode *temp = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(fast !=  NULL && fast -> next != NULL)\\n        {\\n            temp = slow;\\n            slow = slow->next;          //slow increment by 1\\n            fast = fast ->next ->next;  //fast incremented by 2\\n            \\n        }   \\n        temp -> next = NULL;            //end of first left half\\n        \\n        ListNode* l1 = sortList(head);    //left half recursive call\\n        ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n        return mergelist(l1, l2);         //mergelist Function call\\n            \\n    }\\n    \\n    //MergeSort Function O(n*logn)\\n    ListNode* mergelist(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ptr = new ListNode(0);\\n        ListNode *curr = ptr;\\n        \\n        while(l1 != NULL && l2 != NULL)\\n        {\\n            if(l1->val <= l2->val)\\n            {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }\\n            else\\n            {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n        \\n        curr = curr ->next;\\n        \\n        }\\n        \\n        //for unqual length linked list\\n        \\n        if(l1 != NULL)\\n        {\\n            curr -> next = l1;\\n            l1 = l1->next;\\n        }\\n        \\n        if(l2 != NULL)\\n        {\\n            curr -> next = l2;\\n            l2 = l2 ->next;\\n        }\\n        \\n        return ptr->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795343,
                "title": "c-detailed-explanation-w-comments-easy-to-understand-code",
                "content": "***Brief note about Question-***\\n* We have to *return the linked list after sorting it in ascending order.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose head of linked list given to us is like, head: [3,-9,8,67,9]\\n\\nthen answer should like [-9,3,8,9,67] after sorting it in ascending order.\\n```\\n_______\\n***Solution - I (Using Merge sort, Accepted)-***\\n* We want to sort a linked list, then we may able to use any of the sorting algorithm and then apply on it.\\n* We will use merge sort here, because I find it easy to implement in linked list.\\n* Whole implementation totally based on the merge sort, so i strongly suggest you to read a article on the merge sort.\\n* Some basic thing that we will do in applying merge sort on our linked list are-\\n* We divide our linked liist into two equal parts until when only one element is left.\\n* After that we start merge them on the basis of value.\\n* Now, if we divide them into two equal parts then then how we will find mid in linked list.\\n* We find mid of linked list using tortise and hare method or say using fast and slow pointer.\\n* See commented code for more explanation.\\n____________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    // function that divides linked list into half parts, and after sorting use to merge them\\n    void mergesorting(ListNode** head) \\n    {\\n        ListNode* curr = *head; // make a current pointer \\n        ListNode* first; // for the first half\\n        ListNode* second; // for the second half\\n        \\n        // if linked list is null or just having a single elemrnt then simple return. because we don\\'t have to do anything\\n        if(curr == NULL || curr -> next == NULL)\\n            return;\\n        \\n        findmid(curr, &first,&second); // function used to find mid in b/w the\\n        \\n        //again call merrge sorting for first half, so it again divides first half into two and for that again....till when only one element is left\\n        mergesorting(&first); \\n        \\n        //again call merrge sorting for second half, so it again divides second half into two and for that again....till when only one element is left\\n        mergesorting(&second);\\n        \\n        *head = merge(first,second); // and at last merge oyr first half and second half\\n    }\\n    \\n    // function to find mid, we use hare and tortise meethod to find mid\\n    void findmid(ListNode* curr, ListNode** first, ListNode** second)\\n    {\\n        ListNode* slow = curr; // make a slow pointer\\n        ListNode* fast = curr -> next; // make a fast pointer\\n        \\n        // then we move our fast upto it not become null, means not reach on last position\\n        while(fast != NULL)\\n        {\\n            fast = fast -> next;\\n            if(fast != NULL)\\n            {\\n                fast = fast -> next;\\n                slow = slow -> next;\\n            }\\n        }\\n        \\n        // after this assign curr to first\\n        *first = curr;\\n        *second = slow -> next; // second to slow next\\n        slow -> next = NULL; // and put slow next to null\\n    }\\n    \\n    // function used to merge first and second pointer\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* answer = NULL; // define answer to null\\n        \\n        if(first == NULL) // if first is null, then what to merge...nothing\\n        {\\n            return second; // return second\\n        }\\n        \\n        if(second == NULL) // if second is null, then what to merge...nothing\\n        {\\n            return first; // return first\\n        }\\n        \\n        // if value of first is less than value of second,then give answer to first\\n        if(first -> val <= second -> val) \\n        {\\n            answer = first;\\n            answer -> next = merge(first -> next, second); // and again call merge for answer\\'s next\\n        }\\n        else // else give answer to second\\n        {\\n            answer = second;\\n            answer -> next = merge(first, second -> next); // and again call merge for answer\\'s next\\n        }\\n        \\n        return answer; // finally return answer\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        // paasing pointer as reference, so that changes are reflected\\n        mergesorting(&head); \\n        \\n        return head;\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose head of linked list given to us is like, head: [3,-9,8,67,9]\\n\\nthen answer should like [-9,3,8,9,67] after sorting it in ascending order.\\n```\n```\\nclass Solution {\\npublic:\\n    // function that divides linked list into half parts, and after sorting use to merge them\\n    void mergesorting(ListNode** head) \\n    {\\n        ListNode* curr = *head; // make a current pointer \\n        ListNode* first; // for the first half\\n        ListNode* second; // for the second half\\n        \\n        // if linked list is null or just having a single elemrnt then simple return. because we don\\'t have to do anything\\n        if(curr == NULL || curr -> next == NULL)\\n            return;\\n        \\n        findmid(curr, &first,&second); // function used to find mid in b/w the\\n        \\n        //again call merrge sorting for first half, so it again divides first half into two and for that again....till when only one element is left\\n        mergesorting(&first); \\n        \\n        //again call merrge sorting for second half, so it again divides second half into two and for that again....till when only one element is left\\n        mergesorting(&second);\\n        \\n        *head = merge(first,second); // and at last merge oyr first half and second half\\n    }\\n    \\n    // function to find mid, we use hare and tortise meethod to find mid\\n    void findmid(ListNode* curr, ListNode** first, ListNode** second)\\n    {\\n        ListNode* slow = curr; // make a slow pointer\\n        ListNode* fast = curr -> next; // make a fast pointer\\n        \\n        // then we move our fast upto it not become null, means not reach on last position\\n        while(fast != NULL)\\n        {\\n            fast = fast -> next;\\n            if(fast != NULL)\\n            {\\n                fast = fast -> next;\\n                slow = slow -> next;\\n            }\\n        }\\n        \\n        // after this assign curr to first\\n        *first = curr;\\n        *second = slow -> next; // second to slow next\\n        slow -> next = NULL; // and put slow next to null\\n    }\\n    \\n    // function used to merge first and second pointer\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* answer = NULL; // define answer to null\\n        \\n        if(first == NULL) // if first is null, then what to merge...nothing\\n        {\\n            return second; // return second\\n        }\\n        \\n        if(second == NULL) // if second is null, then what to merge...nothing\\n        {\\n            return first; // return first\\n        }\\n        \\n        // if value of first is less than value of second,then give answer to first\\n        if(first -> val <= second -> val) \\n        {\\n            answer = first;\\n            answer -> next = merge(first -> next, second); // and again call merge for answer\\'s next\\n        }\\n        else // else give answer to second\\n        {\\n            answer = second;\\n            answer -> next = merge(first, second -> next); // and again call merge for answer\\'s next\\n        }\\n        \\n        return answer; // finally return answer\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        // paasing pointer as reference, so that changes are reflected\\n        mergesorting(&head); \\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46714,
                "title": "java-merge-sort-solution",
                "content": "    public class Solution {\\n      \\n      public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n          return head;\\n            \\n        // step 1. cut the list to two halves\\n        ListNode prev = null, slow = head, fast = head;\\n        \\n        while (fast != null && fast.next != null) {\\n          prev = slow;\\n          slow = slow.next;\\n          fast = fast.next.next;\\n        }\\n        \\n        prev.next = null;\\n        \\n        // step 2. sort each half\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        \\n        // step 3. merge l1 and l2\\n        return merge(l1, l2);\\n      }\\n      \\n      ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode l = new ListNode(0), p = l;\\n        \\n        while (l1 != null && l2 != null) {\\n          if (l1.val < l2.val) {\\n            p.next = l1;\\n            l1 = l1.next;\\n          } else {\\n            p.next = l2;\\n            l2 = l2.next;\\n          }\\n          p = p.next;\\n        }\\n        \\n        if (l1 != null)\\n          p.next = l1;\\n        \\n        if (l2 != null)\\n          p.next = l2;\\n        \\n        return l.next;\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n      \\n      public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n          return head;\\n            \\n        // step 1. cut the list to two halves\\n        ListNode prev = null, slow = head, fast = head;\\n        \\n        while (fast != null && fast.next != null) {\\n          prev = slow;\\n          slow = slow.next;\\n          fast = fast.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 46712,
                "title": "bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity",
                "content": "this problem can be easily solved using recurrence and divide-and-conquer. But it consumes program stack to store the recurring function stack frame, actually it consumes o(lgn) space complexity. Recursion use up-to-bottom strategy , why not try the opposite way--bottom-to-up, luckily it works, it only consumes 0(1) space complexity and o(nlgn) time complextity.\\n\\n    /**\\n     * Merge sort use bottom-up policy, \\n     * so Space Complexity is O(1)\\n     * Time Complexity is O(NlgN)\\n     * stable sort\\n    */\\n    class Solution {\\n    public:\\n    \\tListNode *sortList(ListNode *head) {\\n    \\t\\tif(!head || !(head->next)) return head;\\n    \\t\\t\\n    \\t\\t//get the linked list's length\\n    \\t\\tListNode* cur = head;\\n    \\t\\tint length = 0;\\n    \\t\\twhile(cur){\\n    \\t\\t\\tlength++;\\n    \\t\\t\\tcur = cur->next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode dummy(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode *left, *right, *tail;\\n    \\t\\tfor(int step = 1; step < length; step <<= 1){\\n    \\t\\t\\tcur = dummy.next;\\n    \\t\\t\\ttail = &dummy;\\n    \\t\\t\\twhile(cur){\\n    \\t\\t\\t\\tleft = cur;\\n    \\t\\t\\t\\tright = split(left, step);\\n    \\t\\t\\t\\tcur = split(right,step);\\n    \\t\\t\\t\\ttail = merge(left, right, tail);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}\\n    private:\\n    \\t/**\\n    \\t * Divide the linked list into two lists,\\n         * while the first list contains first n ndoes\\n    \\t * return the second list's head\\n    \\t */\\n    \\tListNode* split(ListNode *head, int n){\\n    \\t\\t//if(!head) return NULL;\\n    \\t\\tfor(int i = 1; head && i < n; i++) head = head->next;\\n    \\t\\t\\n    \\t\\tif(!head) return NULL;\\n    \\t\\tListNode *second = head->next;\\n    \\t\\thead->next = NULL;\\n    \\t\\treturn second;\\n    \\t}\\n    \\t/**\\n    \\t  * merge the two sorted linked list l1 and l2,\\n    \\t  * then append the merged sorted linked list to the node head\\n    \\t  * return the tail of the merged sorted linked list\\n    \\t */\\n    \\tListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){\\n    \\t\\tListNode *cur = head;\\n    \\t\\twhile(l1 && l2){\\n    \\t\\t\\tif(l1->val > l2->val){\\n    \\t\\t\\t\\tcur->next = l2;\\n    \\t\\t\\t\\tcur = l2;\\n    \\t\\t\\t\\tl2 = l2->next;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcur->next = l1;\\n    \\t\\t\\t\\tcur = l1;\\n    \\t\\t\\t\\tl1 = l1->next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tcur->next = (l1 ? l1 : l2);\\n    \\t\\twhile(cur->next) cur = cur->next;\\n    \\t\\treturn cur;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tListNode *sortList(ListNode *head) {\\n    \\t\\tif(!head || !(head->next)) return head;\\n    \\t\\t\\n    \\t\\t//get the linked list's length\\n    \\t\\tListNode* cur = head;\\n    \\t\\tint length = 0;\\n    \\t\\twhile(cur){\\n    \\t\\t\\tlength++;\\n    \\t\\t\\tcur = cur->next;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 166324,
                "title": "python-c-c-java-legit-iterative-solutions-o-1-space-no-recursion-with-detailed-explaination",
                "content": "# **TL;DR**\\n### **Short and sweet. O(nlogn) time, O(1) space.**\\n``` python []\\ndef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  dummy = ListNode(0)\\n  dummy.next = head\\n\\n  # Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  steps = 1\\n  while True:\\n    # Record the progress of the current pass into a single semi sorted list by updating\\n    # the next of the previous node (or the dummy on the first loop)\\n    prev = dummy\\n\\n    # Keep track of how much is left to process on this pass of the list\\n    remaining = prev.next\\n\\n    # While the current pass though the list has not been completed\\n    num_loops = 0\\n    while remaining:\\n      num_loops += 1\\n\\n      # Split 2 sublists of steps length from the front\\n      sublists = [None, None]\\n      sublists_tail = [None, None]\\n      for i in range(2):\\n        sublists[i] = remaining\\n        substeps = steps\\n        while substeps and remaining:\\n          substeps -= 1\\n          sublists_tail[i] = remaining\\n          remaining = remaining.next\\n        # Ensure the subslist (if one was made) is terminated\\n        if sublists_tail[i]:\\n          sublists_tail[i].next = None\\n\\n      # We have two sublists of (upto) length step that are sorted, merge them onto \\n      # the end into a single list of (upto) step * 2\\n      while sublists[0] and sublists[1]:\\n        if sublists[0].val <= sublists[1].val:\\n          prev.next = sublists[0]\\n          sublists[0] = sublists[0].next\\n        else:\\n          prev.next = sublists[1]\\n          sublists[1] = sublists[1].next\\n        prev = prev.next\\n      \\n      # One list has been finished, attach what ever is left of the other to the end\\n      if sublists[0]:\\n        prev.next = sublists[0]\\n        prev = sublists_tail[0]\\n      else:\\n        prev.next = sublists[1]\\n        prev = sublists_tail[1]\\n    \\n    # Double the steps each go around\\n    steps *= 2\\n\\n    # If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if 1 >= num_loops:\\n      return dummy.next\\n```\\n\\n``` c []\\nstruct ListNode* sortList(struct ListNode* head){\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= 2) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split 2 sublists of steps length from the front */\\n      struct ListNode* sublists[2];\\n      struct ListNode* sublists_tail[2] = {NULL, NULL};\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        /* Ensure the subslist (if one was made) is terminated */\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      /* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */\\n      while (sublists[0] && sublists[1]) {\\n        if (sublists[0]->val <= sublists[1]->val) {\\n          *next_ptr = sublists[0];\\n          next_ptr = &sublists[0]->next;\\n          sublists[0] = sublists[0]->next;\\n        } else {\\n          *next_ptr = sublists[1];\\n          next_ptr = &sublists[1]->next;\\n          sublists[1] = sublists[1]->next;\\n        }\\n      }   \\n\\n      /* One list has been finished, attach what ever is left of the other to the end */\\n      if (sublists[0]) {\\n        *next_ptr = sublists[0];\\n        next_ptr = &sublists_tail[0]->next;\\n      } else {\\n        *next_ptr = sublists[1];\\n        next_ptr = &sublists_tail[1]->next;\\n      }\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\\n\\n``` cpp []\\nListNode* sortList(ListNode* head) {\\n  // Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  for (int steps = 1;; steps *= 2) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split 2 sublists of steps length from the front\\n      ListNode* sublists[2];\\n      ListNode* sublists_tail[2] = {nullptr, nullptr};\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = nullptr;\\n        }\\n      }\\n\\n      // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n      while (sublists[0] && sublists[1]) {\\n        if (sublists[0]->val <= sublists[1]->val) {\\n          *next_ptr = sublists[0];\\n          next_ptr = &sublists[0]->next;\\n          sublists[0] = sublists[0]->next;\\n        } else {\\n          *next_ptr = sublists[1];\\n          next_ptr = &sublists[1]->next;\\n          sublists[1] = sublists[1]->next;\\n        }\\n      }   \\n\\n      // One list has been finished, attach what ever is left of the other to the end\\n      if (sublists[0]) {\\n        *next_ptr = sublists[0];\\n        next_ptr = &sublists_tail[0]->next;\\n      } else {\\n        *next_ptr = sublists[1];\\n        next_ptr = &sublists_tail[1]->next;\\n      }\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  } \\n}\\n```\\n\\n``` java []\\npublic ListNode sortList(ListNode head) {\\n  ListNode dummy = new ListNode(0);\\n  dummy.next = head;\\n\\n  ListNode [] sublists = new ListNode[2];\\n  ListNode [] sublists_tail = new ListNode[2];\\n\\n  // Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  for (int steps = 1;; steps *= 2) {\\n    // Record the progress of the current pass into a single semi sorted list by updating\\n    // the next of the previous node (or the dummy on the first loop)\\n    ListNode prev = dummy;\\n\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode remaining = prev.next;\\n\\n    int num_loops = 0;\\n    for (; null != remaining; ++num_loops) {\\n      // Split 2 sublists of steps length from the front\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = null;\\n        for (int j = 0; null != remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining.next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (null != sublists_tail[i]) {\\n          sublists_tail[i].next = null;\\n        }\\n      }\\n\\n      // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n      while (null != sublists[0] && null != sublists[1]) {\\n        if (sublists[0].val <= sublists[1].val) {\\n          prev.next = sublists[0];\\n          sublists[0] = sublists[0].next;\\n        } else {\\n          prev.next = sublists[1];\\n          sublists[1] = sublists[1].next;\\n        }\\n        prev = prev.next;\\n      }   \\n\\n      // One list has been finished, attach what ever is left of the other to the end\\n      if (null != sublists[0]) {\\n        prev.next = sublists[0];\\n        prev = sublists_tail[0];\\n      } else {\\n        prev.next = sublists[1];\\n        prev = sublists_tail[1];\\n      }\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return dummy.next;\\n    }\\n  }\\n}\\n```\\n\\n### **Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant.**\\nCode is a little more complex, can make a big performance difference. See desciption below.\\n``` python []\\ndef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  buffer_size = 8\\n\\n  dummy = ListNode(0)\\n  dummy.next = head\\n\\n  # Grab sublists of size 1, then buffer_size, then buffer_size^2, etc, until fully merged\\n  steps = 1\\n  while True:\\n    # Record the progress of the current pass into a single semi sorted list by updating\\n    # the next of the previous node (or the dummy on the first loop)\\n    prev = dummy\\n\\n    # Keep track of how much is left to process on this pass of the list\\n    remaining = prev.next\\n\\n    # While the current pass though the list has not been completed\\n    num_loops = 0\\n    while remaining:\\n      num_loops += 1\\n\\n      # Split buffer_size sublists of upto steps length from the front\\n      sublists = [None] * buffer_size\\n      sublists_tail = [None] * buffer_size\\n      for i in range(buffer_size):\\n        sublists[i] = remaining\\n        substeps = steps\\n        while substeps and remaining:\\n          substeps -= 1\\n          sublists_tail[i] = remaining\\n          remaining = remaining.next\\n        # Ensure the subslist (if one was made) is terminated\\n        if sublists_tail[i]:\\n          sublists_tail[i].next = None\\n\\n      # Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      # That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      num_sublists = buffer_size\\n      while 1 < num_sublists:\\n        # Merge each pair of sublists\\n        subdummy = ListNode()\\n        for i in range(0, num_sublists, 2):\\n          subprev = subdummy;\\n          subprev.next = None\\n\\n          # We have two sublists of (upto) length step that are sorted, merge them onto \\n          # the end into a single list of (upto) step * 2\\n          while sublists[i] and sublists[i + 1]:\\n            if sublists[i].val <= sublists[i + 1].val:\\n              subprev.next = sublists[i]\\n              sublists[i] = sublists[i].next\\n            else:\\n              subprev.next = sublists[i + 1]\\n              sublists[i + 1] = sublists[i + 1].next\\n            subprev = subprev.next\\n      \\n          # One list has been finished, attach what ever is left of the other to the end\\n          if sublists[i]:\\n            subprev.next = sublists[i]\\n            sublists_tail[i // 2] = sublists_tail[i]\\n          else:\\n            subprev.next = sublists[i + 1]\\n            sublists_tail[i // 2] = sublists_tail[i + 1]\\n\\n          # Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i // 2] = subdummy.next;\\n\\n        # Half the sublists remain now that we have merged each pair of lists\\n        num_sublists //= 2\\n\\n      # Attach the single sublist into this passes progress\\n      prev.next = sublists[0];\\n      prev = sublists_tail[0];\\n    \\n    # Increase the steps each go around\\n    steps *= buffer_size\\n\\n    # If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if 1 >= num_loops:\\n      return dummy.next\\n```\\n\\n``` c []\\n\\nstruct ListNode* sortList(struct ListNode* head){\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      struct ListNode* sublists_tail[BUFFER_SIZE];\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = NULL;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        /* Ensure the subslist (if one was made) is terminated */\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      /*\\n      Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      */\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        /* Merge each pair of sublists */\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          struct ListNode* subhead = NULL;\\n          struct ListNode** sub_next_ptr = &subhead;\\n      \\n          /* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */\\n          while (sublists[i] && sublists[i + 1]) {\\n            if (sublists[i]->val <= sublists[i + 1]->val) {\\n              *sub_next_ptr = sublists[i];\\n              sub_next_ptr = &sublists[i]->next;\\n              sublists[i] = sublists[i]->next;\\n            } else {\\n              *sub_next_ptr = sublists[i + 1];\\n              sub_next_ptr = &sublists[i + 1]->next;\\n              sublists[i + 1] = sublists[i + 1]->next;\\n            }\\n          }\\n\\n          /* One list has been finished, attach what ever is left of the other to the end */\\n          if (sublists[i]) {\\n            *sub_next_ptr = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            *sub_next_ptr = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          /* Record the head of our new longer sublist in the correct location for the next loop around */\\n          sublists[i / 2] = subhead;\\n        }\\n      }\\n\\n      /* Attach the single sublist into this passes progress */\\n      *next_ptr = sublists[0];\\n      next_ptr = &sublists_tail[0]->next;\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\\n\\n```cpp []\\nListNode* sortList(ListNode* head) {\\n  constexpr const int BUFFER_SIZE = 8;\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      ListNode* sublists[BUFFER_SIZE];\\n      ListNode* sublists_tail[BUFFER_SIZE];\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = NULL;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          ListNode* subhead = NULL;\\n          ListNode** sub_next_ptr = &subhead;\\n      \\n          // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n          while (sublists[i] && sublists[i + 1]) {\\n            if (sublists[i]->val <= sublists[i + 1]->val) {\\n              *sub_next_ptr = sublists[i];\\n              sub_next_ptr = &sublists[i]->next;\\n              sublists[i] = sublists[i]->next;\\n            } else {\\n              *sub_next_ptr = sublists[i + 1];\\n              sub_next_ptr = &sublists[i + 1]->next;\\n              sublists[i + 1] = sublists[i + 1]->next;\\n            }\\n          }\\n\\n          // One list has been finished, attach what ever is left of the other to the end\\n          if (sublists[i]) {\\n            *sub_next_ptr = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            *sub_next_ptr = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subhead;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      *next_ptr = sublists[0];\\n      next_ptr = &sublists_tail[0]->next;\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\\n\\n```java []\\npublic ListNode sortList(ListNode head) {\\n  int BUFFER_SIZE = 8;\\n\\n  ListNode dummy = new ListNode(0);\\n  ListNode subdummy = new ListNode(0);\\n  dummy.next = head;\\n\\n  ListNode [] sublists = new ListNode[BUFFER_SIZE];\\n  ListNode [] sublists_tail = new ListNode[BUFFER_SIZE];\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Record the progress of the current pass into a single semi sorted list by updating\\n    // the next of the previous node (or the dummy on the first loop)\\n    ListNode prev = dummy;\\n\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode remaining = prev.next;\\n\\n    int num_loops = 0;\\n    for (; null != remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = null;\\n        for (int j = 0; null != remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining.next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (null != sublists_tail[i]) {\\n          sublists_tail[i].next = null;\\n        }\\n      }\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          ListNode subprev = subdummy;\\n          subprev.next = null;\\n      \\n          // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n          while (null != sublists[i] && null != sublists[i + 1]) {\\n            if (sublists[i].val <= sublists[i + 1].val) {\\n              subprev.next = sublists[i];\\n              sublists[i] = sublists[i].next;\\n            } else {\\n              subprev.next = sublists[i + 1];\\n              sublists[i + 1] = sublists[i + 1].next;\\n            }\\n            subprev = subprev.next;\\n          }\\n\\n          // One list has been finished, attach what ever is left of the other to the end\\n          if (null != sublists[i]) {\\n            subprev.next = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            subprev.next = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subdummy.next;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      prev.next = sublists[0];\\n      prev = sublists_tail[0];\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return dummy.next;\\n    }\\n  }\\n}\\n```\\n\\n### **Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant. Using subfunctions**\\n\\nSame idea as the holding buffer above, but using subfunctions to `split_list` to extract the sublists and `merge_lists` for the merge step. It might help demonstrate the main loop better.\\n\\n```cpp []\\n/// Take a list and split it into sublists of the requested size, return the remainder of the input list\\nstatic\\nListNode* split_list(ListNode* head, int sz, ListNode* lists_out[], int num_lists) {\\n  for (int i = 0; i < num_lists; ++i) {\\n    lists_out[i] = head;\\n    ListNode* tail = nullptr;\\n    for (int j = 0; head && j < sz; ++j) {\\n      tail = head;\\n      head = head->next;\\n    }\\n    // Ensure the subslist (if one was made) is terminated */\\n    if (tail) {\\n      tail->next = nullptr;\\n    }\\n  }\\n  return head;\\n}\\n\\n/// Merge two sorted lists into one, the head and tail of the new list is returned\\nstatic\\nstd::pair<ListNode*, ListNode*> merge_lists(ListNode* l1, ListNode* l2) {\\n  ListNode* head = nullptr;\\n  ListNode* tail = nullptr;\\n  ListNode** next_ptr = &head;\\n  while (l1 || l2) {\\n    if (!l2 || (l1 && l1->val <= l2->val)) {\\n      tail = l1;\\n      l1 = l1->next;\\n    } else {\\n      tail = l2;\\n      l2 = l2->next;\\n    }\\n    *next_ptr = tail;\\n    next_ptr = &tail->next;\\n  }\\n  return std::make_pair(head, tail);\\n}\\n\\nListNode* sortList(ListNode* head) {\\n  constexpr const int BUFFER_SIZE = 8;\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      ListNode* sublists[BUFFER_SIZE];\\n      remaining = split_list(remaining, steps, sublists, BUFFER_SIZE);\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      ListNode* tail;\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          auto [subhead, subtail] = merge_lists(sublists[i], sublists[i + 1]);\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subhead;\\n          tail = subtail;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      *next_ptr = sublists[0];\\n      next_ptr = &tail->next;\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\\n\\n```c []\\n\\n/* Take a list and split it into sublists of the requested size, return the remainder of the input list */\\nstatic\\nstruct ListNode* split_list(struct ListNode* head, int sz, struct ListNode* lists_out[], int num_lists) {\\n  for (int i = 0; i < num_lists; ++i) {\\n    lists_out[i] = head;\\n    struct ListNode* tail = NULL;\\n    for (int j = 0; head && j < sz; ++j) {\\n      tail = head;\\n      head = head->next;\\n    }\\n    /* Ensure the subslist (if one was made) is terminated */\\n    if (tail) {\\n      tail->next = NULL;\\n    }\\n  }\\n  return head;\\n}\\n\\n/* Merge two sorted lists into one, the head and tail of the new list is returned */\\nstatic\\nvoid merge_lists(struct ListNode* l1, struct ListNode* l2, struct ListNode** head_out, struct ListNode** tail_out) {\\n  struct ListNode* head = NULL;\\n  struct ListNode* tail = NULL;\\n  struct ListNode** next_ptr = &head;\\n  while (l1 || l2) {\\n    if (!l2 || (l1 && l1->val <= l2->val)) {\\n      tail = l1;\\n      l1 = l1->next;\\n    } else {\\n      tail = l2;\\n      l2 = l2->next;\\n    }\\n    *next_ptr = tail;\\n    next_ptr = &tail->next;\\n  }\\n  *head_out = head;\\n  *tail_out = tail;\\n}\\n\\nstruct ListNode* sortList(struct ListNode* head) {\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    struct ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      remaining = split_list(remaining, steps, sublists, BUFFER_SIZE);\\n\\n      /*\\n      Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      */\\n      struct ListNode* tail;\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        /* Merge each pair of sublists */\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          merge_lists(sublists[i], sublists[i + 1], &sublists[i / 2], &tail);\\n        }\\n      }\\n\\n      /* Attach the single sublist into this passes progress */\\n      *next_ptr = sublists[0];\\n      next_ptr = &tail->next;\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\\n### **Short quicksort for fun. O(nlogn) time, O(logn) stack space.**\\n```cpp []\\n  ListNode* sortList(ListNode* head, ListNode* tail = nullptr)\\n  {\\n    if (head != tail) {\\n      // Use head node as the pivot node\\n      // Everything in the _smaller_ list will be less than _head_\\n      // and everything appearing after _head_ in the list is greater or equal\\n      ListNode* smaller;\\n      ListNode** smaller_next = &smaller;\\n      for (ListNode** prev = &head->next; *prev != tail; ) {\\n        if (head->val > (**prev).val) {\\n          *smaller_next = *prev;\\n          smaller_next = &((**smaller_next).next);\\n\\n          // Remove smaller node from original list\\n          *prev = (**prev).next;\\n        } else {\\n          // Correct position, skip over\\n          prev = &((**prev).next);\\n        }\\n      }\\n\\n      // Connect the end of smaller list to the head (which is the partition node)\\n      // We now have. [smaller list...] -> head -> [larger list]\\n      *smaller_next = head;\\n\\n      // Continue to sort everything after head\\n      head->next = sortList(head->next, tail);\\n\\n      // Sort everything upto head\\n      head = sortList(smaller, head);\\n    }\\n    return head;\\n  }\\n```\\t\\n# Details\\n### **Basic description**\\nThe problem calls for O(1) space. Therefore a solution that does not use recursion is required. Quicksort is out, merge sort is in.\\nThe idea is to merge progressively larger sublists together until the resulting list is sorted. A walkthough will help explain.\\n\\nImagine the input list [3, 45, 2, 15, 37, 19, 39, 20], first process the list as sublists of length _1_, [3], [45], [2], [15], [37], [19], [39], [20]. As they are size _1_, they are obviously sorted sublists. Merge each pair of sublists together to produce 4 sorted sublists of size _2_ [3, 45], [2, 15], [19, 37], [20, 39], these are reassemble into the original list to produce [3, 45, 2, 15, 19, 37, 20, 39]. After this pass first pass, every 2 nodes is sorted. That is 3 is before 45, 2 is before 15, 19 is before 37, etc. Increasing the step size to _2_ and repeat. This produces the following table;\\n|Progress|Step size|Sublists|Merged|\\n|---|---|---|---|\\n|[3, 45, 2, 15, 37, 19, 39, 20]|1|[3], [45], [2], [15], [37], [19], [39], [20]|[3, 45], [2, 15], [19, 37], [20, 39]|\\n|[3, 45, 2, 15, 19, 37, 20, 39]|2|[3, 45], [2, 15], [19, 37], [20, 39]|[2, 3, 15, 45], [19, 20, 37, 39]|\\n|[2, 3, 15, 45, 19, 20, 37, 39]|4|[2, 3, 15, 45], [19, 20, 37, 39]|[2, 3, 15, 19, 20, 37, 39, 45]|\\n\\nSince recursion is out, the process must be done inplace as we go. Basically for each pass;\\n1. Grab two sorted lists of size _step_\\n2. Merge the two lists into a single sorted list of size _step * 2_ and reattach to input list\\n3. Repeat from step 1. until entire list has been sorted (which will be when step * 2 >= length)\\n\\nThis produces the first relatively compact solution shown above.\\n### **Complexity**\\n#### **Space complexity**\\nThere are only a few fixed, stack allocated, variables whose creation is not based on the length of the input list and there is no recursion. Therefore it is O(1) space complexity.\\n#### **Time complexity**\\nThe list will be completely sorted once _step_ * 2 becomes greater than _n_, with _step_ doubling each pass (1, 2, 4, 8, ...). Therefore it will take logn passes to sort the list. Each pass though requires _n_ moves to produce the sublists and the merge of two sorted lists takes _step_ moves for _n/step_ sublists. Therefore it takes _n_ time for each of the logn passes. Therefore the time complexity is O(nlogn).\\n### **Improvements**\\nIn practice, in the real world no one would implement the initial solution as is, instead it would be improved substansually (without impacting space complexity), by using a small holding buffer. Allowing for larger sorted sublists to be created with each full pass of the list. This is the second solution presented above.\\n\\nConsider the first solution, the output of each pass produces the input of the next pass. For example, the first pass, when _step_ is 1, produces sublists of _step * 2_, which is exactly what is needed for the next pass. However, there is nowhere to hold this in O(1) space so we must reassemble the list fully ready for the next pass. However, with a small working buffer we can leaverage this and focus on sorting blocks of nodes. By that I mean, we grab _buf_sz_ sublists, and keep merging them together until we have a single, sorted, sublist in our holding buffer. The sublist is then linked back into the input list before progressing onto the next set of _buf_sz_ sublists.\\n\\nWith a working buffer of 4, using the input [6, 38, 25, 46, 45, 90, 97, 52, 75, 18] an initial pass would progress as follows;\\n|Progress|State 1, grab 4 sublists of _step_ size (1)|State 2, merge into 2 sublists|State 3, merge into 1 sublist|\\n|---|---|---|---|\\n|[6, 38, 25, 46, 45, 90, 97, 52, 75, 18]|[6], [38], [25], [46], [45, 90, 97, 52, 75, 18]|[6, 38], [25, 46], [45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45, 90, 97, 52, 75, 18]|\\n|[6, 25, 38, 46, 45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45], [90], [97], [52], [75, 18]|[6, 25, 38, 46], [45, 90], [52, 97], [75, 18]|[6, 25, 38, 46], [45, 52, 90, 97], [75, 18]|\\n|[6, 25, 38, 46, 45, 52, 90, 97, 75, 18]|[6, 25, 38, 46, 45, 52, 90, 97], [75], [18]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|\\n\\nThe end of the list has been reached, so _step_ is increased, but this time, instead of doubling, it is multiplied by 4, as we now know every 4 nodes forms a sorted sublist. The next pass then becomes;\\n\\n|Progress|State 1, grab 4 sublists of _step_ size (4)|State 2, merge into 2 sublists|State 3, merge into 1 sublist|\\n|---|---|---|---|\\n|[6, 25, 38, 46, 45, 52, 90, 97, 18, 75]|[6, 25, 38, 46], [45, 52, 90, 97], [18, 75]|[6, 25, 38, 45, 46, 52, 90, 97], [18, 75]|[6, 18, 25, 38, 45, 46, 52, 75, 90, 97]|\\n\\nFinished!\\nIncreasing the buffer to 8 or 16 makes a huge difference as we will be sorting blocks of nodes as follows;\\n|Buffer size|Pass 1|Pass 2|Pass 3|\\n|---|---|---|---|\\n|2|2|4|8|\\n|4|4|16|64|\\n|8|8|64|512|\\n|16|16|256|4096|\\n\\nSo after 3 passes of the list, with a buffer size of 8, we will have divided the input list into sorted sublists of size 512. Where as with buffer size of 2, we will only have sublists of size 8. Making processing a huge lists considerably faster.\\n## **Quicksort**\\nI added the quicksort solution for fun as it is quite compact, even if it doesn\\'t fullfil the requirements of O(1) space. It does of course suffer from the normal problems of quicksort, that being a worst case of O(n^2) if the input list is already sorted.\\n\\nBasically, grab the _head_ of the list and use it as a pivot. Then using code adopted from [partition list](https://leetcode.com/problems/partition-list/discuss/155293/Short-single-pass-iterative-c++-solution.-No-allocation-or-dummy-required.-O(n)-time-O(1)-space), divide into two sublists, those nodes less than _head->val_ and those greater or equal. Recurse around, partitioning those lists around a new pivot. Rince and repeat until each sublist is down to a size of 1 and is hence sorted.\\n\\nI did it more for fun as the code is really small. Without comments it is;\\n```cpp []\\n  ListNode* sortList(ListNode* head, ListNode* tail = nullptr)\\n  {\\n    if (head != tail) {\\n      ListNode* smaller;\\n      ListNode** smaller_next = &smaller;\\n      for (ListNode** prev = &head->next; *prev != tail; ) {\\n        if (head->val > (**prev).val) {\\n          *smaller_next = *prev;\\n          smaller_next = &((**smaller_next).next);\\n          *prev = (**prev).next;\\n        } else {\\n          prev = &((**prev).next);\\n        }\\n      }\\n\\n      *smaller_next = head;\\n      head->next = sortList(head->next, tail);\\n      head = sortList(smaller, head);\\n    }\\n    return head;\\n  }\\n```\\t\\n\\n**Please give me a thumbs up if this helped explain this problem for you**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "``` python []\\ndef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  dummy = ListNode(0)\\n  dummy.next = head\\n\\n  # Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  steps = 1\\n  while True:\\n    # Record the progress of the current pass into a single semi sorted list by updating\\n    # the next of the previous node (or the dummy on the first loop)\\n    prev = dummy\\n\\n    # Keep track of how much is left to process on this pass of the list\\n    remaining = prev.next\\n\\n    # While the current pass though the list has not been completed\\n    num_loops = 0\\n    while remaining:\\n      num_loops += 1\\n\\n      # Split 2 sublists of steps length from the front\\n      sublists = [None, None]\\n      sublists_tail = [None, None]\\n      for i in range(2):\\n        sublists[i] = remaining\\n        substeps = steps\\n        while substeps and remaining:\\n          substeps -= 1\\n          sublists_tail[i] = remaining\\n          remaining = remaining.next\\n        # Ensure the subslist (if one was made) is terminated\\n        if sublists_tail[i]:\\n          sublists_tail[i].next = None\\n\\n      # We have two sublists of (upto) length step that are sorted, merge them onto \\n      # the end into a single list of (upto) step * 2\\n      while sublists[0] and sublists[1]:\\n        if sublists[0].val <= sublists[1].val:\\n          prev.next = sublists[0]\\n          sublists[0] = sublists[0].next\\n        else:\\n          prev.next = sublists[1]\\n          sublists[1] = sublists[1].next\\n        prev = prev.next\\n      \\n      # One list has been finished, attach what ever is left of the other to the end\\n      if sublists[0]:\\n        prev.next = sublists[0]\\n        prev = sublists_tail[0]\\n      else:\\n        prev.next = sublists[1]\\n        prev = sublists_tail[1]\\n    \\n    # Double the steps each go around\\n    steps *= 2\\n\\n    # If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if 1 >= num_loops:\\n      return dummy.next\\n```\n``` c []\\nstruct ListNode* sortList(struct ListNode* head){\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= 2) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split 2 sublists of steps length from the front */\\n      struct ListNode* sublists[2];\\n      struct ListNode* sublists_tail[2] = {NULL, NULL};\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        /* Ensure the subslist (if one was made) is terminated */\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      /* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */\\n      while (sublists[0] && sublists[1]) {\\n        if (sublists[0]->val <= sublists[1]->val) {\\n          *next_ptr = sublists[0];\\n          next_ptr = &sublists[0]->next;\\n          sublists[0] = sublists[0]->next;\\n        } else {\\n          *next_ptr = sublists[1];\\n          next_ptr = &sublists[1]->next;\\n          sublists[1] = sublists[1]->next;\\n        }\\n      }   \\n\\n      /* One list has been finished, attach what ever is left of the other to the end */\\n      if (sublists[0]) {\\n        *next_ptr = sublists[0];\\n        next_ptr = &sublists_tail[0]->next;\\n      } else {\\n        *next_ptr = sublists[1];\\n        next_ptr = &sublists_tail[1]->next;\\n      }\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\n``` cpp []\\nListNode* sortList(ListNode* head) {\\n  // Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  for (int steps = 1;; steps *= 2) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split 2 sublists of steps length from the front\\n      ListNode* sublists[2];\\n      ListNode* sublists_tail[2] = {nullptr, nullptr};\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = nullptr;\\n        }\\n      }\\n\\n      // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n      while (sublists[0] && sublists[1]) {\\n        if (sublists[0]->val <= sublists[1]->val) {\\n          *next_ptr = sublists[0];\\n          next_ptr = &sublists[0]->next;\\n          sublists[0] = sublists[0]->next;\\n        } else {\\n          *next_ptr = sublists[1];\\n          next_ptr = &sublists[1]->next;\\n          sublists[1] = sublists[1]->next;\\n        }\\n      }   \\n\\n      // One list has been finished, attach what ever is left of the other to the end\\n      if (sublists[0]) {\\n        *next_ptr = sublists[0];\\n        next_ptr = &sublists_tail[0]->next;\\n      } else {\\n        *next_ptr = sublists[1];\\n        next_ptr = &sublists_tail[1]->next;\\n      }\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  } \\n}\\n```\n``` java []\\npublic ListNode sortList(ListNode head) {\\n  ListNode dummy = new ListNode(0);\\n  dummy.next = head;\\n\\n  ListNode [] sublists = new ListNode[2];\\n  ListNode [] sublists_tail = new ListNode[2];\\n\\n  // Grab sublists of size 1, then 2, then 4, etc, until fully merged\\n  for (int steps = 1;; steps *= 2) {\\n    // Record the progress of the current pass into a single semi sorted list by updating\\n    // the next of the previous node (or the dummy on the first loop)\\n    ListNode prev = dummy;\\n\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode remaining = prev.next;\\n\\n    int num_loops = 0;\\n    for (; null != remaining; ++num_loops) {\\n      // Split 2 sublists of steps length from the front\\n      for (int i = 0; i < 2; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = null;\\n        for (int j = 0; null != remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining.next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (null != sublists_tail[i]) {\\n          sublists_tail[i].next = null;\\n        }\\n      }\\n\\n      // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n      while (null != sublists[0] && null != sublists[1]) {\\n        if (sublists[0].val <= sublists[1].val) {\\n          prev.next = sublists[0];\\n          sublists[0] = sublists[0].next;\\n        } else {\\n          prev.next = sublists[1];\\n          sublists[1] = sublists[1].next;\\n        }\\n        prev = prev.next;\\n      }   \\n\\n      // One list has been finished, attach what ever is left of the other to the end\\n      if (null != sublists[0]) {\\n        prev.next = sublists[0];\\n        prev = sublists_tail[0];\\n      } else {\\n        prev.next = sublists[1];\\n        prev = sublists_tail[1];\\n      }\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return dummy.next;\\n    }\\n  }\\n}\\n```\n``` python []\\ndef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  buffer_size = 8\\n\\n  dummy = ListNode(0)\\n  dummy.next = head\\n\\n  # Grab sublists of size 1, then buffer_size, then buffer_size^2, etc, until fully merged\\n  steps = 1\\n  while True:\\n    # Record the progress of the current pass into a single semi sorted list by updating\\n    # the next of the previous node (or the dummy on the first loop)\\n    prev = dummy\\n\\n    # Keep track of how much is left to process on this pass of the list\\n    remaining = prev.next\\n\\n    # While the current pass though the list has not been completed\\n    num_loops = 0\\n    while remaining:\\n      num_loops += 1\\n\\n      # Split buffer_size sublists of upto steps length from the front\\n      sublists = [None] * buffer_size\\n      sublists_tail = [None] * buffer_size\\n      for i in range(buffer_size):\\n        sublists[i] = remaining\\n        substeps = steps\\n        while substeps and remaining:\\n          substeps -= 1\\n          sublists_tail[i] = remaining\\n          remaining = remaining.next\\n        # Ensure the subslist (if one was made) is terminated\\n        if sublists_tail[i]:\\n          sublists_tail[i].next = None\\n\\n      # Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      # That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      num_sublists = buffer_size\\n      while 1 < num_sublists:\\n        # Merge each pair of sublists\\n        subdummy = ListNode()\\n        for i in range(0, num_sublists, 2):\\n          subprev = subdummy;\\n          subprev.next = None\\n\\n          # We have two sublists of (upto) length step that are sorted, merge them onto \\n          # the end into a single list of (upto) step * 2\\n          while sublists[i] and sublists[i + 1]:\\n            if sublists[i].val <= sublists[i + 1].val:\\n              subprev.next = sublists[i]\\n              sublists[i] = sublists[i].next\\n            else:\\n              subprev.next = sublists[i + 1]\\n              sublists[i + 1] = sublists[i + 1].next\\n            subprev = subprev.next\\n      \\n          # One list has been finished, attach what ever is left of the other to the end\\n          if sublists[i]:\\n            subprev.next = sublists[i]\\n            sublists_tail[i // 2] = sublists_tail[i]\\n          else:\\n            subprev.next = sublists[i + 1]\\n            sublists_tail[i // 2] = sublists_tail[i + 1]\\n\\n          # Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i // 2] = subdummy.next;\\n\\n        # Half the sublists remain now that we have merged each pair of lists\\n        num_sublists //= 2\\n\\n      # Attach the single sublist into this passes progress\\n      prev.next = sublists[0];\\n      prev = sublists_tail[0];\\n    \\n    # Increase the steps each go around\\n    steps *= buffer_size\\n\\n    # If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if 1 >= num_loops:\\n      return dummy.next\\n```\n``` c []\\n\\nstruct ListNode* sortList(struct ListNode* head){\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      struct ListNode* sublists_tail[BUFFER_SIZE];\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = NULL;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        /* Ensure the subslist (if one was made) is terminated */\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      /*\\n      Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      */\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        /* Merge each pair of sublists */\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          struct ListNode* subhead = NULL;\\n          struct ListNode** sub_next_ptr = &subhead;\\n      \\n          /* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */\\n          while (sublists[i] && sublists[i + 1]) {\\n            if (sublists[i]->val <= sublists[i + 1]->val) {\\n              *sub_next_ptr = sublists[i];\\n              sub_next_ptr = &sublists[i]->next;\\n              sublists[i] = sublists[i]->next;\\n            } else {\\n              *sub_next_ptr = sublists[i + 1];\\n              sub_next_ptr = &sublists[i + 1]->next;\\n              sublists[i + 1] = sublists[i + 1]->next;\\n            }\\n          }\\n\\n          /* One list has been finished, attach what ever is left of the other to the end */\\n          if (sublists[i]) {\\n            *sub_next_ptr = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            *sub_next_ptr = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          /* Record the head of our new longer sublist in the correct location for the next loop around */\\n          sublists[i / 2] = subhead;\\n        }\\n      }\\n\\n      /* Attach the single sublist into this passes progress */\\n      *next_ptr = sublists[0];\\n      next_ptr = &sublists_tail[0]->next;\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\n```cpp []\\nListNode* sortList(ListNode* head) {\\n  constexpr const int BUFFER_SIZE = 8;\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      ListNode* sublists[BUFFER_SIZE];\\n      ListNode* sublists_tail[BUFFER_SIZE];\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = NULL;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (sublists_tail[i]) {\\n          sublists_tail[i]->next = NULL;\\n        }\\n      }\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          ListNode* subhead = NULL;\\n          ListNode** sub_next_ptr = &subhead;\\n      \\n          // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n          while (sublists[i] && sublists[i + 1]) {\\n            if (sublists[i]->val <= sublists[i + 1]->val) {\\n              *sub_next_ptr = sublists[i];\\n              sub_next_ptr = &sublists[i]->next;\\n              sublists[i] = sublists[i]->next;\\n            } else {\\n              *sub_next_ptr = sublists[i + 1];\\n              sub_next_ptr = &sublists[i + 1]->next;\\n              sublists[i + 1] = sublists[i + 1]->next;\\n            }\\n          }\\n\\n          // One list has been finished, attach what ever is left of the other to the end\\n          if (sublists[i]) {\\n            *sub_next_ptr = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            *sub_next_ptr = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subhead;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      *next_ptr = sublists[0];\\n      next_ptr = &sublists_tail[0]->next;\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\n```java []\\npublic ListNode sortList(ListNode head) {\\n  int BUFFER_SIZE = 8;\\n\\n  ListNode dummy = new ListNode(0);\\n  ListNode subdummy = new ListNode(0);\\n  dummy.next = head;\\n\\n  ListNode [] sublists = new ListNode[BUFFER_SIZE];\\n  ListNode [] sublists_tail = new ListNode[BUFFER_SIZE];\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Record the progress of the current pass into a single semi sorted list by updating\\n    // the next of the previous node (or the dummy on the first loop)\\n    ListNode prev = dummy;\\n\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode remaining = prev.next;\\n\\n    int num_loops = 0;\\n    for (; null != remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = null;\\n        for (int j = 0; null != remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining.next;\\n        }\\n        // Ensure the subslist (if one was made) is terminated\\n        if (null != sublists_tail[i]) {\\n          sublists_tail[i].next = null;\\n        }\\n      }\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          ListNode subprev = subdummy;\\n          subprev.next = null;\\n      \\n          // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2\\n          while (null != sublists[i] && null != sublists[i + 1]) {\\n            if (sublists[i].val <= sublists[i + 1].val) {\\n              subprev.next = sublists[i];\\n              sublists[i] = sublists[i].next;\\n            } else {\\n              subprev.next = sublists[i + 1];\\n              sublists[i + 1] = sublists[i + 1].next;\\n            }\\n            subprev = subprev.next;\\n          }\\n\\n          // One list has been finished, attach what ever is left of the other to the end\\n          if (null != sublists[i]) {\\n            subprev.next = sublists[i];\\n            sublists_tail[i / 2] = sublists_tail[i];\\n          } else {\\n            subprev.next = sublists[i + 1];\\n            sublists_tail[i / 2] = sublists_tail[i + 1];\\n          }\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subdummy.next;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      prev.next = sublists[0];\\n      prev = sublists_tail[0];\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return dummy.next;\\n    }\\n  }\\n}\\n```\n```cpp []\\n/// Take a list and split it into sublists of the requested size, return the remainder of the input list\\nstatic\\nListNode* split_list(ListNode* head, int sz, ListNode* lists_out[], int num_lists) {\\n  for (int i = 0; i < num_lists; ++i) {\\n    lists_out[i] = head;\\n    ListNode* tail = nullptr;\\n    for (int j = 0; head && j < sz; ++j) {\\n      tail = head;\\n      head = head->next;\\n    }\\n    // Ensure the subslist (if one was made) is terminated */\\n    if (tail) {\\n      tail->next = nullptr;\\n    }\\n  }\\n  return head;\\n}\\n\\n/// Merge two sorted lists into one, the head and tail of the new list is returned\\nstatic\\nstd::pair<ListNode*, ListNode*> merge_lists(ListNode* l1, ListNode* l2) {\\n  ListNode* head = nullptr;\\n  ListNode* tail = nullptr;\\n  ListNode** next_ptr = &head;\\n  while (l1 || l2) {\\n    if (!l2 || (l1 && l1->val <= l2->val)) {\\n      tail = l1;\\n      l1 = l1->next;\\n    } else {\\n      tail = l2;\\n      l2 = l2->next;\\n    }\\n    *next_ptr = tail;\\n    next_ptr = &tail->next;\\n  }\\n  return std::make_pair(head, tail);\\n}\\n\\nListNode* sortList(ListNode* head) {\\n  constexpr const int BUFFER_SIZE = 8;\\n\\n  // Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      // Split BUFFER_SIZE sublists of upto steps length from the front\\n      ListNode* sublists[BUFFER_SIZE];\\n      remaining = split_list(remaining, steps, sublists, BUFFER_SIZE);\\n\\n      // Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      // That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      ListNode* tail;\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        // Merge each pair of sublists\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          auto [subhead, subtail] = merge_lists(sublists[i], sublists[i + 1]);\\n\\n          // Record the head of our new longer sublist in the correct location for the next loop around\\n          sublists[i / 2] = subhead;\\n          tail = subtail;\\n        }\\n      }\\n\\n      // Attach the single sublist into this passes progress\\n      *next_ptr = sublists[0];\\n      next_ptr = &tail->next;\\n    }\\n\\n    // If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\n```c []\\n\\n/* Take a list and split it into sublists of the requested size, return the remainder of the input list */\\nstatic\\nstruct ListNode* split_list(struct ListNode* head, int sz, struct ListNode* lists_out[], int num_lists) {\\n  for (int i = 0; i < num_lists; ++i) {\\n    lists_out[i] = head;\\n    struct ListNode* tail = NULL;\\n    for (int j = 0; head && j < sz; ++j) {\\n      tail = head;\\n      head = head->next;\\n    }\\n    /* Ensure the subslist (if one was made) is terminated */\\n    if (tail) {\\n      tail->next = NULL;\\n    }\\n  }\\n  return head;\\n}\\n\\n/* Merge two sorted lists into one, the head and tail of the new list is returned */\\nstatic\\nvoid merge_lists(struct ListNode* l1, struct ListNode* l2, struct ListNode** head_out, struct ListNode** tail_out) {\\n  struct ListNode* head = NULL;\\n  struct ListNode* tail = NULL;\\n  struct ListNode** next_ptr = &head;\\n  while (l1 || l2) {\\n    if (!l2 || (l1 && l1->val <= l2->val)) {\\n      tail = l1;\\n      l1 = l1->next;\\n    } else {\\n      tail = l2;\\n      l2 = l2->next;\\n    }\\n    *next_ptr = tail;\\n    next_ptr = &tail->next;\\n  }\\n  *head_out = head;\\n  *tail_out = tail;\\n}\\n\\nstruct ListNode* sortList(struct ListNode* head) {\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    struct ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      remaining = split_list(remaining, steps, sublists, BUFFER_SIZE);\\n\\n      /*\\n      Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      */\\n      struct ListNode* tail;\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        /* Merge each pair of sublists */\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          merge_lists(sublists[i], sublists[i + 1], &sublists[i / 2], &tail);\\n        }\\n      }\\n\\n      /* Attach the single sublist into this passes progress */\\n      *next_ptr = sublists[0];\\n      next_ptr = &tail->next;\\n    }\\n\\n    /* If the entire list was fully processed in a single loop, it means we\\'ve completely sorted the list and are done */\\n    if (1 >= num_loops) {\\n      return head;\\n    }\\n  }\\n}\\n```\n```cpp []\\n  ListNode* sortList(ListNode* head, ListNode* tail = nullptr)\\n  {\\n    if (head != tail) {\\n      // Use head node as the pivot node\\n      // Everything in the _smaller_ list will be less than _head_\\n      // and everything appearing after _head_ in the list is greater or equal\\n      ListNode* smaller;\\n      ListNode** smaller_next = &smaller;\\n      for (ListNode** prev = &head->next; *prev != tail; ) {\\n        if (head->val > (**prev).val) {\\n          *smaller_next = *prev;\\n          smaller_next = &((**smaller_next).next);\\n\\n          // Remove smaller node from original list\\n          *prev = (**prev).next;\\n        } else {\\n          // Correct position, skip over\\n          prev = &((**prev).next);\\n        }\\n      }\\n\\n      // Connect the end of smaller list to the head (which is the partition node)\\n      // We now have. [smaller list...] -> head -> [larger list]\\n      *smaller_next = head;\\n\\n      // Continue to sort everything after head\\n      head->next = sortList(head->next, tail);\\n\\n      // Sort everything upto head\\n      head = sortList(smaller, head);\\n    }\\n    return head;\\n  }\\n```\n```cpp []\\n  ListNode* sortList(ListNode* head, ListNode* tail = nullptr)\\n  {\\n    if (head != tail) {\\n      ListNode* smaller;\\n      ListNode** smaller_next = &smaller;\\n      for (ListNode** prev = &head->next; *prev != tail; ) {\\n        if (head->val > (**prev).val) {\\n          *smaller_next = *prev;\\n          smaller_next = &((**smaller_next).next);\\n          *prev = (**prev).next;\\n        } else {\\n          prev = &((**prev).next);\\n        }\\n      }\\n\\n      *smaller_next = head;\\n      head->next = sortList(head->next, tail);\\n      head = sortList(smaller, head);\\n    }\\n    return head;\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 46711,
                "title": "python-easy-to-understand-merge-sort-solution",
                "content": "```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        fast, slow = head.next, head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        start = slow.next\\n        slow.next = None\\n        l, r = self.sortList(head), self.sortList(start)\\n        return self.merge(l, r)\\n        \\n        \\n    def merge(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        dummy = p = ListNode(0)\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        fast, slow = head.next, head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        start = slow.next\\n        slow.next = None\\n        l, r = self.sortList(head), self.sortList(start)\\n        return self.merge(l, r)\\n        \\n        \\n    def merge(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        dummy = p = ListNode(0)\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46710,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def merge(self, h1, h2):\\n            dummy = tail = ListNode(None)\\n            while h1 and h2:\\n                if h1.val < h2.val:\\n                    tail.next, tail, h1 = h1, h1, h1.next\\n                else:\\n                    tail.next, tail, h2 = h2, h2, h2.next\\n        \\n            tail.next = h1 or h2\\n            return dummy.next\\n        \\n        def sortList(self, head):\\n            if not head or not head.next:\\n                return head\\n        \\n            pre, slow, fast = None, head, head\\n            while fast and fast.next:\\n                pre, slow, fast = slow, slow.next, fast.next.next\\n            pre.next = None\\n\\n            return self.merge(*map(self.sortList, (head, slow)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def merge(self, h1, h2):\\n            dummy = tail = ListNode(None)\\n            while h1 and h2:\\n                if h1.val < h2.val:\\n                    tail.next, tail, h1 = h1, h1, h1.next\\n                else:\\n                    tail.next, tail, h2 = h2, h2, h2.next\\n        \\n            tail.next = h1 or h2\\n            return dummy.next\\n        \\n        def sortList(self, head):\\n            if not head or not head.next:\\n                return head\\n        \\n            pre, slow, fast = None, head, head\\n            while fast and fast.next:\\n                pre, slow, fast = slow, slow.next, fast.next.next\\n            pre.next = None\\n\\n            return self.merge(*map(self.sortList, (head, slow)))",
                "codeTag": "Java"
            },
            {
                "id": 46720,
                "title": "share-my-c-concise-solutions-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        ListNode* sortList(ListNode* head) {\\n            if (head == NULL || head->next == NULL)\\n                return head;\\n            \\n            ListNode* slow = head;\\n            ListNode* fast = head->next;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            //divide the list into two parts \\n            fast = slow->next;\\n            slow->next = NULL;\\n            \\n            return merge(sortList(head), sortList(fast));\\n        }\\n        \\n        ListNode* merge(ListNode* l1, ListNode* l2)\\n        {\\n            ListNode dump(0);\\n            ListNode* cur = &dump;\\n            \\n            while (l1 != NULL && l2 != NULL)\\n            {\\n                if (l1->val < l2->val)\\n                {\\n                    cur->next = l1;\\n                    l1 = l1->next;\\n                }\\n                else\\n                {\\n                    cur->next = l2;\\n                    l2 = l2->next;\\n                }\\n                    \\n                cur = cur->next;\\n            }\\n            \\n            if (l1 != NULL)\\n                cur->next = l1;\\n            else\\n                cur->next = l2;\\n                \\n            return dump.next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* sortList(ListNode* head) {\\n            if (head == NULL || head->next == NULL)\\n                return head;\\n            \\n            ListNode* slow = head;\\n            ListNode* fast = head->next;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46772,
                "title": "i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) {\\n     *         val = x;\\n     *         next = null;\\n     *     }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode sortList(ListNode head) {\\n            if (head == null || head.next == null)\\n                return head;\\n            ListNode f = head.next.next;\\n            ListNode p = head;\\n            while (f != null && f.next != null) {\\n                p = p.next;\\n                f =  f.next.next;\\n            }\\n            ListNode h2 = sortList(p.next);\\n            p.next = null;\\n            return merge(sortList(head), h2);\\n        }\\n        public ListNode merge(ListNode h1, ListNode h2) {\\n            ListNode hn = new ListNode(Integer.MIN_VALUE);\\n            ListNode c = hn;\\n            while (h1 != null && h2 != null) {\\n                if (h1.val < h2.val) {\\n                    c.next = h1;\\n                    h1 = h1.next;\\n                }\\n                else {\\n                    c.next = h2;\\n                    h2 = h2.next;\\n                }\\n                c = c.next;\\n            }\\n            if (h1 != null)\\n                c.next = h1;\\n            if (h2 != null)\\n                c.next = h2;\\n            return hn.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode sortList(ListNode head) {\\n            if (head == null || head.next == null)\\n                return head;\\n            ListNode f = head.next.next;\\n            ListNode p = head;\\n            while (f != null && f.next != null) {\\n                p = p.next;\\n                f =  f.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46716,
                "title": "basically-it-seems-like-merge-sort-problem-really-easy-understand",
                "content": "Each time divided the given list into two sub list. Merge sub list after bottom case return.\\nHere is the code:\\n\\n    public class Solution {\\n        \\n        //merge two sorted list, return result head\\n        public ListNode merge(ListNode h1, ListNode h2){\\n            if(h1 == null){\\n                return h2;\\n            }\\n            if(h2 == null){\\n                return h1;\\n            }\\n            \\n            if(h1.val < h2.val){\\n                h1.next = merge(h1.next, h2);\\n                return h1;\\n            }\\n            else{\\n                h2.next = merge(h1, h2.next);\\n                return h2;\\n            }\\n            \\n        }\\n        \\n        public ListNode sortList(ListNode head) {\\n            //bottom case\\n            if(head == null){\\n                return head;\\n            }\\n            if(head.next == null){\\n                return head;\\n            }\\n            \\n            //p1 move 1 step every time, p2 move 2 step every time, pre record node before p1\\n            ListNode p1 = head;\\n            ListNode p2 = head;\\n            ListNode pre = head;\\n            \\n            while(p2 != null && p2.next != null){\\n                pre = p1;\\n                p1 = p1.next;\\n                p2 = p2.next.next;\\n            }\\n            //change pre next to null, make two sub list(head to pre, p1 to p2)\\n            pre.next = null;\\n            \\n            //handle those two sub list\\n            ListNode h1 = sortList(head);\\n            ListNode h2 = sortList(p1);\\n            \\n            return merge(h1, h2);\\n            \\n        }\\n        \\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n        \\n        //merge two sorted list, return result head\\n        public ListNode merge(ListNode h1, ListNode h2){\\n            if(h1 == null){\\n                return h2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 892759,
                "title": "python-o-n-log-n-log-n-merge-sort-explained",
                "content": "This is pretty straightforward question, if you know how to use merge sort. All we need to do is to split our list into two parts, sort the first half, then sort the second half and finally merge this two parts. Here I use two axuilary function:\\n\\n1. `getMid(head)`, which will find the middle of list with given `head` and cut it into two smaller lists. We use the idea of slow and fast pointers here to find middle efficiently.\\n2. `merge(head1, head2)` will merge two lists with given heads. To make it more readible and to avoid corner cases, it is good idea to use dummy sentinel node in the beginning of list. We iterate over two lists, using two pointers and add them one by one. When we out of nodes, we attach the rest of on of the lists to the end, we return the start of our new list.\\n3. `sortList(head)`: it is our original function: if list has length `0` or `1`, we do not do anything, it is corner case of our recursion. If it is not the case, we find `mid = self.getMid(head)`, which will cut our list into two smaller lists and return the start of the second list. Finally, we apply `sortList()` to `head` and to `mid` and merge two parts.\\n\\n**Complexity**: Time complexity is `O(n log n)`, because it is classical complexity of merge sort. Space complexity is `O(log n)`, because we use recursion which can be `log n` deep.\\n\\n```\\nclass Solution:\\n    def sortList(self, head):\\n        if not head or not head.next: return head\\n        mid = self.getMid(head)\\n        left = self.sortList(head)\\n        right = self.sortList(mid)\\n        return self.merge(left, right)\\n    \\n    def getMid(self, head):\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        mid = slow.next\\n        slow.next = None\\n        return mid\\n    \\n    def merge(self, head1, head2):\\n        dummy = tail = ListNode(None)\\n        while head1 and head2:\\n            if head1.val < head2.val:\\n                tail.next, tail, head1 = head1, head1, head1.next\\n            else:\\n                tail.next, tail, head2 = head2, head2, head2.next\\n    \\n        tail.next = head1 or head2\\n        return dummy.next\\n```\\n\\n**Follow up** question askes us to do it in `O(1)` memory, and it is possible to do it, using bottom-up merge sort, which is much more difficult to implement during interview limits. What I expect that if you just explain the idea, without implementing this will be already quite good. So, idea is the following: imagine, that we have list `a1, a2, a3, a4, a5, a6, a7, a8`. Let us first sort values in pairs:\\n`(a1, a2)`, `(a3, a4)`, `(a5, a6)`, `(a7, a8)`. \\nthen we sort values in groups by `4`, mergin our pairs:\\n`(a1, a2, a3, a4)`, `(a5, a6, a7, a8)`.\\nAnd finally we merge them in one group of `9`. It is more difficult to implement and I will add code later.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortList(self, head):\\n        if not head or not head.next: return head\\n        mid = self.getMid(head)\\n        left = self.sortList(head)\\n        right = self.sortList(mid)\\n        return self.merge(left, right)\\n    \\n    def getMid(self, head):\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        mid = slow.next\\n        slow.next = None\\n        return mid\\n    \\n    def merge(self, head1, head2):\\n        dummy = tail = ListNode(None)\\n        while head1 and head2:\\n            if head1.val < head2.val:\\n                tail.next, tail, head1 = head1, head1, head1.next\\n            else:\\n                tail.next, tail, head2 = head2, head2, head2.next\\n    \\n        tail.next = head1 or head2\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46767,
                "title": "java-solution-with-strict-o-1-auxiliary-space-complexity",
                "content": "First of all, allow me to explain the meaning of **strict O(1) auxiliary space complexity**. \\n\\nIt means the **maximum** number of memory used by the program, except the memory taken by the input data, doesn't change with the input size.\\nThis indicates that, strictly speaking, any solution that involves recursion can never have a strict O(1) auxiliary space complexity. Because the maximum recursion level depends on the the input size and each recursion call consumes memory on stack, thus the maximum number of memory used depends on the input size.\\n\\n\\n----------\\nSecondly, allow me to explain my solution based on merge sort.\\n\\nAssume the length of list is n, which is unknown at the beginning.\\n\\n      level log(n)         [ A0, A2, A3, ... , An-2, An-1 ]\\n      ...\\n      level 2        [ A0, A1, A2,  A3 ], [A4, A5, A6, A7] ,... , [ ..., An-2, An-1 ]\\n      level 1        [ A0, A1], [A2,  A3 ], [A4, A5], [A6, A7] ,... , [An-2, An-1]\\n      level 0        [ A0 ], [ A1] , [ A2 ],  [ A3 ],... , [ An-2 ], [ An-1 ]\\n\\nAt each level, each group only contains at maximum 2^level elements. Merge-sort theses groups pair by pair. Then level ++. Stop until 2^level > n.\\nAssume the original input is :\\n\\n      level 0        5, 3, 6, 1, 4, 2, 7\\nAfter level 0, we got the length of the list and the list become:\\n\\n      level 1        3, 5,   1, 6,    2, 4,    7\\nNow each group contains 2 elements. After level 1, the list become:\\n\\n      level 2        1, 3, 5, 6,    2, 4, 7\\n\\nNow each group contains 2^2 = 4 elements. After level 2, the list become:\\n\\n      level 3        1, 2, 3, 4, 5, 6, 7\\nNow, 2^3 > 7, stop.\\n\\nTime complexity:\\nIn each level, each node is visited by at maximum twice. And there are log(n) level. Thus the time complexity is O(2n* log n ) => O( n* log n )\\n\\n\\nHere is the code:\\n\\n    public class Solution {\\n    private class MergeHelper {\\n            public ListNode newHead;\\n            public ListNode newTail;\\n    }\\n    public ListNode sortList(ListNode head) {\\n        if ( head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummyHeadOne = new ListNode(0);\\n        ListNode dummyHeadTwo = new ListNode(0);\\n        ListNode dummySortedHead = new ListNode(0);\\n        ListNode dummySortedLast = dummySortedHead;\\n        ListNode unvisitedNode = head;\\n        MergeHelper mergeRst = new MergeHelper();\\n        \\n        int listLength = 0;\\n        int level = 0;\\n        while ( unvisitedNode != null && unvisitedNode.next != null ) {\\n            unvisitedNode = addNode ( dummyHeadOne, unvisitedNode, 1<<level);\\n            unvisitedNode = addNode ( dummyHeadTwo, unvisitedNode, 1<<level);\\n            merge ( dummyHeadOne.next, dummyHeadTwo.next, mergeRst);\\n            dummySortedLast.next = mergeRst.newHead;\\n            dummySortedLast = mergeRst.newTail;\\n            listLength += 2;\\n        }\\n        if (unvisitedNode != null) {\\n            dummySortedLast.next = unvisitedNode;\\n            listLength ++;\\n        }\\n        level ++;\\n        \\n        while ( listLength > 1 << level) {\\n            dummySortedLast = dummySortedHead;\\n            unvisitedNode = dummySortedHead.next;\\n            while (unvisitedNode != null) {\\n                unvisitedNode = addNode ( dummyHeadOne, unvisitedNode, 1<<level);\\n                unvisitedNode = addNode ( dummyHeadTwo, unvisitedNode, 1<<level);\\n                merge ( dummyHeadOne.next, dummyHeadTwo.next, mergeRst);\\n                dummySortedLast.next = mergeRst.newHead;\\n                dummySortedLast = mergeRst.newTail;\\n            }\\n            level ++;\\n        }\\n        \\n        return dummySortedHead.next;\\n    }\\n    \\n    /* merge listOne and listTwo. \\n    Save the sorted list head into rst.newHead\\n    Save the last node of the sorted list into rst.newTail\\n    */\\n    private void merge (ListNode listOne, ListNode listTwo, MergeHelper rst) {\\n        ListNode dummyHead = new ListNode (0);\\n        ListNode lastNode = dummyHead;\\n        while (listOne != null && listTwo != null) {\\n            if ( listOne.val < listTwo.val ) {\\n                lastNode.next = listOne;\\n                listOne = listOne.next;\\n            } else {\\n                lastNode.next = listTwo;\\n                listTwo = listTwo.next;\\n            }\\n            lastNode = lastNode.next;\\n        }\\n        \\n        while (listOne != null) {\\n            lastNode.next = listOne;\\n            listOne = listOne.next;\\n            lastNode = lastNode.next;\\n        }\\n        while ( listTwo != null ) {\\n            lastNode.next = listTwo;\\n            listTwo = listTwo.next;\\n            lastNode = lastNode.next;\\n        }\\n        rst.newHead = dummyHead.next;\\n        rst.newTail = lastNode;\\n    }\\n    \\n    /*\\n     add at max #\"count\" nodes into \"head\" from \"source\"\\n     return the new position of source after adding.\\n    */\\n    private ListNode addNode ( ListNode head, ListNode source, int count ) {\\n        while (count > 0 && source != null) {\\n            head.next = source;\\n            head = head.next;\\n            source = source.next;\\n            count --;\\n        }\\n        head.next = null;\\n        return source;\\n    }}\\n\\nSpace complexity:\\nThere are no recursion calls in this solution. Thus the maximum number of function calls is constant.\\nThe number of dummy nodes is constant.\\nThus the auxiliary space complexity is O(1).",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private class MergeHelper {\\n            public ListNode newHead;\\n            public ListNode newTail;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 46721,
                "title": "my-o-n-log-n-time-o-1-space-solution",
                "content": "Nice problem. I use a non-recurisve way to write merge sort.\\nFor example, the size of ListNode is 8,\\n\\nRound #1  block_size = 1\\n\\n(a1, a2), (a3, a4), (a5, a6), (a7, a8)\\n\\nCompare a1 with a2,   a3 with a4 ...\\n\\nRound #2  block_size = 2\\n\\n(a1, a2, a3, a4), (a5, a6, a7, a8)\\n\\nmerge two sorted arrays (a1, a2) and (a3, a4),  then merge tow sorted arrays(a5, a6) and (a7, a8)\\n\\nRound #3  block_size = 4\\n\\n(a1, a2, a3, a4, a5, a6, a7, a8)\\n\\nmerge two sorted arrays (a1, a2, a3, a4), and (a5, a6, a7, a8)\\n\\nNo need for round #4 cause block_size = 8 >= n = 8\\n\\n    class Solution {\\n    public:\\n        int count_size(ListNode *node){\\n            int n = 0;\\n            while (node != NULL){\\n                node = node->next;\\n                ++n;\\n            }\\n            return n;\\n        }\\n        ListNode *sortList(ListNode *head) {\\n            int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0;\\n            ListNode virtual_head(0);\\n            ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL;\\n            virtual_head.next = head;\\n            while (block_size < n){\\n                iter = 0;\\n                last = &virtual_head;\\n                it = virtual_head.next;\\n                while (iter <  n){\\n                    a = min(n - iter, block_size);\\n                    b = min(n - iter - a, block_size);\\n                    \\n                    A = it;\\n                    if (b != 0){\\n                        for (i = 0; i < a - 1; ++i) it = it->next;\\n                        B = it->next;\\n                        it->next = NULL;\\n                        it = B;\\n                        \\n                        for (i = 0; i < b - 1; ++i) it = it->next;\\n                        tmp = it->next;\\n                        it->next = NULL;\\n                        it = tmp;\\n                    }\\n                    \\n                    while (A || B){\\n                        if (B == NULL || (A != NULL && A->val <= B->val)){\\n                            last->next = A;\\n                            last = last->next;\\n                            A = A->next;\\n                        } else {\\n                            last->next = B;\\n                            last = last->next;\\n                            B = B->next;\\n                        }\\n                    }\\n                    last->next = NULL;\\n                    iter += a + b;\\n                }\\n                block_size <<= 1;\\n            }\\n            return virtual_head.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int count_size(ListNode *node){\\n            int n = 0;\\n            while (node != NULL){\\n                node = node->next;\\n                ++n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46877,
                "title": "c-merge-sort-solution",
                "content": "       \\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *fast = head->next->next, *slow = head;\\n        while(fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode *r = sortList(slow->next);\\n        slow->next = NULL;\\n        ListNode *l = sortList(head);\\n        return merge(l, r);\\n    }\\n    \\n    ListNode *merge(ListNode *l, ListNode *r) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        while (l && r) {\\n            if (l->val < r->val) {\\n                node->next = l;\\n                l = l->next;\\n            } else {\\n                node->next = r;\\n                r = r->next;\\n            }\\n            node = node->next;\\n        }\\n        if (l)\\n            node->next = l;\\n        else \\n            node->next = r;\\n        return dummy->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "       \\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *fast = head->next->next, *slow = head;\\n        while(fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode *r = sortList(slow->next);\\n        slow->next = NULL;\\n        ListNode *l = sortList(head);\\n        return merge(l, r);\\n    }\\n    \\n    ListNode *merge(ListNode *l, ListNode *r) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        while (l && r) {\\n            if (l->val < r->val) {\\n                node->next = l;\\n                l = l->next;\\n            } else {\\n                node->next = r;\\n                r = r->next;\\n            }\\n            node = node->next;\\n        }\\n        if (l)\\n            node->next = l;\\n        else \\n            node->next = r;\\n        return dummy->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46808,
                "title": "my-python-solution-merge-sort",
                "content": "```\\nclass Solution(object):\\n\\n    def sortList(self, head):\\n        if head is None or head.next is None:\\n            return head\\n        middle_node = self.find_middle_node(head)\\n        right_head = middle_node.next\\n        middle_node.next = None\\n        return self.merge(self.sortList(head), self.sortList(right_head))\\n    \\n    def find_middle_node(self, head):\\n        slow, fast = head, head\\n        while fast and fast.next and fast.next.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        return slow\\n        \\n    def merge(self, head1, head2):\\n        dummy = ListNode(None)\\n        node = dummy\\n        while head1 and head2:\\n            if head1.val < head2.val:\\n                node.next = head1\\n                head1 = head1.next\\n            else:\\n                node.next = head2\\n                head2 = head2.next\\n            node = node.next\\n            \\n        node.next = head1 or head2\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def sortList(self, head):\\n        if head is None or head.next is None:\\n            return head\\n        middle_node = self.find_middle_node(head)\\n        right_head = middle_node.next\\n        middle_node.next = None\\n        return self.merge(self.sortList(head), self.sortList(right_head))\\n    \\n    def find_middle_node(self, head):\\n        slow, fast = head, head\\n        while fast and fast.next and fast.next.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        return slow\\n        \\n    def merge(self, head1, head2):\\n        dummy = ListNode(None)\\n        node = dummy\\n        while head1 and head2:\\n            if head1.val < head2.val:\\n                node.next = head1\\n                head1 = head1.next\\n            else:\\n                node.next = head2\\n                head2 = head2.next\\n            node = node.next\\n            \\n        node.next = head1 or head2\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796085,
                "title": "sort-list-python-o-nlogn-solution-95-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        # Split the list into two halfs\\n        left = head\\n        right = self.getMid(head)\\n        tmp = right.next\\n        right.next = None\\n        right = tmp\\n        \\n        left = self.sortList(left)\\n        right = self.sortList(right)\\n        \\n        return self.merge(left, right)\\n    \\n    def getMid(self, head):\\n        slow = head\\n        fast = head.next\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow\\n    \\n    # Merge the list\\n    def merge(self, list1, list2):\\n        newHead = tail = ListNode()\\n        while list1 and list2:\\n            if list1.val > list2.val:\\n                tail.next = list2\\n                list2 = list2.next\\n            else:\\n                tail.next = list1\\n                list1 = list1.next\\n            tail = tail.next\\n        \\n        if list1:\\n            tail.next = list1\\n        if list2:\\n            tail.next = list2\\n        \\n        return newHead.next\\n        \\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        # Split the list into two halfs\\n        left = head\\n        right = self.getMid(head)\\n        tmp = right.next\\n        right.next = None\\n        right = tmp\\n        \\n        left = self.sortList(left)\\n        right = self.sortList(right)\\n        \\n        return self.merge(left, right)\\n    \\n    def getMid(self, head):\\n        slow = head\\n        fast = head.next\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow\\n    \\n    # Merge the list\\n    def merge(self, list1, list2):\\n        newHead = tail = ListNode()\\n        while list1 and list2:\\n            if list1.val > list2.val:\\n                tail.next = list2\\n                list2 = list2.next\\n            else:\\n                tail.next = list1\\n                list1 = list1.next\\n            tail = tail.next\\n        \\n        if list1:\\n            tail.next = list1\\n        if list2:\\n            tail.next = list2\\n        \\n        return newHead.next\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 46857,
                "title": "clean-and-short-merge-sort-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        ListNode* merge( ListNode* head1 , ListNode * head2){\\n            ListNode* d = new ListNode (0);            // dummy node\\n            ListNode* e = d;\\n            while(head1||head2){\\n                if(head1 && (!head2 || head1->val <= head2 -> val) ){\\n                    e=e->next= head1 ; \\n                    head1 = head1 -> next;\\n                }\\n                if(head2 && (!head1 || head2->val < head1 -> val) ){\\n                    e=e->next= head2 ; \\n                    head2 = head2 -> next;\\n                }\\n            }\\n            e->next = NULL;\\n            return d->next;\\n        }\\n       ListNode* sortList(ListNode* head) {\\n            if(!head || !head->next) return head;\\n            ListNode* slow = head;\\n            ListNode* fast =head->next;\\n             while(fast && fast->next){         // to find middle node     \\n                fast= fast->next->next;\\n                slow = slow->next;\\n            }\\n            ListNode* headb = slow->next;     // headb is start of 2nd half of list\\n            slow->next = NULL;                 \\n            return merge(sortList(head) , sortList(headb));\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* merge( ListNode* head1 , ListNode * head2){\\n            ListNode* d = new ListNode (0);            // dummy node\\n            ListNode* e = d;\\n            while(head1||head2){\\n                if(head1 && (!head2 || head1->val <= head2 -> val) ){\\n                    e=e->next= head1 ; \\n                    head1 = head1 -> next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3206790,
                "title": "148-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach we will use is Merge Sort:\\n\\n1. Base Case: If the length of the linked list is less than or equal to 1, then the list is already sorted.\\n2. Split the linked list into two halves. We will use the \"slow and fast pointer\" technique to find the midpoint of the linked list.\\n3. Recursively sort the left and right halves of the linked list.\\n4. Merge the two sorted halves of the linked list.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) because we are dividing the linked list in half log n times, and merging the two halves in linear time.\\n\\n- Space complexity:\\nO(log n) because the space used by the call stack during the recursive calls is log n.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case: If the length of the linked list is less than or equal to 1, then the list is already sorted\\n        if not head or not head.next:\\n            return head\\n\\n        # Split the linked list into two halves using \"slow and fast pointer\" technique to find the midpoint of the linked list\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        # The midpoint of the linked list is slow.next\\n        mid = slow.next\\n        # Set slow.next to None to separate the left and right halves of the linked list\\n        slow.next = None\\n\\n        # Recursively sort the left and right halves of the linked list\\n        left = self.sortList(head)\\n        right = self.sortList(mid)\\n\\n        # Merge the two sorted halves of the linked list\\n        dummy = ListNode(0)\\n        curr = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                curr.next = left\\n                left = left.next\\n            else:\\n                curr.next = right\\n                right = right.next\\n            curr = curr.next\\n        # Append the remaining nodes of the left or right half to the end of the sorted list\\n        curr.next = left or right\\n\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case: If the length of the linked list is less than or equal to 1, then the list is already sorted\\n        if not head or not head.next:\\n            return head\\n\\n        # Split the linked list into two halves using \"slow and fast pointer\" technique to find the midpoint of the linked list\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        # The midpoint of the linked list is slow.next\\n        mid = slow.next\\n        # Set slow.next to None to separate the left and right halves of the linked list\\n        slow.next = None\\n\\n        # Recursively sort the left and right halves of the linked list\\n        left = self.sortList(head)\\n        right = self.sortList(mid)\\n\\n        # Merge the two sorted halves of the linked list\\n        dummy = ListNode(0)\\n        curr = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                curr.next = left\\n                left = left.next\\n            else:\\n                curr.next = right\\n                right = right.next\\n            curr = curr.next\\n        # Append the remaining nodes of the left or right half to the end of the sorted list\\n        curr.next = left or right\\n\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583753,
                "title": "intuitive-javascript-solution-with-mergesort",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    /**\\n     * The goal is to use merge sort on the linked list. \\n     * We need to split the list into two and merge them in the ascending order \\n     * recursively.\\n     */\\n    const [left, right] = split(head);\\n    // use a temparary node to link all the sorted nodes\\n    const root = new ListNode(null);\\n    return merge(root, sortList(left), sortList(right))\\n};\\n\\nfunction split(node) {\\n    let slow = node;\\n    let fast = node;\\n    // use fast & slow pointer to find the middle node so that \\n    // we can split the list into list[0 -> slow] & list[slow + 1 -> list.size]\\n    while (fast.next && fast.next.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    const left = node;\\n    const right = slow.next;\\n    // break off the list so that `left` doesn\\'t link to `right`\\n    slow.next = null;\\n    \\n    return [left, right];\\n}\\n\\nfunction merge(root, left, right) {\\n    let pointer = root;\\n    /**\\n     * merge the smaller node in the `left` and `right` list first.\\n     * return the second node in the list because the first is a \\n     * temparary node.\\n     */\\n    while(left !== null || right !== null) {\\n        if (left === null) {\\n            pointer.next = right;\\n            right = right.next;\\n        } else if (right === null) {\\n            pointer.next = left;\\n            left = left.next;\\n        } else {\\n            if (left.val < right.val) {\\n                pointer.next = left;\\n                left = left.next;\\n            } else {\\n                pointer.next = right;\\n                right = right.next;\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\n    return root.next;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    /**\\n     * The goal is to use merge sort on the linked list. \\n     * We need to split the list into two and merge them in the ascending order \\n     * recursively.\\n     */\\n    const [left, right] = split(head);\\n    // use a temparary node to link all the sorted nodes\\n    const root = new ListNode(null);\\n    return merge(root, sortList(left), sortList(right))\\n};\\n\\nfunction split(node) {\\n    let slow = node;\\n    let fast = node;\\n    // use fast & slow pointer to find the middle node so that \\n    // we can split the list into list[0 -> slow] & list[slow + 1 -> list.size]\\n    while (fast.next && fast.next.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    const left = node;\\n    const right = slow.next;\\n    // break off the list so that `left` doesn\\'t link to `right`\\n    slow.next = null;\\n    \\n    return [left, right];\\n}\\n\\nfunction merge(root, left, right) {\\n    let pointer = root;\\n    /**\\n     * merge the smaller node in the `left` and `right` list first.\\n     * return the second node in the list because the first is a \\n     * temparary node.\\n     */\\n    while(left !== null || right !== null) {\\n        if (left === null) {\\n            pointer.next = right;\\n            right = right.next;\\n        } else if (right === null) {\\n            pointer.next = left;\\n            left = left.next;\\n        } else {\\n            if (left.val < right.val) {\\n                pointer.next = left;\\n                left = left.next;\\n            } else {\\n                pointer.next = right;\\n                right = right.next;\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\n    return root.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892573,
                "title": "c-o-n-log-n-solution-using-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode *cur = new ListNode(0);\\n        ListNode *temp = cur;\\n        while(l1 && l2) {\\n            if(l1->val < l2->val) {\\n                cur->next = l1;\\n                l1 = l1->next;\\n            }\\n            else {\\n                cur->next = l2;\\n                l2 = l2->next;\\n            }\\n            cur = cur->next;\\n        }\\n        if(l1) {\\n\\t\\t\\tcur->next = l1;\\n\\t\\t}\\n        if(l2) {\\n\\t\\t\\tcur->next = l2;\\n\\t\\t}\\n        return temp->next;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        // Base Case if the list has 0 or 1 element it means it is already sorted\\n        if(!head || !head->next) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while(fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        // Divide the list into two parts (one start with head and other with fast)\\n        fast = slow->next;\\n        slow->next = NULL;\\n        // Merge these List \\n        return merge(sortList(head), sortList(fast));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode *cur = new ListNode(0);\\n        ListNode *temp = cur;\\n        while(l1 && l2) {\\n            if(l1->val < l2->val) {\\n                cur->next = l1;\\n                l1 = l1->next;\\n            }\\n            else {\\n                cur->next = l2;\\n                l2 = l2->next;\\n            }\\n            cur = cur->next;\\n        }\\n        if(l1) {\\n\\t\\t\\tcur->next = l1;\\n\\t\\t}\\n        if(l2) {\\n\\t\\t\\tcur->next = l2;\\n\\t\\t}\\n        return temp->next;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        // Base Case if the list has 0 or 1 element it means it is already sorted\\n        if(!head || !head->next) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while(fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        // Divide the list into two parts (one start with head and other with fast)\\n        fast = slow->next;\\n        slow->next = NULL;\\n        // Merge these List \\n        return merge(sortList(head), sortList(fast));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840212,
                "title": "python-merge-sort-o-nlogn-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def divide(self,head):\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        return slow\\n    \\n    def Merge(self,l,r):\\n        temp=ans=ListNode()\\n        while l and r:\\n            if l.val<=r.val:\\n                temp.next=l\\n                l=l.next\\n            else:\\n                temp.next=r\\n                r=r.next\\n            temp=temp.next\\n        if l:\\n            temp.next=l\\n        if r:\\n            temp.next=r\\n        return ans.next\\n            \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        left=head\\n        right=self.divide(head)\\n        temp=right.next\\n        right.next=None\\n        right=temp\\n        left=self.sortList(left)\\n        right=self.sortList(right)\\n        return self.Merge(left,right)\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def divide(self,head):\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        return slow\\n    \\n    def Merge(self,l,r):\\n        temp=ans=ListNode()\\n        while l and r:\\n            if l.val<=r.val:\\n                temp.next=l\\n                l=l.next\\n            else:\\n                temp.next=r\\n                r=r.next\\n            temp=temp.next\\n        if l:\\n            temp.next=l\\n        if r:\\n            temp.next=r\\n        return ans.next\\n            \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        left=head\\n        right=self.divide(head)\\n        temp=right.next\\n        right.next=None\\n        right=temp\\n        left=self.sortList(left)\\n        right=self.sortList(right)\\n        return self.Merge(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337254,
                "title": "c-efficient-solution-o-nlog-n-o-1-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* midpoint(ListNode* head){\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *slow = head, *fast = head->next;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    ListNode* mergeSortedLists(ListNode* a, ListNode* b){\\n        if(a == NULL) return b;\\n        if(b == NULL) return a;\\n        \\n        ListNode* temp;\\n        if(a->val <= b->val){\\n            temp = a;\\n            temp->next = mergeSortedLists(a->next, b);\\n        }\\n        else{\\n            temp = b;\\n            temp->next = mergeSortedLists(a, b->next);\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        ListNode* mid = midpoint(head);\\n        ListNode* a = head;\\n        ListNode* b = mid->next;\\n        \\n        mid->next = NULL;\\n        \\n        a = sortList(a);\\n        b = sortList(b);\\n        \\n        ListNode* temp = mergeSortedLists(a, b);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* midpoint(ListNode* head){\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *slow = head, *fast = head->next;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    ListNode* mergeSortedLists(ListNode* a, ListNode* b){\\n        if(a == NULL) return b;\\n        if(b == NULL) return a;\\n        \\n        ListNode* temp;\\n        if(a->val <= b->val){\\n            temp = a;\\n            temp->next = mergeSortedLists(a->next, b);\\n        }\\n        else{\\n            temp = b;\\n            temp->next = mergeSortedLists(a, b->next);\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        ListNode* mid = midpoint(head);\\n        ListNode* a = head;\\n        ListNode* b = mid->next;\\n        \\n        mid->next = NULL;\\n        \\n        a = sortList(a);\\n        b = sortList(b);\\n        \\n        ListNode* temp = mergeSortedLists(a, b);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892537,
                "title": "python-js-by-merge-sort-w-comment",
                "content": "Python by merge sort\\n\\n---\\n\\n**Implementation** by merge sort\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        \\n        # -------------------------------\\n        \\n        def merge( a, b):\\n            \\n            if not a:\\n                return b\\n            \\n            elif not b:\\n                return a\\n            \\n            if a.val < b.val:\\n                a.next = merge(a.next, b)\\n                return a\\n                \\n            else:\\n                b.next = merge(a, b.next)\\n                return b\\n        \\n        # -------------------------------\\n        \\n        ## base case\\n        \\n        if head is None:\\n            # empty node\\n            return None\\n        \\n        elif head.next is None:\\n            # one node only\\n            return head\\n        \\n        ## general case\\n        # divide into two halves\\n        \\n        pre, slow, fast = None, head, head\\n        \\n        while fast and fast.next:\\n            pre, slow, fast = slow, slow.next, fast.next.next\\n        \\n\\t\\tif pre:\\n\\t\\t\\tpre.next = None\\n\\n        \\n        # sort by divide-and-conquer\\n        \\n        first_half = self.sortList(head)\\n        second_half = self.sortList(slow)\\n        result = merge(first_half, second_half)\\n        return result\\n        \\n        \\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar sortList = function(head) {\\n    \\n    \\n    var merge = function(a, b){\\n        \\n        if( a == null ){\\n            return b;\\n        }else if( b == null ){\\n            return a;\\n        }\\n        \\n        if( a.val < b.val ){\\n            a.next = merge(a.next, b);\\n            return a;\\n        }else{\\n            b.next = merge(a, b.next);\\n            return b;\\n        }\\n        \\n    }\\n    \\n    // ------------------------------\\n    \\n    // Base case:\\n    \\n    if( head == null ){\\n        \\n        // Empty linked list\\n        return null;\\n        \\n    }else if ( head.next == null ){\\n        \\n        // Linked list with one node only\\n        return head;\\n    }\\n    \\n    \\n    \\n    // General cases:\\n    let [prev, slow, fast] = [null, head, head];\\n    \\n    while( (fast != null) && (fast.next != null) ){\\n        \\n        //[prev, slow, fast] = [slow, slow.next, fast.next.next];\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n\\n    // cut the linkage on midpoint\\n    if( prev != null ){\\n        prev.next = null;    \\n    }\\n    \\n    \\n    // sort by divide and conquer\\n    let firstHalf = sortList(head);\\n    let secondHalf = sortList(slow);\\n    \\n    \\n    result = merge( firstHalf, secondHalf );\\n    \\n    \\n    return result;\\n};\\n```\\n\\n\\n---\\n\\nReference:\\n\\n[1] Wiki: [Merge Sort](https://en.wikipedia.org/wiki/Merge_sort)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        \\n        # -------------------------------\\n        \\n        def merge( a, b):\\n            \\n            if not a:\\n                return b\\n            \\n            elif not b:\\n                return a\\n            \\n            if a.val < b.val:\\n                a.next = merge(a.next, b)\\n                return a\\n                \\n            else:\\n                b.next = merge(a, b.next)\\n                return b\\n        \\n        # -------------------------------\\n        \\n        ## base case\\n        \\n        if head is None:\\n            # empty node\\n            return None\\n        \\n        elif head.next is None:\\n            # one node only\\n            return head\\n        \\n        ## general case\\n        # divide into two halves\\n        \\n        pre, slow, fast = None, head, head\\n        \\n        while fast and fast.next:\\n            pre, slow, fast = slow, slow.next, fast.next.next\\n        \\n\\t\\tif pre:\\n\\t\\t\\tpre.next = None\\n\\n        \\n        # sort by divide-and-conquer\\n        \\n        first_half = self.sortList(head)\\n        second_half = self.sortList(slow)\\n        result = merge(first_half, second_half)\\n        return result\\n        \\n        \\n```\n```\\nvar sortList = function(head) {\\n    \\n    \\n    var merge = function(a, b){\\n        \\n        if( a == null ){\\n            return b;\\n        }else if( b == null ){\\n            return a;\\n        }\\n        \\n        if( a.val < b.val ){\\n            a.next = merge(a.next, b);\\n            return a;\\n        }else{\\n            b.next = merge(a, b.next);\\n            return b;\\n        }\\n        \\n    }\\n    \\n    // ------------------------------\\n    \\n    // Base case:\\n    \\n    if( head == null ){\\n        \\n        // Empty linked list\\n        return null;\\n        \\n    }else if ( head.next == null ){\\n        \\n        // Linked list with one node only\\n        return head;\\n    }\\n    \\n    \\n    \\n    // General cases:\\n    let [prev, slow, fast] = [null, head, head];\\n    \\n    while( (fast != null) && (fast.next != null) ){\\n        \\n        //[prev, slow, fast] = [slow, slow.next, fast.next.next];\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n\\n    // cut the linkage on midpoint\\n    if( prev != null ){\\n        prev.next = null;    \\n    }\\n    \\n    \\n    // sort by divide and conquer\\n    let firstHalf = sortList(head);\\n    let secondHalf = sortList(slow);\\n    \\n    \\n    result = merge( firstHalf, secondHalf );\\n    \\n    \\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417365,
                "title": "c-java-python-javascript-memory-o-1-3-approaches-linked-list",
                "content": "# Approach 1: Time Complexity: O(nlogn) Space Complexity: O(n)\\n**Intuition:**\\nThe problem asks to sort the linked list, so the most straightforward approach is to convert the linked list into an array or vector, sort it using the built-in sort function, and then create a new linked list using the sorted values.\\n\\n**Approach:**\\n\\n1. Check if the given linked list is empty or not.\\n2. Traverse the linked list and store the node values into a vector.\\n3. Sort the vector using the built-in sort function.\\n4. Create a new linked list using the sorted vector.\\n5. Return the head of the newly created linked list.\\n\\n**Complexity:**\\n- Time Complexity: O(nlogn) as the vector is sorted using the built-in sort function.\\n- Space Complexity: O(n) as we store all the node values in a vector.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        ListNode* ptr=head;\\n        vector<int> vec;\\n        while(ptr){\\n            vec.push_back(ptr->val);\\n            ptr=ptr->next;\\n        }\\n        sort(vec.begin(),vec.end());\\n        ListNode* n = new ListNode(vec[0]);\\n        head=n;\\n        ListNode* temp=head;\\n        for(int i=1;i<vec.size();i++){\\n            ListNode* n1 = new ListNode(vec[i]);\\n            temp->next=n1;\\n            temp=temp->next;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode ptr=head;\\n        List<Integer> list=new ArrayList<>();\\n        while(ptr!=null){\\n            list.add(ptr.val);\\n            ptr=ptr.next;\\n        }\\n        Collections.sort(list);\\n        ListNode n = new ListNode(list.get(0));\\n        head=n;\\n        ListNode temp=head;\\n        for(int i=1;i<list.size();i++){\\n            ListNode n1 = new ListNode(list.get(i));\\n            temp.next=n1;\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if head is None:\\n            return None\\n        ptr=head\\n        arr=[]\\n        while ptr is not None:\\n            arr.append(ptr.val)\\n            ptr=ptr.next\\n        arr.sort()\\n        n = ListNode(arr[0])\\n        head=n\\n        temp=head\\n        for i in range(1,len(arr)):\\n            n1 = ListNode(arr[i])\\n            temp.next=n1\\n            temp=temp.next       \\n        return head\\n\\n```\\n\\n# JavaScript\\n```\\nvar sortList = function(head) {\\n    if(head==null){\\n        return null;\\n    }\\n    let ptr=head;\\n    let arr=[];\\n    while(ptr){\\n        arr.push(ptr.val);\\n        ptr=ptr.next;\\n    }\\n    arr.sort((a,b)=>a-b);\\n    let n = new ListNode(arr[0]);\\n    head=n;\\n    let temp=head;\\n    for(let i=1;i<arr.length;i++){\\n        let n1 = new ListNode(arr[i]);\\n        temp.next=n1;\\n        temp=temp.next;       \\n    }\\n    return head;\\n};\\n```\\n\\n---\\n# Approach 2: Time Complexity: O(nlogn) Space Complexity: O(log n)\\n\\n**Intuition:**\\nThe merge sort algorithm is based on the divide-and-conquer strategy. It recursively divides the linked list into two halves, sorts each half separately, and then merges the sorted halves to obtain the final sorted list.\\n\\n**Approach:**\\n1. The `merge()` function is responsible for merging two sorted linked lists `l1` and `l2`. It maintains a dummy node (`dummy`) and a `tail` pointer to build the merged list.\\n2. Iterate while both `l1` and `l2` are not `nullptr`.\\n    - If the value of the current node in `l1` is less than or equal to the value of the current node in `l2`, append the current node from `l1` to the merged list, and move the `l1` pointer to the next node.\\n    - Otherwise, append the current node from `l2` to the merged list, and move the `l2` pointer to the next node.\\n    - Move the `tail` pointer to the next node.\\n3. After the above loop, if any elements are remaining in either `l1` or `l2`, append them to the merged list.\\n4. Return the `next` pointer of the dummy node, which will be the head of the merged list.\\n\\n5. The `sortList()` function is the recursive implementation of merge sort for a linked list.\\n    - If the `head` is `nullptr` or there is only one node in the list (`head->next` is `nullptr`), return the `head` itself as it is already sorted.\\n    - Find the middle node of the list using the slow and fast pointer approach.\\n    - Break the list into two halves by setting the `next` pointer of the node before the middle node to `nullptr`.\\n    - Recursively call `sortList()` on the first half (`head` to `slow`) and the second half (`mid` to the end of the list).\\n    - Merge the two sorted halves using the `merge()` function.\\n    - Return the head of the merged and sorted list.\\n\\n**Complexity:**\\n- The time complexity of the `merge()` function is O(n), where n is the total number of nodes in the merged list. Each node is visited once during the merging process.\\n- The `sortList()` function has a time complexity of O(n log n), where n is the total number of nodes in the linked list. This is because the list is divided into halves recursively until there is only one node in each partition. The merge step takes O(n) time at each level of recursion.\\n- The space complexity is O(log n) due to the recursion stack used in the `sortList()` function.\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode dummy(0);\\n        ListNode* tail = &dummy;\\n\\n        while (l1 && l2) {\\n            if (l1->val <= l2->val) {\\n                tail->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                tail->next = l2;\\n                l2 = l2->next;\\n            }\\n            tail = tail->next;\\n        }\\n\\n        if (l1)\\n            tail->next = l1;\\n        else if (l2)\\n            tail->next = l2;\\n\\n        return dummy.next;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head->next)\\n        return head;\\n\\n        // Find the middle node using slow and fast pointers\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        ListNode* mid = slow->next;\\n        slow->next = nullptr; // Break the list into two halves\\n\\n        ListNode* l1 = sortList(head); // Sort the first half\\n        ListNode* l2 = sortList(mid);  // Sort the second half\\n\\n        return merge(l1, l2); // Merge the sorted halves\\n    }\\n};\\n```\\n\\n# JavaScript\\n```\\nvar merge = function (l1, l2) {\\n    let dummy = new ListNode(0);\\n    let tail = dummy;\\n\\n    while (l1 && l2) {\\n        if (l1.val <= l2.val) {\\n            tail.next = l1;\\n            l1 = l1.next;\\n        } else {\\n            tail.next = l2;\\n            l2 = l2.next;\\n        }\\n        tail = tail.next;\\n    }\\n\\n    if (l1)\\n        tail.next = l1;\\n    else if (l2)\\n        tail.next = l2;\\n\\n    return dummy.next;\\n};\\n\\nvar sortList = function (head) {\\n    if (!head || !head.next)\\n        return head;\\n\\n    let slow = head;\\n    let fast = head.next;\\n    while (fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n\\n    let mid = slow.next;\\n    slow.next = null;\\n\\n    let l1 = sortList(head);\\n    let l2 = sortList(mid);\\n\\n    return merge(l1, l2);\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode tail = dummy;\\n\\n        while (l1 != null && l2 != null) {\\n            if (l1.val <= l2.val) {\\n                tail.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                tail.next = l2;\\n                l2 = l2.next;\\n            }\\n            tail = tail.next;\\n        }\\n\\n        if (l1 != null)\\n            tail.next = l1;\\n        else if (l2 != null)\\n            tail.next = l2;\\n\\n        return dummy.next;\\n    }\\n\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode mid = slow.next;\\n        slow.next = null;\\n\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(mid);\\n\\n        return merge(l1, l2);\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        tail = dummy\\n\\n        while l1 and l2:\\n            if l1.val <= l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n            tail = tail.next\\n\\n        if l1:\\n            tail.next = l1\\n        elif l2:\\n            tail.next = l2\\n\\n        return dummy.next\\n\\n    def sortList(self, head):\\n        if not head or not head.next:\\n            return head\\n\\n        # Find the middle node using slow and fast pointers\\n        slow = head\\n        fast = head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        mid = slow.next\\n        slow.next = None  # Break the list into two halves\\n\\n        l1 = self.sortList(head)  # Sort the first half\\n        l2 = self.sortList(mid)   # Sort the second half\\n\\n        return self.merge(l1, l2)  # Merge the sorted halves\\n```\\n---\\n\\n# Approach 3: Time Complexity: O(nlogn) Space Complexity: O(1)\\n\\n1. The `sortList` function takes the head of the linked list as input and returns the sorted linked list.\\n2. The first step is to check if the list is empty or contains only one element. In such cases, the list is already sorted, so the function simply returns the head.\\n3. The `getLength` function is used to determine the length of the linked list.\\n4. The `split` function takes a linked list and a step size as input. It traverses the linked list until the specified step size is reached or the end of the list is reached. It then splits the list by setting the `next` pointer of the last node in the left sublist to `nullptr` and returns the head of the right sublist.\\n5. The `merge` function takes two sorted linked lists (`left` and `right`) and a `tail` pointer as input. It merges the two lists into a single sorted list and returns the tail of the merged list.\\n6. The main sorting logic is implemented using a loop that iterates until the step size is greater than or equal to the length of the list.\\n7. Inside the loop, a `curr` pointer is set to the head of the list, and a `tail` pointer is set to a dummy node (`dummy`) that is initially connected to the head.\\n8. The `while` loop is used to iterate through the list in pairs, where each pair consists of a left sublist, a right sublist, and a merged sublist.\\n9. Within the loop, the `split` function is used to split the list into left and right sublists of size `step`.\\n10. The `merge` function is then called to merge the left and right sublists into a single sorted sublist, and the `tail` pointer is updated to point to the last node of the merged sublist.\\n11. After the loop completes, the sorted list is stored in `dummy.next`, and the function returns the head of the sorted list.\\n\\n**Complexity:**\\n- The time complexity of this algorithm is O(n log n), where n is the length of the linked list. This is because the list is divided into smaller sublists in each iteration, and merging two sorted sublists takes linear time. \\n- The space complexity is O(1) since the algorithm sorts the list in place without using any extra space, except for the dummy node.\\n\\nOverall, the code efficiently sorts a singly-linked list using the Merge Sort algorithm.\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)\\n            return head;\\n\\n        int length = getLength(head);\\n        ListNode dummy(0);\\n        dummy.next = head;\\n\\n        for (int step = 1; step < length; step *= 2) {\\n            ListNode* curr = dummy.next;\\n            ListNode* tail = &dummy;\\n\\n            while (curr) {\\n                ListNode* left = curr;\\n                ListNode* right = split(left, step);\\n                curr = split(right, step);\\n\\n                tail = merge(left, right, tail);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\nprivate:\\n    int getLength(ListNode* head) {\\n        int length = 0;\\n        ListNode* curr = head;\\n        while (curr) {\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n    ListNode* split(ListNode* head, int step) {\\n        if (head == nullptr)\\n            return nullptr;\\n\\n        for (int i = 1; i < step && head->next; i++) {\\n            head = head->next;\\n        }\\n\\n        ListNode* right = head->next;\\n        head->next = nullptr;\\n        return right;\\n    }\\n\\n    ListNode* merge(ListNode* left, ListNode* right, ListNode* tail) {\\n        ListNode* curr = tail;\\n        while (left && right) {\\n            if (left->val < right->val) {\\n                curr->next = left;\\n                left = left->next;\\n            } else {\\n                curr->next = right;\\n                right = right->next;\\n            }\\n            curr = curr->next;\\n        }\\n\\n        curr->next = left ? left : right;\\n        while (curr->next)\\n            curr = curr->next;\\n\\n        return curr;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        int length = getLength(head);\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        for (int step = 1; step < length; step *= 2) {\\n            ListNode curr = dummy.next;\\n            ListNode tail = dummy;\\n\\n            while (curr != null) {\\n                ListNode left = curr;\\n                ListNode right = split(left, step);\\n                curr = split(right, step);\\n\\n                tail = merge(left, right, tail);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    private int getLength(ListNode head) {\\n        int length = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        return length;\\n    }\\n\\n    private ListNode split(ListNode head, int step) {\\n        if (head == null)\\n            return null;\\n\\n        for (int i = 1; i < step && head.next != null; i++) {\\n            head = head.next;\\n        }\\n\\n        ListNode right = head.next;\\n        head.next = null;\\n        return right;\\n    }\\n\\n    private ListNode merge(ListNode left, ListNode right, ListNode tail) {\\n        ListNode curr = tail;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                curr.next = left;\\n                left = left.next;\\n            } else {\\n                curr.next = right;\\n                right = right.next;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        curr.next = (left != null) ? left : right;\\n        while (curr.next != null)\\n            curr = curr.next;\\n\\n        return curr;\\n    }\\n}\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if head is None or head.next is None:\\n            return head\\n\\n        length = self.getLength(head)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n\\n        step = 1\\n        while step < length:\\n            curr = dummy.next\\n            tail = dummy\\n\\n            while curr:\\n                left = curr\\n                right = self.split(left, step)\\n                curr = self.split(right, step)\\n\\n                tail = self.merge(left, right, tail)\\n\\n            step *= 2\\n\\n        return dummy.next\\n\\n    def getLength(self, head):\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        return length\\n\\n    def split(self, head, step):\\n        if head is None:\\n            return None\\n\\n        for i in xrange(1, step):\\n            if head.next is None:\\n                break\\n            head = head.next\\n\\n        right = head.next\\n        head.next = None\\n        return right\\n\\n    def merge(self, left, right, tail):\\n        curr = tail\\n        while left and right:\\n            if left.val < right.val:\\n                curr.next = left\\n                left = left.next\\n            else:\\n                curr.next = right\\n                right = right.next\\n            curr = curr.next\\n\\n        curr.next = left if left else right\\n        while curr.next:\\n            curr = curr.next\\n\\n        return curr\\n\\n```\\n# JavaScript\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head){\\n    if (head === null || head.next === null)\\n        return head;\\n\\n    const getLength = function (head) {\\n        let length = 0;\\n        let curr = head;\\n        while (curr) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        return length;\\n    };\\n\\n    const split = function (head, step) {\\n        if (head === null)\\n            return null;\\n\\n        for (let i = 1; i < step && head.next; i++) {\\n            head = head.next;\\n        }\\n\\n        const right = head.next;\\n        head.next = null;\\n        return right;\\n    };\\n\\n    const merge = function (left, right, tail) {\\n        let curr = tail;\\n        while (left && right) {\\n            if (left.val < right.val) {\\n                curr.next = left;\\n                left = left.next;\\n            } else {\\n                curr.next = right;\\n                right = right.next;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        curr.next = left ? left : right;\\n        while (curr.next)\\n            curr = curr.next;\\n\\n        return curr;\\n    };\\n\\n    const length = getLength(head);\\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n\\n    let step = 1;\\n    while (step < length) {\\n        let curr = dummy.next;\\n        let tail = dummy;\\n\\n        while (curr) {\\n            const left = curr;\\n            const right = split(left, step);\\n            curr = split(right, step);\\n\\n            tail = merge(left, right, tail);\\n        }\\n\\n        step *= 2;\\n    }\\n\\n    return dummy.next;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        ListNode* ptr=head;\\n        vector<int> vec;\\n        while(ptr){\\n            vec.push_back(ptr->val);\\n            ptr=ptr->next;\\n        }\\n        sort(vec.begin(),vec.end());\\n        ListNode* n = new ListNode(vec[0]);\\n        head=n;\\n        ListNode* temp=head;\\n        for(int i=1;i<vec.size();i++){\\n            ListNode* n1 = new ListNode(vec[i]);\\n            temp->next=n1;\\n            temp=temp->next;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode ptr=head;\\n        List<Integer> list=new ArrayList<>();\\n        while(ptr!=null){\\n            list.add(ptr.val);\\n            ptr=ptr.next;\\n        }\\n        Collections.sort(list);\\n        ListNode n = new ListNode(list.get(0));\\n        head=n;\\n        ListNode temp=head;\\n        for(int i=1;i<list.size();i++){\\n            ListNode n1 = new ListNode(list.get(i));\\n            temp.next=n1;\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if head is None:\\n            return None\\n        ptr=head\\n        arr=[]\\n        while ptr is not None:\\n            arr.append(ptr.val)\\n            ptr=ptr.next\\n        arr.sort()\\n        n = ListNode(arr[0])\\n        head=n\\n        temp=head\\n        for i in range(1,len(arr)):\\n            n1 = ListNode(arr[i])\\n            temp.next=n1\\n            temp=temp.next       \\n        return head\\n\\n```\n```\\nvar sortList = function(head) {\\n    if(head==null){\\n        return null;\\n    }\\n    let ptr=head;\\n    let arr=[];\\n    while(ptr){\\n        arr.push(ptr.val);\\n        ptr=ptr.next;\\n    }\\n    arr.sort((a,b)=>a-b);\\n    let n = new ListNode(arr[0]);\\n    head=n;\\n    let temp=head;\\n    for(let i=1;i<arr.length;i++){\\n        let n1 = new ListNode(arr[i]);\\n        temp.next=n1;\\n        temp=temp.next;       \\n    }\\n    return head;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode dummy(0);\\n        ListNode* tail = &dummy;\\n\\n        while (l1 && l2) {\\n            if (l1->val <= l2->val) {\\n                tail->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                tail->next = l2;\\n                l2 = l2->next;\\n            }\\n            tail = tail->next;\\n        }\\n\\n        if (l1)\\n            tail->next = l1;\\n        else if (l2)\\n            tail->next = l2;\\n\\n        return dummy.next;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head->next)\\n        return head;\\n\\n        // Find the middle node using slow and fast pointers\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        ListNode* mid = slow->next;\\n        slow->next = nullptr; // Break the list into two halves\\n\\n        ListNode* l1 = sortList(head); // Sort the first half\\n        ListNode* l2 = sortList(mid);  // Sort the second half\\n\\n        return merge(l1, l2); // Merge the sorted halves\\n    }\\n};\\n```\n```\\nvar merge = function (l1, l2) {\\n    let dummy = new ListNode(0);\\n    let tail = dummy;\\n\\n    while (l1 && l2) {\\n        if (l1.val <= l2.val) {\\n            tail.next = l1;\\n            l1 = l1.next;\\n        } else {\\n            tail.next = l2;\\n            l2 = l2.next;\\n        }\\n        tail = tail.next;\\n    }\\n\\n    if (l1)\\n        tail.next = l1;\\n    else if (l2)\\n        tail.next = l2;\\n\\n    return dummy.next;\\n};\\n\\nvar sortList = function (head) {\\n    if (!head || !head.next)\\n        return head;\\n\\n    let slow = head;\\n    let fast = head.next;\\n    while (fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n\\n    let mid = slow.next;\\n    slow.next = null;\\n\\n    let l1 = sortList(head);\\n    let l2 = sortList(mid);\\n\\n    return merge(l1, l2);\\n};\\n```\n```\\nclass Solution {\\n    public ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode tail = dummy;\\n\\n        while (l1 != null && l2 != null) {\\n            if (l1.val <= l2.val) {\\n                tail.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                tail.next = l2;\\n                l2 = l2.next;\\n            }\\n            tail = tail.next;\\n        }\\n\\n        if (l1 != null)\\n            tail.next = l1;\\n        else if (l2 != null)\\n            tail.next = l2;\\n\\n        return dummy.next;\\n    }\\n\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode mid = slow.next;\\n        slow.next = null;\\n\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(mid);\\n\\n        return merge(l1, l2);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        tail = dummy\\n\\n        while l1 and l2:\\n            if l1.val <= l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n            tail = tail.next\\n\\n        if l1:\\n            tail.next = l1\\n        elif l2:\\n            tail.next = l2\\n\\n        return dummy.next\\n\\n    def sortList(self, head):\\n        if not head or not head.next:\\n            return head\\n\\n        # Find the middle node using slow and fast pointers\\n        slow = head\\n        fast = head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        mid = slow.next\\n        slow.next = None  # Break the list into two halves\\n\\n        l1 = self.sortList(head)  # Sort the first half\\n        l2 = self.sortList(mid)   # Sort the second half\\n\\n        return self.merge(l1, l2)  # Merge the sorted halves\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)\\n            return head;\\n\\n        int length = getLength(head);\\n        ListNode dummy(0);\\n        dummy.next = head;\\n\\n        for (int step = 1; step < length; step *= 2) {\\n            ListNode* curr = dummy.next;\\n            ListNode* tail = &dummy;\\n\\n            while (curr) {\\n                ListNode* left = curr;\\n                ListNode* right = split(left, step);\\n                curr = split(right, step);\\n\\n                tail = merge(left, right, tail);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\nprivate:\\n    int getLength(ListNode* head) {\\n        int length = 0;\\n        ListNode* curr = head;\\n        while (curr) {\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n    ListNode* split(ListNode* head, int step) {\\n        if (head == nullptr)\\n            return nullptr;\\n\\n        for (int i = 1; i < step && head->next; i++) {\\n            head = head->next;\\n        }\\n\\n        ListNode* right = head->next;\\n        head->next = nullptr;\\n        return right;\\n    }\\n\\n    ListNode* merge(ListNode* left, ListNode* right, ListNode* tail) {\\n        ListNode* curr = tail;\\n        while (left && right) {\\n            if (left->val < right->val) {\\n                curr->next = left;\\n                left = left->next;\\n            } else {\\n                curr->next = right;\\n                right = right->next;\\n            }\\n            curr = curr->next;\\n        }\\n\\n        curr->next = left ? left : right;\\n        while (curr->next)\\n            curr = curr->next;\\n\\n        return curr;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        int length = getLength(head);\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        for (int step = 1; step < length; step *= 2) {\\n            ListNode curr = dummy.next;\\n            ListNode tail = dummy;\\n\\n            while (curr != null) {\\n                ListNode left = curr;\\n                ListNode right = split(left, step);\\n                curr = split(right, step);\\n\\n                tail = merge(left, right, tail);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    private int getLength(ListNode head) {\\n        int length = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        return length;\\n    }\\n\\n    private ListNode split(ListNode head, int step) {\\n        if (head == null)\\n            return null;\\n\\n        for (int i = 1; i < step && head.next != null; i++) {\\n            head = head.next;\\n        }\\n\\n        ListNode right = head.next;\\n        head.next = null;\\n        return right;\\n    }\\n\\n    private ListNode merge(ListNode left, ListNode right, ListNode tail) {\\n        ListNode curr = tail;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                curr.next = left;\\n                left = left.next;\\n            } else {\\n                curr.next = right;\\n                right = right.next;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        curr.next = (left != null) ? left : right;\\n        while (curr.next != null)\\n            curr = curr.next;\\n\\n        return curr;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def sortList(self, head):\\n        if head is None or head.next is None:\\n            return head\\n\\n        length = self.getLength(head)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n\\n        step = 1\\n        while step < length:\\n            curr = dummy.next\\n            tail = dummy\\n\\n            while curr:\\n                left = curr\\n                right = self.split(left, step)\\n                curr = self.split(right, step)\\n\\n                tail = self.merge(left, right, tail)\\n\\n            step *= 2\\n\\n        return dummy.next\\n\\n    def getLength(self, head):\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        return length\\n\\n    def split(self, head, step):\\n        if head is None:\\n            return None\\n\\n        for i in xrange(1, step):\\n            if head.next is None:\\n                break\\n            head = head.next\\n\\n        right = head.next\\n        head.next = None\\n        return right\\n\\n    def merge(self, left, right, tail):\\n        curr = tail\\n        while left and right:\\n            if left.val < right.val:\\n                curr.next = left\\n                left = left.next\\n            else:\\n                curr.next = right\\n                right = right.next\\n            curr = curr.next\\n\\n        curr.next = left if left else right\\n        while curr.next:\\n            curr = curr.next\\n\\n        return curr\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head){\\n    if (head === null || head.next === null)\\n        return head;\\n\\n    const getLength = function (head) {\\n        let length = 0;\\n        let curr = head;\\n        while (curr) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        return length;\\n    };\\n\\n    const split = function (head, step) {\\n        if (head === null)\\n            return null;\\n\\n        for (let i = 1; i < step && head.next; i++) {\\n            head = head.next;\\n        }\\n\\n        const right = head.next;\\n        head.next = null;\\n        return right;\\n    };\\n\\n    const merge = function (left, right, tail) {\\n        let curr = tail;\\n        while (left && right) {\\n            if (left.val < right.val) {\\n                curr.next = left;\\n                left = left.next;\\n            } else {\\n                curr.next = right;\\n                right = right.next;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        curr.next = left ? left : right;\\n        while (curr.next)\\n            curr = curr.next;\\n\\n        return curr;\\n    };\\n\\n    const length = getLength(head);\\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n\\n    let step = 1;\\n    while (step < length) {\\n        let curr = dummy.next;\\n        let tail = dummy;\\n\\n        while (curr) {\\n            const left = curr;\\n            const right = split(left, step);\\n            curr = split(right, step);\\n\\n            tail = merge(left, right, tail);\\n        }\\n\\n        step *= 2;\\n    }\\n\\n    return dummy.next;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217777,
                "title": "c-beats-99-88-different-approach-intuition",
                "content": "## Intuition\\nSorting an array is easy, we can use any sorting algorithm we want, and access randomly and what not. But the problem comes when we need to sort a linked list. Then we need to work a little bit.\\n\\nIn this post, I\\'m going to be explaining my solution to this problem, in which I used **quicksort** algorithm, while the official solution uses **merge sort**. Take a look at the official solution as well, it is pretty intuitive itself, although pretty long.\\n\\nAt each recursive call, we take the first element of the list as pivot, and then rearrange the nodes of the linked list such that the nodes with value less than pivot come before the pivot, and nodes with values greater than or equal to the pivot stay at their own places.\\nThis switching of places requires at least one node before the list\\'s head, which is fulfilled by the sentinel node.\\n\\nAfter this whole process is complete and we reach the tail of our sublist, we recurse on the top half to find the new top element of the list, and set the pivot\\'s next element to be the result of the recursive call on the second half of the list.\\nThis way, the list is sorted.\\n\\nWe then return the top element.\\n\\nBut this algorithm on its own, would not be accepted, since quicksort algorithm with the first element as the pivot, goes to worst case performance for already sorted lists/arrays, which is **O(n^2)**.\\n\\nTo solve this problem, we avoid that situation by first checking if the list is already sorted. if it is, then this subproblem is already solved, and hence we return it as it is, avoiding all further recursive calls.\\n\\nThis brings its performance in line with quicksort algorithm for arrays (albeit a little slow because of this extra check), but with the advantage that it avoids the worst case intelligently.\\n\\n## Code \\n\\n```\\nListNode *sortListQuickly(ListNode *head, ListNode *tail) {\\n\\tif(head == tail) return head;\\n\\telse if(head->next == tail) return head;\\n\\t//make a sentinel node \\n\\tListNode *sentinel = new ListNode(-1, head);\\n\\t//make the first element a pivot\\n\\tListNode *pivot = head;\\n\\tListNode *ptr = head->next;\\n\\tListNode *preptr = head;\\n\\tbool isSorted;\\n\\twhile(ptr!=tail && preptr->val <= ptr->val) {\\n\\t\\tpreptr = ptr;\\n\\t\\tptr = ptr->next;\\n\\t}\\n\\tif(ptr == tail) {\\n\\t\\t//sublist is already sorted;\\n\\t\\treturn pivot;\\n\\t}\\n\\tptr = head->next;\\n\\tpreptr = head;\\n\\twhile(ptr!=tail) {\\n\\t\\twhile(ptr!=tail && ptr->val >= pivot->val) {\\n\\t\\t\\tpreptr = ptr;\\n\\t\\t\\tptr = ptr->next;\\n\\t\\t}\\n\\t\\tif(ptr == tail) break;\\n\\t\\t//swap this node to the front of the list\\n\\t\\tListNode *newptr = ptr->next;\\n\\t\\tptr->next = sentinel->next;\\n\\t\\tsentinel->next = ptr;\\n\\t\\tpreptr->next = newptr;\\n\\t\\tptr = newptr;\\n\\t}\\n\\tListNode *top = sentinel->next;\\n\\tdelete(sentinel);\\n\\ttop = sortListQuickly(top, pivot);\\n\\tpivot->next = sortListQuickly(pivot->next, tail);\\n\\treturn top;\\n}\\nListNode* sortList(ListNode* head) {\\n\\treturn sortListQuickly(head, nullptr);\\n}\\n```\\n\\n## Complexity\\nTime: **O(nlogn)**, the maximum recursion depth will be logn, and taking O(n) at each step.\\nSpace: **O(1)**, the algorithm always uses a constant amount of extra space, irregardless of the input size, if the program stack space is not taken into account. If the program stack is also considered, then the space is **O(logn)**, which is the number of calls to the function.\\n\\n**Upvote** if you liked this post, and feel free to suggest any improvements, or ask any doubts in the comments.",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nListNode *sortListQuickly(ListNode *head, ListNode *tail) {\\n\\tif(head == tail) return head;\\n\\telse if(head->next == tail) return head;\\n\\t//make a sentinel node \\n\\tListNode *sentinel = new ListNode(-1, head);\\n\\t//make the first element a pivot\\n\\tListNode *pivot = head;\\n\\tListNode *ptr = head->next;\\n\\tListNode *preptr = head;\\n\\tbool isSorted;\\n\\twhile(ptr!=tail && preptr->val <= ptr->val) {\\n\\t\\tpreptr = ptr;\\n\\t\\tptr = ptr->next;\\n\\t}\\n\\tif(ptr == tail) {\\n\\t\\t//sublist is already sorted;\\n\\t\\treturn pivot;\\n\\t}\\n\\tptr = head->next;\\n\\tpreptr = head;\\n\\twhile(ptr!=tail) {\\n\\t\\twhile(ptr!=tail && ptr->val >= pivot->val) {\\n\\t\\t\\tpreptr = ptr;\\n\\t\\t\\tptr = ptr->next;\\n\\t\\t}\\n\\t\\tif(ptr == tail) break;\\n\\t\\t//swap this node to the front of the list\\n\\t\\tListNode *newptr = ptr->next;\\n\\t\\tptr->next = sentinel->next;\\n\\t\\tsentinel->next = ptr;\\n\\t\\tpreptr->next = newptr;\\n\\t\\tptr = newptr;\\n\\t}\\n\\tListNode *top = sentinel->next;\\n\\tdelete(sentinel);\\n\\ttop = sortListQuickly(top, pivot);\\n\\tpivot->next = sortListQuickly(pivot->next, tail);\\n\\treturn top;\\n}\\nListNode* sortList(ListNode* head) {\\n\\treturn sortListQuickly(head, nullptr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691834,
                "title": "python-mergesort-solution-o-1-space",
                "content": "```\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : MERGE SORT ##\\n        ## Similar to Leetcode: 21. Merge Two Sorted Lists ##\\n        ## Similar to Leetcode: 876. Middle of the Linked List ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        def mergeSort(head):\\n            if not head or not head.next : \\n                return head                 # as we branch and move left, left ... when only one node is left, we return it\\n            \\n            left = slow = fast = head\\n            fast = fast.next                # for [1,2,3,4] as mid will be node 3, if this statement not used\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            right = slow.next               # slow is at middle, next elements are considered right\\n            slow.next = None                # this makes left has only left part\\n            \\n            left_sorted = mergeSort(left)\\n            right_sorted = mergeSort(right)\\n            return merge(left_sorted, right_sorted)\\n        \\n        def merge(l1, l2):\\n            dummy = ListNode(-1)\\n            prev = dummy\\n            while l1 and l2:\\n                if l1.val <= l2.val:\\n                    prev.next = l1\\n                    l1 = l1.next\\n                else:\\n                    prev.next = l2\\n                    l2 = l2.next            \\n                prev = prev.next\\n            prev.next = l1 or l2    # one of l1 and l2 can be non-null at this point\\n            return dummy.next\\n        return mergeSort(head)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : MERGE SORT ##\\n        ## Similar to Leetcode: 21. Merge Two Sorted Lists ##\\n        ## Similar to Leetcode: 876. Middle of the Linked List ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        def mergeSort(head):\\n            if not head or not head.next : \\n                return head                 # as we branch and move left, left ... when only one node is left, we return it\\n            \\n            left = slow = fast = head\\n            fast = fast.next                # for [1,2,3,4] as mid will be node 3, if this statement not used\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            right = slow.next               # slow is at middle, next elements are considered right\\n            slow.next = None                # this makes left has only left part\\n            \\n            left_sorted = mergeSort(left)\\n            right_sorted = mergeSort(right)\\n            return merge(left_sorted, right_sorted)\\n        \\n        def merge(l1, l2):\\n            dummy = ListNode(-1)\\n            prev = dummy\\n            while l1 and l2:\\n                if l1.val <= l2.val:\\n                    prev.next = l1\\n                    l1 = l1.next\\n                else:\\n                    prev.next = l2\\n                    l2 = l2.next            \\n                prev = prev.next\\n            prev.next = l1 or l2    # one of l1 and l2 can be non-null at this point\\n            return dummy.next\\n        return mergeSort(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46849,
                "title": "java-solution-using-merge-sort",
                "content": "\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode slow = head, fast = head, pre = head;\\n        while(fast != null && fast.next != null) {\\n            pre = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        pre.next = null;\\n        return merge(sortList(head), sortList(slow));\\n    }\\n    \\n    public ListNode merge(ListNode l1, ListNode l2) {\\n        if(l1 == null) return l2;\\n        if(l2 == null) return l1;\\n        if(l1.val <= l2.val) {\\n            l1.next = merge(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = merge(l1, l2.next);\\n            return l2;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode slow = head, fast = head, pre = head;\\n        while(fast != null && fast.next != null) {\\n            pre = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        pre.next = null;\\n        return merge(sortList(head), sortList(slow));\\n    }\\n    \\n    public ListNode merge(ListNode l1, ListNode l2) {\\n        if(l1 == null) return l2;\\n        if(l2 == null) return l1;\\n        if(l1.val <= l2.val) {\\n            l1.next = merge(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = merge(l1, l2.next);\\n            return l2;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1383575,
                "title": "java-standard-merge-sort-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        \\n        return mergeSort(head);\\n    }\\n    ListNode getMidNode(ListNode head)\\n    {\\n        if(head == null || head.next ==null)\\n            return head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next!=null && fast.next.next!= null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    ListNode mergeSort(ListNode head)\\n    {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode mid = getMidNode(head);\\n        ListNode nhead = mid.next;\\n        mid.next = null;\\n        ListNode l1 = mergeSort(head);\\n        ListNode l2 = mergeSort(nhead);\\n        return merge(l1,l2);\\n    }\\n    ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null || list2 == null)\\n            return list1 == null ? list2 : list1;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode curr = dummy;\\n        ListNode l1 = list1,l2 = list2;\\n        while(l1 != null && l2 != null)\\n        {\\n            if(l1.val < l2.val)\\n            {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            }\\n            else\\n            {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        if(l1!= null || l2!= null)\\n            curr.next = (l1 == null) ? l2 : l1;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        \\n        return mergeSort(head);\\n    }\\n    ListNode getMidNode(ListNode head)\\n    {\\n        if(head == null || head.next ==null)\\n            return head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next!=null && fast.next.next!= null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    ListNode mergeSort(ListNode head)\\n    {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode mid = getMidNode(head);\\n        ListNode nhead = mid.next;\\n        mid.next = null;\\n        ListNode l1 = mergeSort(head);\\n        ListNode l2 = mergeSort(nhead);\\n        return merge(l1,l2);\\n    }\\n    ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null || list2 == null)\\n            return list1 == null ? list2 : list1;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode curr = dummy;\\n        ListNode l1 = list1,l2 = list2;\\n        while(l1 != null && l2 != null)\\n        {\\n            if(l1.val < l2.val)\\n            {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            }\\n            else\\n            {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        if(l1!= null || l2!= null)\\n            curr.next = (l1 == null) ? l2 : l1;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941851,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    private var tail = ListNode(-1)\\n    private var nextSublist: ListNode? = ListNode(-1)\\n\\n\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var start = head\\n        let dummy = ListNode(-1)\\n\\n        var size = 1\\n        let n = getCount(head)\\n\\n        while size < n {\\n            tail = dummy\\n            while start != nil {\\n                guard start?.next != nil else {\\n                    tail.next = start\\n                    break\\n                }\\n\\n                var mid = split(start, size)\\n                merge(&start, &mid)\\n                start = nextSublist\\n            }\\n            start = dummy.next\\n\\n            size *= 2\\n        }\\n\\n        return dummy.next\\n    }\\n\\n\\n    private func split(_ start: ListNode?, _ size: Int) -> ListNode? {\\n        var start = start\\n        var end = start?.next\\n\\n        for _ in 1..<size {\\n            if let endNext = end?.next { end = endNext.next ?? endNext }\\n            if let startNext = start?.next { start = startNext }\\n        }\\n        let mid = start?.next\\n        start?.next = nil\\n        nextSublist = end?.next\\n        end?.next = nil\\n\\n        return mid\\n    }\\n\\n\\n    private func merge(_ list1: inout ListNode?, _ list2: inout ListNode?) {\\n        let dummy = ListNode(-1)\\n        var newTail: ListNode? = dummy\\n\\n        while let list1Val = list1?.val, let list2Val = list2?.val {\\n            if list1Val < list2Val {\\n                newTail?.next = list1\\n                list1 = list1?.next\\n            } else {\\n                newTail?.next = list2\\n                list2 = list2?.next\\n            }\\n            newTail = newTail?.next\\n        }\\n        newTail?.next = list1 != nil ? list1 : list2\\n        while newTail?.next != nil { newTail = newTail?.next }\\n\\n        tail.next = dummy.next\\n        if let newTail = newTail { tail = newTail }\\n    }\\n\\n\\n    private func getCount(_ head: ListNode?) -> Int {\\n        var count = 0\\n        var cur = head\\n\\n        while cur != nil {\\n            cur = cur?.next\\n            count += 1\\n        }\\n\\n        return count\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    private var tail = ListNode(-1)\\n    private var nextSublist: ListNode? = ListNode(-1)\\n\\n\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var start = head\\n        let dummy = ListNode(-1)\\n\\n        var size = 1\\n        let n = getCount(head)\\n\\n        while size < n {\\n            tail = dummy\\n            while start != nil {\\n                guard start?.next != nil else {\\n                    tail.next = start\\n                    break\\n                }\\n\\n                var mid = split(start, size)\\n                merge(&start, &mid)\\n                start = nextSublist\\n            }\\n            start = dummy.next\\n\\n            size *= 2\\n        }\\n\\n        return dummy.next\\n    }\\n\\n\\n    private func split(_ start: ListNode?, _ size: Int) -> ListNode? {\\n        var start = start\\n        var end = start?.next\\n\\n        for _ in 1..<size {\\n            if let endNext = end?.next { end = endNext.next ?? endNext }\\n            if let startNext = start?.next { start = startNext }\\n        }\\n        let mid = start?.next\\n        start?.next = nil\\n        nextSublist = end?.next\\n        end?.next = nil\\n\\n        return mid\\n    }\\n\\n\\n    private func merge(_ list1: inout ListNode?, _ list2: inout ListNode?) {\\n        let dummy = ListNode(-1)\\n        var newTail: ListNode? = dummy\\n\\n        while let list1Val = list1?.val, let list2Val = list2?.val {\\n            if list1Val < list2Val {\\n                newTail?.next = list1\\n                list1 = list1?.next\\n            } else {\\n                newTail?.next = list2\\n                list2 = list2?.next\\n            }\\n            newTail = newTail?.next\\n        }\\n        newTail?.next = list1 != nil ? list1 : list2\\n        while newTail?.next != nil { newTail = newTail?.next }\\n\\n        tail.next = dummy.next\\n        if let newTail = newTail { tail = newTail }\\n    }\\n\\n\\n    private func getCount(_ head: ListNode?) -> Int {\\n        var count = 0\\n        var cur = head\\n\\n        while cur != nil {\\n            cur = cur?.next\\n            count += 1\\n        }\\n\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796857,
                "title": "python-3-solutions-easy-and-clean-explained",
                "content": "\\u274C **Solution 1: Bubble Sort** \\n\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        count = head\\n        while count:\\n            itr = head\\n            while itr.next:\\n                if itr.val > itr.next.val: \\n                    itr.val, itr.next.val = itr.next.val, itr.val\\n                itr = itr.next\\n            count = count.next\\n        return head\\n```\\n***\\nTime Complexity: O(N*N)          | This solution will give **TLE**\\nSpace Complexity: O(1)\\n***\\n\\n\\n\\u2714 **Solution 2: Extract and Fill** \\nExtract all the element into an array, sort and then fill the values in the linkedlist.\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        arr, itr = [], head    # take an array to store all the extracted values\\n        while itr:             # iterate and copy\\n            arr.append(itr.val)    \\n            itr = itr.next\\n        arr.sort()             # sort it\\n        itr, i = head, 0       # take i to traverse the array along with linked list\\n\\t\\t\\t\\t\\n        while itr:             # fill the sorted values\\n            itr.val = arr[i]  \\n            i += 1\\n            itr = itr.next\\n        return head\\n```\\n***\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N)\\n***\\n\\n\\u2714 **Solution 3: MergeSort**\\nWell this solution contains three subproblems, I would recommend you to first check those out and try to solve it.\\n**1.  Merge Sort an Array (Leetcode 912)** [Clickhere](https://leetcode.com/problems/sort-an-array/)\\n**2.  Middle of the Linked List( Leetcode 876)** [Clickhere](https://leetcode.com/problems/middle-of-the-linked-list/)\\n**3.  Merge Two Sorted Lists( Leetcode 21)** [Clickhere](https://leetcode.com/problems/merge-two-sorted-lists/)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def getMid(self, head):            # we will be using two pointers\\n        slow = fast = head             # what we want? Middle right, but we will stop the loop at one node before the middle\\n        while fast and fast.next:      # try to think about odd and even length of the list to completely understand the while loop\\n            fast = fast.next.next\\n            if fast: slow = slow.next\\n        mid, slow.next = slow.next, None   # assign None to the last node\\'s next of left half, that is why we broke the loop one node before the middle.\\n        return mid\\n        \\n    def merge(self, left, right):\\n        head = prev = None    # taking prev pointers to point previous\\n        while left and right:  \\n\\t\\t#Find the minimum value node and change its pointer to next accordingly\\n            mini = right        \\n            if left.val < right.val:\\n                mini = left\\n                left = left.next\\n            else: right = right.next\\n        \\n            if not head: head = prev = mini      # if head is None assign the head\\n            else: prev.next = prev = mini        # point the previous next and prev to minimum node just found\\n        if left: prev.next = left                # adding the remainings of left, while loop could have stopped because of right\\n        if right: prev.next = right              # adding the remainings of right, while loop could have stopped because of left\\n        return head\\n        \\n    def sortList(self, head: Optional[ListNode]):\\n        if not (head and head.next): return head     # if lesser than 2 element no need to divide\\n        mid = self.getMid(head)                      # get the middle node\\n        left = self.sortList(head)                   # further divide the left part list\\n        right = self.sortList(mid)                   # further divide the right part of the list\\n        return self.merge(left, right)               # merge the sorted lists\\n```\\n\\n***\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N)\\n***\\n\\n***If you have any doubts please let me know, if you think this code can be further improved or you have a code much shorter than this please comment below.***\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        count = head\\n        while count:\\n            itr = head\\n            while itr.next:\\n                if itr.val > itr.next.val: \\n                    itr.val, itr.next.val = itr.next.val, itr.val\\n                itr = itr.next\\n            count = count.next\\n        return head\\n```\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        arr, itr = [], head    # take an array to store all the extracted values\\n        while itr:             # iterate and copy\\n            arr.append(itr.val)    \\n            itr = itr.next\\n        arr.sort()             # sort it\\n        itr, i = head, 0       # take i to traverse the array along with linked list\\n\\t\\t\\t\\t\\n        while itr:             # fill the sorted values\\n            itr.val = arr[i]  \\n            i += 1\\n            itr = itr.next\\n        return head\\n```\n```\\nclass Solution:\\n    def getMid(self, head):            # we will be using two pointers\\n        slow = fast = head             # what we want? Middle right, but we will stop the loop at one node before the middle\\n        while fast and fast.next:      # try to think about odd and even length of the list to completely understand the while loop\\n            fast = fast.next.next\\n            if fast: slow = slow.next\\n        mid, slow.next = slow.next, None   # assign None to the last node\\'s next of left half, that is why we broke the loop one node before the middle.\\n        return mid\\n        \\n    def merge(self, left, right):\\n        head = prev = None    # taking prev pointers to point previous\\n        while left and right:  \\n\\t\\t#Find the minimum value node and change its pointer to next accordingly\\n            mini = right        \\n            if left.val < right.val:\\n                mini = left\\n                left = left.next\\n            else: right = right.next\\n        \\n            if not head: head = prev = mini      # if head is None assign the head\\n            else: prev.next = prev = mini        # point the previous next and prev to minimum node just found\\n        if left: prev.next = left                # adding the remainings of left, while loop could have stopped because of right\\n        if right: prev.next = right              # adding the remainings of right, while loop could have stopped because of left\\n        return head\\n        \\n    def sortList(self, head: Optional[ListNode]):\\n        if not (head and head.next): return head     # if lesser than 2 element no need to divide\\n        mid = self.getMid(head)                      # get the middle node\\n        left = self.sortList(head)                   # further divide the left part list\\n        right = self.sortList(mid)                   # further divide the right part of the list\\n        return self.merge(left, right)               # merge the sorted lists\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548843,
                "title": "the-lol-approach-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(order.begin() , order.end());\\n        temp = head;\\n        int index = 0;\\n        while(temp!=NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nu can use any sort i have used the sort function",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(order.begin() , order.end());\\n        temp = head;\\n        int index = 0;\\n        while(temp!=NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228473,
                "title": "quicksort-for-list-clean-and-easy-but-not-fast",
                "content": "My  English is not good.So maybe I cannot express my real meaning .sry\\n\\nFor an array,we can easily get the index of elements.But for a link list ,how can we partition the array by pivot to make the previous data less than pivot and the later data bigger than pivot?\\n\\nI think we can use two pointers.P  points the first node, and Q  points the second node.\\nWe choose the first elem as the pivot. Let\\'s make Q goes through this array(Q = Q ->next). \\nwhen Q < pivot,\\n{make P =P->next, then swap P-value and Q-value.}\\nThe small value will be changed to P location, and P =P->next make P\\'s left always smaller than P.\\n\\nQuickSort fuction is as same as array,\\nRecursive traversal  (start,mid) and (mid->next,end);\\n\\n\\nBelieve me ,I really try my best to explain it.BUT MY ENGLISH IS REAL POOOOOOL.\\nmaybe you can read the code below directly.\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    \\n    void SwapValue (ListNode* a ,ListNode* b){\\n        int temp = a->val;\\n        a->val = b->val;\\n        b->val = temp;\\n        \\n    }\\n    \\n    \\n    ListNode* Partition(ListNode* start ,ListNode* end){\\n        int pivotValue = start->val;\\n        ListNode* p = start;\\n        ListNode* q = start -> next;\\n        while(q != end){\\n            if (q -> val < pivotValue){\\n                p = p -> next;\\n                SwapValue(p,q);\\n            }\\n            q = q -> next;\\n        }\\n        SwapValue(p,start);\\n        return p;\\n    }\\n        \\n        \\n    void QuickSort(ListNode* start ,ListNode* end){\\n        if (start != end){\\n            ListNode* mid =Partition(start ,end);\\n            QuickSort(start,mid);\\n            QuickSort(mid->next,end);\\n        }\\n        \\n    }\\n        \\n    \\n    ListNode* sortList(ListNode* head) {\\n        QuickSort(head,NULL);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    \\n    void SwapValue (ListNode* a ,ListNode* b){\\n        int temp = a->val;\\n        a->val = b->val;\\n        b->val = temp;\\n        \\n    }\\n    \\n    \\n    ListNode* Partition(ListNode* start ,ListNode* end){\\n        int pivotValue = start->val;\\n        ListNode* p = start;\\n        ListNode* q = start -> next;\\n        while(q != end){\\n            if (q -> val < pivotValue){\\n                p = p -> next;\\n                SwapValue(p,q);\\n            }\\n            q = q -> next;\\n        }\\n        SwapValue(p,start);\\n        return p;\\n    }\\n        \\n        \\n    void QuickSort(ListNode* start ,ListNode* end){\\n        if (start != end){\\n            ListNode* mid =Partition(start ,end);\\n            QuickSort(start,mid);\\n            QuickSort(mid->next,end);\\n        }\\n        \\n    }\\n        \\n    \\n    ListNode* sortList(ListNode* head) {\\n        QuickSort(head,NULL);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892975,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=lQ6ZUritW70)\\nhttps://www.youtube.com/watch?v=lQ6ZUritW70\\n```\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        p, slow, fast = None, head, head\\n        while fast and fast.next:\\n            p = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        p.next = None\\n        \\n        return self.merge(self.sortList(head), self.sortList(slow))\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(None)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val > l2.val:\\n                curr.next, l2 = l2, l2.next\\n            else:\\n                curr.next, l1 = l1, l1.next\\n            curr = curr.next\\n        \\n        if l1:\\n            curr.next = l1\\n        elif l2:\\n            curr.next = l2\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        p, slow, fast = None, head, head\\n        while fast and fast.next:\\n            p = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        p.next = None\\n        \\n        return self.merge(self.sortList(head), self.sortList(slow))\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(None)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val > l2.val:\\n                curr.next, l2 = l2, l2.next\\n            else:\\n                curr.next, l1 = l1, l1.next\\n            curr = curr.next\\n        \\n        if l1:\\n            curr.next = l1\\n        elif l2:\\n            curr.next = l2\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383522,
                "title": "quick-sort-and-merge-sort",
                "content": "Up to Bottom Devide and Conquer Merge Sort Solution \\nSpace : O(logn) Becuse we use recrusive method . we need conside stack call .\\n```\\n public ListNode sortList(ListNode head) {\\n\\tif(head==null || head.next==null) return head;\\n\\tListNode fast = head, slow = head, pre = null;\\n\\twhile(fast!=null && fast.next!=null){\\n\\t\\tpre = slow;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\tpre.next = null;\\n\\treturn merge(sortList(head),sortList(slow));\\n}\\npublic ListNode merge(ListNode l1,ListNode l2){\\n\\tif(l1==null) return l2;\\n\\tif(l2==null) return l1;\\n\\tif(l1.val < l2.val){\\n\\t\\t l1.next = merge(l1.next,l2);   \\n\\t\\t return l1;\\n\\t}else{\\n\\t\\tl2.next = merge(l1,l2.next);\\n\\t\\treturn l2;\\n\\t}\\n}\\n```\\n\\nBottom to Up Divide and Conquer Merge Sort\\nSpace O(1) \\n```\\npublic ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        int len = getLen(head);\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre, cur, left, right;\\n        for (int step = 1; step <= len; step *= 2) {\\n            pre = dummy;\\n            cur = dummy.next;\\n            while (cur != null) {\\n                left = cur;\\n                right = split(left, step);\\n                cur = split(right, step);\\n                pre = merge(left, right, pre);\\n            }\\n        }\\n        return dummy.next;\\n    }\\n\\n    public ListNode merge(ListNode left, ListNode right,ListNode pre) {\\n        ListNode cur = pre;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                cur.next = left;\\n                left = left.next;\\n            } else {\\n                cur.next = right;\\n                right = right.next;\\n            }\\n            cur = cur.next;\\n        }\\n        if (left != null) {cur.next = left;}\\n        if (right !=null) {cur.next = right;}\\n        while (cur.next!=null) {cur = cur.next;}\\n        return cur;\\n    }\\n\\n    public ListNode split(ListNode head, int step) {\\n        if (head == null) { return null; }\\n        int cnt = 1;\\n        while (cnt < step && head.next != null) {\\n            head = head.next;\\n            cnt++;\\n        }\\n        ListNode newHead = head.next;\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public int getLen(ListNode head){\\n        int cnt = 0;\\n        while (head != null) {\\n            cnt++;\\n            head = head.next;\\n        }\\n        return cnt;\\n    }\\n```\\n\\n\\nQucik Sort Solution\\nSpace : O(logn) Becuse we use recrusive method . we need conside stack call .\\n```\\npublic ListNode sortList(ListNode head) {\\n\\tif(head==null || head.next==null) return head;\\n\\tListNode small = new ListNode(-1), large = new ListNode(-1), cur = head.next, sp = small, lp = large;\\n\\twhile(cur!=null){\\n\\t\\tif(cur.val<head.val){\\n\\t\\t\\tsp.next = cur;\\n\\t\\t\\tsp = sp.next;\\n\\t\\t}else{\\n\\t\\t\\tlp.next = cur;\\n\\t\\t\\tlp = lp.next;\\n\\t\\t}\\n\\t\\tcur = cur.next;\\n\\t}\\n\\tsp.next = null;\\n\\tlp.next = null;\\n\\tsp = sortList(small.next);\\n\\tlp = sortList(large.next);\\n\\tcur = sp;\\n\\tif(cur!=null){\\n\\t\\twhile(cur.next!=null) cur = cur.next;\\n\\t\\tcur.next = head;\\n\\t\\thead.next = lp;\\n\\t\\treturn sp;\\n\\t}else{\\n\\t\\thead.next = lp;\\n\\t\\treturn head;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n public ListNode sortList(ListNode head) {\\n\\tif(head==null || head.next==null) return head;\\n\\tListNode fast = head, slow = head, pre = null;\\n\\twhile(fast!=null && fast.next!=null){\\n\\t\\tpre = slow;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\tpre.next = null;\\n\\treturn merge(sortList(head),sortList(slow));\\n}\\npublic ListNode merge(ListNode l1,ListNode l2){\\n\\tif(l1==null) return l2;\\n\\tif(l2==null) return l1;\\n\\tif(l1.val < l2.val){\\n\\t\\t l1.next = merge(l1.next,l2);   \\n\\t\\t return l1;\\n\\t}else{\\n\\t\\tl2.next = merge(l1,l2.next);\\n\\t\\treturn l2;\\n\\t}\\n}\\n```\n```\\npublic ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        int len = getLen(head);\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode pre, cur, left, right;\\n        for (int step = 1; step <= len; step *= 2) {\\n            pre = dummy;\\n            cur = dummy.next;\\n            while (cur != null) {\\n                left = cur;\\n                right = split(left, step);\\n                cur = split(right, step);\\n                pre = merge(left, right, pre);\\n            }\\n        }\\n        return dummy.next;\\n    }\\n\\n    public ListNode merge(ListNode left, ListNode right,ListNode pre) {\\n        ListNode cur = pre;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                cur.next = left;\\n                left = left.next;\\n            } else {\\n                cur.next = right;\\n                right = right.next;\\n            }\\n            cur = cur.next;\\n        }\\n        if (left != null) {cur.next = left;}\\n        if (right !=null) {cur.next = right;}\\n        while (cur.next!=null) {cur = cur.next;}\\n        return cur;\\n    }\\n\\n    public ListNode split(ListNode head, int step) {\\n        if (head == null) { return null; }\\n        int cnt = 1;\\n        while (cnt < step && head.next != null) {\\n            head = head.next;\\n            cnt++;\\n        }\\n        ListNode newHead = head.next;\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public int getLen(ListNode head){\\n        int cnt = 0;\\n        while (head != null) {\\n            cnt++;\\n            head = head.next;\\n        }\\n        return cnt;\\n    }\\n```\n```\\npublic ListNode sortList(ListNode head) {\\n\\tif(head==null || head.next==null) return head;\\n\\tListNode small = new ListNode(-1), large = new ListNode(-1), cur = head.next, sp = small, lp = large;\\n\\twhile(cur!=null){\\n\\t\\tif(cur.val<head.val){\\n\\t\\t\\tsp.next = cur;\\n\\t\\t\\tsp = sp.next;\\n\\t\\t}else{\\n\\t\\t\\tlp.next = cur;\\n\\t\\t\\tlp = lp.next;\\n\\t\\t}\\n\\t\\tcur = cur.next;\\n\\t}\\n\\tsp.next = null;\\n\\tlp.next = null;\\n\\tsp = sortList(small.next);\\n\\tlp = sortList(large.next);\\n\\tcur = sp;\\n\\tif(cur!=null){\\n\\t\\twhile(cur.next!=null) cur = cur.next;\\n\\t\\tcur.next = head;\\n\\t\\thead.next = lp;\\n\\t\\treturn sp;\\n\\t}else{\\n\\t\\thead.next = lp;\\n\\t\\treturn head;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46827,
                "title": "python-quick-sort-solution-easy-to-understand-beats-95-51",
                "content": "To solve the TLE problem, I set two pivots in the partition function, pivotPrev and pivotPost. We just pick the first element as pivot. And if we encounter a node with the same value as pivotPrev, we move the pivotPost one step forward. When partition function returns, the pivotPrev becomes the end node for the former half while the pivotPost becomes the start node for the latter half. In this way, we don't have to sort nodes between two pivots in the next round.\\n\\nFor example, input like 2-3-2-1-4-6-2-5 will become 1-2-2-2-5-6-4-3, and the partition function returns the first node with value 2 and the last node with value 2, then we only have to sort 1 and 5-6-4-3 respectively.\\n\\n\\n    class Solution(object):\\n        def sortList(self, head):\\n            \"\"\"\\n            :type head: ListNode\\n            :rtype: ListNode\\n            \"\"\"\\n            def partition(start, end):\\n                node = start.next.next\\n                pivotPrev = start.next\\n                pivotPrev.next = end\\n                pivotPost = pivotPrev\\n                while node != end:\\n                    temp = node.next\\n                    if node.val > pivotPrev.val:\\n                        node.next = pivotPost.next\\n                        pivotPost.next = node\\n                    elif node.val < pivotPrev.val:\\n                        node.next = start.next\\n                        start.next = node\\n                    else:\\n                        node.next = pivotPost.next\\n                        pivotPost.next = node\\n                        pivotPost = pivotPost.next\\n                    node = temp\\n                return [pivotPrev, pivotPost]\\n            \\n            def quicksort(start, end):\\n                if start.next != end:\\n                    prev, post = partition(start, end)\\n                    quicksort(start, prev)\\n                    quicksort(post, end)\\n    \\n            newHead = ListNode(0)\\n            newHead.next = head\\n            quicksort(newHead, None)\\n            return newHead.next",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "To solve the TLE problem, I set two pivots in the partition function, pivotPrev and pivotPost. We just pick the first element as pivot. And if we encounter a node with the same value as pivotPrev, we move the pivotPost one step forward. When partition function returns, the pivotPrev becomes the end node for the former half while the pivotPost becomes the start node for the latter half. In this way, we don't have to sort nodes between two pivots in the next round.\\n\\nFor example, input like 2-3-2-1-4-6-2-5 will become 1-2-2-2-5-6-4-3, and the partition function returns the first node with value 2 and the last node with value 2, then we only have to sort 1 and 5-6-4-3 respectively.\\n\\n\\n    class Solution(object):\\n        def sortList(self, head):\\n            \"\"\"\\n            :type head: ListNode\\n            :rtype: ListNode\\n            \"\"\"\\n            def partition(start, end):\\n                node = start.next.next\\n                pivotPrev = start.next\\n                pivotPrev.next = end\\n                pivotPost = pivotPrev\\n                while node != end:\\n                    temp = node.next\\n                    if node.val > pivotPrev.val:\\n                        node.next = pivotPost.next\\n                        pivotPost.next = node\\n                    elif node.val < pivotPrev.val:\\n                        node.next = start.next\\n                        start.next = node\\n                    else:\\n                        node.next = pivotPost.next\\n                        pivotPost.next = node\\n                        pivotPost = pivotPost.next\\n                    node = temp\\n                return [pivotPrev, pivotPost]\\n            \\n            def quicksort(start, end):\\n                if start.next != end:\\n                    prev, post = partition(start, end)\\n                    quicksort(start, prev)\\n                    quicksort(post, end)\\n    \\n            newHead = ListNode(0)\\n            newHead.next = head\\n            quicksort(newHead, None)\\n            return newHead.next",
                "codeTag": "Java"
            },
            {
                "id": 3822590,
                "title": "java-solution-98-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to sort the given linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution we stored the elements of the linked list in a array then we sorted the array and updated the values of the sorted array in the linked list.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        int[] arr = new int[count];\\n        temp = head;\\n        count = 0;\\n        while(temp!=null){\\n            arr[count++] = temp.val;\\n            temp = temp.next;\\n        }\\n        Arrays.sort(arr);\\n        temp = head;\\n        count = 0;\\n        while(temp!=null){\\n            temp.val = arr[count++];\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/31a99290-73a7-4835-a421-2971618f2776_1690444139.0532181.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        int[] arr = new int[count];\\n        temp = head;\\n        count = 0;\\n        while(temp!=null){\\n            arr[count++] = temp.val;\\n            temp = temp.next;\\n        }\\n        Arrays.sort(arr);\\n        temp = head;\\n        count = 0;\\n        while(temp!=null){\\n            temp.val = arr[count++];\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46745,
                "title": "java-quick-sort-fast-beats-98-also-includes-merge-sort-code",
                "content": "    ListNode quickSort(final ListNode h){\\n        if(h == null || h.next == null)\\n            return h;\\n        \\n        /*split into three list*/\\n        ListNode fakesmall = new ListNode(0), small = fakesmall;\\n        ListNode fakelarge = new ListNode(0), large = fakelarge;\\n        ListNode fakeequal = new ListNode(0), equal = fakeequal;\\n        \\n        ListNode cur = h; // pivot is h.\\n        while(cur != null){\\n            if(cur.val < h.val){\\n                small.next = cur;\\n                small = small.next;\\n            }\\n            else if(cur.val == h.val){\\n                equal.next = cur;\\n                equal = equal.next;\\n            }\\n            else{\\n                large.next = cur;\\n                large = large.next;\\n            }\\n            \\n            cur = cur.next;\\n        }\\n        \\n        // put an end.\\n        small.next = equal.next = large.next = null;\\n        // merge them and return . merge reusing below one. merge for quicksort should be simplified. \\n        return merge(merge(quickSort(fakesmall.next), quickSort(fakelarge.next)),fakeequal.next) ;\\n    }\\n    \\n    \\n    /*mrege sort*/\\n    ListNode mergeSort(ListNode h){\\n        if(h == null || h.next == null)\\n            return h;\\n        \\n        /*find cutting point*/    \\n        ListNode slow = h, cut = null, fast = h;\\n        while(fast != null && fast.next != null){\\n            cut = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        /*cut*/\\n        cut.next = null;\\n        \\n        return merge(mergeSort(h),mergeSort(slow));\\n    }\\n    \\n    ListNode merge(ListNode h, ListNode m){\\n        ListNode fake = new ListNode(0), cur = fake;\\n        \\n        while(h != null && m != null){\\n    \\n            if(h.val < m.val){\\n                cur.next = h;\\n                h = h.next;\\n            }\\n            else{\\n                cur.next = m;\\n                m = m.next;\\n            }\\n            cur = cur.next;\\n        }\\n        \\n        cur.next = (h == null ? m : h);\\n        \\n        return fake.next;\\n    }",
                "solutionTags": [],
                "code": "    ListNode quickSort(final ListNode h){\\n        if(h == null || h.next == null)\\n            return h;\\n        \\n        /*split into three list*/\\n        ListNode fakesmall = new ListNode(0), small = fakesmall;\\n        ListNode fakelarge = new ListNode(0), large = fakelarge;\\n        ListNode fakeequal = new ListNode(0), equal = fakeequal;\\n        \\n        ListNode cur = h; // pivot is h.\\n        while(cur != null){\\n            if(cur.val < h.val){\\n                small.next = cur;\\n                small = small.next;\\n            }\\n            else if(cur.val == h.val){\\n                equal.next = cur;\\n                equal = equal.next;\\n            }\\n            else{\\n                large.next = cur;\\n                large = large.next;\\n            }\\n            \\n            cur = cur.next;\\n        }\\n        \\n        // put an end.\\n        small.next = equal.next = large.next = null;\\n        // merge them and return . merge reusing below one. merge for quicksort should be simplified. \\n        return merge(merge(quickSort(fakesmall.next), quickSort(fakelarge.next)),fakeequal.next) ;\\n    }\\n    \\n    \\n    /*mrege sort*/\\n    ListNode mergeSort(ListNode h){\\n        if(h == null || h.next == null)\\n            return h;\\n        \\n        /*find cutting point*/    \\n        ListNode slow = h, cut = null, fast = h;\\n        while(fast != null && fast.next != null){\\n            cut = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        /*cut*/\\n        cut.next = null;\\n        \\n        return merge(mergeSort(h),mergeSort(slow));\\n    }\\n    \\n    ListNode merge(ListNode h, ListNode m){\\n        ListNode fake = new ListNode(0), cur = fake;\\n        \\n        while(h != null && m != null){\\n    \\n            if(h.val < m.val){\\n                cur.next = h;\\n                h = h.next;\\n            }\\n            else{\\n                cur.next = m;\\n                m = m.next;\\n            }\\n            cur = cur.next;\\n        }\\n        \\n        cur.next = (h == null ? m : h);\\n        \\n        return fake.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 679972,
                "title": "concise-merge-sort-solution-javascript",
                "content": "```\\nfunction sortList (head) {\\n    if(!head || !head.next) return head;\\n    let fast = head, slow = head;\\n    while(fast.next && fast.next.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    let middle = slow.next;\\n    slow.next = null;\\n    return merge(sortList(head), sortList(middle));\\n}\\nconst merge = (o, t) => {\\n    let d = new ListNode(-1); //dummy and temp\\n    let tmp = d;\\n    while(o && t) {\\n        tmp.next = (o.val < t.val) ? o : t;\\n        tmp = tmp.next;\\n        if(o.val < t.val) o = o.next; else t = t.next;\\n    }\\n    if(o) tmp.next = o;\\n    if(t) tmp.next = t;\\n    return d.next;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\nfunction sortList (head) {\\n    if(!head || !head.next) return head;\\n    let fast = head, slow = head;\\n    while(fast.next && fast.next.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    let middle = slow.next;\\n    slow.next = null;\\n    return merge(sortList(head), sortList(middle));\\n}\\nconst merge = (o, t) => {\\n    let d = new ListNode(-1); //dummy and temp\\n    let tmp = d;\\n    while(o && t) {\\n        tmp.next = (o.val < t.val) ? o : t;\\n        tmp = tmp.next;\\n        if(o.val < t.val) o = o.next; else t = t.next;\\n    }\\n    if(o) tmp.next = o;\\n    if(t) tmp.next = t;\\n    return d.next;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 46838,
                "title": "python-bottom-up-o-nlogn-time-o-1-space-solution",
                "content": "Recursion is not correct.\\n\\nCodes below follow the idea of :\\nhttps://leetcode.com/discuss/28594/bottom-recurring-with-space-complextity-time-complextity\\n\\n    class Solution(object):\\n        def sortList(self, head):\\n            \"\"\"\\n            :type head: ListNode\\n            :rtype: ListNode\\n            \"\"\"\\n            if not head or not head.next: return head\\n            dummy = ListNode('s'); dummy.next = head; tmp = head\\n            length = 0\\n            while tmp:\\n                tmp = tmp.next\\n                length += 1\\n            step = 1\\n            while step<length:\\n                cur, tail = dummy.next, dummy\\n                while cur:\\n                    left = cur\\n                    right = self.split(left,step)\\n                    cur = self.split(right, step)\\n                    tail = self.merge2(left,right,tail)\\n                step <<= 1\\n            return dummy.next\\n        \\n        # merge 2 sorted lists, and append the result to head\\n        # return the tail\\n        def merge2(self, p1, p2, head):\\n            dummy = ListNode('#');p = dummy\\n            while p1 and p2:\\n                if p1.val <= p2.val:\\n                    p.next = p1\\n                    p1 = p1.next; p = p.next\\n                else:\\n                    p.next = p2\\n                    p2 = p2.next; p = p.next\\n            p.next = p1 or p2\\n            head.next = dummy.next\\n            while p.next: p = p.next\\n            return p\\n    \\n        # divide the linked list into two lists\\n        # first linked list contains n nodes\\n        # return the head of second linked list\\n        def split(self, head, n):\\n            for i in range(n-1): \\n                if head: head = head.next\\n                else: break\\n            if not head: return None\\n            second = head.next\\n            head.next = None\\n            return second",
                "solutionTags": [
                    "Python"
                ],
                "code": "Recursion is not correct.\\n\\nCodes below follow the idea of :\\nhttps://leetcode.com/discuss/28594/bottom-recurring-with-space-complextity-time-complextity\\n\\n    class Solution(object):\\n        def sortList(self, head):\\n            \"\"\"\\n            :type head: ListNode\\n            :rtype: ListNode\\n            \"\"\"\\n            if not head or not head.next: return head\\n            dummy = ListNode('s'); dummy.next = head; tmp = head\\n            length = 0\\n            while tmp:\\n                tmp = tmp.next\\n                length += 1\\n            step = 1\\n            while step<length:\\n                cur, tail = dummy.next, dummy\\n                while cur:\\n                    left = cur\\n                    right = self.split(left,step)\\n                    cur = self.split(right, step)\\n                    tail = self.merge2(left,right,tail)\\n                step <<= 1\\n            return dummy.next\\n        \\n        # merge 2 sorted lists, and append the result to head\\n        # return the tail\\n        def merge2(self, p1, p2, head):\\n            dummy = ListNode('#');p = dummy\\n            while p1 and p2:\\n                if p1.val <= p2.val:\\n                    p.next = p1\\n                    p1 = p1.next; p = p.next\\n                else:\\n                    p.next = p2\\n                    p2 = p2.next; p = p.next\\n            p.next = p1 or p2\\n            head.next = dummy.next\\n            while p.next: p = p.next\\n            return p\\n    \\n        # divide the linked list into two lists\\n        # first linked list contains n nodes\\n        # return the head of second linked list\\n        def split(self, head, n):\\n            for i in range(n-1): \\n                if head: head = head.next\\n                else: break\\n            if not head: return None\\n            second = head.next\\n            head.next = None\\n            return second",
                "codeTag": "Java"
            },
            {
                "id": 46722,
                "title": "very-easy-merge-sort-c",
                "content": "    class Solution {\\n    private:\\n        ListNode* mergeList(ListNode* l1, ListNode* l2) {\\n            ListNode head(0);\\n            ListNode* headPtr = &head; \\n            while(l1 && l2) {\\n                if(l1->val < l2->val) {\\n                    headPtr->next = l1;\\n                    l1 = l1->next;\\n                } else {\\n                    headPtr->next = l2;\\n                    l2 = l2->next;\\n                }\\n                headPtr = headPtr->next;\\n            }\\n            headPtr->next = (!l1 )? l2 : l1;\\n            return head.next;\\n        }\\n        \\n        ListNode* getMid(ListNode* front, ListNode* back) {\\n            if(front == back) return front;\\n            ListNode* slow = front;\\n            ListNode* fast = front;\\n            while(slow && fast && fast->next && fast->next->next ) {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            return slow;\\n        }\\n        \\n        ListNode* mergeSortList(ListNode* head, ListNode* tail) {\\n            if(head == tail) return head;\\n            ListNode* mid = getMid(head, tail);\\n            ListNode* sortedPost = mergeSortList(mid->next, tail);\\n            mid->next = NULL;\\n            ListNode* sortedPre = mergeSortList(head, mid);\\n            \\n            return mergeList(sortedPre, sortedPost);\\n        }\\n        \\n        \\n    public:\\n        ListNode* sortList(ListNode* head) {\\n            if(!head) return head;\\n            ListNode* tail = head;\\n            while(tail->next) {\\n                tail = tail->next;\\n            }\\n            return mergeSortList(head, tail);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    private:\\n        ListNode* mergeList(ListNode* l1, ListNode* l2) {\\n            ListNode head(0);\\n            ListNode* headPtr = &head; \\n            while(l1 && l2) {\\n                if(l1->val < l2->val) {\\n                    headPtr->next = l1;\\n                    l1 = l1->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 47018,
                "title": "how-to-solve-the-problem-without-recursion",
                "content": "I solved the problem in Java with recursion, merge sort. But I realized that it don't have a **constant space complexity**.\\n\\nEvery time the function is used, constant space is allocated. The function will be used nearly log(n) times, so the space complexity is log(n).\\n\\nMaybe it can only be solved without recursion while it has a constant space complexity.\\n\\nAnyone agrees with me? Who solve it **without recursion**?\\n\\nEven though it's not necessary, here is my **accepted** code: (2 ints and 3 pointers of ListNode are allocated when the funtion is used every time.)\\n\\n    public class Solution {\\n        public ListNode sortList(ListNode head) {\\n            int len = 0;\\n            for( ListNode now=head; now!=null; now=now.next )\\n            \\t++len;\\n            if(len<2)\\n            \\treturn head;\\n            ListNode firstHead, secondHead, tail;\\n            firstHead = tail = secondHead = head;\\n            for( int pos=0; pos+1<len/2; ++pos )\\n            \\ttail = tail.next;       //\"tail\" is the firstHead's tail\\n            secondHead = tail.next;\\n            tail.next = null;\\n            firstHead = sortList(firstHead);\\n            secondHead = sortList(secondHead);\\n            tail=null;                  //\"tail\" is the tail of new sorted list now\\n            while( firstHead!=null&&secondHead!=null )\\n            {\\n            \\tif(tail==null)\\n            \\t{\\n            \\t\\tif(firstHead.val<=secondHead.val)\\n            \\t\\t{\\n            \\t\\t\\ttail = head = firstHead;    //\"head\" becomes the head of new sorted list\\n            \\t\\t\\tfirstHead = firstHead.next;\\n            \\t\\t}\\n            \\t\\telse\\n            \\t\\t{\\n            \\t\\t\\ttail = head = secondHead;\\n            \\t\\t\\tsecondHead = secondHead.next;\\n            \\t\\t}\\n            \\t}\\n            \\telse\\n            \\t{\\n            \\t\\tif(firstHead.val<=secondHead.val)\\n            \\t\\t{\\n            \\t\\t\\ttail.next = firstHead;\\n            \\t\\t\\tfirstHead = firstHead.next;\\n            \\t\\t}\\n            \\t\\telse\\n            \\t\\t{\\n            \\t\\t\\ttail.next = secondHead;\\n            \\t\\t\\tsecondHead = secondHead.next;\\n            \\t\\t}\\n            \\t\\ttail = tail.next;\\n            \\t}\\n            \\t\\n            }\\n            if( firstHead==null )\\n            \\ttail.next = secondHead;\\n            else if( secondHead==null )\\n            \\ttail.next = firstHead;\\n            return head;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode sortList(ListNode head) {\\n            int len = 0;\\n            for( ListNode now=head; now!=null; now=now.next )\\n            \\t++len;\\n            if(len<2)\\n            \\treturn head;\\n            ListNode firstHead, secondHead, tail;\\n            firstHead = tail = secondHead = head;\\n            for( int pos=0; pos+1<len/2; ++pos )\\n            \\ttail = tail.next;       //\"tail\" is the firstHead's tail\\n            secondHead = tail.next;\\n            tail.next = null;\\n            firstHead = sortList(firstHead);\\n            secondHead = sortList(secondHead);\\n            tail=null;                  //\"tail\" is the tail of new sorted list now\\n            while( firstHead!=null&&secondHead!=null )\\n            {\\n            \\tif(tail==null)\\n            \\t{\\n            \\t\\tif(firstHead.val<=secondHead.val)\\n            \\t\\t{\\n            \\t\\t\\ttail = head = firstHead;    //\"head\" becomes the head of new sorted list\\n            \\t\\t\\tfirstHead = firstHead.next;\\n            \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3289476,
                "title": "easy-solution-in-c-merge-sort-o-n-log-n",
                "content": "# Intuition\\nWe can use merge sort to solve this problem because it is very efficient sorting algorithm for singly linked lists. It has a time complexity of O(n log n), which is much faster than other sorting algorithms like selection sort and insertion sort.\\n\\n# Approach\\n1. Find Mid\\n2. Cut list into two halves\\n3. Recursively sort left and right halves\\n4. Merge them\\n5. Return sorted list\\n\\n# Complexity\\n- Time complexity:\\n O(n log n) \\n\\n- Space complexity:\\n O(log n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* findMid(ListNode* head){\\n        ListNode* slow =head;\\n        ListNode* fast =head->next;\\n\\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\n    ListNode* merge(ListNode* left, ListNode* right){\\n\\n        if(left == NULL)\\n        return right;\\n\\n        if(right == NULL)\\n        return left;\\n\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* temp = ans;\\n\\n        while(left != NULL && right != NULL){\\n\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n            }\\n            else{\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n            }\\n        }\\n\\n        while(left != NULL){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n        }\\n\\n        while(right != NULL){\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n        }\\n\\n        ans = ans->next;\\n        return ans;\\n\\n    }\\n\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL || head->next == NULL){\\n            return head;\\n        }\\n    ListNode* mid = findMid(head);\\n    ListNode* left = head;\\n    ListNode* right = mid->next;\\n    mid->next = NULL;\\n\\n    //sort two half ll recursively\\n    left = sortList(left);\\n    right =sortList(right);\\n\\n    // merge them\\n    ListNode* result = merge(left,right);\\n\\n    return result;\\n\\n    }\\n};\\n\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/12a9e453-080a-44b9-9a81-901ec3338d5b_1678645318.3246436.jpeg)\\nUpvote if you like it!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* findMid(ListNode* head){\\n        ListNode* slow =head;\\n        ListNode* fast =head->next;\\n\\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\n    ListNode* merge(ListNode* left, ListNode* right){\\n\\n        if(left == NULL)\\n        return right;\\n\\n        if(right == NULL)\\n        return left;\\n\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* temp = ans;\\n\\n        while(left != NULL && right != NULL){\\n\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n            }\\n            else{\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n            }\\n        }\\n\\n        while(left != NULL){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n        }\\n\\n        while(right != NULL){\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n        }\\n\\n        ans = ans->next;\\n        return ans;\\n\\n    }\\n\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL || head->next == NULL){\\n            return head;\\n        }\\n    ListNode* mid = findMid(head);\\n    ListNode* left = head;\\n    ListNode* right = mid->next;\\n    mid->next = NULL;\\n\\n    //sort two half ll recursively\\n    left = sortList(left);\\n    right =sortList(right);\\n\\n    // merge them\\n    ListNode* result = merge(left,right);\\n\\n    return result;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386345,
                "title": "merge-sort-algorithm-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\nListNode* merge(ListNode* l1, ListNode* l2)\\n{\\n    if(!l1)\\n        return l2;\\n    if(!l2)\\n        return l1;\\n    \\n    if(l1 -> val <= l2 -> val)\\n    {\\n        l1 -> next = merge(l1 -> next, l2);\\n        return l1;\\n    }\\n    else\\n    {\\n        l2 -> next = merge(l1, l2 -> next);\\n        return l2;\\n    }\\n}\\n\\nListNode* sortList(ListNode* head) \\n{\\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    ListNode* slow = head;\\n    ListNode* fast = head -> next;  // Finding the middle point first\\n    \\n    while(fast && fast -> next)\\n    {\\n        slow = slow -> next;\\n        fast = fast -> next -> next;\\n    }\\n    \\n    ListNode* newHead = slow -> next;  // creating two seperate LL \\n    slow -> next = NULL;   \\n    \\n    return merge(sortList(head), sortList(newHead));\\n }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\npublic:\\nListNode* merge(ListNode* l1, ListNode* l2)\\n{\\n    if(!l1)\\n        return l2;\\n    if(!l2)\\n        return l1;\\n    \\n    if(l1 -> val <= l2 -> val)\\n    {\\n        l1 -> next = merge(l1 -> next, l2);\\n        return l1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 893280,
                "title": "java-clean-code-merge-sort-algorithm-o-n-log-n-time-complexity",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate ListNode getMid (ListNode head) {\\n\\t\\t\\n\\t\\tListNode slow = head;\\n\\t\\tListNode fast = head.next;\\n\\t\\t\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\thead = slow.next;\\n\\t\\tslow.next = null;\\n\\t\\treturn head;\\n\\t}\\n\\t\\t\\n\\tprivate ListNode mergeList (ListNode left, ListNode right) {\\n\\t\\t\\n\\t\\tListNode head = new ListNode ();\\n\\t\\tListNode tail = head;\\n\\t\\t\\n\\t\\twhile (left != null && right != null) {\\n\\t\\t\\tif (left.val < right.val) {\\n\\t\\t\\t\\ttail.next = left;\\n\\t\\t\\t\\tleft = left.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ttail.next = right;\\n\\t\\t\\t\\tright = right.next;\\n\\t\\t\\t}\\n\\t\\t\\ttail = tail.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\ttail.next = left != null ? left :right;\\n\\t\\treturn head.next;\\n\\t}\\n\\t\\n\\tpublic ListNode sortList (ListNode head) {\\n\\t\\t\\n\\t\\tif (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode mid = getMid (head);\\n\\t\\tListNode left = sortList (head);\\n\\t\\tListNode right = sortList (mid);\\n\\t\\t\\n\\t\\treturn mergeList (left, right);\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate ListNode getMid (ListNode head) {\\n\\t\\t\\n\\t\\tListNode slow = head;\\n\\t\\tListNode fast = head.next;\\n\\t\\t\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\thead = slow.next;\\n\\t\\tslow.next = null;\\n\\t\\treturn head;\\n\\t}\\n\\t\\t\\n\\tprivate ListNode mergeList (ListNode left, ListNode right) {\\n\\t\\t\\n\\t\\tListNode head = new ListNode ();\\n\\t\\tListNode tail = head;\\n\\t\\t\\n\\t\\twhile (left != null && right != null) {\\n\\t\\t\\tif (left.val < right.val) {\\n\\t\\t\\t\\ttail.next = left;\\n\\t\\t\\t\\tleft = left.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ttail.next = right;\\n\\t\\t\\t\\tright = right.next;\\n\\t\\t\\t}\\n\\t\\t\\ttail = tail.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\ttail.next = left != null ? left :right;\\n\\t\\treturn head.next;\\n\\t}\\n\\t\\n\\tpublic ListNode sortList (ListNode head) {\\n\\t\\t\\n\\t\\tif (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode mid = getMid (head);\\n\\t\\tListNode left = sortList (head);\\n\\t\\tListNode right = sortList (mid);\\n\\t\\t\\n\\t\\treturn mergeList (left, right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239384,
                "title": "java-real-o-1-space-no-recursion-only-iterative-merge-sort-with-full-comments",
                "content": "This problem asks for O(1) space.\\nI saw a lot of solution with Merge sort with Log(N) call stack space.\\nI do see some real O(1) solution but in C++.\\nHere is my version of the O(1) implementation in Java.\\nI write several helper function trying to make it more readable.\\nThe main idea is a bottom up merge sort with the step initalized to 1 and go up.\\nThe main idea is similar to the C++ version here.\\nhttps://leetcode.com/problems/sort-list/discuss/46712/Bottom-to-up(not-recurring)-with-o(1)-space-complextity-and-o(nlgn)-time-complextity\\nThe code should be easily understandable.\\n\\n```\\n   public ListNode sortList(ListNode head) {\\n        int step = 1;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        int size = getSize(head);\\n        while (step < size) {\\n            dummyHead.next = splitAndMergeAtK(dummyHead.next, step);\\n            step *= 2;\\n        }\\n        return dummyHead.next;\\n    }\\n    private ListNode splitAndMergeAtK(ListNode head, int K) {\\n        // iterative merge for every 2 size K segment,\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode cur = dummyHead;\\n        while (head != null) {\\n            ListNode[] headTail1 = getK(head, K); // Get a segment of size K\\n            head = headTail1[1].next;\\n            headTail1[1].next = null;\\n            if (head == null) {\\n                cur.next = headTail1[0];\\n                return dummyHead.next;\\n            }\\n            ListNode[] headTail2 = getK(head, K); // Get another segment of size K\\n            \\n            head = headTail2[1].next;\\n            headTail2[1].next = null;\\n            ListNode[] mergedHeadTail =  mergeK(headTail1[0], headTail2[0]); //merge two segments\\n            cur.next = mergedHeadTail[0]; // hook up\\n            cur = mergedHeadTail[1];\\n        }\\n        return dummyHead.next;\\n    }\\n    private ListNode[] getK(ListNode head, int K) { // get a segment of size K\\n        ListNode[] ans = new ListNode[2]; //head must not be null;\\n        ans[0] = head;\\n        for (int i = 0; i < K; i++) {\\n            ans[1] = head;\\n            head = head.next;\\n            if (head == null) break;\\n        }\\n        return ans;\\n    }\\n    private ListNode[] mergeK(ListNode head1, ListNode head2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode cur = dummyHead;\\n        while (head1 != null && head2 != null) {\\n            if (head1.val <= head2.val) {\\n                cur.next = head1;\\n                head1 = head1.next;\\n            } else {\\n                cur.next = head2;\\n                head2 = head2.next;\\n            }\\n            cur = cur.next;\\n            cur.next = null;\\n        }\\n        cur.next = head1 != null ? head1 : head2;\\n        while (cur.next != null) {\\n            cur = cur.next;\\n        }\\n        return new ListNode[]{dummyHead.next, cur};\\n    }\\n    private int getSize(ListNode head) {\\n        int count = 0;\\n        while (head != null) {\\n            count++;\\n            head = head.next;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public ListNode sortList(ListNode head) {\\n        int step = 1;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        int size = getSize(head);\\n        while (step < size) {\\n            dummyHead.next = splitAndMergeAtK(dummyHead.next, step);\\n            step *= 2;\\n        }\\n        return dummyHead.next;\\n    }\\n    private ListNode splitAndMergeAtK(ListNode head, int K) {\\n        // iterative merge for every 2 size K segment,\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode cur = dummyHead;\\n        while (head != null) {\\n            ListNode[] headTail1 = getK(head, K); // Get a segment of size K\\n            head = headTail1[1].next;\\n            headTail1[1].next = null;\\n            if (head == null) {\\n                cur.next = headTail1[0];\\n                return dummyHead.next;\\n            }\\n            ListNode[] headTail2 = getK(head, K); // Get another segment of size K\\n            \\n            head = headTail2[1].next;\\n            headTail2[1].next = null;\\n            ListNode[] mergedHeadTail =  mergeK(headTail1[0], headTail2[0]); //merge two segments\\n            cur.next = mergedHeadTail[0]; // hook up\\n            cur = mergedHeadTail[1];\\n        }\\n        return dummyHead.next;\\n    }\\n    private ListNode[] getK(ListNode head, int K) { // get a segment of size K\\n        ListNode[] ans = new ListNode[2]; //head must not be null;\\n        ans[0] = head;\\n        for (int i = 0; i < K; i++) {\\n            ans[1] = head;\\n            head = head.next;\\n            if (head == null) break;\\n        }\\n        return ans;\\n    }\\n    private ListNode[] mergeK(ListNode head1, ListNode head2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode cur = dummyHead;\\n        while (head1 != null && head2 != null) {\\n            if (head1.val <= head2.val) {\\n                cur.next = head1;\\n                head1 = head1.next;\\n            } else {\\n                cur.next = head2;\\n                head2 = head2.next;\\n            }\\n            cur = cur.next;\\n            cur.next = null;\\n        }\\n        cur.next = head1 != null ? head1 : head2;\\n        while (cur.next != null) {\\n            cur = cur.next;\\n        }\\n        return new ListNode[]{dummyHead.next, cur};\\n    }\\n    private int getSize(ListNode head) {\\n        int count = 0;\\n        while (head != null) {\\n            count++;\\n            head = head.next;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46853,
                "title": "java-quicksort-4ms",
                "content": "    \\n    public class Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null) return null;\\n        \\n        ListNode pivot = head;\\n        head = head.next;\\n        pivot.next = null;\\n        if (head == null) return pivot;\\n        ListNode small = new ListNode(0);\\n        ListNode large = new ListNode(0);\\n        ListNode p = pivot;\\n        ListNode s = small;\\n        ListNode l = large;\\n        while (head!=null) {\\n            if (head.val < pivot.val) {\\n                s.next = head;\\n                s = s.next;\\n            } else if (head.val == pivot.val) {\\n                p.next = head;\\n                p = p.next;\\n            } else {\\n                l.next = head;\\n                l = l.next;\\n            }\\n            head = head.next;\\n        }\\n        l.next = null;\\n        s.next = null;\\n        p.next = null;\\n        ListNode ss = sortList(small.next);\\n        if (ss == null) {\\n            ss = pivot;    \\n        } else {\\n            ListNode sss = ss;\\n            while (sss.next!=null) {\\n                sss = sss.next;\\n            }\\n            sss.next = pivot;\\n        }\\n        p.next = sortList(large.next);\\n        return ss;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null) return null;\\n        \\n        ListNode pivot = head;\\n        head = head.next;\\n        pivot.next = null;\\n        if (head == null) return pivot;\\n        ListNode small = new ListNode(0);\\n        ListNode large = new ListNode(0);\\n        ListNode p = pivot;\\n        ListNode s = small;\\n        ListNode l = large;\\n        while (head!=null) {\\n            if (head.val < pivot.val) {\\n                s.next = head;\\n                s = s.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46723,
                "title": "super-easy-to-understand-java-iterative-merge-sort-using-o-1-space",
                "content": "I found most iterative merge sort solutions not quite easy to read. So I decided to write my own. I tried to write it as readable as possible. \\n\\nThe basic idea is simple: bottom-up merge sort. Plenty of threads have covered this so I won't elaborate. \\nHowever, a few observations make it easier to build your code.\\n\\n1. At the very beginning, we have sorted sublists of length 1. Then we have sorted sublists of length 2, 4, 8,.....2^i.  When 2^i >= length of the input list, we are done. So we can use this fact for our main loop.\\n\\n2. At the ith pass, only the last sorted sublist may have length less than 2^{i-1}. All the other sorted sublists have length exactly 2^{i-1}. So we can use this fact to get the heads of all sublists. \\nI wrote a function getListTail(head, len). Given the head of a sublist, we can walk (len - 1) steps to get to it's tail. The head of the next sublist is just tail.next. \\nWhy do we want the tail? Because when we merge two sublists, we want to set tail.next = null.\\n\\n3. When you have even number of sublists, you can always pair them. When it's odd, you can just leave the last one there, you will eventually merge it with other another sublist. At the last pass, we always merge two sorted sublists, although the second one may not have length 2^k for some k.\\n\\n4. So for each pass, each time we want to get two sorted sublists and merge them until either (1) we are left with only one sublist, or (2) we are left nothing.\\n\\n5. When merging two adjacent sublists. You want to set their tails point to null. Then after merging, you want to connect its head to the previously merged pairs and its tail to the rest of the unmerged sublists. So keep pointers to both ends. Also your merge function should return both the head and tail of the merged list.\\n\\nThe iterative solution consumes O(1) space since it doesn't use collections or recursion. \\nMy implementation is slower than my recursive version. I think it's reasonable because of the tradeoff between space and speed (recursion use O(log n) stack memory, part of the memory is used to mark the boundary of sublists, but we have to \"manually\" find the boundary, doing setting to null and reconnecting staff)\\n\\n   \\n\\n     public class Solution {\\n            class ListNodePair{\\n                ListNode head;\\n                ListNode tail;\\n                ListNodePair(ListNode h, ListNode t){   head = h;   tail = t;   } \\n            }\\n            public ListNode sortList(ListNode head) {\\n                if(head == null || head.next == null)   return head;\\n                int len = 0;\\n                for(ListNode runner = head; runner != null; runner = runner.next)   len++;\\n                int lenOfList = 1;              //length of sorted sublists: at first we start with 1\\n                while(lenOfList < len){         //if greater than len, we have the whole list sorted\\n                    head = mergeLayer(head, lenOfList);\\n                    lenOfList *= 2;             //each iterate double the length of sorted sublists\\n                }\\n                return head;\\n            }\\n            //merge every two sublists of length lenOfList, assuming each sublist is already sorted \\n            private ListNode mergeLayer(ListNode head, int lenOfList){\\n                ListNode fakehead = new ListNode(0);\\n                ListNode merge_tail = fakehead;   //merge_pail points to the tail of merged part of this layer\\n                ListNode first;\\n                ListNode first_tail;\\n                ListNode second;\\n                ListNode second_tail;\\n                ListNodePair pair;\\n                while(head != null){\\n                    first = head;\\n                    first_tail = getListTail(first, lenOfList);\\n                    second = first_tail.next;\\n                    if(second == null){                     //we have only 1 sorted sublist, \\n                        merge_tail.next = head;             //link the sorted part to the last sorted sublist\\n                        break;\\n                    }\\n                    second_tail = getListTail(second, lenOfList);\\n                    head = second_tail.next;    //now we have get two suitable subllists, point head to the rest\\n                    \\n                    first_tail.next = null;\\n                    second_tail.next = null;\\n                    pair = merge(first, second);\\n                    merge_tail.next = pair.head;  //link the old sorted part to the newly sorted part\\n                    merge_tail = pair.tail;       //update the end of sorted part\\n                }\\n                return fakehead.next;\\n            }\\n            //get the tail of the list with head 'head' and length 'len' (or at most len)     \\n            private ListNode getListTail(ListNode head, int len){ \\n                while(len > 1 && head.next != null){\\n                    head = head.next;\\n                    len --;\\n                }\\n                return head;\\n            }  \\n            //merge two sorted lists, return both the head and tail of the new list\\n            private ListNodePair merge(ListNode l1, ListNode l2){\\n                ListNode fakehead = new ListNode(0);\\n                ListNode tail = fakehead;\\n                while(l1 != null && l2 != null){\\n                    if(l1.val < l2.val){\\n                        tail.next = l1;\\n                        l1 = l1.next;\\n                    }else{\\n                        tail.next = l2;\\n                        l2 = l2.next;\\n                    }\\n                    tail = tail.next;\\n                }\\n                tail.next = (l1 == null) ? l2 : l1;\\n                while(tail.next != null)    tail = tail.next;\\n                return new ListNodePair(fakehead.next, tail);\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            class ListNodePair{\\n                ListNode head;\\n                ListNode tail;\\n                ListNodePair(ListNode h, ListNode t){   head = h;   tail = t;   }",
                "codeTag": "Java"
            },
            {
                "id": 644804,
                "title": "c-merge-sort-easiest-to-understand-fast",
                "content": "````\\nListNode* sortedMerge(ListNode* l, ListNode* r) {\\n        if (! l || !r) return ! l ? r : l;\\n\\n        ListNode *m;\\n\\n        if ( l->val < r->val) {\\n            m =  l;\\n            m->next = sortedMerge( l->next, r);\\n        } else {\\n            m = r;\\n            m->next = sortedMerge( l, r->next);\\n        }\\n\\n        return m;\\n    }\\n\\n    ListNode* frontBackSplit(ListNode* head) {\\n        ListNode *slow = head, *fast = head->next->next;\\n\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        return slow;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head->next) return head;\\n        \\n        ListNode *m = frontBackSplit(head);\\n        ListNode *r = sortList(m->next);\\n        m->next = nullptr;\\n        ListNode *l = sortList(head);\\n        \\n        return sortedMerge(l, r);\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "````\\nListNode* sortedMerge(ListNode* l, ListNode* r) {\\n        if (! l || !r) return ! l ? r : l;\\n\\n        ListNode *m;\\n\\n        if ( l->val < r->val) {\\n            m =  l;\\n            m->next = sortedMerge( l->next, r);\\n        } else {\\n            m = r;\\n            m->next = sortedMerge( l, r->next);\\n        }\\n\\n        return m;\\n    }\\n\\n    ListNode* frontBackSplit(ListNode* head) {\\n        ListNode *slow = head, *fast = head->next->next;\\n\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        return slow;\\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head->next) return head;\\n        \\n        ListNode *m = frontBackSplit(head);\\n        ListNode *r = sortList(m->next);\\n        m->next = nullptr;\\n        ListNode *l = sortList(head);\\n        \\n        return sortedMerge(l, r);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 277478,
                "title": "a-neat-java-solution",
                "content": "```\\n        public ListNode sortList(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode pre = null, slow = head, fast = head;\\n            while (fast != null && fast.next != null) {\\n                pre = slow;\\n                slow = slow.next;\\n                fast = fast.next.next;\\n            }\\n            pre.next = null; // closing up;\\n            // bug - 1 => using the returned node as the header;\\n            return merge(sortList(head), sortList(slow));\\n        }\\n\\n        private ListNode merge(ListNode head1, ListNode head2) {\\n            ListNode newHead = new ListNode(0);\\n            ListNode tail = newHead;\\n            while (head1 != null || head2 != null) {\\n                if (head2 == null || (head1 != null && head1.val <= head2.val)) {\\n                    tail.next = head1;\\n                    head1 = head1.next;\\n                } else {\\n                    tail.next = head2;\\n                    head2 = head2.next;\\n                }\\n                tail = tail.next;\\n            }\\n            return newHead.next;\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        public ListNode sortList(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode pre = null, slow = head, fast = head;\\n            while (fast != null && fast.next != null) {\\n                pre = slow;\\n                slow = slow.next;\\n                fast = fast.next.next;\\n            }\\n            pre.next = null; // closing up;\\n            // bug - 1 => using the returned node as the header;\\n            return merge(sortList(head), sortList(slow));\\n        }\\n\\n        private ListNode merge(ListNode head1, ListNode head2) {\\n            ListNode newHead = new ListNode(0);\\n            ListNode tail = newHead;\\n            while (head1 != null || head2 != null) {\\n                if (head2 == null || (head1 != null && head1.val <= head2.val)) {\\n                    tail.next = head1;\\n                    head1 = head1.next;\\n                } else {\\n                    tail.next = head2;\\n                    head2 = head2.next;\\n                }\\n                tail = tail.next;\\n            }\\n            return newHead.next;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212231,
                "title": "java-solutions-for-four-sorting-algorithms-on-linked-list",
                "content": "**Solution 1: Merge Sort - Ideal for Linked List Sorting**\\n\\nTime Complexity: `O(n log n)`\\nSpace Complexity: `O(log n)` - Maximum depth of recursive function call stack. Merge sort implementation on Linked List avoids the `O(n)` auxiliary storage cost.\\n```\\nclass Solution \\n{\\n    public ListNode mergeSortList(ListNode head) \\n    {\\n        if(head == null || head.next == null)\\n            return head;\\n\\n        ListNode mid = getMid(head), second_head = mid.next; mid.next = null;\\n\\n        ListNode L1 = mergeSortList(head);\\n\\t\\tListNode L2 = mergeSortList(second_head);\\n\\n\\t\\treturn merge(L1, L2);\\n    }\\n    \\n    private ListNode merge(ListNode L1, ListNode L2)\\n\\t{\\n\\t\\tListNode dummy = new ListNode(0), current = dummy;\\n\\t\\t\\n\\t\\twhile(L1 != null && L2 != null)\\n\\t\\t{\\n\\t\\t\\tif(L1.val < L2.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent.next = L1;\\n\\t\\t\\t\\tL1 = L1.next;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent.next = L2;\\n\\t\\t\\t\\tL2 = L2.next;\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(L1 != null) current.next = L1;\\n\\t\\tif(L2 != null) current.next = L2;\\n\\t\\t\\n\\t\\treturn dummy.next;\\n\\t}\\n\\n    private ListNode getMid(ListNode head)\\n    {\\n        ListNode slow = head, fast = head.next;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n}\\n```\\n\\n**Solution 2: Insertion Sort**\\n\\nTime Complexity: `O(n^2)`\\nSpace Complexity: `O(1)` - Insertion sort is In-Place sorting algorithm\\n\\n***Insertion Sort Implementation 1:***\\n```\\nclass Solution \\n{\\n    public ListNode insertionSortList(ListNode head)\\n    {\\n        // Initialize partially sorted list\\n\\t\\tListNode dummy = new ListNode(0), prev = dummy, current = head;\\n\\n        while(current != null)\\n        {\\n            if(prev.val > current.val)\\n                prev = dummy;\\n            \\n            // Find the right place to insert current node\\n            while(prev.next != null && prev.next.val < current.val)\\n                prev = prev.next;\\n\\n            // Insert current between prev and prev.next\\n            ListNode nextNode = current.next;\\n\\t\\t\\tcurrent.next = prev.next;\\n            prev.next = current;\\n            current = nextNode;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n***Insertion Sort Implementation 2:***\\n```\\nclass Solution \\n{\\n    public ListNode insertionSortList(ListNode head)\\n    {\\n        // Initialize partially sorted list\\n\\t\\tListNode dummy = new ListNode(0); dummy.next = head;\\n        ListNode current = head;\\n\\n        while(current != null && current.next != null)\\n        {\\n\\t\\t\\tif(current.val > current.next.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tListNode prev = dummy;\\n                ListNode target = current.next;\\n                \\n                // Find the right place to insert current node\\n                while(prev.next != null && prev.next.val < target.val)\\n\\t\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t\\n\\t            // Insert target between prev and prev.next\\n                current.next = target.next;\\n\\t\\t\\t\\ttarget.next = prev.next;\\n                prev.next = target;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent = current.next;\\n\\t\\t\\t}\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**Solution 3: Selection Sort**\\n\\nTime Complexity: `O(n^2)`\\nSpace Complexity: `O(1)` - Selection sort is In-Place sorting algorithm\\n```\\nclass Solution \\n{\\n    public ListNode selectionSortList(ListNode head)\\n    {\\n\\t\\tfor(ListNode current = head; current != null; current = current.next)\\n\\t\\t{\\n\\t\\t\\tswap(current, findMinimumNode(current));\\n\\t\\t}\\n        return head;\\n\\t}\\n\\n\\tprivate void swap(ListNode x, ListNode y)\\n    {\\n        if(x != y)\\n        {\\n            int temp = x.val;\\n            x.val = y.val;\\n            y.val = temp;    \\n        }\\n    }\\n\\n\\tprivate ListNode findMinimumNode(ListNode head)\\n\\t{\\n\\t\\tif(head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n        ListNode minimumNode = head;\\n        \\n\\t\\tfor(ListNode current = head.next; current != null; current = current.next)\\n\\t\\t{\\n\\t\\t\\tif(minimumNode.val > current.val)\\n\\t\\t\\t\\tminimumNode = current;\\n\\t\\t}\\n\\t\\treturn minimumNode;\\n\\t}\\n}    \\n```\\n\\n**Solution 4: Bubble Sort**\\n\\nTime Complexity: `O(n^2)`\\nSpace Complexity:` O(1)` - Bubble sort is In-Place sorting algorithm\\n```\\nclass Solution\\n{\\n    public ListNode bubbleSortList(ListNode head)\\n    {\\n        boolean isSwapped = true;\\n        \\n        for(ListNode current = head, tail = null; isSwapped && head != tail; tail = current, current = head)\\n\\t\\t{\\n\\t\\t\\tfor(isSwapped = false; current.next != tail; current = current.next) \\n\\t\\t\\t{ \\n\\t\\t\\t\\tif (current.val > current.next.val) \\n\\t\\t\\t\\t{  \\n\\t\\t\\t\\t\\tswap(current, current.next); \\n\\t\\t\\t\\t\\tisSwapped = true; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn head;\\n    }\\n\\n    private void swap(ListNode x, ListNode y)\\n    {\\n        if(x != y)\\n        {\\n            int temp = x.val;\\n            x.val = y.val;\\n            y.val = temp;    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public ListNode mergeSortList(ListNode head) \\n    {\\n        if(head == null || head.next == null)\\n            return head;\\n\\n        ListNode mid = getMid(head), second_head = mid.next; mid.next = null;\\n\\n        ListNode L1 = mergeSortList(head);\\n\\t\\tListNode L2 = mergeSortList(second_head);\\n\\n\\t\\treturn merge(L1, L2);\\n    }\\n    \\n    private ListNode merge(ListNode L1, ListNode L2)\\n\\t{\\n\\t\\tListNode dummy = new ListNode(0), current = dummy;\\n\\t\\t\\n\\t\\twhile(L1 != null && L2 != null)\\n\\t\\t{\\n\\t\\t\\tif(L1.val < L2.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent.next = L1;\\n\\t\\t\\t\\tL1 = L1.next;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent.next = L2;\\n\\t\\t\\t\\tL2 = L2.next;\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.next;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(L1 != null) current.next = L1;\\n\\t\\tif(L2 != null) current.next = L2;\\n\\t\\t\\n\\t\\treturn dummy.next;\\n\\t}\\n\\n    private ListNode getMid(ListNode head)\\n    {\\n        ListNode slow = head, fast = head.next;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public ListNode insertionSortList(ListNode head)\\n    {\\n        // Initialize partially sorted list\\n\\t\\tListNode dummy = new ListNode(0), prev = dummy, current = head;\\n\\n        while(current != null)\\n        {\\n            if(prev.val > current.val)\\n                prev = dummy;\\n            \\n            // Find the right place to insert current node\\n            while(prev.next != null && prev.next.val < current.val)\\n                prev = prev.next;\\n\\n            // Insert current between prev and prev.next\\n            ListNode nextNode = current.next;\\n\\t\\t\\tcurrent.next = prev.next;\\n            prev.next = current;\\n            current = nextNode;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public ListNode insertionSortList(ListNode head)\\n    {\\n        // Initialize partially sorted list\\n\\t\\tListNode dummy = new ListNode(0); dummy.next = head;\\n        ListNode current = head;\\n\\n        while(current != null && current.next != null)\\n        {\\n\\t\\t\\tif(current.val > current.next.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tListNode prev = dummy;\\n                ListNode target = current.next;\\n                \\n                // Find the right place to insert current node\\n                while(prev.next != null && prev.next.val < target.val)\\n\\t\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t\\n\\t            // Insert target between prev and prev.next\\n                current.next = target.next;\\n\\t\\t\\t\\ttarget.next = prev.next;\\n                prev.next = target;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrent = current.next;\\n\\t\\t\\t}\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public ListNode selectionSortList(ListNode head)\\n    {\\n\\t\\tfor(ListNode current = head; current != null; current = current.next)\\n\\t\\t{\\n\\t\\t\\tswap(current, findMinimumNode(current));\\n\\t\\t}\\n        return head;\\n\\t}\\n\\n\\tprivate void swap(ListNode x, ListNode y)\\n    {\\n        if(x != y)\\n        {\\n            int temp = x.val;\\n            x.val = y.val;\\n            y.val = temp;    \\n        }\\n    }\\n\\n\\tprivate ListNode findMinimumNode(ListNode head)\\n\\t{\\n\\t\\tif(head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n        ListNode minimumNode = head;\\n        \\n\\t\\tfor(ListNode current = head.next; current != null; current = current.next)\\n\\t\\t{\\n\\t\\t\\tif(minimumNode.val > current.val)\\n\\t\\t\\t\\tminimumNode = current;\\n\\t\\t}\\n\\t\\treturn minimumNode;\\n\\t}\\n}    \\n```\n```\\nclass Solution\\n{\\n    public ListNode bubbleSortList(ListNode head)\\n    {\\n        boolean isSwapped = true;\\n        \\n        for(ListNode current = head, tail = null; isSwapped && head != tail; tail = current, current = head)\\n\\t\\t{\\n\\t\\t\\tfor(isSwapped = false; current.next != tail; current = current.next) \\n\\t\\t\\t{ \\n\\t\\t\\t\\tif (current.val > current.next.val) \\n\\t\\t\\t\\t{  \\n\\t\\t\\t\\t\\tswap(current, current.next); \\n\\t\\t\\t\\t\\tisSwapped = true; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn head;\\n    }\\n\\n    private void swap(ListNode x, ListNode y)\\n    {\\n        if(x != y)\\n        {\\n            int temp = x.val;\\n            x.val = y.val;\\n            y.val = temp;    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46878,
                "title": "java-5ms-quick-sort",
                "content": "\\n    public ListNode sortList(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode left = new ListNode(0), leftHead = left;\\n        ListNode right = new ListNode(0), rightHead = right;\\n        ListNode mid = new ListNode(0), midHead = mid;\\n        int val = head.val;\\n        while(head != null){\\n            if(head.val < val){\\n                left.next = head;\\n                left = head;\\n            }  \\n            if(head.val > val){\\n                right.next = head;\\n                right = head;\\n            }\\n            if(head.val == val){\\n                mid.next = head;\\n                mid = head;\\n            }\\n            head = head.next;\\n        }\\n        left.next = null;\\n        right.next = null;\\n        mid.next = null;\\n        \\n        return concat(sortList(leftHead.next),midHead.next,sortList(rightHead.next));\\n        \\n    }\\n    public ListNode concat(ListNode left, ListNode mid, ListNode right){\\n        ListNode LeftTail = getTail(left);\\n        ListNode midTail = getTail(mid);\\n        midTail.next = right;\\n        if(LeftTail != null) {\\n            LeftTail.next = mid;\\n            return left;\\n        } else {\\n            return mid;\\n        }\\n    }\\n    public ListNode getTail(ListNode head){\\n        if(head == null) return head;\\n        while(head.next != null) head = head.next;\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "\\n    public ListNode sortList(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode left = new ListNode(0), leftHead = left;\\n        ListNode right = new ListNode(0), rightHead = right;\\n        ListNode mid = new ListNode(0), midHead = mid;\\n        int val = head.val;\\n        while(head != null){\\n            if(head.val < val){\\n                left.next = head;\\n                left = head;\\n            }  \\n            if(head.val > val){\\n                right.next = head;\\n                right = head;\\n            }\\n            if(head.val == val){\\n                mid.next = head;\\n                mid = head;\\n            }\\n            head = head.next;\\n        }\\n        left.next = null;\\n        right.next = null;\\n        mid.next = null;\\n        \\n        return concat(sortList(leftHead.next),midHead.next,sortList(rightHead.next));\\n        \\n    }\\n    public ListNode concat(ListNode left, ListNode mid, ListNode right){\\n        ListNode LeftTail = getTail(left);\\n        ListNode midTail = getTail(mid);\\n        midTail.next = right;\\n        if(LeftTail != null) {\\n            LeftTail.next = mid;\\n            return left;\\n        } else {\\n            return mid;\\n        }\\n    }\\n    public ListNode getTail(ListNode head){\\n        if(head == null) return head;\\n        while(head.next != null) head = head.next;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3027781,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        \\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        int a[]=new int[count];\\n        count=0;\\n        while(temp!=null){\\n            a[count++]=temp.val;\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        Arrays.sort(a);\\n        int k=0;\\n        while(temp!=null){\\n            temp.val=a[k++];\\n            temp=temp.next;\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        \\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        int a[]=new int[count];\\n        count=0;\\n        while(temp!=null){\\n            a[count++]=temp.val;\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        Arrays.sort(a);\\n        int k=0;\\n        while(temp!=null){\\n            temp.val=a[k++];\\n            temp=temp.next;\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797262,
                "title": "radix-sort-with-o-n-log-n-runtime-and-o-1-space",
                "content": "Because I don\\'t see anyone applied radix sort approach for the follow up question, I tried it myself.\\nDifferent from traditional radix sort on array, we don\\'t need an extra memory for reordering the linked list. All we need is a similar array for counting.\\n![image](https://assets.leetcode.com/users/images/6be87d1a-9739-4563-a7fc-85361834fa57_1645746214.2404487.png)\\nFor simple, here I use `10^exp` base for the radix sort. We just need to run 5 times to cover all possible values from the test cases\\nSteps:\\n- For each `exp` from 0 to 5\\n\\t- Create an array `tails` with size 20 (0-9 for negative, 10-19 for positive)\\n\\t- Loop over all nodes on the original list\\n\\t    - Calculate index of the node based on index\\n\\t    - Append new node to the linked list (`tails[index].next = node`)\\n\\t- Merge all sub-list on the tail array \\n\\nOne note for merge step, because we store the sub-list in reverse order, we need to reverve the list when merge. Merge runs in `O(n)` but we can improve to `O(1)` by keeping both `head` and `tail` of the sub-list.\\n\\nCode:\\n```python\\ndef radix_sort(head):\\n    def reverse(node):\\n        cur, nex, tail = None, node, node\\n        while nex:\\n            tmp = nex.next\\n            nex.next = cur\\n            cur, nex = nex, tmp\\n        return cur, tail\\n\\n    def radix(head, exp):\\n        # From exp = 1, the tail looks like: 4 -> 3 -> 2 -> 1, therefore, we need to reverse when merging\\n        tails = [ListNode(0) for _ in range(20)]\\n        div = 10 ** exp\\n        cur = head\\n        while cur:\\n            abs_index = (abs(cur.val) // div) % 10\\n            index = 10 + abs_index * (1 if cur.val >= 0 else -1)\\n            tmp = cur.next\\n            cur.next = tails[index].next\\n            tails[index].next = cur\\n            cur = tmp\\n\\n        dummy = ListNode(0)\\n        cur = dummy\\n        # Merge. If we store both head and tail, the merge is faster with O(1)\\n        for tail in tails:\\n            if tail.next:\\n                h, t = reverse(tail.next)\\n                cur.next = h\\n                cur = t\\n        return dummy.next\\n\\n    # Run\\n    for i in range(0, 5):\\n        head = radix(head, i)\\n    return head\\n```\\n**Improvement**\\nIn addition to merge step improvement, there is 1 more place we can improve the run time.\\nAt the `#Run` step, we can also do ealry break if we check there is only 1 tail in the `tails` array has valid value.\\n```python\\n        # Merge\\n        count = 0\\n        for tail in tails:\\n            if tail.next:\\n                h, t = reverse(tail.next)\\n                cur.next = h\\n                cur = t\\n\\t\\t\\t\\tcount += 1\\n        return dummy.next, count == 1\\n```\\nthen\\n```python\\n    # Run\\n    for i in range(0, 5):\\n        head, is_merged = radix(head, i)\\n\\t\\tif is_merged: break\\n```\\n\\n**Complexity**:\\nWe need `O(n)` for breaking the list into sublist and also `O(n)` for merging, therefore `radix` \\'s time complexity is `O(n)`. `Run` is fixed to 5 for this problem (`-10^5 <= Node.val <= 10^5`) but it\\'s actually `O(log n)` in general cases. Therefore, overall, the time complexity is `O(n log n)`.\\nWe just need an extra array with fixed size, therefore, space complexity is `O(1)`\\n\\nIf you have any question, feel free to leave a comment. Please **upvote** if you like this.\\n",
                "solutionTags": [],
                "code": "```python\\ndef radix_sort(head):\\n    def reverse(node):\\n        cur, nex, tail = None, node, node\\n        while nex:\\n            tmp = nex.next\\n            nex.next = cur\\n            cur, nex = nex, tmp\\n        return cur, tail\\n\\n    def radix(head, exp):\\n        # From exp = 1, the tail looks like: 4 -> 3 -> 2 -> 1, therefore, we need to reverse when merging\\n        tails = [ListNode(0) for _ in range(20)]\\n        div = 10 ** exp\\n        cur = head\\n        while cur:\\n            abs_index = (abs(cur.val) // div) % 10\\n            index = 10 + abs_index * (1 if cur.val >= 0 else -1)\\n            tmp = cur.next\\n            cur.next = tails[index].next\\n            tails[index].next = cur\\n            cur = tmp\\n\\n        dummy = ListNode(0)\\n        cur = dummy\\n        # Merge. If we store both head and tail, the merge is faster with O(1)\\n        for tail in tails:\\n            if tail.next:\\n                h, t = reverse(tail.next)\\n                cur.next = h\\n                cur = t\\n        return dummy.next\\n\\n    # Run\\n    for i in range(0, 5):\\n        head = radix(head, i)\\n    return head\\n```\n```python\\n        # Merge\\n        count = 0\\n        for tail in tails:\\n            if tail.next:\\n                h, t = reverse(tail.next)\\n                cur.next = h\\n                cur = t\\n\\t\\t\\t\\tcount += 1\\n        return dummy.next, count == 1\\n```\n```python\\n    # Run\\n    for i in range(0, 5):\\n        head, is_merged = radix(head, i)\\n\\t\\tif is_merged: break\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1795826,
                "title": "python-simple-python-solution-with-two-approach",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Approach 1: - Append all element in array then sort that array after this replace all elements in linked list with array\\'s elements.\\n# Runtime: 195 ms, faster than 95.97% of Python3\\n\\tclass Solution:\\n\\t\\tdef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnew_node=head\\n\\n\\t\\t\\tresult = new_node\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\twhile head != None:\\n\\t\\t\\t\\tarray.append(head.val)\\n\\t\\t\\t\\thead=head.next\\n\\n\\t\\t\\tarray = sorted(array)\\n\\n\\t\\t\\tfor num in array:\\n\\t\\t\\t\\tnew_node.val = num\\n\\t\\t\\t\\tnew_node = new_node.next\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Approach 1: - Append all element in array then sort that array after this replace all elements in linked list with array\\'s elements.\\n# Runtime: 195 ms, faster than 95.97% of Python3\\n\\tclass Solution:\\n\\t\\tdef sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnew_node=head\\n\\n\\t\\t\\tresult = new_node\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\twhile head != None:\\n\\t\\t\\t\\tarray.append(head.val)\\n\\t\\t\\t\\thead=head.next\\n\\n\\t\\t\\tarray = sorted(array)\\n\\n\\t\\t\\tfor num in array:\\n\\t\\t\\t\\tnew_node.val = num\\n\\t\\t\\t\\tnew_node = new_node.next\\n\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 1795186,
                "title": "c-easy-understanding-merge-2-pointers",
                "content": "\\'\\uD83C\\uDF3B A beautiful life begins with a beautiful mind , \\uD83C\\uDF3B G O O D \\uD83C\\uDF3B M O R N I N G\\uD83C\\uDF3B \\'\\n\\n### Problem Statement\\n```\\nProblem statement is a quite simple we have to sort the give list in O(nlogn).\\nApproaches are many like sorting (merge sort , quick sort),then we can use 2 pointer concept.\\nSo for this problem we are using 2 pointer concept + Merge sort concept.\\n```\\n\\n### How 2 pointers approach is using??\\n```\\nBaically we all know turtle and rabbit race story.\\nTurtle runs slowly slowly step by step.\\nRabbit runs fast 2 steps at a time. That Thing i am using in my approach.\\n\\nSo Lets see with an example.\\n\\t\\n\\t    turtle,head                      //head is not changing its position it will remain to its original Positition\\n\\t      \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n          \\u2B06\\uFE0F\\n\\t\\t rabbit\\n\\t\\t \\nRACE STARTS\\t\\t \\n\\nStep-1\\n\\t\\t      turtle\\n\\t            \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4]\\n\\t\\t\\t\\t        \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t  rabbit\\nStep-1\\n\\t\\t\\t\\t\\t  turtle\\n\\t\\t\\t\\t\\t   \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t\\t\\t\\t rabbit\\nStep-3\\n\\t\\t\\t\\t\\t\\t  turtle\\n\\t\\t\\t\\t\\t        \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n\\t\\t\\t\\t\\t\\t\\t\\t          \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t\\t\\t\\t          rabbit\\n\\t\\t\\t\\t\\t  \\nSo Now we cant go further and  if we see position of turtle it is in middle.\\nThats the thing what i wanted to split the array into two and then using same concept again and again.\\nMy array split into two.\\narray 1 (left array) = [5 , 8 , 6 ]\\narray 2(right array) = [1 , 3 , 4 ]\\nhead will be poiniting to starting node of array 1;\\nturtle will poiniting the head of array 2 list.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tNOW THIS PROCESS CONTINUES TILL I CAN\\'T BE ABLE TO DIVIDE MY ARRAY\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (until my if condition is not satisfied)\\n\\n```\\n\\n### Merge Sort\\n```\\nWe are using merge sort to combine all the unsorted sub array into a single sorted array.\\n```\\n\\n### CODE\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\'UpVote If You Like It\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\'\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //This checks whether it contain should not a contain empty list or only 1 node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        //turtke and rabbit working as my slow and fast pointers\\n        ListNode *x = NULL;\\n        ListNode *turtle = head;\\n        ListNode *rabbit = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(rabbit !=  NULL && rabbit -> next != NULL)\\n        {\\n            x = turtle;\\n            turtle = turtle->next;          //turtle takes one step at a time\\n            rabbit = rabbit ->next ->next;  //rabbit takes 2 step at a time to reach it before turtle\\n            \\n        }   \\n        x -> next = NULL;            //end of first left half\\n        \\n        ListNode* p = sortList(head);    //turtle have divided my list into two and sharing divided list left part . head is pointing to the first node of left sublist\\n        ListNode* q = sortList(turtle);    //sharinig right half part and turtle is pointing the \\n        \\n        return mergelist(p, q);         //merging them\\n            \\n    }\\n   \\n    ListNode* mergelist(ListNode *p, ListNode *q)\\n    {\\n        ListNode *temp = new ListNode(0);\\n        ListNode *current = temp;\\n        \\n            while(p != NULL && q != NULL)\\n            {\\n                if(p->val <= q->val)\\n                {\\n                    current -> next = p;\\n                    p = p -> next;\\n                }\\n                else\\n                {\\n                    current-> next = q;\\n                    q=q->next;\\n                }\\n            current = current ->next;    \\n            }\\n    \\n                //if anything is remaining\\n        if(p != NULL)\\n        {\\n            current -> next = p;\\n            p= p->next;\\n        }\\n        \\n        if(q != NULL)\\n        {\\n           current -> next = q;\\n            q = q ->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Merge Sort"
                ],
                "code": "```\\nProblem statement is a quite simple we have to sort the give list in O(nlogn).\\nApproaches are many like sorting (merge sort , quick sort),then we can use 2 pointer concept.\\nSo for this problem we are using 2 pointer concept + Merge sort concept.\\n```\n```\\nBaically we all know turtle and rabbit race story.\\nTurtle runs slowly slowly step by step.\\nRabbit runs fast 2 steps at a time. That Thing i am using in my approach.\\n\\nSo Lets see with an example.\\n\\t\\n\\t    turtle,head                      //head is not changing its position it will remain to its original Positition\\n\\t      \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n          \\u2B06\\uFE0F\\n\\t\\t rabbit\\n\\t\\t \\nRACE STARTS\\t\\t \\n\\nStep-1\\n\\t\\t      turtle\\n\\t            \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4]\\n\\t\\t\\t\\t        \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t  rabbit\\nStep-1\\n\\t\\t\\t\\t\\t  turtle\\n\\t\\t\\t\\t\\t   \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t\\t\\t\\t rabbit\\nStep-3\\n\\t\\t\\t\\t\\t\\t  turtle\\n\\t\\t\\t\\t\\t        \\u2B07\\uFE0F\\n\\tarr=[  5  ,  8   ,  6  , 1 ,   3  ,   4  ]\\n\\t\\t\\t\\t\\t\\t\\t\\t          \\u2B06\\uFE0F\\n\\t\\t\\t\\t\\t\\t\\t\\t          rabbit\\n\\t\\t\\t\\t\\t  \\nSo Now we cant go further and  if we see position of turtle it is in middle.\\nThats the thing what i wanted to split the array into two and then using same concept again and again.\\nMy array split into two.\\narray 1 (left array) = [5 , 8 , 6 ]\\narray 2(right array) = [1 , 3 , 4 ]\\nhead will be poiniting to starting node of array 1;\\nturtle will poiniting the head of array 2 list.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tNOW THIS PROCESS CONTINUES TILL I CAN\\'T BE ABLE TO DIVIDE MY ARRAY\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (until my if condition is not satisfied)\\n\\n```\n```\\nWe are using merge sort to combine all the unsorted sub array into a single sorted array.\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\'UpVote If You Like It\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\'\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //This checks whether it contain should not a contain empty list or only 1 node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        //turtke and rabbit working as my slow and fast pointers\\n        ListNode *x = NULL;\\n        ListNode *turtle = head;\\n        ListNode *rabbit = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(rabbit !=  NULL && rabbit -> next != NULL)\\n        {\\n            x = turtle;\\n            turtle = turtle->next;          //turtle takes one step at a time\\n            rabbit = rabbit ->next ->next;  //rabbit takes 2 step at a time to reach it before turtle\\n            \\n        }   \\n        x -> next = NULL;            //end of first left half\\n        \\n        ListNode* p = sortList(head);    //turtle have divided my list into two and sharing divided list left part . head is pointing to the first node of left sublist\\n        ListNode* q = sortList(turtle);    //sharinig right half part and turtle is pointing the \\n        \\n        return mergelist(p, q);         //merging them\\n            \\n    }\\n   \\n    ListNode* mergelist(ListNode *p, ListNode *q)\\n    {\\n        ListNode *temp = new ListNode(0);\\n        ListNode *current = temp;\\n        \\n            while(p != NULL && q != NULL)\\n            {\\n                if(p->val <= q->val)\\n                {\\n                    current -> next = p;\\n                    p = p -> next;\\n                }\\n                else\\n                {\\n                    current-> next = q;\\n                    q=q->next;\\n                }\\n            current = current ->next;    \\n            }\\n    \\n                //if anything is remaining\\n        if(p != NULL)\\n        {\\n            current -> next = p;\\n            p= p->next;\\n        }\\n        \\n        if(q != NULL)\\n        {\\n           current -> next = q;\\n            q = q ->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795152,
                "title": "javascript-built-in-sort-explained",
                "content": "__Before giving me a negative vote, please tell me what is your expectation__\\n\\nThe idea here is just put everything into an array, use the JS Arrray.prototype.sort() function to sort that array, and then modify the linked list values.\\n\\n__Runtime:__ 112 ms (99.55%)\\n__Memory Usage:__ 46.9 MB (42.54%)\\n```JavaScript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head) {\\n    const arr = []; //To store all the numbers\\n    let node = head; //helper node to iterate the linked list\\n    \\n    //Fill the array\\n    while(head) {\\n        arr.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    //Sort the numbers\\n    arr.sort((a,b) => a - b);\\n    \\n    \\n    head = node; // We want to return the same head, and we already changed its value when filling the array\\n    \\n    for(const n of arr) {\\n        node.val = n; //Change list value\\n        node = node.next; //Go next\\n    }\\n    \\n    //Finally return the head of the new linked list\\n    return head;\\n};\\n```\\n\\nComplexity Analisys:\\n__Time:__ `O (n log n)` travarse the linked list twice is just O(n) while the sorting implementation in NodeJS is O(n log n) which uses an alrothim called TimSort https://en.wikipedia.org/wiki/Timsort\\n__Space:__ `O(n)` which is the array used to store all the linked list values\\n\\nAs always, any feedback will be well accepted.\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar sortList = function(head) {\\n    const arr = []; //To store all the numbers\\n    let node = head; //helper node to iterate the linked list\\n    \\n    //Fill the array\\n    while(head) {\\n        arr.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    //Sort the numbers\\n    arr.sort((a,b) => a - b);\\n    \\n    \\n    head = node; // We want to return the same head, and we already changed its value when filling the array\\n    \\n    for(const n of arr) {\\n        node.val = n; //Change list value\\n        node = node.next; //Go next\\n    }\\n    \\n    //Finally return the head of the new linked list\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450542,
                "title": "constant-space-python-bottom-up",
                "content": "One can argue if the authors really meant by constant space useage of memory completely independent on the number of nodes, because even for 2^32 nodes O(log N) space complexity is in practice constant (~32). Even for huge numbers like 2^1000 the memory useage is nothing. Wikipedia article actually outlines bottom-up approach with the explicit use of an additional array of size 32 without any mentioning of the size of the list. Recursion in this sense is not any worse.\\n\\nIt is of course possible not to use any additional arrays or recursion without any price for O(N log N) complexity of the algorithm (outlined below), however you have to pay by the increase of an actual constant coefficient of O(N logN). Meaning it\\'s slower and for any practical list sizes also not really more memory efficient. \\n\\nThe idea is very simple - start by sorting each bucket of n=1 elements, then  n=2, n = 4 etc by merging with the next neighbouring bucket, which gives Log_2(N) number of iterations for the choice of n. For each n we have to find all elements first for the left bucket (because we don\\'t use addititonal memory), then merge with the right bucket, finding takes O(N), merging takes another O(N), so we could of course optimize efficiency by using O(log N) memory to simplify finding of the left elements but it does not affect the theoretical complexity of O(N log N).\\n\\nThe realisation below is not really nice (especially comparing to recursive solutions), it was accepted with 19.7 MB (100% less memory, which does not really mean anything for python submissions), so the purpose of this post is to question the original constant space complexity idea of the problem.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def merge(self, plist1: ListNode, list1: ListNode, plist2: ListNode, list2: ListNode, n, n2: int):\\n        elist1 = list2\\n        pres = res = None\\n        pfirst = plist1\\n        first = list1\\n        n21 = n2\\n        while list1 != elist1 or n2 > 0:\\n            if list1 != elist1 and (n2 == 0 or list1.val <= list2.val):\\n                plist1 = list1\\n                list1 = list1.next\\n                if n2 == 0 and list1 == elist1:\\n                    pres = plist1\\n                    res = list1                  \\n            else:\\n                if list1 != elist1:\\n                    if not plist1 is None:\\n                        plist1.next = list2\\n                    if first == list1:\\n                        first = list2\\n                    plist1 = list2\\n                    if elist1 == list2:\\n                        elist1 = list2.next\\n                    plist2.next = list2.next\\n                    list2.next = list1\\n                    list2 = plist2.next\\n                else:\\n                    plist2 = list2\\n                    list2 = list2.next\\n                n2 -= 1\\n        return (first, plist2, list2) if pres is None else (first, pres, res)\\n                \\n    def sortList(self, head: ListNode) -> ListNode:\\n        n = 1\\n        l = 0\\n        if head is None or head.next is None:\\n            return head\\n        while l == 0 or n <= l // 2:\\n            pleft = None\\n            left = head\\n            pright = left\\n            right = head\\n            it = 0\\n            n2 = n\\n            while not left is None and not right is None:\\n                for j in range(n):\\n                    pright = right\\n                    right = right.next\\n                it += 2 * n\\n                if l > 0:\\n                    if l - it < 2 * n:\\n                        left, pright, right = self.merge(pleft, left, pright, right, n, n2)    \\n                        if pleft is None:\\n                            head = left\\n                        n2 = l - it                  \\n                elif not right.next is None and right.next.next is None:\\n                    n2 += 1\\n                    it += 1\\n                    if right.next.val < right.val:\\n                        right.next.next = right\\n                        pright.next = right.next\\n                        right.next = None\\n                        right = pright.next\\n                \\n                pright, right, left = self.merge(pleft, left, pright, right, n, n2)\\n                if pleft is None:\\n                    head = pright\\n                pleft = right\\n                right = left\\n            if l == 0:\\n                l = it\\n            n *= 2\\n        return head\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def merge(self, plist1: ListNode, list1: ListNode, plist2: ListNode, list2: ListNode, n, n2: int):\\n        elist1 = list2\\n        pres = res = None\\n        pfirst = plist1\\n        first = list1\\n        n21 = n2\\n        while list1 != elist1 or n2 > 0:\\n            if list1 != elist1 and (n2 == 0 or list1.val <= list2.val):\\n                plist1 = list1\\n                list1 = list1.next\\n                if n2 == 0 and list1 == elist1:\\n                    pres = plist1\\n                    res = list1                  \\n            else:\\n                if list1 != elist1:\\n                    if not plist1 is None:\\n                        plist1.next = list2\\n                    if first == list1:\\n                        first = list2\\n                    plist1 = list2\\n                    if elist1 == list2:\\n                        elist1 = list2.next\\n                    plist2.next = list2.next\\n                    list2.next = list1\\n                    list2 = plist2.next\\n                else:\\n                    plist2 = list2\\n                    list2 = list2.next\\n                n2 -= 1\\n        return (first, plist2, list2) if pres is None else (first, pres, res)\\n                \\n    def sortList(self, head: ListNode) -> ListNode:\\n        n = 1\\n        l = 0\\n        if head is None or head.next is None:\\n            return head\\n        while l == 0 or n <= l // 2:\\n            pleft = None\\n            left = head\\n            pright = left\\n            right = head\\n            it = 0\\n            n2 = n\\n            while not left is None and not right is None:\\n                for j in range(n):\\n                    pright = right\\n                    right = right.next\\n                it += 2 * n\\n                if l > 0:\\n                    if l - it < 2 * n:\\n                        left, pright, right = self.merge(pleft, left, pright, right, n, n2)    \\n                        if pleft is None:\\n                            head = left\\n                        n2 = l - it                  \\n                elif not right.next is None and right.next.next is None:\\n                    n2 += 1\\n                    it += 1\\n                    if right.next.val < right.val:\\n                        right.next.next = right\\n                        pright.next = right.next\\n                        right.next = None\\n                        right = pright.next\\n                \\n                pright, right, left = self.merge(pleft, left, pright, right, n, n2)\\n                if pleft is None:\\n                    head = pright\\n                pleft = right\\n                right = left\\n            if l == 0:\\n                l = it\\n            n *= 2\\n        return head\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46880,
                "title": "simple-java-merge-sort-commented",
                "content": "     public ListNode sortList(ListNode head) {\\n    \\tif (head == null || head.next == null) return head;\\n    \\t\\n    \\t//Use two runners to break list into two halfs.\\n        ListNode fast = head, slow = head, prev = null;\\n        while (fast != null && fast.next != null) {\\n        \\tprev = slow;\\n        \\tslow = slow.next;\\n        \\tfast = fast.next.next;\\n        }\\n        ListNode second = prev.next;\\n        prev.next = null;\\n        //sort each half\\n        ListNode first = sortList(head);\\n        second = sortList(second);\\n        //merge them.\\n        head = mergeList(first, second);\\n        return head;\\n    }\\n\\n\\tprivate ListNode mergeList(ListNode first, ListNode second) {\\n\\t\\tListNode dummy = new ListNode(0), merged = dummy;\\n\\t\\twhile (first != null && second != null) {\\n\\t\\t\\tif (first.val <= second.val) {\\n\\t\\t\\t\\tmerged.next = first;\\n\\t\\t\\t\\tmerged = merged.next;\\n\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmerged.next = second;\\n\\t\\t\\t\\tmerged = merged.next;\\n\\t\\t\\t\\tsecond = second.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (first != null || second != null)\\n\\t\\t\\tmerged.next = (first != null)? first :second;\\n\\t\\t\\n\\t\\treturn dummy.next;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "     public ListNode sortList(ListNode head) {\\n    \\tif (head == null || head.next == null) return head;\\n    \\t\\n    \\t//Use two runners to break list into two halfs.\\n        ListNode fast = head, slow = head, prev = null;\\n        while (fast != null && fast.next != null) {\\n        \\tprev = slow;\\n        \\tslow = slow.next;\\n        \\tfast = fast.next.next;\\n        }\\n        ListNode second = prev.next;\\n        prev.next = null;\\n        //sort each half\\n        ListNode first = sortList(head);\\n        second = sortList(second);\\n        //merge them.\\n        head = mergeList(first, second);\\n        return head;\\n    }\\n\\n\\tprivate ListNode mergeList(ListNode first, ListNode second) {\\n\\t\\tListNode dummy = new ListNode(0), merged = dummy;\\n\\t\\twhile (first != null && second != null) {\\n\\t\\t\\tif (first.val <= second.val) {\\n\\t\\t\\t\\tmerged.next = first;\\n\\t\\t\\t\\tmerged = merged.next;\\n\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmerged.next = second;\\n\\t\\t\\t\\tmerged = merged.next;\\n\\t\\t\\t\\tsecond = second.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (first != null || second != null)\\n\\t\\t\\tmerged.next = (first != null)? first :second;\\n\\t\\t\\n\\t\\treturn dummy.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3428071,
                "title": "java-solution-using-best-2-approaches-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        /*\\n        //Approach1: just I got this approach in my mind when I show this question\\n        //T.C: O(nlogn), S.C: O(n)\\n        ArrayList<Integer> list = new ArrayList<>();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        Collections.sort(list);\\n        curr = head;\\n        for(int num : list){\\n            curr.val = num;\\n            curr = curr.next;\\n        }\\n        return head;\\n        */\\n        //Approach2: Using MergeSort\\n        // Base case: If the list is empty or has only one element, it is already sorted\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        // Find the middle of the list using the slow and fast pointer approach\\n        ListNode slow = head, fast = head.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // Split the list into two halves at the middle node\\n        ListNode mid = slow.next;\\n        slow.next = null;\\n        // Recursively sort the two halves of the list\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(mid);\\n        // Merge the two sorted halves of the list\\n        return merge(left, right);\\n    }\\n    // Merge two sorted linked lists into a single sorted linked list\\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        // Compare the values of the nodes in l1 and l2 and add the smaller value to the merged list\\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        // Add the remaining nodes of l1 or l2 to the merged list\\n        if (l1 != null) {\\n            curr.next = l1;\\n        } else {\\n            curr.next = l2;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        /*\\n        //Approach1: just I got this approach in my mind when I show this question\\n        //T.C: O(nlogn), S.C: O(n)\\n        ArrayList<Integer> list = new ArrayList<>();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        Collections.sort(list);\\n        curr = head;\\n        for(int num : list){\\n            curr.val = num;\\n            curr = curr.next;\\n        }\\n        return head;\\n        */\\n        //Approach2: Using MergeSort\\n        // Base case: If the list is empty or has only one element, it is already sorted\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        // Find the middle of the list using the slow and fast pointer approach\\n        ListNode slow = head, fast = head.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // Split the list into two halves at the middle node\\n        ListNode mid = slow.next;\\n        slow.next = null;\\n        // Recursively sort the two halves of the list\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(mid);\\n        // Merge the two sorted halves of the list\\n        return merge(left, right);\\n    }\\n    // Merge two sorted linked lists into a single sorted linked list\\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        // Compare the values of the nodes in l1 and l2 and add the smaller value to the merged list\\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        // Add the remaining nodes of l1 or l2 to the merged list\\n        if (l1 != null) {\\n            curr.next = l1;\\n        } else {\\n            curr.next = l2;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828044,
                "title": "easy-java-solution-o-nlogn-time-complexity-7ms-beats-88-tc-and-69-50-sc",
                "content": "In this we have taken a naive approach, we first find the number of nodes in the linked list and then created an array of that size. Then we put the list values in the array and then used the inbuilt Arrays.sort() function to sort the array and then put the sorted array values back in the Linked List.\\nTime Complexity - O(nlogn)\\nSpace Complexity - O(n)\\nIf this helps, please \"UPVOTE\".\\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode l = head;\\n        int c = 0;\\n        while(l!=null){\\n            c++;\\n            l = l.next;\\n        }\\n        int a[] = new int[c];\\n        l = head;\\n        int i = 0;\\n        while(l!=null){\\n            a[i++] = l.val;\\n            l = l.next;\\n        }\\n        Arrays.sort(a);\\n        l = head;\\n        i = 0;\\n        while(l!=null){\\n            l.val = a[i++];\\n            l = l.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode l = head;\\n        int c = 0;\\n        while(l!=null){\\n            c++;\\n            l = l.next;\\n        }\\n        int a[] = new int[c];\\n        l = head;\\n        int i = 0;\\n        while(l!=null){\\n            a[i++] = l.val;\\n            l = l.next;\\n        }\\n        Arrays.sort(a);\\n        l = head;\\n        i = 0;\\n        while(l!=null){\\n            l.val = a[i++];\\n            l = l.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795567,
                "title": "merge-sort-c-solution-recursive-iterative-solution",
                "content": "\\t**Do \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F upvote if it helps you in anyway**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode * mergelist(ListNode *p1,ListNode *p2){\\n\\t\\t\\tListNode *ans=new ListNode(0);\\n\\t\\t\\tListNode *t=ans;\\n\\t\\t\\twhile(p1 and p2){\\n\\t\\t\\t\\tif(p1->val<p2->val){\\n\\t\\t\\t\\t\\tt->next=p1;\\n\\t\\t\\t\\t\\tp1=p1->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t   t->next=p2;\\n\\t\\t\\t\\t\\tp2=p2->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt=t->next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(p1){\\n\\t\\t\\t\\tt->next=p1;\\n\\t\\t\\t\\t\\tp1=p1->next;\\n\\t\\t\\t\\tt=t->next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(p2){\\n\\t\\t\\t\\t t->next=p2;\\n\\t\\t\\t\\t\\tp2=p2->next;\\n\\t\\t\\t\\tt=t->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans->next;\\n\\t\\t}\\n\\t\\tListNode* sortList(ListNode* head) {\\n\\t\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\tListNode *fast=head->next->next,*slow=head;\\n\\n\\t\\t\\t//splitting list into two part\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tfast=fast->next->next;\\n\\t\\t\\t\\tslow=slow->next;\\n\\t\\t\\t}\\n\\t\\t\\tListNode *r=sortList(slow->next);  //passign second half \\n\\t\\t\\tslow->next=nullptr;\\n\\t\\t\\tListNode *l=sortList(head);  //passing first half after setting slow next as null\\n\\t\\t\\treturn mergelist(l,r);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t==============================\\n\\tRecursive Merge Function\\u2705\\n\\t==============================\\n\\t\\n\\t\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode * mergelist(ListNode *list1,ListNode *list2){\\n\\t\\t\\tif(list1 == NULL)return list2;\\n\\t\\t\\tif(list2 == NULL)return list1;\\n\\t\\t\\tif(list1->val < list2->val){\\n\\t\\t\\t\\tlist1->next=mergelist(list1->next,list2);\\n\\t\\t\\t\\treturn list1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tlist2->next=mergelist(list1,list2->next);\\n\\t\\t\\t\\treturn list2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tListNode* sortList(ListNode* head) {\\n\\t\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\tListNode *fast=head->next->next,*slow=head;\\n\\n\\t\\t\\t//splitting list into two part\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tfast=fast->next->next;\\n\\t\\t\\t\\tslow=slow->next;\\n\\t\\t\\t}\\n\\t\\t\\tListNode *r=sortList(slow->next);\\n\\t\\t\\tslow->next=nullptr;\\n\\t\\t\\tListNode *l=sortList(head);\\n\\t\\t\\treturn mergelist(l,r);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode * mergelist(ListNode *p1,ListNode *p2){\\n\\t\\t\\tListNode *ans=new ListNode(0);\\n\\t\\t\\tListNode *t=ans;\\n\\t\\t\\twhile(p1 and p2){\\n\\t\\t\\t\\tif(p1->val<p2->val){\\n\\t\\t\\t\\t\\tt->next=p1;\\n\\t\\t\\t\\t\\tp1=p1->next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1001947,
                "title": "easy-self-descriptive-recursive-code-java",
                "content": "```\\npublic ListNode sortList(ListNode head) {\\n\\t\\t// If no element or one element list is already sorted so return\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\t\\t// Find middle to divide th list into two parts\\n        ListNode middle = getMiddleNode(head);\\n        ListNode nextOfMiddle = middle.next;\\n\\n        // Separate both lists by breaking the list\\n        middle.next = null;\\n\\n\\t\\t// Recursively sort both parts\\n        ListNode firstPart = sortList(head);\\n        ListNode secondPart = sortList(nextOfMiddle);\\n\\t\\t// Merge both sorted parts\\n        return merge(firstPart, secondPart);\\n    }\\n\\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n\\t\\t\\t// list1 is empty so just return list2\\n            return l2;\\n        }\\n        if (l2 == null) {\\n\\t\\t\\t// list2 is empty so just return list1\\n            return l1;\\n        }\\n        if (l1.val <= l2.val) {\\n\\t\\t\\t// list1 have smaller value so recursively merge the remaining of list1 with list2\\n\\t\\t\\t// then just append this merged list after the smaller element\\n\\t\\t\\t// and return the list1\\n            l1.next = merge(l1.next, l2);\\n            return l1;\\n        } else {\\n\\t\\t\\t// list2 have smaller value so recursively merge the remaining of list2 with list1\\n\\t\\t\\t// then just append this merged list after the smaller element \\n\\t\\t\\t// and return the list2\\n            l2.next = merge(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    private ListNode getMiddleNode(ListNode node) {\\n\\t\\t// Slow and fast ptr approch to find middle element\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        while (fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\npublic ListNode sortList(ListNode head) {\\n\\t\\t// If no element or one element list is already sorted so return\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\t\\t// Find middle to divide th list into two parts\\n        ListNode middle = getMiddleNode(head);\\n        ListNode nextOfMiddle = middle.next;\\n\\n        // Separate both lists by breaking the list\\n        middle.next = null;\\n\\n\\t\\t// Recursively sort both parts\\n        ListNode firstPart = sortList(head);\\n        ListNode secondPart = sortList(nextOfMiddle);\\n\\t\\t// Merge both sorted parts\\n        return merge(firstPart, secondPart);\\n    }\\n\\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n\\t\\t\\t// list1 is empty so just return list2\\n            return l2;\\n        }\\n        if (l2 == null) {\\n\\t\\t\\t// list2 is empty so just return list1\\n            return l1;\\n        }\\n        if (l1.val <= l2.val) {\\n\\t\\t\\t// list1 have smaller value so recursively merge the remaining of list1 with list2\\n\\t\\t\\t// then just append this merged list after the smaller element\\n\\t\\t\\t// and return the list1\\n            l1.next = merge(l1.next, l2);\\n            return l1;\\n        } else {\\n\\t\\t\\t// list2 have smaller value so recursively merge the remaining of list2 with list1\\n\\t\\t\\t// then just append this merged list after the smaller element \\n\\t\\t\\t// and return the list2\\n            l2.next = merge(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    private ListNode getMiddleNode(ListNode node) {\\n\\t\\t// Slow and fast ptr approch to find middle element\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        while (fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661980,
                "title": "python-mergesort-top-down-explained",
                "content": "To achieve O(n log n) run time with MergeSort and Divide and Conquer. To achieve constant space, once must do bottom-up merge sort.\\n4 -> 3 -> 2 -> 1\\n4 -> 3     2 -> 1\\n4    3      2      1\\n3  ->  4      1 -> 2\\n1 -> 2 -> 3 ->4\\n\\nMerge sort has two functions, split and merge.\\n\\n1. Split\\n\\t*  We use the two pointer find mid approach to find the middle of a LinkedList\\n\\t*  We use a ```prev``` variable to keep track of the Node right befor the mid to that we can split the list, i.e. ``` prev.next = None`` `\\n\\t\\n``` \\nslow, fast, pre = head, head, None\\nwhile fast and fast.next:\\n    pre = slow\\n    slow = slow.next\\n    fast = fast.next.next\\npre.next = None\\t\\n```\\nThe left list starts at ```head``` and the right list starts at ```slows```.\\n\\n2.  Merge\\n\\t*  To merge, we use the merge two linkedlists from LC 21 (https://leetcode.com/problems/merge-two-sorted-lists/)\\n\\t*  We set a ```dummy``` node and a ```curr``` node. We then compare each nodes in left and right and set ```curr.next``` as the smaller of the two\\n\\t*  Conditions of while loop are set as ```while left and right```.\\n\\t\\t*  Once one or both of them are empty, ```curr.next``` is set as the remaining one or ```None``` (as from the last traversed list. I.e. if the last node was from ```right```, ```right.next``` was ```None``` thus ```curr.next``` is ```None```\\n\\t*  Once the two sorted lists are merged, we return ```dummy.next```\\n```\\ndef merge(left, right): \\n    dummy = curr = ListNode()\\n    \\n    while left and right:\\n        if left.val < right.val:\\n            curr.next = left\\n            left = left.next\\n        else:\\n            curr.next = right\\n            right = right.next\\n        curr = curr.next\\n    if left:\\n        curr.next = left\\n    elif right:\\n        curr.next = right\\n        \\n    return dummy.next\\n```\\n\\nNow to sort the list, we just put the split and merge together recursively.\\n* Recursive base base is return either ```None``` or the single ```Node```\\n```\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n    ######################################\\n    # Recursive Merge Sort Function\\n    ######################################\\n    def sort(head):\\n        if not head or not head.next:\\n            return head\\n        # split\\n        slow, fast, pre = head, head, None\\n        while fast and fast.next:\\n            pre = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        pre.next = None\\n        \\n        mid = slow\\n        left = sort(head)\\n        right = sort(mid)\\n        return merge(left, right)\\n        \\n    ######################################\\n    # Merge Function\\n    ######################################\\n    def merge(left, right): \\n        dummy = curr = ListNode()\\n        \\n        while left and right:\\n            if left.val < right.val:\\n                curr.next = left\\n                left = left.next\\n            else:\\n                curr.next = right\\n                right = right.next\\n            curr = curr.next\\n        if left:\\n            curr.next = left\\n        elif right:\\n            curr.next = right\\n        return dummy.next\\n    \\n    return sort(head)\\n```\\n\\nTime Complexity is O( n log n). \\n* Divide takes O (n log n)\\n\\t* Each divide step takes O(n) since you have to find the middle. There are O( log n) divides\\n* Merge Takes O( n )\\n\\t* There are O( log n) merges\\n* Total runtime = n log n + n log n = O ( n log n)\\n\\nSpace Complexity O( log n)\\n* log n stack to hold top-down recursion\\n",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```prev```\n``` prev.next = None`` `\\n\\t\\n```\n```\\nThe left list starts at ```\n``` and the right list starts at ```\n```.\\n\\n2.  Merge\\n\\t*  To merge, we use the merge two linkedlists from LC 21 (https://leetcode.com/problems/merge-two-sorted-lists/)\\n\\t*  We set a ```\n``` node and a ```\n``` node. We then compare each nodes in left and right and set ```\n``` as the smaller of the two\\n\\t*  Conditions of while loop are set as ```\n```.\\n\\t\\t*  Once one or both of them are empty, ```\n``` is set as the remaining one or ```\n``` (as from the last traversed list. I.e. if the last node was from ```\n```, ```\n``` was ```\n``` thus ```\n``` is ```\n```\\n\\t*  Once the two sorted lists are merged, we return ```\n```\\n```\n```\\n\\nNow to sort the list, we just put the split and merge together recursively.\\n* Recursive base base is return either ```\n``` or the single ```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260817,
                "title": "javascript-solution-merge-sort",
                "content": "```javascript\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    let fast = head.next; // \\u9700\\u8981\\u5148\\u8D70\\u4E00\\u6B65\\uFF0C\\u539F\\u56E0\\u662F\\uFF0C\\u5BF9\\u4E8E\\u5076\\u6570\\u957F\\u5EA6\\uFF0Cmid \\u53EF\\u4EE5\\u5728\\u4E00\\u534A\\u7684\\u5730\\u65B9\\u5206\\u5272\\n    let slow = head;\\n    while (fast !== null && fast.next !== null) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    const mid = slow.next;\\n    slow.next = null;\\n    let left = sortList(head);\\n    let right = sortList(mid);\\n    const dummy = new ListNode(0);\\n    let h = dummy;\\n    while (left !== null && right !== null) {\\n        if (left.val < right.val) {\\n            h.next = left;\\n            left = left.next;\\n        } else {\\n            h.next = right;\\n            right = right.next;\\n        }\\n        h = h.next;\\n    }\\n    if (left) {\\n        h.next = left;\\n    }\\n    if (right) {\\n        h.next = right;\\n    }\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    let fast = head.next; // \\u9700\\u8981\\u5148\\u8D70\\u4E00\\u6B65\\uFF0C\\u539F\\u56E0\\u662F\\uFF0C\\u5BF9\\u4E8E\\u5076\\u6570\\u957F\\u5EA6\\uFF0Cmid \\u53EF\\u4EE5\\u5728\\u4E00\\u534A\\u7684\\u5730\\u65B9\\u5206\\u5272\\n    let slow = head;\\n    while (fast !== null && fast.next !== null) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    const mid = slow.next;\\n    slow.next = null;\\n    let left = sortList(head);\\n    let right = sortList(mid);\\n    const dummy = new ListNode(0);\\n    let h = dummy;\\n    while (left !== null && right !== null) {\\n        if (left.val < right.val) {\\n            h.next = left;\\n            left = left.next;\\n        } else {\\n            h.next = right;\\n            right = right.next;\\n        }\\n        h = h.next;\\n    }\\n    if (left) {\\n        h.next = left;\\n    }\\n    if (right) {\\n        h.next = right;\\n    }\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249966,
                "title": "c-recursive-merge-sort",
                "content": "Use `slow` and `fast` pointers to cut the list into two halves. Recursively sort each half and merge them.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head -> next) {\\n            return head;\\n        }\\n        ListNode *slow = head, *fast = head -> next;\\n        while (fast && fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        ListNode *r = slow -> next;\\n        slow -> next = NULL;\\n        return merge(sortList(head), sortList(r));\\n    }\\nprivate:\\n    ListNode* merge(ListNode* l, ListNode* r) {\\n        if (!l || !r) {\\n            return l ? l : r;\\n        }\\n        if (l -> val < r -> val) {\\n            l -> next = merge(l -> next, r);\\n            return l;\\n        }\\n        r -> next = merge(l, r -> next);\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (!head || !head -> next) {\\n            return head;\\n        }\\n        ListNode *slow = head, *fast = head -> next;\\n        while (fast && fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        ListNode *r = slow -> next;\\n        slow -> next = NULL;\\n        return merge(sortList(head), sortList(r));\\n    }\\nprivate:\\n    ListNode* merge(ListNode* l, ListNode* r) {\\n        if (!l || !r) {\\n            return l ? l : r;\\n        }\\n        if (l -> val < r -> val) {\\n            l -> next = merge(l -> next, r);\\n            return l;\\n        }\\n        r -> next = merge(l, r -> next);\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46754,
                "title": "golang-concise-solution-using-merge-sort",
                "content": "Using recursive function, so it's not `O(1)` space complexity though...\\nThe idea is simple, just recursively divide the list to the former half and the latter half (using two pointers and delete the connection between the former and the latter).\\n\\nAfter it's divided into single element, then apply \"merge two sorted lists\" method for each pair, back to the sorted one list.\\n\\n```\\nfunc sortList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tslow, fast := head, head\\n\\tfor fast.Next != nil && fast.Next.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next.Next\\n\\t}\\n\\n\\tfirstTail := slow\\n\\tslow = slow.Next\\n\\tfirstTail.Next = nil // divide the first list and the second\\n\\n\\tfirst, second := sortList(head), sortList(slow)\\n\\treturn merge(first, second)\\n}\\n\\nfunc merge(head1 *ListNode, head2 *ListNode) *ListNode {\\n\\tcurHead := &ListNode{}\\n\\ttmpHead := curHead\\n\\n\\tfor head1 != nil && head2 != nil {\\n\\t\\tif head1.Val < head2.Val {\\n\\t\\t\\tcurHead.Next = head1\\n\\t\\t\\thead1 = head1.Next\\n\\t\\t\\tcurHead = curHead.Next\\n\\t\\t} else {\\n\\t\\t\\tcurHead.Next = head2\\n\\t\\t\\thead2 = head2.Next\\n\\t\\t\\tcurHead = curHead.Next\\n\\t\\t}\\n\\t}\\n\\n\\tif head1 != nil {\\n\\t\\tcurHead.Next = head1\\n\\t} else if head2 != nil {\\n\\t\\tcurHead.Next = head2\\n\\t}\\n\\treturn tmpHead.Next\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sortList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tslow, fast := head, head\\n\\tfor fast.Next != nil && fast.Next.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next.Next\\n\\t}\\n\\n\\tfirstTail := slow\\n\\tslow = slow.Next\\n\\tfirstTail.Next = nil // divide the first list and the second\\n\\n\\tfirst, second := sortList(head), sortList(slow)\\n\\treturn merge(first, second)\\n}\\n\\nfunc merge(head1 *ListNode, head2 *ListNode) *ListNode {\\n\\tcurHead := &ListNode{}\\n\\ttmpHead := curHead\\n\\n\\tfor head1 != nil && head2 != nil {\\n\\t\\tif head1.Val < head2.Val {\\n\\t\\t\\tcurHead.Next = head1\\n\\t\\t\\thead1 = head1.Next\\n\\t\\t\\tcurHead = curHead.Next\\n\\t\\t} else {\\n\\t\\t\\tcurHead.Next = head2\\n\\t\\t\\thead2 = head2.Next\\n\\t\\t\\tcurHead = curHead.Next\\n\\t\\t}\\n\\t}\\n\\n\\tif head1 != nil {\\n\\t\\tcurHead.Next = head1\\n\\t} else if head2 != nil {\\n\\t\\tcurHead.Next = head2\\n\\t}\\n\\treturn tmpHead.Next\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46775,
                "title": "c-solution-19ms-using-merge-sort",
                "content": "We use Merge Sort to tackle this problem:\\n- Split the list into half. Use fast/slow pointer to get to the middle of the list.\\n- Recursively sort the two independent lists.\\n- Use [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) to merge the two sorted lists (left and right) together.\\n- Return the new merged list as the sorted list.\\n```c\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2);\\n\\nstruct ListNode* sortList(struct ListNode* head) {\\n    if (!head || !head->next) return head;\\n    struct ListNode *slow = head, *fast = head, *prev, *left, *right;\\n    while (fast && fast->next) {\\n        prev = slow;\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    prev->next = NULL;\\n    left = sortList(head);\\n    right = sortList(slow);\\n    return mergeTwoLists(left, right);\\n}\\n\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    struct ListNode dummyHead = {0}, *prev = &dummyHead;\\n    while (l1 && l2) {\\n        if (l1->val < l2->val) {\\n            prev->next = l1;\\n            l1 = l1->next;\\n        } else {\\n            prev->next = l2;\\n            l2 = l2->next;\\n        }\\n        prev = prev->next;\\n    }\\n    if (l1) prev->next = l1; else prev->next = l2;\\n    return dummyHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2);\\n\\nstruct ListNode* sortList(struct ListNode* head) {\\n    if (!head || !head->next) return head;\\n    struct ListNode *slow = head, *fast = head, *prev, *left, *right;\\n    while (fast && fast->next) {\\n        prev = slow;\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    prev->next = NULL;\\n    left = sortList(head);\\n    right = sortList(slow);\\n    return mergeTwoLists(left, right);\\n}\\n\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    struct ListNode dummyHead = {0}, *prev = &dummyHead;\\n    while (l1 && l2) {\\n        if (l1->val < l2->val) {\\n            prev->next = l1;\\n            l1 = l1->next;\\n        } else {\\n            prev->next = l2;\\n            l2 = l2->next;\\n        }\\n        prev = prev->next;\\n    }\\n    if (l1) prev->next = l1; else prev->next = l2;\\n    return dummyHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46833,
                "title": "quick-sort-4-ms-beats-96-51",
                "content": "    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy1 = new ListNode(0);\\n        ListNode dummy2 = new ListNode(0);\\n        ListNode prev1 = dummy1;\\n        ListNode prev2 = dummy2;\\n        ListNode node = head.next;\\n        ListNode prev = head;\\n        while (node != null) {\\n            if (node.val < head.val) {\\n                prev1.next = node;\\n                prev1 = prev1.next;\\n            } else if (node.val > head.val) {\\n                prev2.next = node;\\n                prev2 = prev2.next;\\n            } else {\\n                prev.next = node;\\n                prev = prev.next;\\n            }\\n            node = node.next;\\n        }\\n        \\n        prev1.next = prev2.next = prev.next = null;\\n        dummy1.next = sortList(dummy1.next);\\n        dummy2.next = sortList(dummy2.next);\\n        prev1 = dummy1;\\n        while (prev1.next != null) {\\n            prev1 = prev1.next;\\n        }\\n        \\n        prev1.next = head;\\n        prev.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy1 = new ListNode(0);\\n        ListNode dummy2 = new ListNode(0);\\n        ListNode prev1 = dummy1;\\n        ListNode prev2 = dummy2;\\n        ListNode node = head.next;\\n        ListNode prev = head;\\n        while (node != null) {\\n            if (node.val < head.val) {\\n                prev1.next = node;\\n                prev1 = prev1.next;\\n            } else if (node.val > head.val) {\\n                prev2.next = node;\\n                prev2 = prev2.next;\\n            } else {\\n                prev.next = node;\\n                prev = prev.next;\\n            }\\n            node = node.next;\\n        }\\n        \\n        prev1.next = prev2.next = prev.next = null;\\n        dummy1.next = sortList(dummy1.next);\\n        dummy2.next = sortList(dummy2.next);\\n        prev1 = dummy1;\\n        while (prev1.next != null) {\\n            prev1 = prev1.next;\\n        }\\n        \\n        prev1.next = head;\\n        prev.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46799,
                "title": "two-different-solutions-well-commented-in-c-accepted-as-best",
                "content": "    //AC - 20ms;\\n    struct ListNode* merge(struct ListNode* l, struct ListNode* r)\\n    {\\n        struct ListNode head;\\n        struct ListNode* p = &head;\\n        while(l && r)\\n        {\\n            if(l->val <= r->val) //collect left first when left and right are equal;\\n            {\\n                p->next = l;\\n                l = l->next;\\n            }\\n            else\\n            {\\n                p->next = r;\\n                r = r->next;\\n            }\\n            p = p->next;\\n        }\\n        p->next = (l == NULL ? r : l);\\n        return head.next; //return without the fake head;\\n    }\\n    struct ListNode* sortList(struct ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        struct ListNode *s1 = head, *s2 = head->next;\\n        while(s2 && s2->next) //split the list into two halves;\\n        {\\n            s1 = s1->next;\\n            s2 = s2->next->next;\\n        }\\n        s2 = s1->next;\\n        s1->next = NULL;\\n        return merge(sortList(head), sortList(s2)); //merge two parts by invoking recursive method;\\n    }\\n    \\n----------\\n    \\n    \\n    struct ListNode* partition(struct ListNode* head, struct ListNode* tail)\\n    {\\n        if(head == tail || head->next == tail)\\n            return head;\\n        int pivot = head->val;\\n        struct ListNode left, mid, right; //the head of each position;\\n        struct ListNode *l=&left, *m=&mid, *r=&right; //used to move forward;\\n        while(head != tail)\\n        {\\n            if(head->val < pivot)\\n            {\\n                l->next = head;\\n                l = l->next;\\n            }\\n            else if(head->val > pivot)\\n            {\\n                r->next = head;\\n                r = r->next;\\n            }\\n            else\\n            {\\n                m->next = head;\\n                m = m->next;\\n            }\\n            head = head->next;\\n        }\\n        r->next = tail; //connect the right end to the next part;\\n        m->next = partition(right.next, tail);  //connect the middle part to the right;\\n        l->next = mid.next; //connect the left to the middle;\\n        return partition(left.next, l->next); //handle the left part and return the head of the left;\\n    }\\n    \\n    \\n    //AC - 16ms;\\n    struct ListNode* swiftSort(struct ListNode* head)\\n    {\\n        return partition(head, NULL);\\n    }",
                "solutionTags": [],
                "code": "    //AC - 20ms;\\n    struct ListNode* merge(struct ListNode* l, struct ListNode* r)\\n    {\\n        struct ListNode head;\\n        struct ListNode* p = &head;\\n        while(l && r)\\n        {\\n            if(l->val <= r->val) //collect left first when left and right are equal;\\n            {\\n                p->next = l;\\n                l = l->next;\\n            }\\n            else\\n            {\\n                p->next = r;\\n                r = r->next;\\n            }\\n            p = p->next;\\n        }\\n        p->next = (l == NULL ? r : l);\\n        return head.next; //return without the fake head;\\n    }\\n    struct ListNode* sortList(struct ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        struct ListNode *s1 = head, *s2 = head->next;\\n        while(s2 && s2->next) //split the list into two halves;\\n        {\\n            s1 = s1->next;\\n            s2 = s2->next->next;\\n        }\\n        s2 = s1->next;\\n        s1->next = NULL;\\n        return merge(sortList(head), sortList(s2)); //merge two parts by invoking recursive method;\\n    }\\n    \\n----------\\n    \\n    \\n    struct ListNode* partition(struct ListNode* head, struct ListNode* tail)\\n    {\\n        if(head == tail || head->next == tail)\\n            return head;\\n        int pivot = head->val;\\n        struct ListNode left, mid, right; //the head of each position;\\n        struct ListNode *l=&left, *m=&mid, *r=&right; //used to move forward;\\n        while(head != tail)\\n        {\\n            if(head->val < pivot)\\n            {\\n                l->next = head;\\n                l = l->next;\\n            }\\n            else if(head->val > pivot)\\n            {\\n                r->next = head;\\n                r = r->next;\\n            }\\n            else\\n            {\\n                m->next = head;\\n                m = m->next;\\n            }\\n            head = head->next;\\n        }\\n        r->next = tail; //connect the right end to the next part;\\n        m->next = partition(right.next, tail);  //connect the middle part to the right;\\n        l->next = mid.next; //connect the left to the middle;\\n        return partition(left.next, l->next); //handle the left part and return the head of the left;\\n    }\\n    \\n    \\n    //AC - 16ms;\\n    struct ListNode* swiftSort(struct ListNode* head)\\n    {\\n        return partition(head, NULL);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3306343,
                "title": "python-recursize-merge-sort",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        size = 0;\\n        t = head;\\n        while(t):\\n            size+=1\\n            t=t.next\\n        if( size < 2 ): return head;\\n\\n        def merge(node,size):\\n            if( size == 1 ): return ListNode(node.val);\\n            \\n            ls = size//2\\n            rs = size - ls \\n            ll = merge(node,ls);\\n            for i in range(0,ls): node = node.next ;\\n            rl = merge(node,rs)\\n\\n            #now merge ll(left list) and right list(rl) \\n\\n            nroot =  ListNode(-1);\\n            node = nroot;\\n            while( ll or rl ):\\n                if( ll and rl ):\\n                    if( ll.val < rl.val ):\\n                        node.next = ll\\n                        ll = ll.next;\\n                        node = node.next\\n                    else:\\n                        node.next = rl\\n                        rl = rl.next;\\n                        node=node.next\\n                elif(ll):\\n                    node.next = ll \\n                    ll = ll.next;\\n                    node =node.next\\n                else:\\n                    node.next = rl\\n                    rl = rl.next\\n                    node = node.next\\n            return nroot.next;\\n\\n        \\n        return merge(head,size)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        size = 0;\\n        t = head;\\n        while(t):\\n            size+=1\\n            t=t.next\\n        if( size < 2 ): return head;\\n\\n        def merge(node,size):\\n            if( size == 1 ): return ListNode(node.val);\\n            \\n            ls = size//2\\n            rs = size - ls \\n            ll = merge(node,ls);\\n            for i in range(0,ls): node = node.next ;\\n            rl = merge(node,rs)\\n\\n            #now merge ll(left list) and right list(rl) \\n\\n            nroot =  ListNode(-1);\\n            node = nroot;\\n            while( ll or rl ):\\n                if( ll and rl ):\\n                    if( ll.val < rl.val ):\\n                        node.next = ll\\n                        ll = ll.next;\\n                        node = node.next\\n                    else:\\n                        node.next = rl\\n                        rl = rl.next;\\n                        node=node.next\\n                elif(ll):\\n                    node.next = ll \\n                    ll = ll.next;\\n                    node =node.next\\n                else:\\n                    node.next = rl\\n                    rl = rl.next\\n                    node = node.next\\n            return nroot.next;\\n\\n        \\n        return merge(head,size)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163734,
                "title": "easy-cpp-code-with-80-better-time-results",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI am using a vector to store all the values of the linked list, and then use the sort function. Then overwriting the values of the vector into the same given linked list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> a;\\n        ListNode* ptr=head;\\n        while(ptr!=NULL)\\n        {\\n            a.push_back(ptr->val);\\n            ptr=ptr->next;\\n        }\\n        sort(a.begin(),a.end());\\n        std::vector<int>::iterator itr=a.begin();\\n        ptr=head;\\n        while(itr!=a.end())\\n        {\\n            ptr->val=*itr;\\n            ptr=ptr->next;\\n            itr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> a;\\n        ListNode* ptr=head;\\n        while(ptr!=NULL)\\n        {\\n            a.push_back(ptr->val);\\n            ptr=ptr->next;\\n        }\\n        sort(a.begin(),a.end());\\n        std::vector<int>::iterator itr=a.begin();\\n        ptr=head;\\n        while(itr!=a.end())\\n        {\\n            ptr->val=*itr;\\n            ptr=ptr->next;\\n            itr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052136,
                "title": "python-iterate-all-sort-and-reconstruct-the-list",
                "content": "https://leetcode.com/submissions/detail/878266192/  \\nRuntime: **335 ms**, faster than 93.72% of Python3 online submissions for Sort List.  \\nMemory Usage: 40.2 MB, less than 23.34% of Python3 online submissions for Sort List.  \\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head: return\\n        \\n        ## iterate the list\\n        node, l = head, [[head.val, head]]\\n        while node.next:\\n            node = node.next\\n            l.append([node.val, node])\\n            \\n        l.sort(key=lambda x:x[0])\\n\\t\\t\\n\\t\\t## reconstruct the list\\n        node = head = l[0][1]\\n        for k,v in l[1:]:\\n            node.next = v\\n            node = node.next\\n        node.next = None\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head: return\\n        \\n        ## iterate the list\\n        node, l = head, [[head.val, head]]\\n        while node.next:\\n            node = node.next\\n            l.append([node.val, node])\\n            \\n        l.sort(key=lambda x:x[0])\\n\\t\\t\\n\\t\\t## reconstruct the list\\n        node = head = l[0][1]\\n        for k,v in l[1:]:\\n            node.next = v\\n            node = node.next\\n        node.next = None\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756116,
                "title": "easiest-approach-only-3-steps-beginner-friendly-easiest-c-solution",
                "content": "**3 simple Steps**\\n1. Store all node values in a vector\\n2. Sort the vector\\n3. Make a new linkedlist out of that vector\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL)return head;\\n\\t\\t// store all node values in a vector\\n        vector<int> v;\\n        ListNode *p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n\\t\\t// sort the vector\\n        sort(v.begin(), v.end());\\n\\t\\t// make a new linkedlist from the vector\\n        reverse(v.begin(), v.end());\\n        ListNode *a = new ListNode(v.back());\\n        ListNode *b = a;\\n        v.pop_back();\\n        while(!v.empty()){\\n            b->next = new ListNode(v.back());\\n            v.pop_back();\\n            b = b->next;\\n        }\\n        return a;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL)return head;\\n\\t\\t// store all node values in a vector\\n        vector<int> v;\\n        ListNode *p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1999207,
                "title": "python-merge-sort-clean-concise",
                "content": "```python\\nclass Solution:\\n    # 1 2 3 4\\n    # 1 2 3\\n    def findMid(self, head):  # return mid and its prev\\n        slow = fast = head\\n        prev = None\\n        while fast != None and fast.next != None:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        return prev, slow\\n    \\n    def merge(self, head1, head2):\\n        head = dummyHead = ListNode(0)\\n        while head1 != None and head2 != None:\\n            if head1.val <= head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        if head1 != None:\\n            head.next = head1\\n        elif head2 != None:\\n            head.next = head2\\n            \\n        return dummyHead.next\\n    \\n    def sortList(self, head: ListNode) -> ListNode:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        prev, mid = self.findMid(head)\\n        if prev != None:\\n            prev.next = None\\n        \\n        list1 = self.sortList(head)\\n        list2 = self.sortList(mid)\\n        return self.merge(list1, list2)\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Space: `O(logN)`, memory for stack depth",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    # 1 2 3 4\\n    # 1 2 3\\n    def findMid(self, head):  # return mid and its prev\\n        slow = fast = head\\n        prev = None\\n        while fast != None and fast.next != None:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        return prev, slow\\n    \\n    def merge(self, head1, head2):\\n        head = dummyHead = ListNode(0)\\n        while head1 != None and head2 != None:\\n            if head1.val <= head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        if head1 != None:\\n            head.next = head1\\n        elif head2 != None:\\n            head.next = head2\\n            \\n        return dummyHead.next\\n    \\n    def sortList(self, head: ListNode) -> ListNode:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        prev, mid = self.findMid(head)\\n        if prev != None:\\n            prev.next = None\\n        \\n        list1 = self.sortList(head)\\n        list2 = self.sortList(mid)\\n        return self.merge(list1, list2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800542,
                "title": "merge-sort-bottom-up-implementation-with-comment-in-each-line",
                "content": "I was taught the merge sort top-down implementations, but not the bottom-up one. I found it was really more **intuitive, strightforward** than the top-down implementation...\\n\\n---\\n**About Merge Sort**\\nMerge Sort is `devide and conquer` algorithm, it has 2 implementations:\\n1. Top-Down Implementation\\n2. Bottom-Up Implementation\\n\\nBased on Wiki, \\n> Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945.[2] A detailed description and analysis of bottom-up merge sort appeared in a report by Goldstine and von Neumann as early as 1948.[3]\\n\\nSo bottom-up one is newer compared with top-down one seems like, and it has history. Interesting to learn...\\n\\n**TP vs BU**\\nBTW, of course you can implement Top-Down here, but seems like few ppl do that.\\nBottom-Up has few advantanges compared with Top-Down:\\n- Intuitive, easier to understand\\n- Iterative, no need to take recursion stack space\\n\\n---\\n**Example Flow in diagram**\\n![image](https://github.com/ZhengguanLi/Leetcode-Notes/blob/main/148.%20Sort%20List%20-%20Screenshot%202022-02-26%20021549.png?raw=true)\\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        // count the linkedlist size, since merge sort needs to split the list into\\n        // every 1 element, every 2 elements, every 4, every 8...\\n        int n = 0;\\n        // head can be safely overwritten, as we can already get head from dummy.next\\n        while(head != null) {\\n            head = head.next;\\n            n++;\\n        }\\n        \\n        // for the list, split to multiple sublists, i is size of the sublist starting from 1\\n        // and multiply by 2 everytime, \\n        for(int i = 1; i <= n; i <<= 1) { \\n            // merge sort, in each level, we merge from beginning\\n            ListNode pre = dummy;\\n            ListNode cur = dummy.next;\\n            \\n            // scan through the list once to split and merge sublist\\n            while(cur != null) {\\n                ListNode left = cur;\\n                ListNode leftEnd = split(left, i);\\n                // 1. if there is only left part, then there is no need to do the rest run\\n                // 2. avoid leftEnd.next NullPointerException\\n                if(leftEnd.next == null) break; \\n                \\n                ListNode right = leftEnd.next;\\n                ListNode rightEnd = split(right, i);\\n                \\n                // back up for the next run\\n                cur = rightEnd.next;\\n                \\n                // cut down the connection for left and right\\n                leftEnd.next = null;\\n                rightEnd.next = null;\\n                \\n                pre = merge(pre, left, leftEnd, right, rightEnd);\\n                // connect with cur in case we do not have right sublist in the next loop, i.e.\\n                // \"if(leftEnd.next == null) break;\" above\\n                pre.next = cur; \\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    // return the last node in the sublist. Note: I am not cutting down the tail of sublist now\\n    public ListNode split(ListNode node, int size) {\\n        size--;\\n        while(size-- > 0 && node != null) {\\n            if(node.next == null) return node;\\n            node = node.next;\\n        }\\n        \\n        return node;\\n    }\\n    \\n    // return the last node after merging, instead of head like we normally do\\n    public ListNode merge(ListNode pre, ListNode left, ListNode leftEnd, ListNode right, ListNode rightEnd) {\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                pre.next = left;\\n                left = left.next;\\n            } else {\\n                pre.next = right;\\n                right = right.next;\\n            }\\n            pre = pre.next;\\n        }\\n        \\n        if(left != null) {\\n            pre.next = left;\\n            return leftEnd; // last node is leftEnd\\n        } else{\\n            pre.next = right;\\n            return rightEnd; // last node is rightEnd\\n        }\\n    } \\n}\\n```\\n\\n---\\nTime Complexity: `O(nLogn)`, Space Complexity: `O(1)` where `n` is the number of elements in the list.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        // count the linkedlist size, since merge sort needs to split the list into\\n        // every 1 element, every 2 elements, every 4, every 8...\\n        int n = 0;\\n        // head can be safely overwritten, as we can already get head from dummy.next\\n        while(head != null) {\\n            head = head.next;\\n            n++;\\n        }\\n        \\n        // for the list, split to multiple sublists, i is size of the sublist starting from 1\\n        // and multiply by 2 everytime, \\n        for(int i = 1; i <= n; i <<= 1) { \\n            // merge sort, in each level, we merge from beginning\\n            ListNode pre = dummy;\\n            ListNode cur = dummy.next;\\n            \\n            // scan through the list once to split and merge sublist\\n            while(cur != null) {\\n                ListNode left = cur;\\n                ListNode leftEnd = split(left, i);\\n                // 1. if there is only left part, then there is no need to do the rest run\\n                // 2. avoid leftEnd.next NullPointerException\\n                if(leftEnd.next == null) break; \\n                \\n                ListNode right = leftEnd.next;\\n                ListNode rightEnd = split(right, i);\\n                \\n                // back up for the next run\\n                cur = rightEnd.next;\\n                \\n                // cut down the connection for left and right\\n                leftEnd.next = null;\\n                rightEnd.next = null;\\n                \\n                pre = merge(pre, left, leftEnd, right, rightEnd);\\n                // connect with cur in case we do not have right sublist in the next loop, i.e.\\n                // \"if(leftEnd.next == null) break;\" above\\n                pre.next = cur; \\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    // return the last node in the sublist. Note: I am not cutting down the tail of sublist now\\n    public ListNode split(ListNode node, int size) {\\n        size--;\\n        while(size-- > 0 && node != null) {\\n            if(node.next == null) return node;\\n            node = node.next;\\n        }\\n        \\n        return node;\\n    }\\n    \\n    // return the last node after merging, instead of head like we normally do\\n    public ListNode merge(ListNode pre, ListNode left, ListNode leftEnd, ListNode right, ListNode rightEnd) {\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                pre.next = left;\\n                left = left.next;\\n            } else {\\n                pre.next = right;\\n                right = right.next;\\n            }\\n            pre = pre.next;\\n        }\\n        \\n        if(left != null) {\\n            pre.next = left;\\n            return leftEnd; // last node is leftEnd\\n        } else{\\n            pre.next = right;\\n            return rightEnd; // last node is rightEnd\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796191,
                "title": "java-recursive-merge-sort-iterative-merge-sort",
                "content": "**Recursive Merge Sort: O(nlogn) Time & O(logn) Space**\\n```\\nclass Solution {\\n    private ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode();\\n        ListNode temp = dummy;\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                temp.next = left;\\n                left = left.next;\\n            }\\n            else {\\n                temp.next = right;\\n                right = right.next;\\n            }\\n            temp = temp.next;\\n        }\\n        if(left != null) temp.next = left;\\n        if(right != null) temp.next = right;\\n        return dummy.next;\\n    }\\n    private ListNode getMiddleNode(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        ListNode prev = null;\\n        while(fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return prev;\\n    }\\n    private ListNode mergeSort(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode left = head;\\n        ListNode mid = getMiddleNode(head);\\n        ListNode right = mid.next;\\n        mid.next = null;\\n        left = mergeSort(left);\\n        right = mergeSort(right);\\n        return merge(left, right);\\n    }\\n    public ListNode sortList(ListNode head) {\\n        return mergeSort(head);\\n    }\\n}\\n```\\n**Iterative Merge Sort: O(nlogn) Time & O(1) Space**\\n```\\nclass Solution {\\n    private ListNode merge(ListNode left, ListNode right, ListNode res) {\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                res.next = left;\\n                left = left.next;\\n            }\\n            else {\\n                res.next = right;\\n                right = right.next;\\n            }\\n            res = res.next;\\n        }\\n        if(left != null) res.next = left;\\n        if(right != null) res.next = right;\\n        while(res.next != null) res = res.next;\\n        return res;\\n    }\\n    private ListNode split(ListNode head, int cnt) {\\n        if(head == null) return head;\\n        for(int i = 1; i < cnt && head.next != null; i++) head = head.next;\\n        ListNode right = head.next;\\n        head.next = null;\\n        return right;\\n    }\\n    public ListNode sortList(ListNode head) {\\n        ListNode temp = head;\\n        int cnt = 0;\\n        while(temp != null) {\\n            ++cnt;\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        for(int i = 1; i < cnt; i *= 2) {\\n            ListNode res = dummy;\\n            ListNode curr = dummy.next;\\n            while(curr != null) {\\n                ListNode left = curr;\\n                ListNode right = split(left, i);\\n                curr = split(right, i);\\n                res = merge(left, right, res);\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode();\\n        ListNode temp = dummy;\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                temp.next = left;\\n                left = left.next;\\n            }\\n            else {\\n                temp.next = right;\\n                right = right.next;\\n            }\\n            temp = temp.next;\\n        }\\n        if(left != null) temp.next = left;\\n        if(right != null) temp.next = right;\\n        return dummy.next;\\n    }\\n    private ListNode getMiddleNode(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        ListNode prev = null;\\n        while(fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return prev;\\n    }\\n    private ListNode mergeSort(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode left = head;\\n        ListNode mid = getMiddleNode(head);\\n        ListNode right = mid.next;\\n        mid.next = null;\\n        left = mergeSort(left);\\n        right = mergeSort(right);\\n        return merge(left, right);\\n    }\\n    public ListNode sortList(ListNode head) {\\n        return mergeSort(head);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private ListNode merge(ListNode left, ListNode right, ListNode res) {\\n        while(left != null && right != null) {\\n            if(left.val < right.val) {\\n                res.next = left;\\n                left = left.next;\\n            }\\n            else {\\n                res.next = right;\\n                right = right.next;\\n            }\\n            res = res.next;\\n        }\\n        if(left != null) res.next = left;\\n        if(right != null) res.next = right;\\n        while(res.next != null) res = res.next;\\n        return res;\\n    }\\n    private ListNode split(ListNode head, int cnt) {\\n        if(head == null) return head;\\n        for(int i = 1; i < cnt && head.next != null; i++) head = head.next;\\n        ListNode right = head.next;\\n        head.next = null;\\n        return right;\\n    }\\n    public ListNode sortList(ListNode head) {\\n        ListNode temp = head;\\n        int cnt = 0;\\n        while(temp != null) {\\n            ++cnt;\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        for(int i = 1; i < cnt; i *= 2) {\\n            ListNode res = dummy;\\n            ListNode curr = dummy.next;\\n            while(curr != null) {\\n                ListNode left = curr;\\n                ListNode right = split(left, i);\\n                curr = split(right, i);\\n                res = merge(left, right, res);\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795136,
                "title": "python3-clean-simple-fast-slow-mergesort",
                "content": "**Split Function:** Splits the linked list into 2 halves. (Fast & Slow Pointer)\\n**Merge Function:** Merges 2 sorted linked lists into 1 sorted linked list\\n**sortList Function:** Uses divide and conquer technique to sort the linked list (Mergesort)\\n\\n**Time Complexity:** O(NlgN)\\n**Space Complexity:** O(lgN)\\n```\\nclass Solution:\\n    def split(self, head):\\n        prev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        if prev: prev.next = None\\n        return slow\\n    \\n    def merge(self, l1, l2):\\n        dummy = tail = ListNode()\\n        while l1 or l2:\\n            v1 = l1.val if l1 else inf\\n            v2 = l2.val if l2 else inf\\n            if v1 <= v2:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n            tail = tail.next\\n        return dummy.next\\n            \\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        head2 = self.split(head)\\n        \\n        head1 = self.sortList(head)\\n        head2 = self.sortList(head2)\\n        \\n        return self.merge(head1, head2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def split(self, head):\\n        prev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        if prev: prev.next = None\\n        return slow\\n    \\n    def merge(self, l1, l2):\\n        dummy = tail = ListNode()\\n        while l1 or l2:\\n            v1 = l1.val if l1 else inf\\n            v2 = l2.val if l2 else inf\\n            if v1 <= v2:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n            tail = tail.next\\n        return dummy.next\\n            \\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        head2 = self.split(head)\\n        \\n        head1 = self.sortList(head)\\n        head2 = self.sortList(head2)\\n        \\n        return self.merge(head1, head2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277294,
                "title": "explained-python-merge-sort-simple-easy",
                "content": "#  Merge Sort\\n*Here I am performing **Merge Sort**, So basically we need to perform **3 steps** for Merge Sort :-*\\n\\n**1. Divide the Linked list ( By getting the middle element - see function getMiddle) \\n2. Sort the sub-lists \\n3. Merge sorted sub-lists (see function - mergeSortedList)**\\n\\n\\n```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        # base case\\n        if head is None or head.next is None:\\n            return head\\n        \\n        # get the middle of linked list\\n        middle = self.getMiddle(head)\\n        nextToMiddle = middle.next\\n        \\n        # so that one linked list is divided into 2 parts\\n        middle.next = None\\n        \\n        # apply merge sort on left & right sub-list\\n        left = self.sortList(head)\\n        right = self.sortList(nextToMiddle)\\n        \\n        # merge the sorted left and right sub-lists\\n        sortedList=self.mergeSortedList(left, right)\\n        \\n        return sortedList\\n            \\n        \\n    def mergeSortedList(self, first, second):\\n        \\n        # Base cases\\n        if not first:\\n            return second\\n        \\n        if not second:\\n            return first\\n        \\n        res = None\\n        \\n        if first.val <= second.val:\\n            res = first\\n            res.next = self.mergeSortedList(first.next, second)\\n            \\n        else:\\n            res=second\\n            res.next = self.mergeSortedList(first, second.next)\\n            \\n        return res\\n    \\n            \\n    # function to get the middle of linked list   \\n    def getMiddle(self, head):\\n        \\n        slow = fast = head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        return slow\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        # base case\\n        if head is None or head.next is None:\\n            return head\\n        \\n        # get the middle of linked list\\n        middle = self.getMiddle(head)\\n        nextToMiddle = middle.next\\n        \\n        # so that one linked list is divided into 2 parts\\n        middle.next = None\\n        \\n        # apply merge sort on left & right sub-list\\n        left = self.sortList(head)\\n        right = self.sortList(nextToMiddle)\\n        \\n        # merge the sorted left and right sub-lists\\n        sortedList=self.mergeSortedList(left, right)\\n        \\n        return sortedList\\n            \\n        \\n    def mergeSortedList(self, first, second):\\n        \\n        # Base cases\\n        if not first:\\n            return second\\n        \\n        if not second:\\n            return first\\n        \\n        res = None\\n        \\n        if first.val <= second.val:\\n            res = first\\n            res.next = self.mergeSortedList(first.next, second)\\n            \\n        else:\\n            res=second\\n            res.next = self.mergeSortedList(first, second.next)\\n            \\n        return res\\n    \\n            \\n    # function to get the middle of linked list   \\n    def getMiddle(self, head):\\n        \\n        slow = fast = head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        return slow\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276416,
                "title": "merge-sort-in-linked-lists-faster-than-100",
                "content": "\\tclass Solution {\\n    \\n\\tpublic:\\n    \\n    ListNode* merge(ListNode* l1 , ListNode* l2)\\n    {\\n        ListNode* head = NULL;\\n        \\n        if(l1==NULL)\\n        {\\n            return(l2);\\n        }\\n        if(l2==NULL)\\n        {\\n            return(l1);\\n        }\\n        \\n        if(l1->val <= l2->val)\\n        {\\n            head = l1;\\n            head->next = merge( l1->next , l2 );\\n        }\\n        else\\n        {\\n            head = l2;\\n            head->next = merge(l1 , l2->next);\\n        }\\n        return(head);\\n    }\\n    \\n    \\n    ListNode* sort(ListNode*  head, ListNode* tail)\\n    {\\n        if(head == tail) return head;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        \\n        while(fast!=tail && fast->next!=tail)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n                \\n        fast = slow->next;\\n        slow->next = NULL;\\n        \\n        return( merge( sort(head,slow) , sort(fast , tail)));\\n        \\n        \\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n\\n        if(!head) return head;\\n\\n        \\n        ListNode* tail = head;\\n        while(tail->next)\\n        {\\n            tail = tail->next;\\n        }\\n\\n        return( sort(head , tail));\\n    }\\n\\t};\\n\\nPlease Upvote, If you liked the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    \\n\\tpublic:\\n    \\n    ListNode* merge(ListNode* l1 , ListNode* l2)\\n    {\\n        ListNode* head = NULL;\\n        \\n        if(l1==NULL)\\n        {\\n            return(l2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1162947,
                "title": "python-using-merge-sort-t-o-nlogn-s-o-n-recursions",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        \\n        def merge_sort(head):\\n            if head is None or head.next is None: return head\\n            \\n            left = slow = fast = head\\n            fast = fast.next\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            right = slow.next\\n            slow.next = None\\n            \\n            left_sorted = merge_sort(left)\\n            right_sorted = merge_sort(right)\\n            \\n            return merge(left_sorted, right_sorted)\\n        \\n        def merge(l1, l2):\\n            \\n            dummy = ListNode()\\n            prev = dummy\\n            \\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    prev.next = l1\\n                    l1 = l1.next\\n                else:\\n                    prev.next = l2\\n                    l2 = l2.next\\n                prev = prev.next\\n            prev.next = l1 or l2\\n            return dummy.next\\n        \\n        \\n        return merge_sort(head)\\n```\\nPlease upvote if you get it.",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        \\n        def merge_sort(head):\\n            if head is None or head.next is None: return head\\n            \\n            left = slow = fast = head\\n            fast = fast.next\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            right = slow.next\\n            slow.next = None\\n            \\n            left_sorted = merge_sort(left)\\n            right_sorted = merge_sort(right)\\n            \\n            return merge(left_sorted, right_sorted)\\n        \\n        def merge(l1, l2):\\n            \\n            dummy = ListNode()\\n            prev = dummy\\n            \\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    prev.next = l1\\n                    l1 = l1.next\\n                else:\\n                    prev.next = l2\\n                    l2 = l2.next\\n                prev = prev.next\\n            prev.next = l1 or l2\\n            return dummy.next\\n        \\n        \\n        return merge_sort(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892587,
                "title": "golang-bubble-sort",
                "content": "```golang\\nfunc sortList(head *ListNode) *ListNode {\\n\\tfor i := head; i != nil; i = i.Next {\\n\\t\\tfor j := i.Next; j != nil; j = j.Next {\\n\\t\\t\\tif j.Val < i.Val {\\n\\t\\t\\t\\ti.Val, j.Val = j.Val, i.Val\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc sortList(head *ListNode) *ListNode {\\n\\tfor i := head; i != nil; i = i.Next {\\n\\t\\tfor j := i.Next; j != nil; j = j.Next {\\n\\t\\t\\tif j.Val < i.Val {\\n\\t\\t\\t\\ti.Val, j.Val = j.Val, i.Val\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712403,
                "title": "clean-merge-sort-solution-with-two-recursive-methods-java-easy-to-understand",
                "content": "I saw solutions where the merge method was iterative. So I tried make a recursive one :)\\n\\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null)   return head;\\n        \\n        ListNode fast = head, slow = head, temp = null;\\n        while(fast!=null && fast.next!=null){\\n            temp = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        temp.next = null;\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(slow);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode l1, ListNode l2){\\n        if(l1==null){\\n            return l2;\\n        }\\n        if(l2==null){\\n            return l1;\\n        }\\n        if(l1.val < l2.val){\\n            l1.next = merge(l1.next,l2);\\n            return l1;\\n        }\\n        else{\\n            l2.next = merge(l1,l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null)   return head;\\n        \\n        ListNode fast = head, slow = head, temp = null;\\n        while(fast!=null && fast.next!=null){\\n            temp = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        temp.next = null;\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(slow);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode l1, ListNode l2){\\n        if(l1==null){\\n            return l2;\\n        }\\n        if(l2==null){\\n            return l1;\\n        }\\n        if(l1.val < l2.val){\\n            l1.next = merge(l1.next,l2);\\n            return l1;\\n        }\\n        else{\\n            l2.next = merge(l1,l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641574,
                "title": "c-95-time-o-nlogn-and-o-1-space",
                "content": "**Upvotes are appreciated**\\n**If needed explanation please comment**\\n```\\nListNode* mergelist(ListNode* l1,ListNode* l2){\\n        if(!l1 && !l2)return NULL;\\n        if(l1==NULL)return l2;\\n        if(l2==NULL)return l1;\\n        ListNode* last,*start;\\n        if(l1->val <= l2->val){\\n            start=l1;\\n            l1=l1->next;\\n        }\\n        else{\\n            start=l2;\\n            l2=l2->next;\\n        }\\n        last=start;\\n        while(l1 && l2){\\n            if(l1->val <= l2->val){\\n                last->next=l1;\\n                l1=l1->next;\\n                last=last->next;\\n            }\\n            else{\\n                last->next=l2;\\n                l2=l2->next;\\n                last=last->next;\\n            }\\n        }\\n        if(l1)\\n            last->next=l1;\\n        if(l2)\\n            last->next=l2;\\n        return start;\\n    }   \\n\\t\\n    ListNode* findmiddle(ListNode* ptr){\\n        ListNode* slow=ptr;\\n        ListNode* fast=ptr;\\n\\t\\t\\n        while(fast->next and fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\t\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next)\\n            return head;\\n\\t\\t\\t\\n        ListNode* middle = findmiddle(head);\\n        ListNode* middle_next = middle->next;\\n        middle->next=NULL;\\n\\n        ListNode* ls=sortList(head);\\n        ListNode* rs=sortList(middle_next);\\n\\n        ListNode* sorted=mergelist(ls,rs);\\n        return sorted;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* mergelist(ListNode* l1,ListNode* l2){\\n        if(!l1 && !l2)return NULL;\\n        if(l1==NULL)return l2;\\n        if(l2==NULL)return l1;\\n        ListNode* last,*start;\\n        if(l1->val <= l2->val){\\n            start=l1;\\n            l1=l1->next;\\n        }\\n        else{\\n            start=l2;\\n            l2=l2->next;\\n        }\\n        last=start;\\n        while(l1 && l2){\\n            if(l1->val <= l2->val){\\n                last->next=l1;\\n                l1=l1->next;\\n                last=last->next;\\n            }\\n            else{\\n                last->next=l2;\\n                l2=l2->next;\\n                last=last->next;\\n            }\\n        }\\n        if(l1)\\n            last->next=l1;\\n        if(l2)\\n            last->next=l2;\\n        return start;\\n    }   \\n\\t\\n    ListNode* findmiddle(ListNode* ptr){\\n        ListNode* slow=ptr;\\n        ListNode* fast=ptr;\\n\\t\\t\\n        while(fast->next and fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\t\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next)\\n            return head;\\n\\t\\t\\t\\n        ListNode* middle = findmiddle(head);\\n        ListNode* middle_next = middle->next;\\n        middle->next=NULL;\\n\\n        ListNode* ls=sortList(head);\\n        ListNode* rs=sortList(middle_next);\\n\\n        ListNode* sorted=mergelist(ls,rs);\\n        return sorted;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516045,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode *mergeList(struct ListNode *l1, struct ListNode *l2)\\n{\\n    if(l1 == NULL) return l2;\\n    if(l2 == NULL) return l1;\\n\\n    if(l1->val <= l2->val)\\n    {\\n        l1->next = mergeList(l1->next, l2);\\n        return l1;\\n    }\\n    else\\n    {\\n        l2->next = mergeList(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode* sortList(struct ListNode* head){\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next == NULL)\\n        return head;\\n    struct ListNode *fast, *slow, *pre;\\n    fast = slow = head;\\n    while(fast && fast->next)\\n    {\\n        pre = slow;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n\\n    pre->next = NULL;\\n    return mergeList(sortList(head), sortList(slow));\\n}\\n```\\n\\n16/16 cases passed (20 ms)\\nYour runtime beats 71.67 % of c submissions\\nYour memory usage beats 100 % of c submissions (10.8 MB)",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode *mergeList(struct ListNode *l1, struct ListNode *l2)\\n{\\n    if(l1 == NULL) return l2;\\n    if(l2 == NULL) return l1;\\n\\n    if(l1->val <= l2->val)\\n    {\\n        l1->next = mergeList(l1->next, l2);\\n        return l1;\\n    }\\n    else\\n    {\\n        l2->next = mergeList(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode* sortList(struct ListNode* head){\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next == NULL)\\n        return head;\\n    struct ListNode *fast, *slow, *pre;\\n    fast = slow = head;\\n    while(fast && fast->next)\\n    {\\n        pre = slow;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n\\n    pre->next = NULL;\\n    return mergeList(sortList(head), sortList(slow));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499587,
                "title": "c-quick-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* tail = head;\\n        while(tail->next) tail = tail->next;\\n        quickSort(head, tail);\\n        return head;\\n    }\\n    \\n    void quickSort(ListNode* head, ListNode* tail){\\n        if(!head || head == tail) return;\\n        ListNode* pivot = partition(head, tail);\\n        quickSort(head, pivot);\\n        quickSort(pivot->next, tail);\\n    }\\n    \\n    ListNode* partition(ListNode* head, ListNode* tail){\\n        int pivot = head->val;\\n        ListNode* pivotNode = head;\\n        ListNode* walker = head->next;\\n        ListNode* runner = head->next;\\n        while(runner && runner != tail->next){\\n            if(runner->val < pivot){\\n                swap(walker, runner);\\n                walker = walker->next;\\n                pivotNode = pivotNode->next;\\n            }\\n            runner = runner->next;\\n        }\\n        swap(head, pivotNode);\\n        return pivotNode;\\n    }\\n    \\n    void swap(ListNode* A, ListNode* B){\\n        int tmp = A->val;\\n        A->val = B->val;\\n        B->val = tmp;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* tail = head;\\n        while(tail->next) tail = tail->next;\\n        quickSort(head, tail);\\n        return head;\\n    }\\n    \\n    void quickSort(ListNode* head, ListNode* tail){\\n        if(!head || head == tail) return;\\n        ListNode* pivot = partition(head, tail);\\n        quickSort(head, pivot);\\n        quickSort(pivot->next, tail);\\n    }\\n    \\n    ListNode* partition(ListNode* head, ListNode* tail){\\n        int pivot = head->val;\\n        ListNode* pivotNode = head;\\n        ListNode* walker = head->next;\\n        ListNode* runner = head->next;\\n        while(runner && runner != tail->next){\\n            if(runner->val < pivot){\\n                swap(walker, runner);\\n                walker = walker->next;\\n                pivotNode = pivotNode->next;\\n            }\\n            runner = runner->next;\\n        }\\n        swap(head, pivotNode);\\n        return pivotNode;\\n    }\\n    \\n    void swap(ListNode* A, ListNode* B){\\n        int tmp = A->val;\\n        A->val = B->val;\\n        B->val = tmp;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346020,
                "title": "python-merge-sort",
                "content": "```\\nclass Solution:    \\n    def split_list(self, head):\\n        pre, slow, fast = None, head, head\\n        while fast and fast.next:\\n            pre, slow, fast = slow, slow.next, fast.next.next\\n        pre.next = None\\n        return (head, slow)\\n        \\n    def merge(self, h1, h2):\\n        if not h1 or not h2:\\n            return h1 or h2\\n        if h1.val > h2.val:\\n            h1, h2 = h2, h1\\n        head = pre = h1\\n        h1 = h1.next\\n        while h1 and h2:\\n            if h1.val < h2.val:\\n                pre.next = h1\\n                h1 = h1.next\\n            else:\\n                pre.next = h2\\n                h2 = h2.next\\n            pre = pre.next\\n        pre.next = h1 or h2\\n        return head\\n                \\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        h1, h2 = self.split_list(head)\\n        h1, h2 = self.sortList(h1), self.sortList(h2)\\n        head = self.merge(h1, h2)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:    \\n    def split_list(self, head):\\n        pre, slow, fast = None, head, head\\n        while fast and fast.next:\\n            pre, slow, fast = slow, slow.next, fast.next.next\\n        pre.next = None\\n        return (head, slow)\\n        \\n    def merge(self, h1, h2):\\n        if not h1 or not h2:\\n            return h1 or h2\\n        if h1.val > h2.val:\\n            h1, h2 = h2, h1\\n        head = pre = h1\\n        h1 = h1.next\\n        while h1 and h2:\\n            if h1.val < h2.val:\\n                pre.next = h1\\n                h1 = h1.next\\n            else:\\n                pre.next = h2\\n                h2 = h2.next\\n            pre = pre.next\\n        pre.next = h1 or h2\\n        return head\\n                \\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        h1, h2 = self.split_list(head)\\n        h1, h2 = self.sortList(h1), self.sortList(h2)\\n        head = self.merge(h1, h2)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345674,
                "title": "java-quick-sort",
                "content": "```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        quickSort(head, null);\\n        return head;\\n    }\\n    \\n    private void quickSort(ListNode head, ListNode tail){\\n        if (head == tail){\\n            return;\\n        }\\n        ListNode slow = head, fast = head.next;\\n        int p = head.val;\\n        while (fast != tail){\\n            if (fast.val <= p){\\n                slow = slow.next;\\n                swap(slow, fast);\\n            }\\n            fast = fast.next;\\n        }\\n        swap(head, slow);\\n        quickSort(head, slow);\\n        quickSort(slow.next, tail);\\n    }\\n    \\n    private void swap(ListNode node1, ListNode node2){\\n         int tmp = node1.val;\\n         node1.val = node2.val;\\n         node2.val = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        quickSort(head, null);\\n        return head;\\n    }\\n    \\n    private void quickSort(ListNode head, ListNode tail){\\n        if (head == tail){\\n            return;\\n        }\\n        ListNode slow = head, fast = head.next;\\n        int p = head.val;\\n        while (fast != tail){\\n            if (fast.val <= p){\\n                slow = slow.next;\\n                swap(slow, fast);\\n            }\\n            fast = fast.next;\\n        }\\n        swap(head, slow);\\n        quickSort(head, slow);\\n        quickSort(slow.next, tail);\\n    }\\n    \\n    private void swap(ListNode node1, ListNode node2){\\n         int tmp = node1.val;\\n         node1.val = node2.val;\\n         node2.val = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46709,
                "title": "swift-solution-merge-sort",
                "content": "```\\nclass Solution {\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil {\\n            return head\\n        }\\n        \\n        var pre: ListNode? = nil\\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        \\n        while fast != nil && fast?.next != nil {\\n            pre = slow\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        pre?.next = nil\\n        let l1 = sortList(head)\\n        let l2 = sortList(slow)\\n        \\n        return merge(l1, l2)\\n    }\\n    \\n    private func merge(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(0)\\n        var l1 = l1\\n        var l2 = l2\\n        var cur: ListNode? = dummy\\n        \\n        while l1 != nil && l2 != nil {\\n            if l1!.val < l2!.val {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        if l1 != nil {\\n            cur?.next = l1\\n        }\\n        if l2 != nil {\\n            cur?.next = l2\\n        }\\n        \\n        return dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil {\\n            return head\\n        }\\n        \\n        var pre: ListNode? = nil\\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        \\n        while fast != nil && fast?.next != nil {\\n            pre = slow\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        pre?.next = nil\\n        let l1 = sortList(head)\\n        let l2 = sortList(slow)\\n        \\n        return merge(l1, l2)\\n    }\\n    \\n    private func merge(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(0)\\n        var l1 = l1\\n        var l2 = l2\\n        var cur: ListNode? = dummy\\n        \\n        while l1 != nil && l2 != nil {\\n            if l1!.val < l2!.val {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        if l1 != nil {\\n            cur?.next = l1\\n        }\\n        if l2 != nil {\\n            cur?.next = l2\\n        }\\n        \\n        return dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47031,
                "title": "my-iterative-merge-sort",
                "content": "Consider how iterative merge sort works. first time merge 2 elements, then 4 elements, then 8 elements, until all elements.\\n\\nUse two lists to represent all odd merge parts and all even merge parts.\\n\\nAt first, convert the list to two lists:\\n\\ntop       : 1st    3rd   5th  7th ...\\n\\nbottom : 2nd   4th   6th  8th ...\\n\\nthen merge sort, first time:\\n\\ntop       : SortResult(1st, 2nd) | SortResult(5th, 6th) ...\\n\\nbottom : SortResult(3rd, 4th) |  SortResult(7th, 8th) ...\\n\\nsecond time:\\n\\ntop       : SortResult(1st, 2nd, 3rd, 4th) ...\\n\\nbottom : SortResult(5th, 6th, 7th, 8th) ...\\n\\nActually, if we have previous sort result:\\n\\ntop       : s(1) s(3) ...\\n\\nbottom : s(2) s(4) ...\\n\\nwe can sort it to get:\\n\\ntop       : sort(s(1), s(2)) ...\\n\\nbottom : sort(s(3), s(4)) ...\\n\\nThe code is below:\\n\\n    public class Solution\\n    {\\n        private ListNode merge(ListNode dest, ListNode src, int step)\\n        {\\n            int destCount = 0;\\n            int srcCount = 0;\\n            final int max = step >>> 1;\\n            for (int j = 0; j < step; ++j)\\n            {\\n                if (dest.next == null || destCount >= max)\\n                {\\n                    if (src.next == null)\\n                    {\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        final ListNode temp = dest.next;\\n                        dest.next = src.next;\\n                        src.next = src.next.next;\\n                        dest = dest.next;\\n                        dest.next = temp;\\n                    }\\n                }\\n                else if (src.next == null || srcCount >= max)\\n                {\\n                    if (dest.next != null)\\n                    {\\n                        dest = dest.next;\\n                    }\\n                }\\n                else\\n                {\\n                    if (dest.next.val <= src.next.val)\\n                    {\\n                        dest = dest.next;\\n                        ++destCount;\\n                    }\\n                    else\\n                    {\\n                        final ListNode temp = dest.next;\\n                        dest.next = src.next;\\n                        src.next = src.next.next;\\n                        dest = dest.next;\\n                        dest.next = temp;\\n                        ++srcCount;\\n                    }\\n                }\\n            }\\n            \\n            return dest;\\n        }\\n        \\n        public ListNode sortList(ListNode head)\\n        {\\n            if (head == null || head.next == null)\\n            {\\n                return head;\\n            }\\n            \\n            final ListNode topHead = new ListNode(0);\\n            final ListNode bottomHead = new ListNode(0);\\n            \\n            ListNode top = topHead;\\n            ListNode bottom = bottomHead;\\n            \\n            ListNode node = head;\\n            for (; node != null && node.next != null; node = node.next)\\n            {\\n                top.next = node;\\n                top = top.next;\\n                \\n                node = node.next;\\n                \\n                bottom.next = node;\\n                bottom = bottom.next;\\n            }\\n            \\n            top.next = node;\\n            bottom.next = null;\\n            \\n            for (int i = 1; bottomHead.next != null; i <<= 1)\\n            {\\n                top = topHead;\\n                bottom = bottomHead;\\n                \\n                while (top.next != null && bottom.next != null)\\n                {\\n                    top = merge(top, bottom, i << 1);\\n                    bottom = merge(bottom, top, i << 1);\\n                }\\n            }\\n            \\n            return topHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        private ListNode merge(ListNode dest, ListNode src, int step)\\n        {\\n            int destCount = 0;\\n            int srcCount = 0;\\n            final int max = step >>> 1;\\n            for (int j = 0; j < step; ++j)\\n            {\\n                if (dest.next == null || destCount >= max)\\n                {\\n                    if (src.next == null)\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 47048,
                "title": "merge-sort-solution-in-java",
                "content": "Here is my solution. It's a bottom-up implementation of merge sort. It uses O(1) space since it does not use recursion and the merge process takes constant space. The merge method is very similar to the solution of the problem \"Merge Two Sorted List\", except that it returns both the head and the tail of the merged sub-list so that it can be linked back to the entire list.\\n\\n    /**\\n     * Definition for singly-linked list.\\n     * class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) {\\n     *         val = x;\\n     *         next = null;\\n     *     }\\n     * }\\n     */\\n    public class Solution {\\n        \\n      class Pair {\\n          public ListNode head;\\n          public ListNode tail;\\n          public Pair(ListNode head, ListNode tail) {\\n              this.head = head;\\n              this.tail = tail;\\n          }\\n      }    \\n        \\n      private Pair merge(ListNode l1, ListNode t1, ListNode l2, ListNode t2) {\\n            ListNode head, tail;\\n            ListNode p1 = l1, p2 = l2;\\n            if (l1 == null) return new Pair(l2, t2);\\n            if (l2 == null) return new Pair(l1, t1);\\n            if (l1.val < l2.val) {\\n                head = l1;\\n                p1 = p1.next;\\n            } else {\\n                head = l2;\\n                p2 = p2.next;\\n            }\\n            tail = head;\\n            while (p1 != null && p2 != null) {\\n                ListNode tmp;\\n                if (p1.val < p2.val) {\\n                    tmp = p1.next;\\n                    tail.next = p1;\\n                    p1 = tmp;\\n                } else {\\n                    tmp = p2.next;\\n                    tail.next = p2;\\n                    p2 = tmp;\\n                }\\n                tail = tail.next;\\n            }\\n            if (p1 != null) {\\n                tail.next = p1;\\n            } else {\\n                tail.next = p2;\\n            }\\n            while (tail.next != null) \\n                tail = tail.next;\\n            \\n            return new Pair(head, tail);\\n        }\\n        \\n        private ListNode jump(ListNode start, int len) {\\n            ListNode ans = start;\\n            for (int i=0; i<len; i++) {\\n                if (ans != null) {\\n                    ans = ans.next;\\n                } else {\\n                    break;\\n                }\\n            }\\n            return ans;\\n        }\\n        \\n        public ListNode sortList(ListNode head) {\\n            int len = 1;\\n            ListNode fstHead, fstTail, sndHead, sndTail, lBound, rBound, dummyHead;\\n            boolean changed = true;\\n            dummyHead = new ListNode(0);\\n            dummyHead.next = head;\\n            while (changed) {\\n                changed = false;\\n                lBound = dummyHead;\\n                fstHead = jump(lBound, 1);\\n                fstTail = jump(fstHead, len-1);\\n                sndHead = jump(fstTail, 1);\\n                sndTail = jump(sndHead, len-1);\\n                rBound = jump(sndTail, 1);\\n                \\n                while (sndHead != null) {\\n                    changed = true;\\n                    if (fstTail != null) fstTail.next = null;\\n                    if (sndTail != null) sndTail.next = null;\\n                    Pair p = merge(fstHead, fstTail, sndHead, sndTail);\\n                    if (lBound != null) lBound.next = p.head;\\n                    if (p.tail != null) p.tail.next = rBound;\\n                    lBound = p.tail;\\n                    fstHead = jump(lBound, 1);\\n                    fstTail = jump(fstHead, len-1);\\n                    sndHead = jump(fstTail, 1);\\n                    sndTail = jump(sndHead, len-1);\\n                    rBound = jump(sndTail, 1);\\n                }\\n                \\n                len *= 2;\\n            }\\n            \\n            return dummyHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n      class Pair {\\n          public ListNode head;\\n          public ListNode tail;\\n          public Pair(ListNode head, ListNode tail) {\\n              this.head = head;\\n              this.tail = tail;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 47093,
                "title": "ask-for-suggestion",
                "content": "Here is my solution. Merge sort. Pass OJ. I would like to ask for suggestion to further improve it. E.g. shorter code or simpler design. Thanks in advance.\\n\\n    ListNode *merge(ListNode* l1, ListNode* l2, ListNode* h){\\n        ListNode* l=h;\\n        while(l1||l2){\\n            if(!l1){\\n                l->next=l2;\\n                l2=l2->next;\\n            }\\n            else if(!l2){\\n                l->next=l1;\\n                l1=l1->next;\\n            }\\n            else if(l1->val<l2->val){\\n                l->next=l1;\\n                l1=l1->next;\\n            }\\n            else {\\n                l->next=l2;\\n                l2=l2->next;\\n            }\\n            l=l->next;\\n        }\\n        return l;\\n    }\\n    \\n    ListNode* split(ListNode* h, int len){\\n        for(int i=1;i<len&&h!=NULL;i++){\\n            h=h->next;\\n        }\\n        if(!h) return NULL;\\n        ListNode* t=h->next;\\n        h->next=NULL;\\n        return t;\\n    }\\n    \\n    ListNode *sortList(ListNode *head) {\\n        ListNode n(0);\\n        n.next=head;\\n        int listlen=0;\\n        while(head){listlen++;head=head->next;}\\n        for(int len=1;len<listlen;len*=2){\\n            ListNode* t=n.next,*l1,*l2;\\n            ListNode* h=&n;\\n            while(t!=NULL){\\n                l1=t;\\n                l2=split(t,len);\\n                t=split(l2,len);\\n                ListNode* tail=merge(l1,l2,h);\\n                tail->next=t;\\n                h=tail;\\n            }\\n        }\\n        return n.next;\\n    }",
                "solutionTags": [],
                "code": "Here is my solution. Merge sort. Pass OJ. I would like to ask for suggestion to further improve it. E.g. shorter code or simpler design. Thanks in advance.\\n\\n    ListNode *merge(ListNode* l1, ListNode* l2, ListNode* h){\\n        ListNode* l=h;\\n        while(l1||l2){\\n            if(!l1){\\n                l->next=l2;\\n                l2=l2->next;\\n            }\\n            else if(!l2){\\n                l->next=l1;\\n                l1=l1->next;\\n            }\\n            else if(l1->val<l2->val){\\n                l->next=l1;\\n                l1=l1->next;\\n            }\\n            else {\\n                l->next=l2;\\n                l2=l2->next;\\n            }\\n            l=l->next;\\n        }\\n        return l;\\n    }\\n    \\n    ListNode* split(ListNode* h, int len){\\n        for(int i=1;i<len&&h!=NULL;i++){\\n            h=h->next;\\n        }\\n        if(!h) return NULL;\\n        ListNode* t=h->next;\\n        h->next=NULL;\\n        return t;\\n    }\\n    \\n    ListNode *sortList(ListNode *head) {\\n        ListNode n(0);\\n        n.next=head;\\n        int listlen=0;\\n        while(head){listlen++;head=head->next;}\\n        for(int len=1;len<listlen;len*=2){\\n            ListNode* t=n.next,*l1,*l2;\\n            ListNode* h=&n;\\n            while(t!=NULL){\\n                l1=t;\\n                l2=split(t,len);\\n                t=split(l2,len);\\n                ListNode* tail=merge(l1,l2,h);\\n                tail->next=t;\\n                h=tail;\\n            }\\n        }\\n        return n.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4019735,
                "title": "merge-sort-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nMerge Sort for Singly Linked List\\n\\n- midd Function (Find Middle Element):\\n\\n- This function takes a pointer to the head of a linked list as input.It initializes two pointers, slow and fast, both initially pointing to the head of the list.\\nThe slow pointer moves one step at a time, and the fast pointer moves two steps at a time. This way, the fast pointer will reach the end of the list while the slow pointer is at the middle.\\nThe function returns the slow pointer, which now points to the middle element of the linked list.\\n- mergelist Function (Merge Two Sorted Lists):\\n\\n- This function takes two pointers, left and right, representing two sorted linked lists as input.\\nIt merges these two sorted linked lists into a single sorted linked list and returns the head of the merged list.\\nIt uses three pointers: ans to keep track of the head of the merged list, curr to build the merged list, and initially, both ans and curr are set to nullptr.\\n- It iterates through left and right, comparing the values of the current nodes and attaching the smaller node to the curr pointer.\\nWhen a node is attached to curr, curr moves to the attached node.\\nAfter the loop, if there are remaining nodes in either left or right, it appends them to the end of the merged list.\\nFinally, it returns ans, which is the head of the merged list.\\nsortList Function (Sort the Linked List):\\n\\nThis is the main sorting function.\\n- It checks if the input list head is empty or has only one element. If either condition is met, it returns head as it is already sorted.Otherwise, it proceeds with the sorting:\\n- It finds the middle element of the linked list using the midd function.It splits the list into two halves: left (the original head to mid) and right (from mid->next to the end).It recursively calls sortList on both left and right.Finally, it merges the sorted left and right lists using the mergelist function and returns the merged sorted list.\\nThis approach efficiently sorts a singly linked list using the Merge Sort algorithm, which ensures a time complexity of O(n log n) for linked lists.\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nListNode* midd(ListNode *head){\\n    ListNode *slow = head;\\n    ListNode *fast = head;\\n    while(fast->next !=NULL && fast->next->next !=NULL)\\n    {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return slow;\\n}\\n\\nListNode* mergelist(ListNode *left,ListNode *right)\\n{\\n    if(left==NULL || right==NULL)\\n    {\\n        return (left==NULL) ? right : left;\\n    }\\n    ListNode *ans = new ListNode(0); // made a new ll with  value;\\n    ListNode *curr = ans;\\n    while(left != nullptr && right!=nullptr)\\n    {\\n        if(left->val < right->val)\\n        {\\n            curr->next = left;\\n            left=left->next;\\n        }\\n        else\\n        {\\n            curr->next = right;\\n            right=right->next;\\n\\n        }\\n        curr=curr->next;\\n    }\\n    if(left!=NULL || right!=NULL)\\n    {\\n        curr->next =(left!=NULL) ? left : right;\\n    }\\n    return ans->next;\\n\\n}\\n    ListNode* sortList(ListNode *head)\\n    {\\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode *newhead= head;\\n        ListNode *mid = midd(head);\\n        newhead= mid->next;\\n        mid->next=NULL;\\n        ListNode *left = sortList(head);\\n        ListNode *right = sortList(newhead);\\n\\n        return mergelist(left,right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Divide and Conquer",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nListNode* midd(ListNode *head){\\n    ListNode *slow = head;\\n    ListNode *fast = head;\\n    while(fast->next !=NULL && fast->next->next !=NULL)\\n    {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return slow;\\n}\\n\\nListNode* mergelist(ListNode *left,ListNode *right)\\n{\\n    if(left==NULL || right==NULL)\\n    {\\n        return (left==NULL) ? right : left;\\n    }\\n    ListNode *ans = new ListNode(0); // made a new ll with  value;\\n    ListNode *curr = ans;\\n    while(left != nullptr && right!=nullptr)\\n    {\\n        if(left->val < right->val)\\n        {\\n            curr->next = left;\\n            left=left->next;\\n        }\\n        else\\n        {\\n            curr->next = right;\\n            right=right->next;\\n\\n        }\\n        curr=curr->next;\\n    }\\n    if(left!=NULL || right!=NULL)\\n    {\\n        curr->next =(left!=NULL) ? left : right;\\n    }\\n    return ans->next;\\n\\n}\\n    ListNode* sortList(ListNode *head)\\n    {\\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode *newhead= head;\\n        ListNode *mid = midd(head);\\n        newhead= mid->next;\\n        mid->next=NULL;\\n        ListNode *left = sortList(head);\\n        ListNode *right = sortList(newhead);\\n\\n        return mergelist(left,right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722193,
                "title": "easiest-java-solution-heap-o-n-log-n",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        ListNode curr = head;\\n        while(curr != null){\\n            pq.add(curr.val);\\n            curr = curr.next;\\n        }\\n        curr = head;\\n        while(curr!=null && !pq.isEmpty()){\\n            curr.val = pq.poll();\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        ListNode curr = head;\\n        while(curr != null){\\n            pq.add(curr.val);\\n            curr = curr.next;\\n        }\\n        curr = head;\\n        while(curr!=null && !pq.isEmpty()){\\n            curr.val = pq.poll();\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497480,
                "title": "easiest-c-solution-using-vector-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp=head;\\n        while(temp){\\n            vec.emplace_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(vec.begin(),vec.end());\\n        int i=0;\\n        temp=head;\\n        while(temp){\\n            temp->val=vec[i];\\n            i++;\\n            temp=temp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\nDO UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp=head;\\n        while(temp){\\n            vec.emplace_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(vec.begin(),vec.end());\\n        int i=0;\\n        temp=head;\\n        while(temp){\\n            temp->val=vec[i];\\n            i++;\\n            temp=temp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\nDO UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375513,
                "title": "quickest-and-unique-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust take the elements of linked list in array and than try to restructure it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinked list structuring and destructuring by using of addditional vector. \\n\\n# Complexity\\n- Time complexity:   O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n         ListNode* cur=head;\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        vector<int>v;\\n        while(cur!=NULL){\\n            v.push_back(cur->val);\\n            cur=cur->next;\\n        }\\n        sort(v.begin(),v.end());\\n         ListNode* hea= new ListNode(v[0]);\\n         ListNode* temp=hea;\\n        for(int i=1;i<v.size();i++){\\n               ListNode* curr= new ListNode(v[i]); \\n               temp->next=curr;\\n               temp=curr;\\n        }\\n        temp->next=NULL;\\n         return hea;\\n    }\\n\\n};\\n```\\n\\n![2ui86w.jpg](https://assets.leetcode.com/users/images/dce9c43e-bf48-4fbd-b891-104598069960_1680540836.061523.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n         ListNode* cur=head;\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        vector<int>v;\\n        while(cur!=NULL){\\n            v.push_back(cur->val);\\n            cur=cur->next;\\n        }\\n        sort(v.begin(),v.end());\\n         ListNode* hea= new ListNode(v[0]);\\n         ListNode* temp=hea;\\n        for(int i=1;i<v.size();i++){\\n               ListNode* curr= new ListNode(v[i]); \\n               temp->next=curr;\\n               temp=curr;\\n        }\\n        temp->next=NULL;\\n         return hea;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182473,
                "title": "java-sol-easy-merge-sort-beats-93",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head==null || head.next==null) return head;\\n        ListNode mid = middle(head);\\n        ListNode left = head;\\n        ListNode right = mid.next;\\n        mid.next = null;\\n        left = sortList(left);\\n        right = sortList(right);\\n        return merge(left, right);\\n    }\\n    ListNode middle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummy = new ListNode(0, null);\\n        ListNode temp = dummy;\\n        while (list1!=null && list2!=null) {\\n            if (list1.val<list2.val) {\\n                temp.next = list1;\\n                list1 = list1.next;\\n                temp = temp.next;\\n            }\\n            else {\\n                temp.next = list2;\\n                list2 = list2.next;\\n                temp = temp.next;\\n            }\\n        }\\n        if (list1==null) {\\n            temp.next = list2;\\n            return dummy.next;\\n        }\\n        temp.next = list1;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head==null || head.next==null) return head;\\n        ListNode mid = middle(head);\\n        ListNode left = head;\\n        ListNode right = mid.next;\\n        mid.next = null;\\n        left = sortList(left);\\n        right = sortList(right);\\n        return merge(left, right);\\n    }\\n    ListNode middle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummy = new ListNode(0, null);\\n        ListNode temp = dummy;\\n        while (list1!=null && list2!=null) {\\n            if (list1.val<list2.val) {\\n                temp.next = list1;\\n                list1 = list1.next;\\n                temp = temp.next;\\n            }\\n            else {\\n                temp.next = list2;\\n                list2 = list2.next;\\n                temp = temp.next;\\n            }\\n        }\\n        if (list1==null) {\\n            temp.next = list2;\\n            return dummy.next;\\n        }\\n        temp.next = list1;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783560,
                "title": "java-mergesort-easy-explaination-with-comments",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n\\t//findMid : As the name suggest, it returns us the mid of linkedList\\n    public ListNode findMid(ListNode head) {\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    \\n\\t//merge :- returns us a sorted linked list in which two sorted linkedlists are merged \\n    public ListNode merge(ListNode l1, ListNode l2) {\\n\\t\\tif(l1==null) return l2;         // if l1 is null return l2\\n        if(l2==null) return l1;        // if l2 is null return l1\\n        ListNode ans = l1;           \\n        \\n\\t\\t// assign the lowest value node to ans\\n\\t\\t\\n        while(l2.val<l1.val) {\\n            ListNode temp = l1;\\n            l1=l2;\\n            l2=temp;\\n            ans=l1;\\n        }\\n        \\n\\t\\t//Traversing and rearranging the nodes in sorted order\\n        while(l1!=null && l2!=null) {\\n            ListNode temp = null;\\n            while(l1!=null && l1.val<=l2.val) {    // if value at l1 is smaller\\n                temp = l1;\\n                l1=l1.next;\\n            }   // exchange l1 and l2\\n            temp.next = l2;\\n            temp = l1;\\n            l1=l2;\\n            l2=temp;\\n        }\\n        return ans;\\n    }\\n    \\n    public ListNode sortList(ListNode head) {\\n        //base case\\n        if(head==null || head.next==null) return head;\\n        \\n        //break linkedlist into 2 halves\\n        ListNode mid = findMid(head);\\n        \\n        ListNode left = head;\\n        ListNode right = mid.next;\\n        mid.next=null;\\n        \\n        //recursive calls to sort both the linkedlists\\n        left = sortList(left);\\n        right = sortList(right);\\n        \\n        //merge two sorted linked list\\n        ListNode ans  = merge(left,right);\\n        return ans;\\n    }\\n}\\n```\\nHope it helps, Happy LeetCoding{^_^}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n\\t//findMid : As the name suggest, it returns us the mid of linkedList\\n    public ListNode findMid(ListNode head) {\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    \\n\\t//merge :- returns us a sorted linked list in which two sorted linkedlists are merged \\n    public ListNode merge(ListNode l1, ListNode l2) {\\n\\t\\tif(l1==null) return l2;         // if l1 is null return l2\\n        if(l2==null) return l1;        // if l2 is null return l1\\n        ListNode ans = l1;           \\n        \\n\\t\\t// assign the lowest value node to ans\\n\\t\\t\\n        while(l2.val<l1.val) {\\n            ListNode temp = l1;\\n            l1=l2;\\n            l2=temp;\\n            ans=l1;\\n        }\\n        \\n\\t\\t//Traversing and rearranging the nodes in sorted order\\n        while(l1!=null && l2!=null) {\\n            ListNode temp = null;\\n            while(l1!=null && l1.val<=l2.val) {    // if value at l1 is smaller\\n                temp = l1;\\n                l1=l1.next;\\n            }   // exchange l1 and l2\\n            temp.next = l2;\\n            temp = l1;\\n            l1=l2;\\n            l2=temp;\\n        }\\n        return ans;\\n    }\\n    \\n    public ListNode sortList(ListNode head) {\\n        //base case\\n        if(head==null || head.next==null) return head;\\n        \\n        //break linkedlist into 2 halves\\n        ListNode mid = findMid(head);\\n        \\n        ListNode left = head;\\n        ListNode right = mid.next;\\n        mid.next=null;\\n        \\n        //recursive calls to sort both the linkedlists\\n        left = sortList(left);\\n        right = sortList(right);\\n        \\n        //merge two sorted linked list\\n        ListNode ans  = merge(left,right);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724787,
                "title": "python-solution-2-approaches-time-o-nlogn-space-o-n-and-o-logn",
                "content": "```\\n# ---------------------------- 1st Approach using extra array T : O(nlogn) and S : O(n) ----------------------------\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        curr = head\\n        while curr:\\n            nums.append(curr.val)\\n            curr = curr.next\\n            \\n        nums.sort()                                # sorting use O(nlogn) time complexity\\n        curr = head\\n        for i in nums:\\n            curr.val = i\\n            curr = curr.next\\n            \\n        return head\\n\\t\\t\\n# As we are using extra array nums storing each value node into array and sorting nums and again\\n# sorted nums is stored as new linked list, that\\'s why space complexity - O(n)\\n\\t\\n# ---------------------------- 2nd Approach Merge Sort T : O(nlogn) and S : O(logn) ----------------------------\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # base case \\n        if not head  or not head.next:\\n            return head\\n        \\n        # split the list into 2 halfs\\n        left = head\\n        right = self.getMid(head)\\n        tmp = right.next\\n        right.next = None\\n        right = tmp\\n        \\n        left = self.sortList(left)\\n        right = self.sortList(right)\\n        \\n        return self.mergeLists(left, right)\\n    \\n    # using slow and fast pointers and return slow\\n    def getMid(self, head):\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        return slow\\n    \\n    # merge the left and right lists\\n    def mergeLists(self, list1, list2):\\n        tail = dummy = ListNode()\\n        \\n        while list1 and list2:\\n            if list1.val < list2.val:\\n                tail.next = list1\\n                list1 = list1.next\\n            else:\\n                tail.next = list2\\n                list2 = list2.next\\n                \\n            tail = tail.next\\n        \\n        if list1:\\n            tail.next = list1\\n        else:\\n            tail.next = list2\\n            \\n        return dummy.next\\n\\n# Recursion used extra space for handling multiple return statements\\n# in the call stack that\\'s why space complexity O(logn)\\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\n# ---------------------------- 1st Approach using extra array T : O(nlogn) and S : O(n) ----------------------------\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        curr = head\\n        while curr:\\n            nums.append(curr.val)\\n            curr = curr.next\\n            \\n        nums.sort()                                # sorting use O(nlogn) time complexity\\n        curr = head\\n        for i in nums:\\n            curr.val = i\\n            curr = curr.next\\n            \\n        return head\\n\\t\\t\\n# As we are using extra array nums storing each value node into array and sorting nums and again\\n# sorted nums is stored as new linked list, that\\'s why space complexity - O(n)\\n\\t\\n# ---------------------------- 2nd Approach Merge Sort T : O(nlogn) and S : O(logn) ----------------------------\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # base case \\n        if not head  or not head.next:\\n            return head\\n        \\n        # split the list into 2 halfs\\n        left = head\\n        right = self.getMid(head)\\n        tmp = right.next\\n        right.next = None\\n        right = tmp\\n        \\n        left = self.sortList(left)\\n        right = self.sortList(right)\\n        \\n        return self.mergeLists(left, right)\\n    \\n    # using slow and fast pointers and return slow\\n    def getMid(self, head):\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        return slow\\n    \\n    # merge the left and right lists\\n    def mergeLists(self, list1, list2):\\n        tail = dummy = ListNode()\\n        \\n        while list1 and list2:\\n            if list1.val < list2.val:\\n                tail.next = list1\\n                list1 = list1.next\\n            else:\\n                tail.next = list2\\n                list2 = list2.next\\n                \\n            tail = tail.next\\n        \\n        if list1:\\n            tail.next = list1\\n        else:\\n            tail.next = list2\\n            \\n        return dummy.next\\n\\n# Recursion used extra space for handling multiple return statements\\n# in the call stack that\\'s why space complexity O(logn)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2673513,
                "title": "c-using-merge-sort-easy-and-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    // Function to find mid of linked list using two pointers\\n    ListNode *findMid(ListNode *head){\\n        // making fast point to head next, it will return first mid node, if there are multiple\\n        ListNode *fast = head->next;\\n        \\n        ListNode *slow = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    //Function to merge two sorted linked list\\n    ListNode *mergeList(ListNode *left, ListNode *right){\\n        // if left list is null, return right list simply\\n        if(left == NULL) return right;\\n        \\n        // if right list is null, return left list simply\\n        if(right == NULL) return left;\\n        \\n        // making dummy answer node\\n        ListNode *ans = new ListNode(0);\\n        \\n        // making temp point to ans dummy node for further operations\\n        ListNode *temp = ans;\\n        \\n        // now main logic of merging two sorted linked list\\n        while(left != NULL && right != NULL){\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n            }else{\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n            }\\n        }\\n        \\n        // while left is not null but right becomes null\\n        while(left != NULL){\\n            temp->next = left;\\n            temp = left;\\n            left = left->next;\\n        }\\n        \\n        // while right is not null but left becomes null\\n        while(right != NULL){\\n            temp->next = right;\\n            temp = right;\\n            right = right->next;\\n        }\\n        \\n        // leaving dummy node and moving to actual head of answer\\n        ans = ans->next;\\n        \\n        // returning ans, which is head of merged list\\n        return ans;\\n    }\\n    \\n    // function to sort the linked list\\n    ListNode* sortList(ListNode* head) {\\n        // base case\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        // finding mid of linked list\\n        ListNode *mid = findMid(head);\\n        \\n        // After finding mid, there are 2 halves of linked list\\n        \\n        // left half\\'s head is head itself\\n        ListNode *leftHalfHead = head;\\n        \\n        // right half\\'s head will start from next of mid\\n        ListNode *rightHalfHead = mid->next;\\n        \\n        // making mid\\'s next point to null will make it a individual list\\n        mid->next = NULL;\\n        \\n        // recursively sort the two halves\\n        leftHalfHead = sortList(leftHalfHead);\\n        rightHalfHead = sortList(rightHalfHead);\\n        \\n        // merge both halves using merge two sorted list logic\\n        ListNode *result = mergeList(leftHalfHead, rightHalfHead);\\n        \\n        // return the head of merged and sorted resultant list\\n        return result;\\n    }\\n};\\n\\n```\\n\\n**Hit upvote if somewhere it helped you :)**\\n*Thank you.*",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    // Function to find mid of linked list using two pointers\\n    ListNode *findMid(ListNode *head){\\n        // making fast point to head next, it will return first mid node, if there are multiple\\n        ListNode *fast = head->next;\\n        \\n        ListNode *slow = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    //Function to merge two sorted linked list\\n    ListNode *mergeList(ListNode *left, ListNode *right){\\n        // if left list is null, return right list simply\\n        if(left == NULL) return right;\\n        \\n        // if right list is null, return left list simply\\n        if(right == NULL) return left;\\n        \\n        // making dummy answer node\\n        ListNode *ans = new ListNode(0);\\n        \\n        // making temp point to ans dummy node for further operations\\n        ListNode *temp = ans;\\n        \\n        // now main logic of merging two sorted linked list\\n        while(left != NULL && right != NULL){\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = left;\\n                left = left->next;\\n            }else{\\n                temp->next = right;\\n                temp = right;\\n                right = right->next;\\n            }\\n        }\\n        \\n        // while left is not null but right becomes null\\n        while(left != NULL){\\n            temp->next = left;\\n            temp = left;\\n            left = left->next;\\n        }\\n        \\n        // while right is not null but left becomes null\\n        while(right != NULL){\\n            temp->next = right;\\n            temp = right;\\n            right = right->next;\\n        }\\n        \\n        // leaving dummy node and moving to actual head of answer\\n        ans = ans->next;\\n        \\n        // returning ans, which is head of merged list\\n        return ans;\\n    }\\n    \\n    // function to sort the linked list\\n    ListNode* sortList(ListNode* head) {\\n        // base case\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        // finding mid of linked list\\n        ListNode *mid = findMid(head);\\n        \\n        // After finding mid, there are 2 halves of linked list\\n        \\n        // left half\\'s head is head itself\\n        ListNode *leftHalfHead = head;\\n        \\n        // right half\\'s head will start from next of mid\\n        ListNode *rightHalfHead = mid->next;\\n        \\n        // making mid\\'s next point to null will make it a individual list\\n        mid->next = NULL;\\n        \\n        // recursively sort the two halves\\n        leftHalfHead = sortList(leftHalfHead);\\n        rightHalfHead = sortList(rightHalfHead);\\n        \\n        // merge both halves using merge two sorted list logic\\n        ListNode *result = mergeList(leftHalfHead, rightHalfHead);\\n        \\n        // return the head of merged and sorted resultant list\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540116,
                "title": "java-brute-force-vs-merge-sort-solution",
                "content": "Brute Force Solution:\\n```\\nclass Solution {\\n\\t// brute force O(n^2)\\n     public ListNode sortList(ListNode head) {\\n         if(head == null || head.next == null){\\n             return head;\\n         }\\n         List<Integer> values = new ArrayList<>();\\n         while(head != null){\\n             values.add(head.val);\\n             head = head.next;\\n         }\\n         Collections.sort(values);\\n         ListNode resultTail = new ListNode(0);\\n         ListNode resultHead = new ListNode(0, resultTail);\\n         for(Integer value : values){\\n             resultTail.next = new ListNode(value);\\n             resultTail = resultTail.next;\\n         }\\n         return resultHead.next.next;\\n     }\\n```\\n\\nMerge Sort Solution:\\n\\n```\\n    // Sorting Algorithm O(nLogn) w/ merge sort\\n    public ListNode sortList(ListNode head) {\\n        return mergeSort(head);\\n    }\\n    \\n    private ListNode mergeSort(ListNode head){\\n\\t\\t// base case\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        ListNode middle = getMiddle(head); //O(n)\\n        ListNode middleNext = middle.next;\\n\\t\\t// disconnect and separate the left list and right list\\n        middle.next = null;\\n        // merge sort first list\\n        ListNode rightList = mergeSort(head); // O(logn)* n\\n        // merge sort second list\\n        ListNode leftList = mergeSort(middleNext); // O(logn) * n\\n        // merge both lists\\n        ListNode mergedList = merge(rightList, leftList);\\n        return mergedList;\\n    }\\n    \\n    private ListNode merge(ListNode listOne, ListNode listTwo){\\n        ListNode result = null;\\n        \\n        if(rightList == null){\\n            return listTwo;\\n        }\\n        if(leftList == null){\\n            return listOne;\\n        }\\n        \\n\\t\\t// store smallest value into result list\\n        if(rightList.val <= leftList.val){\\n            result = rightList;\\n\\t\\t\\t// increment right list\\n            result.next = merge(rightList.next, leftList);\\n        }else{\\n            result = leftList;\\n\\t\\t\\t// increment left list\\n            result.next = merge(rightList, leftList.next);\\n        }\\n        return result;\\n    }\\n    \\n    private ListNode getMiddle(ListNode node){\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        \\n        \\n        // as fast steps twice as many as slow, fast will reach the end as slow reaches the middle\\n        while(fast.next != null && fast.next.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n\\t// brute force O(n^2)\\n     public ListNode sortList(ListNode head) {\\n         if(head == null || head.next == null){\\n             return head;\\n         }\\n         List<Integer> values = new ArrayList<>();\\n         while(head != null){\\n             values.add(head.val);\\n             head = head.next;\\n         }\\n         Collections.sort(values);\\n         ListNode resultTail = new ListNode(0);\\n         ListNode resultHead = new ListNode(0, resultTail);\\n         for(Integer value : values){\\n             resultTail.next = new ListNode(value);\\n             resultTail = resultTail.next;\\n         }\\n         return resultHead.next.next;\\n     }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796446,
                "title": "python3-99-01-faster-op-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return head\\n        new = []\\n        curr = head\\n        while curr:\\n            new.append(curr.val)\\n            curr = curr.next\\n\\n        new.sort()\\n\\n        curr = head\\n        index = 0\\n        while curr:\\n            curr.val = new[index]\\n            curr = curr.next\\n            index += 1\\n\\n        return head\\n```\\n\\n![image](https://assets.leetcode.com/users/images/cc544a34-1832-4fe7-9ca3-f6cd4af2d3c0_1645714185.7573817.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return head\\n        new = []\\n        curr = head\\n        while curr:\\n            new.append(curr.val)\\n            curr = curr.next\\n\\n        new.sort()\\n\\n        curr = head\\n        index = 0\\n        while curr:\\n            curr.val = new[index]\\n            curr = curr.next\\n            index += 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796194,
                "title": "brute-solution-using-vector",
                "content": "Store the elements of linkedList in a vector and sort the vector.\\nAfter sorting replace the linkedList original(unsorted) values with the sorted values from the vector.\\n\\n```\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> ans;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            ans.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(ans.begin(),ans.end());\\n        temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            temp->val=ans[i++];\\n            temp=temp->next;\\n        }\\n      return head;      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> ans;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            ans.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(ans.begin(),ans.end());\\n        temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            temp->val=ans[i++];\\n            temp=temp->next;\\n        }\\n      return head;      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795827,
                "title": "java-most-easy-solution",
                "content": "\\n\\tclass Solution {\\n    public ListNode sortList(ListNode head) {\\n       ListNode Fake = new ListNode(0);\\n        ArrayList<Integer> list = new ArrayList();\\n        ListNode temp = head;\\n        while(temp!=null){\\n            list.add(temp.val); \\n            temp=temp.next;\\n        }\\n        Collections.sort(list);\\n        ListNode FakeHead = Fake;\\n        for(int i =0; i<list.size(); i++){\\n            FakeHead.next = new ListNode(list.get(i));\\n            FakeHead = FakeHead.next;\\n        }\\n        return Fake.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n       ListNode Fake = new ListNode(0);\\n        ArrayList<Integer> list = new ArrayList();\\n        ListNode temp = head;\\n        while(temp!=null){\\n            list.add(temp.val); \\n            temp=temp.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1795310,
                "title": "python3-o-1-space-simple-and-concise-solution-with-explanation-mergesort-easy-to-understand",
                "content": "**Steps to sort using merge sort:**\\n1. Given a list find the middle (Using two pointers - Hare and Tortoise).\\n2. Break the list at middle\\n3. Repeat the steps 1 and 2 till the no of nodes in the list become two or one.\\n4. Keep merging the list in sorted order recursively (divide and conquer). \\n\\nTime Complexity: `O(NlogN)`.\\nSpace Complexity: `O(1)` (Ignoring the recursive stack space, else it will be O(logN).\\n\\n```\\nclass Solution:\\n    def findMid(self, node):\\n        slow = fast = node\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tHere the condition is till fast.next.next. \\n\\t\\tBecause, we need to should stop at first mid in case of even length, else we won\\'t be breaking the array equally.\\n\\t\\t\\n\\t\\tExample: 1->2->3->4, here we have to break at 2 so that the list will become 1 -> 2 and 3 -> 4 \\n\\t\\tif we break at 3 the list will become 1 -> 2 -> 3 and 4 which is incorrect \\n\\t\\t\\'\\'\\'\\n        while(fast.next and fast.next.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n        \\n        return slow\\n    \\n    def merge(self, node1, node2):\\n        dummy = cur = ListNode()\\n        intMax = float(\\'inf\\')\\n        \\n        while(node1 or node2):\\n            value1, value2 = node1.val if(node1) else intMax, node2.val if(node2) else intMax\\n            if(value1 < value2):\\n                cur.next = node1\\n                node1 = node1.next\\n            else:\\n                cur.next = node2\\n                node2 = node2.next\\n            cur = cur.next\\n            \\n        return dummy.next\\n            \\n    def mergeSort(self, node):\\n\\t\\t# Incase of single node or empty node we don\\'t have to do anything.\\n        if(node is None or node.next is None):  return node\\n        \\n        mid = self.findMid(node) #Find the mid\\n        nextNode = mid.next #Get the start of second half \\n        mid.next = None #Break at mid\\n        \\n        firstHalf = self.mergeSort(node)\\n        secondHalf = self.mergeSort(nextNode)\\n        \\n        return self.merge(firstHalf, secondHalf)\\n        \\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.mergeSort(head)\\n        \\n```\\n\\n**Please upvote if it helps! Thanks.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findMid(self, node):\\n        slow = fast = node\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tHere the condition is till fast.next.next. \\n\\t\\tBecause, we need to should stop at first mid in case of even length, else we won\\'t be breaking the array equally.\\n\\t\\t\\n\\t\\tExample: 1->2->3->4, here we have to break at 2 so that the list will become 1 -> 2 and 3 -> 4 \\n\\t\\tif we break at 3 the list will become 1 -> 2 -> 3 and 4 which is incorrect \\n\\t\\t\\'\\'\\'\\n        while(fast.next and fast.next.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n        \\n        return slow\\n    \\n    def merge(self, node1, node2):\\n        dummy = cur = ListNode()\\n        intMax = float(\\'inf\\')\\n        \\n        while(node1 or node2):\\n            value1, value2 = node1.val if(node1) else intMax, node2.val if(node2) else intMax\\n            if(value1 < value2):\\n                cur.next = node1\\n                node1 = node1.next\\n            else:\\n                cur.next = node2\\n                node2 = node2.next\\n            cur = cur.next\\n            \\n        return dummy.next\\n            \\n    def mergeSort(self, node):\\n\\t\\t# Incase of single node or empty node we don\\'t have to do anything.\\n        if(node is None or node.next is None):  return node\\n        \\n        mid = self.findMid(node) #Find the mid\\n        nextNode = mid.next #Get the start of second half \\n        mid.next = None #Break at mid\\n        \\n        firstHalf = self.mergeSort(node)\\n        secondHalf = self.mergeSort(nextNode)\\n        \\n        return self.merge(firstHalf, secondHalf)\\n        \\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.mergeSort(head)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770414,
                "title": "used-same-concepts-as-merge-2-sorted-list-cpp-extremely-simple",
                "content": "```\\n ListNode* merge(ListNode *l1, ListNode *l2){\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val <=l2->val){\\n            l1->next= merge(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next= merge(l1,l2->next);\\n            return l2;\\n        }\\n    }\\n    \\n   ListNode* sortList(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while (fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        //divide the list into two parts \\n        fast = slow->next;\\n        slow->next = NULL;\\n        \\n        return merge(sortList(head), sortList(fast));\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n ListNode* merge(ListNode *l1, ListNode *l2){\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val <=l2->val){\\n            l1->next= merge(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next= merge(l1,l2->next);\\n            return l2;\\n        }\\n    }\\n    \\n   ListNode* sortList(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while (fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        //divide the list into two parts \\n        fast = slow->next;\\n        slow->next = NULL;\\n        \\n        return merge(sortList(head), sortList(fast));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1451675,
                "title": "c-bottom-up-approach-merge-sort",
                "content": "**Please Upvote if you like the Code!**\\n\\n    ListNode *merge(ListNode *a,ListNode *b)\\n    {\\n        ListNode *tail=new ListNode(0);\\n        ListNode *res=tail;\\n        \\n        while(a!=nullptr && b!=nullptr)\\n        {\\n            if(a->val < b->val)\\n            {\\n                tail->next=a;\\n                tail=tail->next;\\n                a=a->next;\\n            }\\n            else\\n            {\\n                tail->next=b;\\n                tail=tail->next;\\n                b=b->next;\\n            }\\n        }\\n        if(a==nullptr)\\n            tail->next=b;\\n        else\\n            tail->next=a;\\n        \\n        return res->next;\\n        \\n    }\\n    ListNode* sortList(ListNode* head)\\n    {\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        ListNode *curr=head;\\n        \\n        ListNode *slow=head,*fast=head->next;\\n        \\n        while(fast!=nullptr && fast->next!=nullptr)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode *second=slow->next;\\n        slow->next=nullptr;\\n        \\n        return merge(sortList(curr),sortList(second));\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Merge Sort"
                ],
                "code": "**Please Upvote if you like the Code!**\\n\\n    ListNode *merge(ListNode *a,ListNode *b)\\n    {\\n        ListNode *tail=new ListNode(0);\\n        ListNode *res=tail;\\n        \\n        while(a!=nullptr && b!=nullptr)\\n        {\\n            if(a->val < b->val)\\n            {\\n                tail->next=a;\\n                tail=tail->next;\\n                a=a->next;\\n            }\\n            else\\n            {\\n                tail->next=b;\\n                tail=tail->next;\\n                b=b->next;\\n            }\\n        }\\n        if(a==nullptr)\\n            tail->next=b;\\n        else\\n            tail->next=a;\\n        \\n        return res->next;\\n        \\n    }\\n    ListNode* sortList(ListNode* head)\\n    {\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        ListNode *curr=head;\\n        \\n        ListNode *slow=head,*fast=head->next;\\n        \\n        while(fast!=nullptr && fast->next!=nullptr)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode *second=slow->next;\\n        slow->next=nullptr;\\n        \\n        return merge(sortList(curr),sortList(second));\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1311493,
                "title": "c-code",
                "content": "class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        ListNode * ac = head;\\n        vector<int> a;\\n        while (ac != NULL)\\n        {\\n            a.push_back(ac->val);\\n            ac = ac->next;\\n        }\\n        sort(a.begin(),a.end());\\n        ac = head;\\n        int i = 0;\\n        while (ac != NULL)\\n        {\\n            ac->val = a[i++];\\n            ac =  ac->next;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        ListNode * ac = head;\\n        vector<int> a;\\n        while (ac != NULL)\\n        {\\n            a.push_back(ac->val);\\n            ac = ac->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 892568,
                "title": "sort-list-java-c-o-nlogn-mergesort",
                "content": "We can do this in a regular merge sort.  There are some stardard tricks for Linked list:\\n\\n1. Slow and fast pointers to find the middle of the linked list\\n2. user a dummy node other than the head to merge\\n\\nSo now we have a O(nlogn) solution.  But wait a second, this is **not** O(1) space, it is O(logN) space.   Is O(1) space even possible?  Yes, it is called **bottom-up merge-sort**  Check this video for more info.  I need to go to sleep now. I will have a bottom-up merge-sort later. \\n\\nIf you like it, please upvote it. Thanks.\\n\\nhttps://youtu.be/WVl2QSe4R14?list=PLRdD1c6QbAqJn0606RlOR6T3yUqFWKwmX\\n\\njava\\n```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n\\t\\t\\n\\t\\t// find the middle.  Divide part\\n        ListNode slow = head, fast = head.next;\\n        while (fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode secondHead = slow.next;\\n        slow.next = null;\\n        head = sortList(head);\\n        secondHead = sortList(secondHead);\\n\\n\\t\\t//Merge the two lists.  Conquer part\\n\\t\\tListNode dummy = new ListNode();\\n        ListNode prev = dummy;\\n        while (head != null && secondHead != null)\\n        {\\n            if (head.val < secondHead.val)\\n            {\\n                prev.next = head;\\n                head = head.next;\\n            }\\n            else\\n            {\\n                prev.next = secondHead;\\n                secondHead = secondHead.next;\\n            }\\n            prev = prev.next;\\n        }\\n        prev.next = head != null ? head : secondHead;\\n        return dummy.next;\\n    }\\n}\\n```\\n\\nc++\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\t\\t\\n\\t\\t// find the middle.  Divide part\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while (fast != nullptr && fast->next != nullptr)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* secondHead = slow->next;\\n        slow->next = nullptr;\\n        head = sortList(head);\\n        secondHead = sortList(secondHead);\\n\\t\\t\\n\\t\\t//Merge the two lists.  Conquer part \\n\\t\\t// Don\\'t use new to allocate in heap. It is expensive\\n        ListNode dummy = ListNode(0);\\n        ListNode* prev = &dummy;\\n        while (head != nullptr && secondHead != nullptr)\\n        {\\n            if (head->val < secondHead->val)\\n            {\\n                prev->next = head;\\n                head = head->next;\\n            }\\n            else\\n            {\\n                prev->next = secondHead;\\n                secondHead = secondHead->next;\\n            }\\n            prev = prev->next;\\n        }\\n        prev->next = head != nullptr ? head : secondHead;\\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Merge Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n\\t\\t\\n\\t\\t// find the middle.  Divide part\\n        ListNode slow = head, fast = head.next;\\n        while (fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode secondHead = slow.next;\\n        slow.next = null;\\n        head = sortList(head);\\n        secondHead = sortList(secondHead);\\n\\n\\t\\t//Merge the two lists.  Conquer part\\n\\t\\tListNode dummy = new ListNode();\\n        ListNode prev = dummy;\\n        while (head != null && secondHead != null)\\n        {\\n            if (head.val < secondHead.val)\\n            {\\n                prev.next = head;\\n                head = head.next;\\n            }\\n            else\\n            {\\n                prev.next = secondHead;\\n                secondHead = secondHead.next;\\n            }\\n            prev = prev.next;\\n        }\\n        prev.next = head != null ? head : secondHead;\\n        return dummy.next;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\t\\t\\n\\t\\t// find the middle.  Divide part\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while (fast != nullptr && fast->next != nullptr)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* secondHead = slow->next;\\n        slow->next = nullptr;\\n        head = sortList(head);\\n        secondHead = sortList(secondHead);\\n\\t\\t\\n\\t\\t//Merge the two lists.  Conquer part \\n\\t\\t// Don\\'t use new to allocate in heap. It is expensive\\n        ListNode dummy = ListNode(0);\\n        ListNode* prev = &dummy;\\n        while (head != nullptr && secondHead != nullptr)\\n        {\\n            if (head->val < secondHead->val)\\n            {\\n                prev->next = head;\\n                head = head->next;\\n            }\\n            else\\n            {\\n                prev->next = secondHead;\\n                secondHead = secondHead->next;\\n            }\\n            prev = prev->next;\\n        }\\n        prev->next = head != nullptr ? head : secondHead;\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799446,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* sortList(ListNode* head) \\n\\t{\\n        if (head == nullptr || head->next == nullptr)\\n            return head;\\n\\t\\t\\t\\n        ListNode* second = splitList(head);\\n        head = sortList(head);\\n        second = sortList(second);\\n        return mergeSort(head, second);\\n    }\\n    \\n    ListNode* splitList(ListNode*& head)\\n\\t{\\n        ListNode *slow = head, *fast = head->next;\\n        while (fast != nullptr)\\n\\t\\t{\\n            fast = fast->next;\\n            if (fast != nullptr)\\n\\t\\t\\t{\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n        }\\n\\t\\t\\n        ListNode* second = slow->next;\\n        slow->next = nullptr;\\n        return second;\\n    }\\n    \\n    ListNode* mergeSort (ListNode* first, ListNode* second)\\n\\t{\\n        if (first == nullptr)\\n            return second;\\n\\t\\t\\t\\n        if (second == nullptr)\\n            return first;\\n\\t\\t\\t\\n        if (first->val < second->val)\\n\\t\\t{\\n            first->next = mergeSort(first->next, second);\\n            return first;\\n        }\\n        else\\n\\t\\t{\\n            second->next = mergeSort(first, second->next);\\n            return second;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* sortList(ListNode* head) \\n\\t{\\n        if (head == nullptr || head->next == nullptr)\\n            return head;\\n\\t\\t\\t\\n        ListNode* second = splitList(head);\\n        head = sortList(head);\\n        second = sortList(second);\\n        return mergeSort(head, second);\\n    }\\n    \\n    ListNode* splitList(ListNode*& head)\\n\\t{\\n        ListNode *slow = head, *fast = head->next;\\n        while (fast != nullptr)\\n\\t\\t{\\n            fast = fast->next;\\n            if (fast != nullptr)\\n\\t\\t\\t{\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n        }\\n\\t\\t\\n        ListNode* second = slow->next;\\n        slow->next = nullptr;\\n        return second;\\n    }\\n    \\n    ListNode* mergeSort (ListNode* first, ListNode* second)\\n\\t{\\n        if (first == nullptr)\\n            return second;\\n\\t\\t\\t\\n        if (second == nullptr)\\n            return first;\\n\\t\\t\\t\\n        if (first->val < second->val)\\n\\t\\t{\\n            first->next = mergeSort(first->next, second);\\n            return first;\\n        }\\n        else\\n\\t\\t{\\n            second->next = mergeSort(first, second->next);\\n            return second;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758939,
                "title": "java-97-56-fast-explained-method-mergesort",
                "content": "If you found the solution helpful, kindly upvote and like. :)\\n\\n**MAIN METHOD**\\n1. Split the list into 2 halves, using slow and fast pointer.\\n2. Split recursively the left and right side\\n3. Merge both the sides and return \\n\\n```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n            \\tif(head==null || head.next==null) return head;\\n    \\tListNode prev= null;\\n    \\tListNode slow= head;\\n    \\tListNode fast= head;\\n    \\t\\n    \\twhile(fast!= null && fast.next !=null)\\n    \\t{\\n    \\t\\tprev=slow;\\n    \\t\\tslow= slow.next;\\n    \\t\\tfast=fast.next.next;\\n    \\t}\\n    \\t//Making 2 different list\\n    \\tprev.next=null;\\n    \\tListNode leftSide= sortList(head);\\n    \\tListNode rightSide= sortList(slow);\\n    \\t\\n    \\treturn merge(leftSide, rightSide);\\n    }\\n\\n\\tprivate ListNode merge(ListNode l, ListNode m)\\n\\t{\\n\\t\\tListNode node= new ListNode(0);\\n\\t\\tListNode temp= node;\\n\\t\\t\\n\\t\\t//Merging both the lists\\n\\t\\twhile(l!= null && m!= null)\\n\\t\\t{\\n\\t\\t\\tif(l.val < m.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.next= l;\\n\\t\\t\\t\\tl=l.next;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.next= m;\\n\\t\\t\\t\\tm=m.next;\\n\\t\\t\\t}\\n\\t\\t\\t//Updating the temp for next iteration\\n\\t\\t\\ttemp= temp.next;\\n\\t\\t}\\n\\t\\tif(l!=null)\\n\\t\\t{\\n\\t\\t\\ttemp.next= l;\\n\\t\\t\\tl=l.next;\\n\\t\\t}\\n\\t\\tif(m!=null)\\n\\t\\t{\\n\\t\\t\\ttemp.next= m;\\n\\t\\t\\tm=m.next;\\n\\t\\t}\\n\\t\\treturn node.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n            \\tif(head==null || head.next==null) return head;\\n    \\tListNode prev= null;\\n    \\tListNode slow= head;\\n    \\tListNode fast= head;\\n    \\t\\n    \\twhile(fast!= null && fast.next !=null)\\n    \\t{\\n    \\t\\tprev=slow;\\n    \\t\\tslow= slow.next;\\n    \\t\\tfast=fast.next.next;\\n    \\t}\\n    \\t//Making 2 different list\\n    \\tprev.next=null;\\n    \\tListNode leftSide= sortList(head);\\n    \\tListNode rightSide= sortList(slow);\\n    \\t\\n    \\treturn merge(leftSide, rightSide);\\n    }\\n\\n\\tprivate ListNode merge(ListNode l, ListNode m)\\n\\t{\\n\\t\\tListNode node= new ListNode(0);\\n\\t\\tListNode temp= node;\\n\\t\\t\\n\\t\\t//Merging both the lists\\n\\t\\twhile(l!= null && m!= null)\\n\\t\\t{\\n\\t\\t\\tif(l.val < m.val)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.next= l;\\n\\t\\t\\t\\tl=l.next;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.next= m;\\n\\t\\t\\t\\tm=m.next;\\n\\t\\t\\t}\\n\\t\\t\\t//Updating the temp for next iteration\\n\\t\\t\\ttemp= temp.next;\\n\\t\\t}\\n\\t\\tif(l!=null)\\n\\t\\t{\\n\\t\\t\\ttemp.next= l;\\n\\t\\t\\tl=l.next;\\n\\t\\t}\\n\\t\\tif(m!=null)\\n\\t\\t{\\n\\t\\t\\ttemp.next= m;\\n\\t\\t\\tm=m.next;\\n\\t\\t}\\n\\t\\treturn node.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535583,
                "title": "merge-sort",
                "content": "```\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head\\n    }\\n    \\n    const mid = findMid(head)\\n    const right = sortList(mid.next)\\n    mid.next = null\\n    const left = sortList(head)\\n    \\n    return merge(left, right)\\n};\\n```\\n```\\nconst findMid = (head) => {\\n    let slow = head, fast = head.next\\n    \\n    while(fast !== null && fast.next !== null) {\\n        slow = slow.next\\n        fast = fast.next.next\\n    }\\n    \\n    return slow\\n}\\n```\\n```\\nconst merge = (l1, l2) => {\\n    let dummy = new ListNode(0)\\n    let p = dummy\\n    while (l1 !== null && l2 !== null) {\\n        if (l1.val < l2.val) {\\n            p.next = l1\\n            l1 = l1.next\\n        } else {\\n            p.next = l2\\n            l2 = l2.next\\n        }\\n        p = p.next\\n    }\\n    \\n    if (l1 !== null) {\\n        p.next = l1\\n    }\\n    \\n    if (l2 !== null) {\\n        p.next = l2\\n    }\\n    return dummy.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head\\n    }\\n    \\n    const mid = findMid(head)\\n    const right = sortList(mid.next)\\n    mid.next = null\\n    const left = sortList(head)\\n    \\n    return merge(left, right)\\n};\\n```\n```\\nconst findMid = (head) => {\\n    let slow = head, fast = head.next\\n    \\n    while(fast !== null && fast.next !== null) {\\n        slow = slow.next\\n        fast = fast.next.next\\n    }\\n    \\n    return slow\\n}\\n```\n```\\nconst merge = (l1, l2) => {\\n    let dummy = new ListNode(0)\\n    let p = dummy\\n    while (l1 !== null && l2 !== null) {\\n        if (l1.val < l2.val) {\\n            p.next = l1\\n            l1 = l1.next\\n        } else {\\n            p.next = l2\\n            l2 = l2.next\\n        }\\n        p = p.next\\n    }\\n    \\n    if (l1 !== null) {\\n        p.next = l1\\n    }\\n    \\n    if (l2 !== null) {\\n        p.next = l2\\n    }\\n    return dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409489,
                "title": "simple-ruby-solution-using-merge-sort-recursion",
                "content": "```\\ndef sort_list(head)\\n  return head if head.nil? || head.next.nil?\\n  a, b = split(head)\\n  a = sort_list(a)\\n  b = sort_list(b)\\n  merge(a, b)\\nend\\n\\ndef merge(a, b)\\n  head = curr = prev = ListNode.new(0)\\n  while(a && b)\\n    if a.val < b.val\\n      prev.next = a\\n      a = a.next\\n    else\\n      prev.next = b\\n      b = b.next\\n    end\\n    prev = prev.next\\n  end\\n  prev.next = a if a\\n  prev.next = b if b\\n  head.next\\nend\\n\\ndef split(head)\\n  prev = nil\\n  slow = fast = head\\n  while(fast && fast.next)\\n    prev = slow\\n    slow = slow.next\\n    fast = fast.next.next\\n  end\\n  prev.next = nil\\n  [head, slow]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\ndef sort_list(head)\\n  return head if head.nil? || head.next.nil?\\n  a, b = split(head)\\n  a = sort_list(a)\\n  b = sort_list(b)\\n  merge(a, b)\\nend\\n\\ndef merge(a, b)\\n  head = curr = prev = ListNode.new(0)\\n  while(a && b)\\n    if a.val < b.val\\n      prev.next = a\\n      a = a.next\\n    else\\n      prev.next = b\\n      b = b.next\\n    end\\n    prev = prev.next\\n  end\\n  prev.next = a if a\\n  prev.next = b if b\\n  head.next\\nend\\n\\ndef split(head)\\n  prev = nil\\n  slow = fast = head\\n  while(fast && fast.next)\\n    prev = slow\\n    slow = slow.next\\n    fast = fast.next.next\\n  end\\n  prev.next = nil\\n  [head, slow]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 378465,
                "title": "clean-and-efficient-quick-sort-w-3-way-partition-python-solution",
                "content": "Suggestion: solve problem [86 Partition List](https://leetcode.com/problems/partition-list/description/) before solving this problem, as quick sort will rely on the implementation of subroutine `partition`\\n```py\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        return self._partition(head, head.val)[0]\\n\\n    # 3 way partition\\n    def _partition(self, head, pivot):\\n        if not head or not head.next:\\n            return head, head\\n\\n        # create list to hold nodes < pivot, nodes == pivot, nodes > pivot\\n        smaller, middle, larger = ListNode(-1), ListNode(-1), ListNode(-1)\\n        s, m, l = smaller, middle, larger\\n\\n        while head:\\n            if head.val < pivot:\\n                s.next = head\\n                s = head\\n            elif head.val == pivot:\\n                m.next = head\\n                m = head\\n            else:\\n                l.next = head\\n                l = head\\n            head = head.next\\n\\n        # separate these three parts\\n        s.next = None\\n        m.next = None\\n        l.next = None\\n\\n        # first paritition the smaller part and larger part\\n        lh, lt = self._partition(smaller.next, smaller.next.val if smaller.next else 0)\\n        rh, rt = self._partition(larger.next, larger.next.val if larger.next else 0)\\n\\n        if lt:\\n            lt.next = middle.next\\n\\n        m.next = rh\\n\\n        return lh or middle.next, rt or m\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def sortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        return self._partition(head, head.val)[0]\\n\\n    # 3 way partition\\n    def _partition(self, head, pivot):\\n        if not head or not head.next:\\n            return head, head\\n\\n        # create list to hold nodes < pivot, nodes == pivot, nodes > pivot\\n        smaller, middle, larger = ListNode(-1), ListNode(-1), ListNode(-1)\\n        s, m, l = smaller, middle, larger\\n\\n        while head:\\n            if head.val < pivot:\\n                s.next = head\\n                s = head\\n            elif head.val == pivot:\\n                m.next = head\\n                m = head\\n            else:\\n                l.next = head\\n                l = head\\n            head = head.next\\n\\n        # separate these three parts\\n        s.next = None\\n        m.next = None\\n        l.next = None\\n\\n        # first paritition the smaller part and larger part\\n        lh, lt = self._partition(smaller.next, smaller.next.val if smaller.next else 0)\\n        rh, rt = self._partition(larger.next, larger.next.val if larger.next else 0)\\n\\n        if lt:\\n            lt.next = middle.next\\n\\n        m.next = rh\\n\\n        return lh or middle.next, rt or m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366824,
                "title": "javascript-merge-sort",
                "content": "```\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    \\n    let slow = head, \\n        temp = head, \\n        fast = head;\\n    \\n    while (fast !== null && fast.next !== null) {\\n        temp = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    temp.next = null;\\n    return merge(sortList(head), sortList(slow));\\n};\\n\\n\\nvar merge = function(A,B) {\\n    let sorted = new ListNode(0);\\n    let current = sorted;\\n    \\n    while (A !== null && B !== null) {\\n        if (B.val < A.val) {\\n            current.next = B;\\n            B = B.next;\\n        } else {\\n            current.next = A;\\n            A = A.next;\\n        }\\n        \\n        current = current.next;\\n   }\\n    \\n    while (A !== null) {\\n        current.next = A;\\n        A = A.next;\\n        current = current.next;\\n    }\\n    \\n    while (B !== null) {\\n        current.next = B;\\n        B = B.next;\\n        current = current.next;\\n    }\\n    \\n    return sorted.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortList = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    \\n    let slow = head, \\n        temp = head, \\n        fast = head;\\n    \\n    while (fast !== null && fast.next !== null) {\\n        temp = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    temp.next = null;\\n    return merge(sortList(head), sortList(slow));\\n};\\n\\n\\nvar merge = function(A,B) {\\n    let sorted = new ListNode(0);\\n    let current = sorted;\\n    \\n    while (A !== null && B !== null) {\\n        if (B.val < A.val) {\\n            current.next = B;\\n            B = B.next;\\n        } else {\\n            current.next = A;\\n            A = A.next;\\n        }\\n        \\n        current = current.next;\\n   }\\n    \\n    while (A !== null) {\\n        current.next = A;\\n        A = A.next;\\n        current = current.next;\\n    }\\n    \\n    while (B !== null) {\\n        current.next = B;\\n        B = B.next;\\n        current = current.next;\\n    }\\n    \\n    return sorted.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328177,
                "title": "c-99-beat-no-extra-memory-bottom-up-sort-koderz-kamp",
                "content": "It\\'s a lot easier to describe this than to implement it.\\n\\nEssentially we start with the assumption that all sub-lists of length 1 are already sorted.\\n\\nNext, we multiply our merge length by 2 (=2) and we merge all of the sorted 1-length sub-lists.\\n\\nNext, we multiply our merge length by 2 (=4) and we merge all of the sorted 2-length sub-lists.\\n\\nWe keep going until we have merged the entire thing.\\n\\nThere is no need to make recursive calls or have any computationally relevant extra memory allocations.\\n\\nThe implementation can maybe be shorter, this gets you good speed though.\\n\\nUsed 2 sentinel nodes, one is used for merging and one is used for stitching...\\n\\nEnJoY!!! GG!!! LOOL!!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode *mMergeSentinel;\\n    ListNode *mLinkSentinel;\\n    \\n    ListNode* sortList(ListNode* head) {\\n        \\n        ListNode *aNode = head;\\n        int aCount = 0;\\n        while (aNode != NULL) {\\n            aNode = aNode->next;\\n            aCount += 1;\\n        }\\n        \\n        if (aCount <= 1) { return head; }\\n        \\n        mMergeSentinel = new ListNode(0);\\n        mLinkSentinel = new ListNode(0);\\n        \\n        mLinkSentinel->next = head;\\n        \\n        for (int aSplitSize=2;aSplitSize<(aCount << 1);aSplitSize <<= 1) {\\n            ListNode *aHalf1 = NULL, *aHalf2 = NULL;\\n            ListNode *aHold = mLinkSentinel;\\n            \\n            aNode = mLinkSentinel->next;\\n            mLinkSentinel->next = NULL;\\n            \\n            ListNode *aMergeHead = NULL, *aMergeTail = NULL;\\n            \\n            while (aNode != NULL) {\\n                aNode = split(aNode, aSplitSize, &aHalf1, &aHalf2);\\n\\n                merge(aHalf1, aHalf2, &aMergeHead, &aMergeTail);\\n                \\n                if (mLinkSentinel->next == NULL) { mLinkSentinel->next = aMergeHead; }\\n                \\n                aHold->next = aMergeHead;\\n                aHold = aMergeTail;\\n            }\\n        }\\n        \\n        ListNode *aResult = mLinkSentinel->next;\\n        delete mMergeSentinel;\\n        delete mLinkSentinel;\\n        return aResult;\\n    }\\n    \\n    void merge(ListNode *pHalf1, ListNode *pHalf2, ListNode **pHead, ListNode **pTail) {\\n        \\n        if (pHalf1 == NULL || pHalf2 == NULL) { \\n            *pHead = pHalf1;\\n            *pTail = pHalf1;\\n            while (pHalf1 != NULL) {\\n                *pTail = pHalf1;\\n                pHalf1 = pHalf1->next;\\n            }\\n            return;\\n        }\\n        \\n        ListNode *aHold = mMergeSentinel;\\n        ListNode *aNext = NULL;\\n        \\n        while (pHalf1 && pHalf2) {\\n            if (pHalf1->val < pHalf2->val) {\\n                aHold->next = pHalf1;\\n                aHold=pHalf1;\\n                pHalf1=pHalf1->next;\\n            } else {\\n                aHold->next = pHalf2;\\n                aHold=pHalf2;\\n                pHalf2=pHalf2->next;\\n            }\\n        }\\n        \\n        while (pHalf1) {\\n            aHold->next = pHalf1;\\n            aHold=pHalf1;\\n            pHalf1=pHalf1->next;\\n        }\\n        \\n        while (pHalf2) {\\n            aHold->next = pHalf2;\\n            aHold=pHalf2;\\n            pHalf2=pHalf2->next;\\n        }\\n        \\n        aHold->next = NULL;\\n        \\n        *pHead = mMergeSentinel->next;\\n        *pTail = aHold;\\n    }\\n    \\n    ListNode *split(ListNode *pNode, int pCount, ListNode **pHalf1, ListNode **pHalf2) {\\n        ListNode *aFast = pNode, *aSlow = pNode, *aFastPrev = NULL, *aSlowPrev = NULL;\\n        \\n        int aCount = pCount;\\n        while (aFast != NULL && aCount > 0) {\\n            aFastPrev = aFast;\\n            aFast = aFast->next;\\n            aCount--;\\n        }\\n        \\n        aCount = (pCount / 2);\\n        while (aSlow != NULL && aCount > 0) {\\n            aSlowPrev = aSlow;\\n            aSlow = aSlow->next;\\n            aCount--;\\n        }\\n        \\n        aFastPrev->next = NULL;\\n        if (aSlowPrev != NULL) { aSlowPrev->next = NULL;  }\\n        \\n        *pHalf1 = pNode;\\n        *pHalf2 = aSlow;\\n        \\n        return aFast;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *mMergeSentinel;\\n    ListNode *mLinkSentinel;\\n    \\n    ListNode* sortList(ListNode* head) {\\n        \\n        ListNode *aNode = head;\\n        int aCount = 0;\\n        while (aNode != NULL) {\\n            aNode = aNode->next;\\n            aCount += 1;\\n        }\\n        \\n        if (aCount <= 1) { return head; }\\n        \\n        mMergeSentinel = new ListNode(0);\\n        mLinkSentinel = new ListNode(0);\\n        \\n        mLinkSentinel->next = head;\\n        \\n        for (int aSplitSize=2;aSplitSize<(aCount << 1);aSplitSize <<= 1) {\\n            ListNode *aHalf1 = NULL, *aHalf2 = NULL;\\n            ListNode *aHold = mLinkSentinel;\\n            \\n            aNode = mLinkSentinel->next;\\n            mLinkSentinel->next = NULL;\\n            \\n            ListNode *aMergeHead = NULL, *aMergeTail = NULL;\\n            \\n            while (aNode != NULL) {\\n                aNode = split(aNode, aSplitSize, &aHalf1, &aHalf2);\\n\\n                merge(aHalf1, aHalf2, &aMergeHead, &aMergeTail);\\n                \\n                if (mLinkSentinel->next == NULL) { mLinkSentinel->next = aMergeHead; }\\n                \\n                aHold->next = aMergeHead;\\n                aHold = aMergeTail;\\n            }\\n        }\\n        \\n        ListNode *aResult = mLinkSentinel->next;\\n        delete mMergeSentinel;\\n        delete mLinkSentinel;\\n        return aResult;\\n    }\\n    \\n    void merge(ListNode *pHalf1, ListNode *pHalf2, ListNode **pHead, ListNode **pTail) {\\n        \\n        if (pHalf1 == NULL || pHalf2 == NULL) { \\n            *pHead = pHalf1;\\n            *pTail = pHalf1;\\n            while (pHalf1 != NULL) {\\n                *pTail = pHalf1;\\n                pHalf1 = pHalf1->next;\\n            }\\n            return;\\n        }\\n        \\n        ListNode *aHold = mMergeSentinel;\\n        ListNode *aNext = NULL;\\n        \\n        while (pHalf1 && pHalf2) {\\n            if (pHalf1->val < pHalf2->val) {\\n                aHold->next = pHalf1;\\n                aHold=pHalf1;\\n                pHalf1=pHalf1->next;\\n            } else {\\n                aHold->next = pHalf2;\\n                aHold=pHalf2;\\n                pHalf2=pHalf2->next;\\n            }\\n        }\\n        \\n        while (pHalf1) {\\n            aHold->next = pHalf1;\\n            aHold=pHalf1;\\n            pHalf1=pHalf1->next;\\n        }\\n        \\n        while (pHalf2) {\\n            aHold->next = pHalf2;\\n            aHold=pHalf2;\\n            pHalf2=pHalf2->next;\\n        }\\n        \\n        aHold->next = NULL;\\n        \\n        *pHead = mMergeSentinel->next;\\n        *pTail = aHold;\\n    }\\n    \\n    ListNode *split(ListNode *pNode, int pCount, ListNode **pHalf1, ListNode **pHalf2) {\\n        ListNode *aFast = pNode, *aSlow = pNode, *aFastPrev = NULL, *aSlowPrev = NULL;\\n        \\n        int aCount = pCount;\\n        while (aFast != NULL && aCount > 0) {\\n            aFastPrev = aFast;\\n            aFast = aFast->next;\\n            aCount--;\\n        }\\n        \\n        aCount = (pCount / 2);\\n        while (aSlow != NULL && aCount > 0) {\\n            aSlowPrev = aSlow;\\n            aSlow = aSlow->next;\\n            aCount--;\\n        }\\n        \\n        aFastPrev->next = NULL;\\n        if (aSlowPrev != NULL) { aSlowPrev->next = NULL;  }\\n        \\n        *pHalf1 = pNode;\\n        *pHalf2 = aSlow;\\n        \\n        return aFast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328102,
                "title": "c-98-beat-o-n-lg-n-with-o-n-memory-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *mSentinel;\\n    \\n    ListNode* sortList(ListNode* head) {\\n        mSentinel = new ListNode(0);\\n        ListNode *aNode = head;\\n        ListNode *aPrev = NULL;\\n        while (aNode) {\\n            aPrev = aNode;\\n            aNode = aNode->next;\\n        }\\n        if (aPrev != NULL) { return helper(head, aPrev); }\\n        return NULL;\\n    }\\n    \\n    ListNode* helper(ListNode *pHead, ListNode *pTail) {\\n        \\n        //We will always NULL terminate these list snips.\\n        pTail->next = NULL;\\n        \\n        if (pHead == pTail) {\\n            //Single node case...\\n            return pHead;\\n        } else if (pHead->next == pTail) {\\n            \\n            //Two-node case...\\n            \\n            if (pHead->val < pTail->val) {\\n                //Already sorted...\\n                return pHead;\\n            } else {\\n                //Reverse the two nodes...\\n                pTail->next = pHead;\\n                pHead->next = NULL;\\n                return pTail;\\n            }\\n        }\\n        \\n        //Do merge sort...\\n        ListNode *aFast = pHead;\\n        ListNode *aMid = pHead;\\n        ListNode *aPrev = NULL;\\n        \\n        while (aFast != NULL && aFast->next != NULL) {\\n            aPrev = aMid;\\n            aMid = aMid->next;\\n            aFast = aFast->next->next;\\n        }\\n        \\n        ListNode *aHalf1 = helper(pHead, aPrev);\\n        ListNode *aHalf2 = helper(aMid,  pTail);\\n        ListNode *aNext = NULL;\\n        \\n        aPrev = mSentinel;\\n        aPrev->next = NULL;\\n        \\n        #define MH1 aNext = aHalf1->next; aHalf1->next = NULL; aPrev->next = aHalf1; aPrev = aHalf1; aHalf1 = aNext;\\n        #define MH2 aNext = aHalf2->next; aHalf2->next = NULL; aPrev->next = aHalf2; aPrev = aHalf2; aHalf2 = aNext;\\n        \\n        while (aHalf1 != NULL && aHalf2 != NULL) {\\n            if (aHalf1->val < aHalf2->val) {\\n                MH1;\\n            } else {\\n                MH2;\\n            }\\n        }\\n        \\n        while (aHalf1 != NULL) { MH1; }\\n        while (aHalf2 != NULL) { MH2; }\\n        \\n        return mSentinel->next;\\n    }\\n    \\n    \\n};\\n```\\n\\nThe reason why memory is O(N) is because of the call-stack. The call-stack can get up to O(LOG(N)) Deep, however, we have head recursion. So, there will be One call at level 0, 2 calls at level 1, 4 calls at level 2, etc. This cancels out the logrithmic depth and we wind up right back with O(N) memory complexity.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *mSentinel;\\n    \\n    ListNode* sortList(ListNode* head) {\\n        mSentinel = new ListNode(0);\\n        ListNode *aNode = head;\\n        ListNode *aPrev = NULL;\\n        while (aNode) {\\n            aPrev = aNode;\\n            aNode = aNode->next;\\n        }\\n        if (aPrev != NULL) { return helper(head, aPrev); }\\n        return NULL;\\n    }\\n    \\n    ListNode* helper(ListNode *pHead, ListNode *pTail) {\\n        \\n        //We will always NULL terminate these list snips.\\n        pTail->next = NULL;\\n        \\n        if (pHead == pTail) {\\n            //Single node case...\\n            return pHead;\\n        } else if (pHead->next == pTail) {\\n            \\n            //Two-node case...\\n            \\n            if (pHead->val < pTail->val) {\\n                //Already sorted...\\n                return pHead;\\n            } else {\\n                //Reverse the two nodes...\\n                pTail->next = pHead;\\n                pHead->next = NULL;\\n                return pTail;\\n            }\\n        }\\n        \\n        //Do merge sort...\\n        ListNode *aFast = pHead;\\n        ListNode *aMid = pHead;\\n        ListNode *aPrev = NULL;\\n        \\n        while (aFast != NULL && aFast->next != NULL) {\\n            aPrev = aMid;\\n            aMid = aMid->next;\\n            aFast = aFast->next->next;\\n        }\\n        \\n        ListNode *aHalf1 = helper(pHead, aPrev);\\n        ListNode *aHalf2 = helper(aMid,  pTail);\\n        ListNode *aNext = NULL;\\n        \\n        aPrev = mSentinel;\\n        aPrev->next = NULL;\\n        \\n        #define MH1 aNext = aHalf1->next; aHalf1->next = NULL; aPrev->next = aHalf1; aPrev = aHalf1; aHalf1 = aNext;\\n        #define MH2 aNext = aHalf2->next; aHalf2->next = NULL; aPrev->next = aHalf2; aPrev = aHalf2; aHalf2 = aNext;\\n        \\n        while (aHalf1 != NULL && aHalf2 != NULL) {\\n            if (aHalf1->val < aHalf2->val) {\\n                MH1;\\n            } else {\\n                MH2;\\n            }\\n        }\\n        \\n        while (aHalf1 != NULL) { MH1; }\\n        while (aHalf2 != NULL) { MH2; }\\n        \\n        return mSentinel->next;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296000,
                "title": "bubble-sort-for-linked-list-python",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def sortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        swap = 0\\n        if head != None:\\n            while(1):\\n\\n                swap = 0\\n                tmp = head\\n                while(tmp.next != None):\\n                    if tmp.val > tmp.next.val:\\n                        # swap them\\n                        swap += 1\\n                        p = tmp.val\\n                        tmp.val = tmp.next.val\\n                        tmp.next.val = p\\n                        tmp = tmp.next\\n                    else:\\n                        tmp = tmp.next\\n\\n                if swap == 0:\\n                    break\\n                else:\\n                    continue\\n\\n\\n\\n            return head\\n        else:\\n            return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def sortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        swap = 0\\n        if head != None:\\n            while(1):\\n\\n                swap = 0\\n                tmp = head\\n                while(tmp.next != None):\\n                    if tmp.val > tmp.next.val:\\n                        # swap them\\n                        swap += 1\\n                        p = tmp.val\\n                        tmp.val = tmp.next.val\\n                        tmp.next.val = p\\n                        tmp = tmp.next\\n                    else:\\n                        tmp = tmp.next\\n\\n                if swap == 0:\\n                    break\\n                else:\\n                    continue\\n\\n\\n\\n            return head\\n        else:\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221219,
                "title": "python-heap-sort-o-n-log-n-amortized-o-1-auxiliary-space",
                "content": "This might be considered taking a shortcut. However, we can use constant extra space if we empty out the given linkedlist into a heap. \\nThis operation will be O(n) (Helpful explanation: https://www.growingwiththeweb.com/data-structures/binary-heap/build-heap-proof/). \\n\\nThen we pop elements off the heap and add them to a new linkedlist which will naturally be sorted. Since each time we pop an element off, we have to heapify which is O (log n), the total time complexity for this operation is O(n log n). So, the total time complexity for all of these operations is O(n log n), and technically we did not use any auxilary space.\\n\\nNote: the reason I say this does not use extra space is because once we set the pointer for head to head.next, the original value of head will be dereferenced. Consequently, it will be GCed since the python reference counter will detect there\\'s no pointer to ListNode object. Additionally, python lists are dynamic arrays so they will not grow much faster than the speed at which the linkedlist shrink.\\n\\nThis was my thought process. I would love to get some feedback. What do you guys think?\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass Solution(object):\\n    def sortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n          return head\\n        h = []\\n        while head:\\n          heapq.heappush(h, head.val)\\n          head = head.next\\n        dummy = ListNode(0)\\n        head = dummy\\n        while h:\\n          head.next = ListNode(heapq.heappop(h))\\n          head = head.next\\n        return dummy.next",
                "solutionTags": [],
                "code": "This might be considered taking a shortcut. However, we can use constant extra space if we empty out the given linkedlist into a heap. \\nThis operation will be O(n) (Helpful explanation: https://www.growingwiththeweb.com/data-structures/binary-heap/build-heap-proof/). \\n\\nThen we pop elements off the heap and add them to a new linkedlist which will naturally be sorted. Since each time we pop an element off, we have to heapify which is O (log n), the total time complexity for this operation is O(n log n). So, the total time complexity for all of these operations is O(n log n), and technically we did not use any auxilary space.\\n\\nNote: the reason I say this does not use extra space is because once we set the pointer for head to head.next, the original value of head will be dereferenced. Consequently, it will be GCed since the python reference counter will detect there\\'s no pointer to ListNode object. Additionally, python lists are dynamic arrays so they will not grow much faster than the speed at which the linkedlist shrink.\\n\\nThis was my thought process. I would love to get some feedback. What do you guys think?\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass Solution(object):\\n    def sortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n          return head\\n        h = []\\n        while head:\\n          heapq.heappush(h, head.val)\\n          head = head.next\\n        dummy = ListNode(0)\\n        head = dummy\\n        while h:\\n          head.next = ListNode(heapq.heappop(h))\\n          head = head.next\\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 183414,
                "title": "java-standard-bottom-up-binary-reduction",
                "content": "The two for loop is the commonly used format for bottom up binary reduction. For the list, we need to know the size of each merge part (len1, len2 in the code). The remaining code is the same as Merge Two Sorted List.\n\nSimlified version for quick view:\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        int len = 0;\n        ListNode curNode = head;\n        //get the length of the list\n        while(curNode!=null) {\n            curNode = curNode.next;\n            len++;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        // binary reduction\n        for(int w=1;w<len;w*=2) {\n            curNode = dummy;\n            for(int i=0;i<len-w;i+=2*w) { // 0,2\n                // head 1: i; head 2: i+w\n                // each list length: \n                int len1 = Math.min(w,len-i);\n                int len2 = Math.min(w,len-i-w);\n                ListNode h1 = curNode.next;\n                ListNode h2 = h1;\n                \n                for(int k=0; k<len1; k++) h2 = h2.next;     \n                                \n                // merge two sorted list with len1 and len2\n                /* code for merge two sorted list*/\n                ...\n                curNode.next = h2; // connect the end node with next section or null\n            }\n\n        }\n        return dummy.next;\n        \n    }\n}\n```\n\nFull version:\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        int len = 0;\n        ListNode curNode = head;\n        while(curNode!=null) {\n            curNode = curNode.next;\n            len++;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        for(int w=1;w<len;w*=2) {\n            curNode = dummy;\n            for(int i=0;i<len-w;i+=2*w) { // 0,2\n                // head 1: i; head 2: i+w\n                // each list length: \n                int len1 = Math.min(w,len-i);\n                int len2 = Math.min(w,len-i-w);\n                ListNode h1 = curNode.next;\n                ListNode h2 = h1;\n                \n                for(int k=0; k<len1; k++) h2 = h2.next;     \n                                \n                // merge two sorted list with len1 and len2\n                int cnt1 = 0, cnt2 = 0;                \n                while(cnt1<len1 && cnt2<len2) {\n                    if(h1.val<h2.val) {\n                        curNode.next = h1;\n                        h1 = h1.next;\n                        cnt1++;\n                    }else {\n                        curNode.next = h2;\n                        h2 = h2.next;\n                        cnt2++;\n                    }\n                    curNode = curNode.next;\n                }\n                while(cnt1<len1) {\n                    curNode.next = h1;\n                    h1 = h1.next;\n                    cnt1++;\n                    curNode = curNode.next;\n                }\n                while(cnt2<len2) {\n                    curNode.next = h2;\n                    h2 = h2.next;\n                    cnt2++;\n                    curNode = curNode.next;\n                }\n                curNode.next = h2; // connect the end node with next section or null\n            }\n\n        }\n        return dummy.next;\n        \n    }\n}\n```",
                "solutionTags": [],
                "code": "```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        int len = 0;\n        ListNode curNode = head;\n        //get the length of the list\n        while(curNode!=null) {\n            curNode = curNode.next;\n            len++;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        // binary reduction\n        for(int w=1;w<len;w*=2) {\n            curNode = dummy;\n            for(int i=0;i<len-w;i+=2*w) { // 0,2\n                // head 1: i; head 2: i+w\n                // each list length: \n                int len1 = Math.min(w,len-i);\n                int len2 = Math.min(w,len-i-w);\n                ListNode h1 = curNode.next;\n                ListNode h2 = h1;\n                \n                for(int k=0; k<len1; k++) h2 = h2.next;     \n                                \n                // merge two sorted list with len1 and len2\n                /* code for merge two sorted list*/\n                ...\n                curNode.next = h2; // connect the end node with next section or null\n            }\n\n        }\n        return dummy.next;\n        \n    }\n}\n```\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        int len = 0;\n        ListNode curNode = head;\n        while(curNode!=null) {\n            curNode = curNode.next;\n            len++;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        for(int w=1;w<len;w*=2) {\n            curNode = dummy;\n            for(int i=0;i<len-w;i+=2*w) { // 0,2\n                // head 1: i; head 2: i+w\n                // each list length: \n                int len1 = Math.min(w,len-i);\n                int len2 = Math.min(w,len-i-w);\n                ListNode h1 = curNode.next;\n                ListNode h2 = h1;\n                \n                for(int k=0; k<len1; k++) h2 = h2.next;     \n                                \n                // merge two sorted list with len1 and len2\n                int cnt1 = 0, cnt2 = 0;                \n                while(cnt1<len1 && cnt2<len2) {\n                    if(h1.val<h2.val) {\n                        curNode.next = h1;\n                        h1 = h1.next;\n                        cnt1++;\n                    }else {\n                        curNode.next = h2;\n                        h2 = h2.next;\n                        cnt2++;\n                    }\n                    curNode = curNode.next;\n                }\n                while(cnt1<len1) {\n                    curNode.next = h1;\n                    h1 = h1.next;\n                    cnt1++;\n                    curNode = curNode.next;\n                }\n                while(cnt2<len2) {\n                    curNode.next = h2;\n                    h2 = h2.next;\n                    cnt2++;\n                    curNode = curNode.next;\n                }\n                curNode.next = h2; // connect the end node with next section or null\n            }\n\n        }\n        return dummy.next;\n        \n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 46731,
                "title": "c-quicksort-43ms-beats-99-82",
                "content": "Considering recursive calls, the space complexity is actually O(logn), not O(1).\\nPlease share your thoughts\\n```\\n    // Quick Sort\\n    ListNode* sortList(ListNode* head) {\\n        \\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        \\n        ListNode* l;    // left half\\n        ListNode* r;    // right half\\n        ListNode* m;    // pivot\\n        ListNode* lt;\\n        ListNode* rt;\\n        ListNode* mt;\\n        ListNode d1(0); // dummy\\n        ListNode d2(0);\\n        \\n        // choose pivot and divide\\n        l = &d1;\\n        r = &d2;\\n        m = head;\\n\\n        // skip pivot\\n        head = head->next;\\n        lt = l;\\n        rt = r;\\n        mt = m;\\n        \\n        // divide\\n        while (head) {\\n            if (head->val < m->val) {\\n                lt->next = head;\\n                head = head->next;\\n                lt = lt->next;\\n            } else if (head->val > m->val){\\n                rt->next = head;\\n                head = head->next;\\n                rt = rt->next;\\n            } else {\\n                mt->next = head;\\n                head = head->next;\\n                mt = mt->next;\\n            }\\n        }\\n        \\n        // handle tail\\n        lt->next = nullptr;\\n        rt->next = nullptr;\\n        mt->next = nullptr;\\n        \\n        // remove dummy\\n        l = l->next; \\n        r = r->next;\\n        \\n        // recursive step\\n        l = sortList(l);\\n        r = sortList(r);\\n        \\n        // merge\\n        if (!l) {\\n            head = m;\\n            mt->next = r;\\n        } else {\\n            head = l;\\n            lt = l;\\n            while (lt->next) lt = lt->next; // find the tail of left half\\n            lt->next = m;\\n            mt->next = r;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    // Quick Sort\\n    ListNode* sortList(ListNode* head) {\\n        \\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        \\n        ListNode* l;    // left half\\n        ListNode* r;    // right half\\n        ListNode* m;    // pivot\\n        ListNode* lt;\\n        ListNode* rt;\\n        ListNode* mt;\\n        ListNode d1(0); // dummy\\n        ListNode d2(0);\\n        \\n        // choose pivot and divide\\n        l = &d1;\\n        r = &d2;\\n        m = head;\\n\\n        // skip pivot\\n        head = head->next;\\n        lt = l;\\n        rt = r;\\n        mt = m;\\n        \\n        // divide\\n        while (head) {\\n            if (head->val < m->val) {\\n                lt->next = head;\\n                head = head->next;\\n                lt = lt->next;\\n            } else if (head->val > m->val){\\n                rt->next = head;\\n                head = head->next;\\n                rt = rt->next;\\n            } else {\\n                mt->next = head;\\n                head = head->next;\\n                mt = mt->next;\\n            }\\n        }\\n        \\n        // handle tail\\n        lt->next = nullptr;\\n        rt->next = nullptr;\\n        mt->next = nullptr;\\n        \\n        // remove dummy\\n        l = l->next; \\n        r = r->next;\\n        \\n        // recursive step\\n        l = sortList(l);\\n        r = sortList(r);\\n        \\n        // merge\\n        if (!l) {\\n            head = m;\\n            mt->next = r;\\n        } else {\\n            head = l;\\n            lt = l;\\n            while (lt->next) lt = lt->next; // find the tail of left half\\n            lt->next = m;\\n            mt->next = r;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46954,
                "title": "my-accepted-python-solution-using-merge-sort",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param {ListNode} head\\n        # @return {ListNode}\\n        def sortList(self, head):\\n            size, node = 0, head\\n            while node:\\n                node = node.next\\n                size += 1\\n            return self.merge_sort(head, size)\\n    \\n        def merge_sort(self, head, size):\\n            if size <= 1:\\n                return head\\n    \\n            right = prev = head\\n            left_size = size/2\\n            right_size = size - left_size\\n    \\n            for i in range(left_size):\\n                prev = right\\n                right = right.next\\n            prev.next = None  # divide list to two part\\n    \\n            left = self.merge_sort(head, left_size)\\n            right = self.merge_sort(right, right_size)\\n            return self.merge(left, right)\\n    \\n        def merge(self, l1, l2):\\n            vhead = curr = ListNode(0)\\n            while l1 and l2:\\n                if l1.val <= l2.val:\\n                    curr.next = l1\\n                    l1 = l1.next\\n                else:\\n                    curr.next = l2\\n                    l2 = l2.next\\n                curr = curr.next\\n            curr.next = l1 or l2\\n            return vhead.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 46947,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    ListNode *sortList(ListNode *head) {\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        ListNode *head2 = slow->next;\\n        slow->next = NULL;\\n        \\n        head = sortList(head);\\n        head2 = sortList(head2);\\n        \\n        ListNode *mergedList = new ListNode(INT_MIN);\\n        ListNode *newHead = mergedList;\\n        \\n        while(head && head2) {\\n            if(head->val < head2->val) {\\n                mergedList->next = head;\\n                mergedList = head;\\n                head = head->next;\\n            }\\n            else {\\n                mergedList->next = head2;\\n                mergedList = head2;\\n                head2 = head2->next;\\n            }\\n        }\\n        \\n        if(head)\\n            mergedList->next = head;\\n        if(head2)\\n            mergedList->next = head2;\\n            \\n        return newHead->next;\\n       }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode *sortList(ListNode *head) {\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 46997,
                "title": "a-minor-tweak-on-quick-sort-to-solve-the-time-limit-exceeded-issue",
                "content": "Since the problem asked for a sort algorithm with O(NlogN) and constant space complexity, it appears to be a quick sort for me. \\n\\nThis is exactly what I did. It is a bit of tricky to do quick sort on a linked list though, since we could not access any element in a constant time. Originally, I took the head as pivot and divided the list into two sublists: (>= pivot), (< pivot). Then I concatenated the sorted sublists. Since I only return the head of the sublist as the result, I need to traverse the (< pivot) sublist again to retrieve the tail so that I can concatenate both sublists. \\n\\nMy first implementation of quick sort with a two-sublist division works. But it exceeded the time limit of OJ.  Then I improved the above version to return the tail as well as the head, so that I could save a traverse during the sublist concatenation. It still failed though... \\n\\nIn the final attempt, I just divided the list into 3 sublists (> pivot) ( = pivot) (< pivot), based on the first version. And it worked this time!  Intuitively, 3 sublists can reduce the reduce the number of recursion, since we reduce the problem into a smaller size at a faster pace. \\n\\n\\n\\n\\n\\t/**\\n\\t * Quick sort on linked list\\n\\t */\\n    public ListNode sortList(ListNode head) {\\n    \\t\\n\\t\\tif(head == null || head.next == null){\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode pivot = head;\\n\\t\\thead = head.next;\\n\\t\\t\\n\\t\\tListNode bigHead = null, smallHead=null;\\n\\t\\tListNode bigIter = null, smallIter=null;\\n\\t\\tListNode pivotIter = pivot;\\n\\t\\t\\n\\t\\twhile(head != null){\\n\\t\\t\\tListNode iter = head.next;\\n\\t\\t\\t\\n\\t\\t\\tif(head.val > pivot.val){\\n\\t\\t\\t\\tif(bigHead == null){\\n\\t\\t\\t\\t\\tbigHead = head;\\n\\t\\t\\t\\t\\tbigIter = bigHead;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tbigIter.next = head;\\n\\t\\t\\t\\t\\tbigIter = bigIter.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else if(head.val == pivot.val){\\n\\t\\t\\t\\tpivotIter.next = head;\\n\\t\\t\\t\\tpivotIter = pivotIter.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(smallHead == null){\\n\\t\\t\\t\\t\\tsmallHead = head;\\n\\t\\t\\t\\t\\tsmallIter = smallHead;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsmallIter.next = head;\\n\\t\\t\\t\\t\\tsmallIter = smallIter.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\thead = iter;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// mark the ends for the big/small sub lists.\\n\\t\\tif(smallIter != null){\\n\\t\\t\\tsmallIter.next = null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpivotIter.next = null;\\n\\t\\t\\n\\t\\tif(bigIter != null){\\n\\t\\t\\tbigIter.next = null;\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tListNode sortBig = sortList(bigHead);\\n\\t\\tListNode sortSmall = sortList(smallHead);\\n\\t\\t\\n\\t\\tif(sortSmall == null){\\n\\t\\t\\tpivotIter.next = sortBig;\\n\\t\\t\\treturn pivot;\\n\\n\\t\\t} else {\\n\\t\\t\\tsmallIter = sortSmall;\\n\\t\\t\\twhile (smallIter.next != null) {\\n\\t\\t\\t\\tsmallIter = smallIter.next;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// reach the tail of the small sublist\\n\\t\\t\\tsmallIter.next = pivot;\\n\\t\\t\\t// concatenate the two sublists.\\n\\t\\t\\tpivotIter.next = sortBig;\\n\\t\\t\\t\\n\\t\\t\\treturn sortSmall;\\t\\n\\t\\t}\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "Since the problem asked for a sort algorithm with O(NlogN) and constant space complexity, it appears to be a quick sort for me. \\n\\nThis is exactly what I did. It is a bit of tricky to do quick sort on a linked list though, since we could not access any element in a constant time. Originally, I took the head as pivot and divided the list into two sublists: (>= pivot), (< pivot). Then I concatenated the sorted sublists. Since I only return the head of the sublist as the result, I need to traverse the (< pivot) sublist again to retrieve the tail so that I can concatenate both sublists. \\n\\nMy first implementation of quick sort with a two-sublist division works. But it exceeded the time limit of OJ.  Then I improved the above version to return the tail as well as the head, so that I could save a traverse during the sublist concatenation. It still failed though... \\n\\nIn the final attempt, I just divided the list into 3 sublists (> pivot) ( = pivot) (< pivot), based on the first version. And it worked this time!  Intuitively, 3 sublists can reduce the reduce the number of recursion, since we reduce the problem into a smaller size at a faster pace. \\n\\n\\n\\n\\n\\t/**\\n\\t * Quick sort on linked list\\n\\t */\\n    public ListNode sortList(ListNode head) {\\n    \\t\\n\\t\\tif(head == null || head.next == null){\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode pivot = head;\\n\\t\\thead = head.next;\\n\\t\\t\\n\\t\\tListNode bigHead = null, smallHead=null;\\n\\t\\tListNode bigIter = null, smallIter=null;\\n\\t\\tListNode pivotIter = pivot;\\n\\t\\t\\n\\t\\twhile(head != null){\\n\\t\\t\\tListNode iter = head.next;\\n\\t\\t\\t\\n\\t\\t\\tif(head.val > pivot.val){\\n\\t\\t\\t\\tif(bigHead == null){\\n\\t\\t\\t\\t\\tbigHead = head;\\n\\t\\t\\t\\t\\tbigIter = bigHead;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tbigIter.next = head;\\n\\t\\t\\t\\t\\tbigIter = bigIter.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else if(head.val == pivot.val){\\n\\t\\t\\t\\tpivotIter.next = head;\\n\\t\\t\\t\\tpivotIter = pivotIter.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(smallHead == null){\\n\\t\\t\\t\\t\\tsmallHead = head;\\n\\t\\t\\t\\t\\tsmallIter = smallHead;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsmallIter.next = head;\\n\\t\\t\\t\\t\\tsmallIter = smallIter.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\thead = iter;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// mark the ends for the big/small sub lists.\\n\\t\\tif(smallIter != null){\\n\\t\\t\\tsmallIter.next = null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpivotIter.next = null;\\n\\t\\t\\n\\t\\tif(bigIter != null){\\n\\t\\t\\tbigIter.next = null;\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tListNode sortBig = sortList(bigHead);\\n\\t\\tListNode sortSmall = sortList(smallHead);\\n\\t\\t\\n\\t\\tif(sortSmall == null){\\n\\t\\t\\tpivotIter.next = sortBig;\\n\\t\\t\\treturn pivot;\\n\\n\\t\\t} else {\\n\\t\\t\\tsmallIter = sortSmall;\\n\\t\\t\\twhile (smallIter.next != null) {\\n\\t\\t\\t\\tsmallIter = smallIter.next;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// reach the tail of the small sublist\\n\\t\\t\\tsmallIter.next = pivot;\\n\\t\\t\\t// concatenate the two sublists.\\n\\t\\t\\tpivotIter.next = sortBig;\\n\\t\\t\\t\\n\\t\\t\\treturn sortSmall;\\t\\n\\t\\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3921681,
                "title": "c-detailed-explanation-easy-to-understand-both-iterative-and-recursive-approaches-for-merging",
                "content": "# Intuition\\nWe need to divide the list in two halves and keep doing so until we have a single Node or empty list at that point we can say that a single node is always a sorted list , next we need to merge two such nodes by comparing which is smaller than other we will get a sorted list of two nodes and we need to perform this for all nodes in the list the list we do so by calling [mergeTwoList](https://leetcode.com/problems/merge-two-sorted-lists/) function.\\n\\n# 1st Approach\\nBy using Fast and Slow pointer , when we exit out of while loop , the slow pointer will be exactly at half  or half +1 th node of list. We will store the next of slow in n and pass this to function again creating a recursion which will end when either its NULL or we have a single node.\\n\\nAfter getting two single nodes we will call mergeTwoList function to merge the two nodes to get a sorted list.\\nThe merge two list function will keep a head pointer(head) and a tail pointer(p) , since we\\'re just changing the links and not creating any more nodes we will keep a tail pointer to keep a track of this. \\nagain there are two condition to break out of while loop it\\'s when either l1 becomes empty or l2 becomes empty in either case we will update the tail to point at l1 if l2 is empty  \\\\ or l2 if l1 is empty.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\nThe sortList and mergeTwoLists is exactly how merge sort works so the time complexity is O(nlogn)\\n\\n- Space complexity:O(n)\\nWhile the Mergetwo list is an iterative approach it will be O(1) but the sort list function is a recursive function and will maintain a stack space of n.\\n\\n# Code 1\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(!list1) return list2;\\n        if(!list2) return list1;\\n        ListNode* head=NULL;\\n        if(list1->val < list2->val)\\n        {\\n            head =list1;\\n            list1=list1->next;\\n        }\\n        else \\n        {\\n            head=list2;\\n            list2=list2->next;\\n        }\\n        ListNode* p=head;\\n        while(list1 && list2)\\n        {\\n            if(list1->val < list2->val)\\n            {\\n                p->next=list1;\\n                list1=list1->next;   \\n            }\\n            else\\n            {\\n                p->next=list2;\\n                list2=list2->next;\\n            }\\n            p=p->next;\\n        }\\n        if(list1) p->next=list1;\\n        else p->next=list2;\\n        return head;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode*n = slow->next;\\n        slow->next=NULL;\\n        ListNode *a=sortList(head);\\n        ListNode *b=sortList(n); \\n        head=mergeTwoLists(a,b);\\n        return head;\\n    }\\n};\\n```\\n\\n# 2nd Approach\\nEvery thing is same except for the mergeTwoList function in this case its recusrive rather than iterative it just eliminates most checks we need to do in iterative soltion and looks more neat although it also costs us stack space. \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n\\n# Code 2\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(!list1) return list2;\\n        if(!list2) return list1;\\n\\n        ListNode*head=NULL;\\n        if(list1->val<list2->val)\\n        {\\n            head=list1;\\n            head->next=mergeTwoLists(list1->next,list2);\\n        }\\n        else\\n        {\\n            head=list2;\\n            head->next=mergeTwoLists(list1,list2->next);\\n        }\\n        return head;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode*n = slow->next;\\n        slow->next=NULL;\\n        ListNode *a=sortList(head);\\n        ListNode *b=sortList(n); \\n        head=mergeTwoLists(a,b);\\n        return head;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(!list1) return list2;\\n        if(!list2) return list1;\\n        ListNode* head=NULL;\\n        if(list1->val < list2->val)\\n        {\\n            head =list1;\\n            list1=list1->next;\\n        }\\n        else \\n        {\\n            head=list2;\\n            list2=list2->next;\\n        }\\n        ListNode* p=head;\\n        while(list1 && list2)\\n        {\\n            if(list1->val < list2->val)\\n            {\\n                p->next=list1;\\n                list1=list1->next;   \\n            }\\n            else\\n            {\\n                p->next=list2;\\n                list2=list2->next;\\n            }\\n            p=p->next;\\n        }\\n        if(list1) p->next=list1;\\n        else p->next=list2;\\n        return head;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode*n = slow->next;\\n        slow->next=NULL;\\n        ListNode *a=sortList(head);\\n        ListNode *b=sortList(n); \\n        head=mergeTwoLists(a,b);\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(!list1) return list2;\\n        if(!list2) return list1;\\n\\n        ListNode*head=NULL;\\n        if(list1->val<list2->val)\\n        {\\n            head=list1;\\n            head->next=mergeTwoLists(list1->next,list2);\\n        }\\n        else\\n        {\\n            head=list2;\\n            head->next=mergeTwoLists(list1,list2->next);\\n        }\\n        return head;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode*n = slow->next;\\n        slow->next=NULL;\\n        ListNode *a=sortList(head);\\n        ListNode *b=sortList(n); \\n        head=mergeTwoLists(a,b);\\n        return head;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880590,
                "title": "simple-java-solution-with-detailed-explanation-time-and-space-complexities",
                "content": "# Intuition\\nThe code is an implementation of the Merge Sort algorithm for sorting a singly-linked list. The idea behind Merge Sort is to divide the list into two halves, recursively sort each half, and then merge the sorted halves to obtain the final sorted list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. **\\'sortList\\' function:**\\n\\nThis function is the entry point for the sorting process.\\nIf the list has one or zero elements (i.e., head is null or has only one node), it\\'s already considered sorted, and the function returns the input list.\\nOtherwise, the list is divided into two halves using the get_mid function to find the middle node.\\nThe sortList function is then recursively called on both halves to sort them.\\nFinally, the two sorted halves are merged using the mergeTwoLists function, and the merged result is returned.\\n\\n2. **get_mid function:**\\n\\nThis function finds the middle node of the input list using the \"slow and fast pointer\" approach.\\nIt maintains two pointers: midPrev and head.\\nWhile head and head.next are not null, the midPrev pointer is advanced one step at a time, and the head pointer is advanced two steps at a time.\\nThis ensures that when head reaches the end of the list, midPrev points to the node just before the middle node.\\nThe middle node is then detached from the rest of the list, and the function returns the middle node.\\n\\n3. **mergeTwoLists function:**\\n\\nThis function merges two sorted linked lists into a single sorted linked list.\\nIt uses a dummy head (dummyhead) and a tail pointer to build the merged list.\\nWhile both input lists (list1 and list2) are not empty, the function compares the values of the nodes at the front of both lists.\\nThe smaller node is added to the merged list, and the corresponding pointer (list1 or list2) is advanced.\\nThe tail pointer is also moved to the newly added node.\\nThe process continues until one of the input lists becomes empty.\\nThe remaining nodes in the non-empty list are then directly appended to the merged list.\\nFinally, the merged list is returned, excluding the initial dummy head.lin\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode mid = get_mid(head);\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(mid);\\n\\n        return mergeTwoLists(left, right);\\n    }\\n\\n    public ListNode get_mid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n\\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\\n        ListNode dummyhead = new ListNode();\\n        ListNode tail = dummyhead;\\n        while(list1 != null && list2 != null){\\n            if(list1.val < list2.val){\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            }else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyhead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Sort",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode mid = get_mid(head);\\n        ListNode left = sortList(head);\\n        ListNode right = sortList(mid);\\n\\n        return mergeTwoLists(left, right);\\n    }\\n\\n    public ListNode get_mid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n\\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\\n        ListNode dummyhead = new ListNode();\\n        ListNode tail = dummyhead;\\n        while(list1 != null && list2 != null){\\n            if(list1.val < list2.val){\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            }else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyhead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856363,
                "title": "sort-linked-list-with-merge-sort",
                "content": "# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* first, ListNode* second) {\\n        if(!first)\\n        return second;\\n        \\n        if(!second)\\n        return first;\\n\\n        ListNode* temp = NULL;\\n\\n        if(first -> val < second -> val) {\\n            temp = first;\\n            temp -> next = merge(first -> next, second);\\n        }\\n        else {\\n            temp = second;\\n            temp -> next = merge(first, second -> next);\\n        }\\n\\n        return temp;\\n    }\\n    ListNode* mid_node(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        return slow;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)\\n        return head;\\n\\n        ListNode* mid = mid_node(head);\\n        ListNode* first = head;\\n        ListNode* second = mid -> next;\\n        mid -> next = NULL;\\n        first = sortList(first);\\n        second = sortList(second);\\n        ListNode* ans = merge(first , second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* first, ListNode* second) {\\n        if(!first)\\n        return second;\\n        \\n        if(!second)\\n        return first;\\n\\n        ListNode* temp = NULL;\\n\\n        if(first -> val < second -> val) {\\n            temp = first;\\n            temp -> next = merge(first -> next, second);\\n        }\\n        else {\\n            temp = second;\\n            temp -> next = merge(first, second -> next);\\n        }\\n\\n        return temp;\\n    }\\n    ListNode* mid_node(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        return slow;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)\\n        return head;\\n\\n        ListNode* mid = mid_node(head);\\n        ListNode* first = head;\\n        ListNode* second = mid -> next;\\n        mid -> next = NULL;\\n        first = sortList(first);\\n        second = sortList(second);\\n        ListNode* ans = merge(first , second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748682,
                "title": "c-merge-sort-o-1-space-complexity",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    ListNode* findMid(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next != NULL && fast->next->next != NULL) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(list1 == NULL)\\n            return list2;\\n        if(list2 == NULL)\\n            return list1;\\n        \\n        ListNode* temp1;\\n        if(list1->val <= list2->val) {\\n            temp1 = list1;\\n            list1 = list1->next;\\n        }\\n        else {\\n            temp1 = list2;\\n            list2 = list2->next;\\n        }\\n        \\n        ListNode* temp2 = temp1;\\n\\n        while(list1 != NULL && list2 != NULL) {\\n            if(list1->val <= list2->val) {\\n                temp1->next = list1;\\n                list1 = list1->next;\\n            }\\n            else {\\n                temp1->next = list2;\\n                list2 = list2->next;\\n            }\\n            temp1 = temp1->next;\\n        }\\n        while(list1 != NULL) {\\n            temp1->next = list1;\\n            list1 = list1->next;\\n            temp1 = temp1->next;\\n        }\\n        while(list2 != NULL) {\\n            temp1->next = list2;\\n            list2 = list2->next;\\n            temp1 = temp1->next;\\n        }\\n        return temp2;\\n    }\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* mid = findMid(head);\\n        ListNode* rightHead = mid->next;\\n        mid->next = NULL;\\n        ListNode* leftHead = head;\\n        leftHead = sortList(leftHead);\\n        rightHead = sortList(rightHead);\\n        ListNode* ans = mergeTwoLists(leftHead, rightHead);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode* findMid(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next != NULL && fast->next->next != NULL) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        if(list1 == NULL)\\n            return list2;\\n        if(list2 == NULL)\\n            return list1;\\n        \\n        ListNode* temp1;\\n        if(list1->val <= list2->val) {\\n            temp1 = list1;\\n            list1 = list1->next;\\n        }\\n        else {\\n            temp1 = list2;\\n            list2 = list2->next;\\n        }\\n        \\n        ListNode* temp2 = temp1;\\n\\n        while(list1 != NULL && list2 != NULL) {\\n            if(list1->val <= list2->val) {\\n                temp1->next = list1;\\n                list1 = list1->next;\\n            }\\n            else {\\n                temp1->next = list2;\\n                list2 = list2->next;\\n            }\\n            temp1 = temp1->next;\\n        }\\n        while(list1 != NULL) {\\n            temp1->next = list1;\\n            list1 = list1->next;\\n            temp1 = temp1->next;\\n        }\\n        while(list2 != NULL) {\\n            temp1->next = list2;\\n            list2 = list2->next;\\n            temp1 = temp1->next;\\n        }\\n        return temp2;\\n    }\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* mid = findMid(head);\\n        ListNode* rightHead = mid->next;\\n        mid->next = NULL;\\n        ListNode* leftHead = head;\\n        leftHead = sortList(leftHead);\\n        rightHead = sortList(rightHead);\\n        ListNode* ans = mergeTwoLists(leftHead, rightHead);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398135,
                "title": "shortcut-easiest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL||head->next==NULL) return head;\\n        ListNode* temp=head;\\n        vector<int> v;\\n        while(temp!=NULL){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(v.begin(),v.end());\\n        ListNode* dummy=new ListNode();\\n        ListNode* fake=dummy;\\n        for(int i=0;i<v.size();i++){\\n            ListNode* c=new ListNode(v[i]);\\n            fake->next=c;\\n            fake=c;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL||head->next==NULL) return head;\\n        ListNode* temp=head;\\n        vector<int> v;\\n        while(temp!=NULL){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        sort(v.begin(),v.end());\\n        ListNode* dummy=new ListNode();\\n        ListNode* fake=dummy;\\n        for(int i=0;i<v.size();i++){\\n            ListNode* c=new ListNode(v[i]);\\n            fake->next=c;\\n            fake=c;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363243,
                "title": "simple-js-98-90",
                "content": "\\n```\\n\\nconst sortList = function (head) {\\n  if(!head) return null\\n\\n  const nodes = [];\\n\\n  while (head) {\\n    nodes.push(head);\\n    head = head.next;\\n  }\\n\\n  nodes.sort((a, b) => a.val - b.val);\\n\\n  for (let i = 0; i < nodes.length; i++) {\\n    nodes[i].next = nodes[i + 1] || null;\\n  }\\n\\n  return nodes[0];\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst sortList = function (head) {\\n  if(!head) return null\\n\\n  const nodes = [];\\n\\n  while (head) {\\n    nodes.push(head);\\n    head = head.next;\\n  }\\n\\n  nodes.sort((a, b) => a.val - b.val);\\n\\n  for (let i = 0; i < nodes.length; i++) {\\n    nodes[i].next = nodes[i + 1] || null;\\n  }\\n\\n  return nodes[0];\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299484,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> v;\\n        while(head) {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        sort(v.rbegin(), v.rend());\\n        ListNode* ans = NULL;\\n        for(int i=0; i<v.size(); i++){\\n            ans = new ListNode(v[i], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int> v;\\n        while(head) {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        sort(v.rbegin(), v.rend());\\n        ListNode* ans = NULL;\\n        for(int i=0; i<v.size(); i++){\\n            ans = new ListNode(v[i], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108951,
                "title": "simple-merge-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeBoth(ListNode * l1,ListNode* l2){\\n        ListNode* root=new ListNode(0);\\n        ListNode* curr=root;\\n        while(l1 && l2){\\n            if(l1->val<=l2->val){\\n                curr->next=l1;\\n                l1=l1->next;\\n            }else{\\n                curr->next=l2;\\n                l2=l2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        if(l1){\\n            curr->next=l1;\\n        }\\n        if(l2){\\n            curr->next=l2;\\n        }\\n        return root->next;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next)return head;\\n        ListNode *tail=NULL,*slow=head,*fast=head;\\n        while(fast && fast->next){\\n            tail=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        tail->next=NULL;\\n        ListNode* l1=sortList(head);\\n        ListNode*l2=sortList(slow);\\n        return mergeBoth(l1,l2);\\n        \\n    }\\n\\n};\\n\\n\\n// \\t\\t\\t\\t\\t\\t\\t// \\\\U0001f609\\\\U0001f609\\\\U0001f609\\\\U0001f609Please upvote if it helps \\\\U0001f609\\\\U0001f609\\\\U0001f609\\\\U0001f609\\n// class Solution {\\n// public:\\n//     ListNode* sortList(ListNode* head) {\\n//         //If List Contain a Single or 0 Node\\n//         if(head == NULL || head ->next == NULL)\\n//             return head;\\n        \\n        \\n//         ListNode *temp = NULL;\\n//         ListNode *slow = head;\\n//         ListNode *fast = head;\\n        \\n//         // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n//         while(fast !=  NULL && fast -> next != NULL)\\n//         {\\n//             temp = slow;\\n//             slow = slow->next;          //slow increment by 1\\n//             fast = fast ->next ->next;  //fast incremented by 2\\n            \\n//         }   \\n//         temp -> next = NULL;            //end of first left half\\n        \\n//         ListNode* l1 = sortList(head);    //left half recursive call\\n//         ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n//         return mergelist(l1, l2);         //mergelist Function call\\n            \\n//     }\\n    \\n//     //MergeSort Function O(n*logn)\\n//     ListNode* mergelist(ListNode *l1, ListNode *l2)\\n//     {\\n//         ListNode *ptr = new ListNode(0);\\n//         ListNode *curr = ptr;\\n        \\n//         while(l1 != NULL && l2 != NULL)\\n//         {\\n//             if(l1->val <= l2->val)\\n//             {\\n//                 curr -> next = l1;\\n//                 l1 = l1 -> next;\\n//             }\\n//             else\\n//             {\\n//                 curr -> next = l2;\\n//                 l2 = l2 -> next;\\n//             }\\n        \\n//         curr = curr ->next;\\n        \\n//         }\\n        \\n//         //for unqual length linked list\\n        \\n//         if(l1 != NULL)\\n//         {\\n//             curr -> next = l1;\\n//             l1 = l1->next;\\n//         }\\n        \\n//         if(l2 != NULL)\\n//         {\\n//             curr -> next = l2;\\n//             l2 = l2 ->next;\\n//         }\\n        \\n//         return ptr->next;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeBoth(ListNode * l1,ListNode* l2){\\n        ListNode* root=new ListNode(0);\\n        ListNode* curr=root;\\n        while(l1 && l2){\\n            if(l1->val<=l2->val){\\n                curr->next=l1;\\n                l1=l1->next;\\n            }else{\\n                curr->next=l2;\\n                l2=l2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        if(l1){\\n            curr->next=l1;\\n        }\\n        if(l2){\\n            curr->next=l2;\\n        }\\n        return root->next;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next)return head;\\n        ListNode *tail=NULL,*slow=head,*fast=head;\\n        while(fast && fast->next){\\n            tail=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        tail->next=NULL;\\n        ListNode* l1=sortList(head);\\n        ListNode*l2=sortList(slow);\\n        return mergeBoth(l1,l2);\\n        \\n    }\\n\\n};\\n\\n\\n// \\t\\t\\t\\t\\t\\t\\t// \\\\U0001f609\\\\U0001f609\\\\U0001f609\\\\U0001f609Please upvote if it helps \\\\U0001f609\\\\U0001f609\\\\U0001f609\\\\U0001f609\\n// class Solution {\\n// public:\\n//     ListNode* sortList(ListNode* head) {\\n//         //If List Contain a Single or 0 Node\\n//         if(head == NULL || head ->next == NULL)\\n//             return head;\\n        \\n        \\n//         ListNode *temp = NULL;\\n//         ListNode *slow = head;\\n//         ListNode *fast = head;\\n        \\n//         // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n//         while(fast !=  NULL && fast -> next != NULL)\\n//         {\\n//             temp = slow;\\n//             slow = slow->next;          //slow increment by 1\\n//             fast = fast ->next ->next;  //fast incremented by 2\\n            \\n//         }   \\n//         temp -> next = NULL;            //end of first left half\\n        \\n//         ListNode* l1 = sortList(head);    //left half recursive call\\n//         ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n//         return mergelist(l1, l2);         //mergelist Function call\\n            \\n//     }\\n    \\n//     //MergeSort Function O(n*logn)\\n//     ListNode* mergelist(ListNode *l1, ListNode *l2)\\n//     {\\n//         ListNode *ptr = new ListNode(0);\\n//         ListNode *curr = ptr;\\n        \\n//         while(l1 != NULL && l2 != NULL)\\n//         {\\n//             if(l1->val <= l2->val)\\n//             {\\n//                 curr -> next = l1;\\n//                 l1 = l1 -> next;\\n//             }\\n//             else\\n//             {\\n//                 curr -> next = l2;\\n//                 l2 = l2 -> next;\\n//             }\\n        \\n//         curr = curr ->next;\\n        \\n//         }\\n        \\n//         //for unqual length linked list\\n        \\n//         if(l1 != NULL)\\n//         {\\n//             curr -> next = l1;\\n//             l1 = l1->next;\\n//         }\\n        \\n//         if(l2 != NULL)\\n//         {\\n//             curr -> next = l2;\\n//             l2 = l2 ->next;\\n//         }\\n        \\n//         return ptr->next;\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053070,
                "title": "c-merger-sort-on-linked-list-no-extra-space",
                "content": "### Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* answer = new ListNode(0);\\n        ListNode* curr = answer;\\n\\n        while(l1 && l2) {\\n            if(l1->val <= l2 -> val) {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }else {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            curr = curr -> next;\\n        }\\n\\n        while(l1) {\\n            curr -> next = l1;\\n            l1 = l1 -> next;\\n            curr = curr -> next;\\n    \\n        }\\n\\n        while(l2) {\\n            curr -> next = l2;\\n            l2 = l2 -> next;\\n            curr = curr -> next;\\n        }\\n\\n        return answer -> next;\\n    }\\n\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }  \\n\\n        prev -> next = nullptr;\\n\\n        ListNode* l1 = sortList(head);\\n        ListNode* l2 = sortList(slow);\\n\\n        return merge(l1, l2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* answer = new ListNode(0);\\n        ListNode* curr = answer;\\n\\n        while(l1 && l2) {\\n            if(l1->val <= l2 -> val) {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }else {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            curr = curr -> next;\\n        }\\n\\n        while(l1) {\\n            curr -> next = l1;\\n            l1 = l1 -> next;\\n            curr = curr -> next;\\n    \\n        }\\n\\n        while(l2) {\\n            curr -> next = l2;\\n            l2 = l2 -> next;\\n            curr = curr -> next;\\n        }\\n\\n        return answer -> next;\\n    }\\n\\n    ListNode* sortList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }  \\n\\n        prev -> next = nullptr;\\n\\n        ListNode* l1 = sortList(head);\\n        ListNode* l2 = sortList(slow);\\n\\n        return merge(l1, l2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020679,
                "title": "solution-swift-merge-sort",
                "content": "# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(\\\\log n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        if head?.next == nil { return head }\\n        \\n        var slow = head\\n        var fast = head?.next\\n        while fast != nil && fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        \\n        let leftHalf = head\\n        let rightHalf = slow?.next\\n        \\n        slow?.next = nil\\n        \\n        var currLeft = sortList(leftHalf)\\n        var currRight = sortList(rightHalf)\\n        \\n        let dummy = ListNode(-1)\\n        var curr: ListNode? = dummy\\n        \\n        while currLeft != nil || currRight != nil {\\n            if currLeft?.val ?? Int.max <= currRight?.val ?? Int.max {\\n                curr?.next = currLeft\\n                currLeft = currLeft?.next\\n            } else {\\n                curr?.next = currRight\\n                currRight = currRight?.next\\n            }\\n            \\n            curr = curr?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    func sortList(_ head: ListNode?) -> ListNode? {\\n        if head?.next == nil { return head }\\n        \\n        var slow = head\\n        var fast = head?.next\\n        while fast != nil && fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        \\n        let leftHalf = head\\n        let rightHalf = slow?.next\\n        \\n        slow?.next = nil\\n        \\n        var currLeft = sortList(leftHalf)\\n        var currRight = sortList(rightHalf)\\n        \\n        let dummy = ListNode(-1)\\n        var curr: ListNode? = dummy\\n        \\n        while currLeft != nil || currRight != nil {\\n            if currLeft?.val ?? Int.max <= currRight?.val ?? Int.max {\\n                curr?.next = currLeft\\n                currLeft = currLeft?.next\\n            } else {\\n                curr?.next = currRight\\n                currRight = currRight?.next\\n            }\\n            \\n            curr = curr?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947360,
                "title": "sort-using-merge-sort-cpp-easy-explanation-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing merge sort is same approch as we solved in the array problem\\nfirst break the list into two halves then merge them in the sorted manner\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep 1: break the list into two half by finding the middle of the list usnig a function findMid(head)\\nstep 2: sort the left list separately and right list separately\\nstep 3: meerge the list into sorted order\\nstep 4: return the head of the list \\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n    no extra space is needed only the constant space is required\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\nprivate:\\n    ListNode* findMid(ListNode* head){\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n\\n        }\\n        return slow;\\n    }\\n\\n    ListNode * mergelist(ListNode* left,ListNode* right)\\n    {\\n        if(left==NULL)\\n            return right;\\n        if(right==NULL)\\n            return left;\\n\\n        ListNode* ans=new ListNode(-1);\\n        ListNode*temp=ans;\\n        while(left!=NULL && right!=NULL)\\n        {\\n            if(left->val< right->val)\\n            {\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n            }\\n            else\\n            {\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n\\n        }\\n        while(left!=NULL)\\n        {\\n            temp->next=left;\\n            temp=left;\\n            left=left->next;\\n        }\\n        while(right!=NULL)\\n        {\\n            temp->next=right;\\n            temp=right;\\n            right=right->next;\\n        }\\n        ans=ans->next;\\n        return ans;\\n    }\\n\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        {\\n            return head;\\n        }\\n        //break the list into two halves\\n        ListNode *mid =findMid(head);\\n        ListNode *left=head;\\n        ListNode *right=mid->next;\\n        mid->next=NULL;\\n        //sort left half\\n        left=sortList(left);\\n        //sort right half\\n        right=sortList(right);\\n        \\n        //nerge both the half\\n        ListNode *result=mergelist(left,right);\\n        //retun the ans\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\nprivate:\\n    ListNode* findMid(ListNode* head){\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n\\n        }\\n        return slow;\\n    }\\n\\n    ListNode * mergelist(ListNode* left,ListNode* right)\\n    {\\n        if(left==NULL)\\n            return right;\\n        if(right==NULL)\\n            return left;\\n\\n        ListNode* ans=new ListNode(-1);\\n        ListNode*temp=ans;\\n        while(left!=NULL && right!=NULL)\\n        {\\n            if(left->val< right->val)\\n            {\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n            }\\n            else\\n            {\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n\\n        }\\n        while(left!=NULL)\\n        {\\n            temp->next=left;\\n            temp=left;\\n            left=left->next;\\n        }\\n        while(right!=NULL)\\n        {\\n            temp->next=right;\\n            temp=right;\\n            right=right->next;\\n        }\\n        ans=ans->next;\\n        return ans;\\n    }\\n\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        {\\n            return head;\\n        }\\n        //break the list into two halves\\n        ListNode *mid =findMid(head);\\n        ListNode *left=head;\\n        ListNode *right=mid->next;\\n        mid->next=NULL;\\n        //sort left half\\n        left=sortList(left);\\n        //sort right half\\n        right=sortList(right);\\n        \\n        //nerge both the half\\n        ListNode *result=mergelist(left,right);\\n        //retun the ans\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429991,
                "title": "c-solution-brute-force-approach",
                "content": "class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n\\t\\n        vector<int>v;\\n        ListNode* temp = head;\\n\\t\\t\\n\\t\\t// inserting values from List to vector\\n        while(temp!=NULL){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n\\t\\t\\n\\t\\t// sorting vector\\n        sort(v.begin(), v.end());\\n\\t\\t\\n\\t\\t// inserting sorted values back to the List\\n        int i=0;\\n        temp=head;\\n        while(temp!=NULL){\\n            temp->val = v[i];\\n            temp=temp->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n\\t\\n        vector<int>v;\\n        ListNode* temp = head;\\n\\t\\t\\n\\t\\t// inserting values from List to vector\\n        while(temp!=NULL){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2326700,
                "title": "python-easy-to-understand-solution-using-merge-sort",
                "content": "#### Please Upvote if you find the code Helpful !!!!\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if head == None or head.next == None:\\n            return head\\n        \\n        mid = self.getMid(head)\\n        mid1 = mid.next\\n        mid.next = None\\n        \\n        l = self.sortList(head)\\n        r = self.sortList(mid1)\\n        \\n        res = self.mergeSortList(l, r)\\n        \\n        return res\\n\\n    # Implementing Merge Sort\\n    def mergeSortList(self, x, y):\\n        \\n        if not x:\\n            return y\\n        if not y:\\n            return x\\n        \\n        res = None\\n        \\n        if x.val <= y.val:\\n            res = x\\n            res.next = self.mergeSortList(x.next, y)\\n        else:\\n            res = y\\n            res.next = self.mergeSortList(x, y.next)\\n        \\n        return res\\n        \\n    # Function for getting the Mid of the Linked List    \\n    def getMid(self, head):\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\t\\t\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "#### Please Upvote if you find the code Helpful !!!!\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if head == None or head.next == None:\\n            return head\\n        \\n        mid = self.getMid(head)\\n        mid1 = mid.next\\n        mid.next = None\\n        \\n        l = self.sortList(head)\\n        r = self.sortList(mid1)\\n        \\n        res = self.mergeSortList(l, r)\\n        \\n        return res\\n\\n    # Implementing Merge Sort\\n    def mergeSortList(self, x, y):\\n        \\n        if not x:\\n            return y\\n        if not y:\\n            return x\\n        \\n        res = None\\n        \\n        if x.val <= y.val:\\n            res = x\\n            res.next = self.mergeSortList(x.next, y)\\n        else:\\n            res = y\\n            res.next = self.mergeSortList(x, y.next)\\n        \\n        return res\\n        \\n    # Function for getting the Mid of the Linked List    \\n    def getMid(self, head):\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2267313,
                "title": "c-mergesort",
                "content": "These solution is divided into 3 questions\\n-> Finding mid \\n-> Dividing the list into 2 parts head to mid and mid->next to end\\n->recursively sorting the two parts and then merging them using the sorted Merge function\\n```\\nclass Solution {\\npublic:\\n    ListNode *sortedMerge(ListNode *a,ListNode *b)\\n    {   \\n        if(!a)return b;\\n        if(!b)return a;\\n        ListNode *ans;\\n        if(a->val<b->val){\\n            ans=a;\\n            ans->next=sortedMerge(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next=sortedMerge(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* findMid(ListNode *head)\\n    {\\n        ListNode *fast=head->next,*slow=head;\\n        while(fast&&fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head||!head->next)return head;\\n        ListNode *mid=findMid(head);\\n        ListNode *midNext=mid->next;\\n        \\n        mid->next=NULL;\\n        \\n        head=sortList(head);\\n        midNext=sortList(midNext);\\n        \\n        return sortedMerge(head,midNext);        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *sortedMerge(ListNode *a,ListNode *b)\\n    {   \\n        if(!a)return b;\\n        if(!b)return a;\\n        ListNode *ans;\\n        if(a->val<b->val){\\n            ans=a;\\n            ans->next=sortedMerge(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next=sortedMerge(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* findMid(ListNode *head)\\n    {\\n        ListNode *fast=head->next,*slow=head;\\n        while(fast&&fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(!head||!head->next)return head;\\n        ListNode *mid=findMid(head);\\n        ListNode *midNext=mid->next;\\n        \\n        mid->next=NULL;\\n        \\n        head=sortList(head);\\n        midNext=sortList(midNext);\\n        \\n        return sortedMerge(head,midNext);        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235077,
                "title": "c-solution-sort-list-using-merge-sort",
                "content": "```\\n//Using Merge Sort : T.C = O(n log n) and S.C = O(log n)\\nclass Solution {\\nprivate:\\n    ListNode *getMid(ListNode *head){\\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n   \\nprivate:\\n    ListNode *merge(ListNode *left , ListNode *right){\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        \\n        ListNode *ans = new ListNode(-1);//dummy node\\n        ListNode *temp = ans;\\n        \\n        while(left != NULL && right != NULL){\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = temp->next;\\n                left = left->next;\\n            }\\n            else{\\n                temp->next = right;\\n                temp = temp->next;\\n                right = right->next;\\n            }\\n        }\\n        \\n        while(left != NULL){\\n            temp->next = left;\\n            temp = temp->next;\\n            left = left->next;\\n        }\\n        while(right != NULL){\\n            temp->next = right;\\n            temp = temp->next;\\n            right = right->next;\\n        }\\n        \\n        ans = ans->next;\\n        return ans;\\n    }\\n    \\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //base case\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode *mid = getMid(head);\\n        \\n        //divide the LL into two halves\\n        ListNode *left = head;\\n        ListNode *right = mid->next;\\n        mid->next = NULL;\\n        \\n        //Use recursion to sort the two halves\\n        left = sortList(left);\\n        right = sortList(right);\\n        \\n        //merge the two LL\\n        ListNode *result = merge(left , right);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n//Using Merge Sort : T.C = O(n log n) and S.C = O(log n)\\nclass Solution {\\nprivate:\\n    ListNode *getMid(ListNode *head){\\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n   \\nprivate:\\n    ListNode *merge(ListNode *left , ListNode *right){\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        \\n        ListNode *ans = new ListNode(-1);//dummy node\\n        ListNode *temp = ans;\\n        \\n        while(left != NULL && right != NULL){\\n            if(left->val < right->val){\\n                temp->next = left;\\n                temp = temp->next;\\n                left = left->next;\\n            }\\n            else{\\n                temp->next = right;\\n                temp = temp->next;\\n                right = right->next;\\n            }\\n        }\\n        \\n        while(left != NULL){\\n            temp->next = left;\\n            temp = temp->next;\\n            left = left->next;\\n        }\\n        while(right != NULL){\\n            temp->next = right;\\n            temp = temp->next;\\n            right = right->next;\\n        }\\n        \\n        ans = ans->next;\\n        return ans;\\n    }\\n    \\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //base case\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode *mid = getMid(head);\\n        \\n        //divide the LL into two halves\\n        ListNode *left = head;\\n        ListNode *right = mid->next;\\n        mid->next = NULL;\\n        \\n        //Use recursion to sort the two halves\\n        left = sortList(left);\\n        right = sortList(right);\\n        \\n        //merge the two LL\\n        ListNode *result = merge(left , right);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926265,
                "title": "c-merge-sort-2-pointer-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n     ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head ->next == NULL) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n\\t\\t//its just that where do we want the extra node ( ist half or 2nd half) in case of odd no. of nodes :------------------------\\n//( NOTE: in merge sort , it doesnt matter wheTher u have extra node in ist or 2nd half ( in case of odd no. of total nodes)\\n         \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        fast=slow->next;\\n        slow->next=NULL;\\n        ListNode* l1=sortList(head);\\n        ListNode* l2=sortList(fast);\\n        \\n        return merge(l1,l2);\\n    }\\n    ListNode* merge(ListNode *l1, ListNode *l2){\\n              ListNode* dummy=new ListNode(0);\\n              ListNode* temp=dummy;\\n              while(l1!=NULL && l2!=NULL){\\n                  if(l1->val < l2->val){\\n                      temp->next=l1;\\n                      l1=l1->next;\\n                    }\\n                  else{\\n                      temp->next=l2;\\n                      l2=l2->next;\\n                   }\\n                  temp=temp->next;\\n                }\\n             if(l1!=NULL) temp->next=l1;\\n              \\n             if(l2!=NULL) temp->next=l2; \\n             \\n         return dummy->next;\\n     \\n     }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n     ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head ->next == NULL) return head;\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n\\t\\t//its just that where do we want the extra node ( ist half or 2nd half) in case of odd no. of nodes :------------------------\\n//( NOTE: in merge sort , it doesnt matter wheTher u have extra node in ist or 2nd half ( in case of odd no. of total nodes)\\n         \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        fast=slow->next;\\n        slow->next=NULL;\\n        ListNode* l1=sortList(head);\\n        ListNode* l2=sortList(fast);\\n        \\n        return merge(l1,l2);\\n    }\\n    ListNode* merge(ListNode *l1, ListNode *l2){\\n              ListNode* dummy=new ListNode(0);\\n              ListNode* temp=dummy;\\n              while(l1!=NULL && l2!=NULL){\\n                  if(l1->val < l2->val){\\n                      temp->next=l1;\\n                      l1=l1->next;\\n                    }\\n                  else{\\n                      temp->next=l2;\\n                      l2=l2->next;\\n                   }\\n                  temp=temp->next;\\n                }\\n             if(l1!=NULL) temp->next=l1;\\n              \\n             if(l2!=NULL) temp->next=l2; \\n             \\n         return dummy->next;\\n     \\n     }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797379,
                "title": "megersort-easy-to-understand-intuition-with-comments-beats-80",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    //this function finds middle in after this function first will be separate link list and second will be the second linklist and divided equaaly\\n    //so here we have put high = curr->next so when in situation 1 2 3 4 low will point to 2 hence low will point to the end of the first listlist\\n    //hence second will be low->next and assigning second we make low->next NUll so cut the first link list so that\\'s why we need pointer at 2 not 3\\n    //cause if pointer at 3 then we can\\'t cut the first list , hence high = curr->next\\n\\t\\n    void findmiddle(ListNode* curr ,ListNode* &first ,ListNode*  &second)\\n    {\\n        ListNode* low = curr , *high = curr->next;\\n        while(high && high->next)\\n        {\\n            high = high->next->next;\\n            low = low->next;\\n        }\\n        \\n        first = curr;\\n        second = low->next;\\n        low->next = NULL;\\n    }\\n    \\n    //this will merge both list if any onr of them is empty then return other one\\n    //if first > second then ans = second and make function call gain with second->next else make ans = fisrst and make call again with first->next\\n\\t\\n    ListNode* mergeBoth(ListNode* first ,ListNode* second)\\n    {\\n        if(first == NULL) return second;\\n        if(second == NULL) return first;\\n        ListNode* ans;\\n        \\n        if(first->val > second->val)\\n        {\\n            ans = second;\\n            ans->next = mergeBoth(first , second->next);\\n        }\\n        else\\n        {\\n            ans = first;\\n            ans->next = mergeBoth(first->next , second);\\n        }\\n        return ans;\\n    }\\n    \\n    //here head is passed by reference hence actual value of the head will be changed\\n    //if no node oe only one node then return else find middle and make 2 linklist by first and second list\\n    //after that futher more divide first and second and then merge both first and second\\n\\t\\n    void divideAndMerge(ListNode* &head)\\n    {\\n        if(head == NULL || head->next == NULL) return;\\n        ListNode* curr = head , *first , *second;\\n        \\n        findmiddle(curr , first , second);\\n        \\n        divideAndMerge(first);\\n        divideAndMerge(second);\\n        \\n        head = mergeBoth(first , second);\\n        \\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        divideAndMerge(head);\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //this function finds middle in after this function first will be separate link list and second will be the second linklist and divided equaaly\\n    //so here we have put high = curr->next so when in situation 1 2 3 4 low will point to 2 hence low will point to the end of the first listlist\\n    //hence second will be low->next and assigning second we make low->next NUll so cut the first link list so that\\'s why we need pointer at 2 not 3\\n    //cause if pointer at 3 then we can\\'t cut the first list , hence high = curr->next\\n\\t\\n    void findmiddle(ListNode* curr ,ListNode* &first ,ListNode*  &second)\\n    {\\n        ListNode* low = curr , *high = curr->next;\\n        while(high && high->next)\\n        {\\n            high = high->next->next;\\n            low = low->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1796774,
                "title": "c-daily-leetcode-challenge-february-day-24",
                "content": "class Solution \\n{\\npublic:\\n*     ListNode* add(int data)\\n*     {\\n        ListNode* newnode = new ListNode();\\n        newnode->val = data;\\n        newnode->next = NULL;\\n        return newnode;\\n      }\\n    \\n*     ListNode* sortList(ListNode* head) \\n*     {\\n        // if our head is null then no need to traverse the LL just return head itself\\n        // []\\n        if(head==NULL)\\n            return head;\\n        \\n        // step 1 - change our LL to a vector just simple\\n        // vector [4,2,1,3]\\n        ListNode* itr = head;\\n        vector<int> ds;\\n        while(itr!=NULL)\\n        {\\n            ds.push_back(itr->val);\\n            itr = itr->next;\\n        }\\n        \\n        // step 2- sort the vector in ascending order\\n        // vector [1,2,3,4] \\n        sort(ds.begin(),ds.end());\\n        \\n        \\n        // step 3- Change the ascending vector into the LL just simple\\n        // LL [1,2,3,4]\\n        ListNode* ans =NULL;\\n        ans = add(ds[0]);\\n        ListNode* cur = ans;\\n        \\n        for(int i=1;i<ds.size();i++)\\n        {\\n            cur->next = add(ds[i]);\\n            cur = cur->next;\\n        }\\n        \\n        // returning the sorted LL\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n*     ListNode* add(int data)\\n*     {\\n        ListNode* newnode = new ListNode();\\n        newnode->val = data;\\n        newnode->next = NULL;\\n        return newnode;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1796041,
                "title": "148-sort-list-easy-understanding-using-merge-sort-solution",
                "content": "```\\n ListNode* mergesort(ListNode* l1, ListNode* l2){\\n        ListNode* result = NULL;\\n        if(l1==NULL)\\n            return l2;\\n        if(l2==NULL)\\n            return l1;\\n        if(l1->val <=l2->val){\\n            l1->next = mergesort(l1->next,l2);\\n            result=  l1;\\n        }\\n        else{\\n            l2->next = mergesort(l1,l2->next);\\n            result =  l2;\\n        }\\n        return(result);\\n       \\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head->next==NULL)\\n            return head;\\n        \\n        // Finding the middle point first\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast =fast->next->next;  \\n        }\\n        // creating two seperate Linked list l1,l2\\n        ListNode* newhead = slow->next;\\n        slow->next= NULL;\\n        \\n        return mergesort(sortList(newhead),sortList(head));\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n ListNode* mergesort(ListNode* l1, ListNode* l2){\\n        ListNode* result = NULL;\\n        if(l1==NULL)\\n            return l2;\\n        if(l2==NULL)\\n            return l1;\\n        if(l1->val <=l2->val){\\n            l1->next = mergesort(l1->next,l2);\\n            result=  l1;\\n        }\\n        else{\\n            l2->next = mergesort(l1,l2->next);\\n            result =  l2;\\n        }\\n        return(result);\\n       \\n    }\\n    \\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL || head->next==NULL)\\n            return head;\\n        \\n        // Finding the middle point first\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast =fast->next->next;  \\n        }\\n        // creating two seperate Linked list l1,l2\\n        ListNode* newhead = slow->next;\\n        slow->next= NULL;\\n        \\n        return mergesort(sortList(newhead),sortList(head));\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795921,
                "title": "using-min-heap-priority-queue-technique-easy-solution",
                "content": "```\\n   class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL) return {};\\n        ListNode* node = head;\\n        ListNode* curr = head;\\n     priority_queue<pair<int,ListNode*>,vector<pair<int,ListNode*>>,greater<pair<int,ListNode*>>> q;\\n        while(curr!=NULL){\\n            cout<<curr->val<<\" \";\\n            q.push({curr->val,curr});\\n            curr=curr->next;\\n        }\\n        \\n        ListNode* head1 = new ListNode(); // can also be called as dummy\\n        ListNode* curr1 = head1; \\n    \\n        while(q.size()!=0){\\n            curr1->next=q.top().second;\\n            q.pop();\\n            curr1=curr1->next;\\n        }\\n        curr1 -> next = NULL; \\n        head1 = head1 -> next; \\n        return head1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n   class Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL) return {};\\n        ListNode* node = head;\\n        ListNode* curr = head;\\n     priority_queue<pair<int,ListNode*>,vector<pair<int,ListNode*>>,greater<pair<int,ListNode*>>> q;\\n        while(curr!=NULL){\\n            cout<<curr->val<<\" \";\\n            q.push({curr->val,curr});\\n            curr=curr->next;\\n        }\\n        \\n        ListNode* head1 = new ListNode(); // can also be called as dummy\\n        ListNode* curr1 = head1; \\n    \\n        while(q.size()!=0){\\n            curr1->next=q.top().second;\\n            q.pop();\\n            curr1=curr1->next;\\n        }\\n        curr1 -> next = NULL; \\n        head1 = head1 -> next; \\n        return head1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1795855,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Recursive Merge Sort\\n* Pre-requisites:\\n\\t* [LC 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/discuss/257773/Java-or-Faster-than-100)\\n\\t* [LC 876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/discuss/1651478/Java-or-0-ms-or-Explained-or-2-pointers)\\n* Idea:\\n\\t* Use Merge Sort\\'s Divide & Conquer paradigm to \\n\\t\\t* Divide: recursively bisect the list until it reduces to single node\\n\\t\\t* Conquer: merge the bisected parts, which are in themselves sorted, in such a way that the merged list is also sorted\\n\\n![image](https://assets.leetcode.com/users/images/38022808-d775-4f96-a4af-31b6de46f541_1645689335.3642704.png)\\n\\n>**T/S:** O(n lg n)/O(lg n)\\n```\\npublic ListNode sortList(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn head;\\n\\tvar mid = mid(head);\\n\\tvar l1 = sortList(head);\\n\\tvar l2 = sortList(mid);\\n\\treturn merge(l1, l2);\\n}\\n\\nprivate ListNode mid(ListNode head) {\\n\\tListNode prev = null;\\n\\tvar slow = head;\\n\\tvar fast = head;\\n\\n\\twhile (fast != null && fast.next != null) {\\n\\t\\tprev = slow;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\n\\tprev.next = null; // detach first half from the second\\n\\treturn slow;\\n}\\n\\nprivate ListNode merge(ListNode l1, ListNode l2) {\\n\\tif (l1 == null)\\n\\t\\treturn l2;\\n\\tif (l2 == null)\\n\\t\\treturn l1;\\n\\tif (l1.val < l2.val) {\\n\\t\\tl1.next = merge(l1.next, l2);\\n\\t\\treturn l1;\\n\\t}\\n\\tl2.next = merge(l1, l2.next);\\n\\treturn l2;\\n}\\n```\\n**Method 2:** Iterative Merge Sort\\n>**T/S:** O(n lg n)/O(1)\\n```\\npublic ListNode sortList(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn head;\\n\\tvar len = sizeOfLL(head);\\n\\tvar dummyHead = new ListNode(0, head);\\n\\t// width = width * 2 ==> because we want to mergeSort nodes in pairs/at\\n\\t// power of 2s -- starting from 1. e.g. 1 -> 2 -> 4 -> 8 -> ...\\n\\t// so...the initial iteration will be mergeSorting the nodes 1-by-1 then\\n\\t// 2-by-2 then etc.\\n\\tfor (var width = 1; width < len; width *= 2) {\\n\\t\\t// re-initialize left (back to the newHead!) whenever the width is\\n\\t\\t// updated - we want to\\n\\t\\t// iterate through the list again from the beginning but\\n\\t\\t// this time is a different pair width/size.\\n\\t\\tvar left = dummyHead.next;\\n\\t\\t// this var is meant to keep track of sub-lists that come before the\\n\\t\\t// sub-list/pair that we are about to merge/sort (in the\\n\\t\\t// inner-loop).\\n\\t\\t// after merging, they are linked back together again.\\n\\t\\t// e.g. 1->2->4->3 ==> 1->2 merge(4, 3) ==> 1->2->3->4\\n\\t\\tListNode beforeCurrMergedList = null;\\n\\t\\t// This (inner) loop will be doing the traversal of the list with\\n\\t\\t// respect to the size of the width!\\n\\t\\t// j = width * 2 ==> 0 + 1*2 == 2 -> 2 + 1*2 == 4 ==> we are sliding\\n\\t\\t// through the list within the specified window/width!\\n\\t\\t// so, if we have a list of 4 nodes and if the current width is 1,\\n\\t\\t// this loop will only be iterating twice.\\n\\t\\t// within this loop, each width/pair will be handled accordingly.\\n\\t\\t// e.g. if the current width is 1 and this is the first iteration of\\n\\t\\t// the inner loop, the first two nodes will be sorted. {left = 1st\\n\\t\\t// node and direction = 2nd node}\\n\\t\\t// so, when we are out of an iteration, we can assume that the\\n\\t\\t// current pair has been sorted and we are now moving to the next\\n\\t\\t// set of pairs.\\n\\t\\tfor (var j = 0; j < len; j = j + width * 2) {\\n\\t\\t\\t// We have the starting left node/list -- we need to get the\\n\\t\\t\\t// direction node/list.\\n\\t\\t\\t// This is done w.r.t the current width.\\n\\t\\t\\tvar tempNode = left;\\n\\t\\t\\t// we stop direction BEFORE the beginning of the direction node/list.\\n\\t\\t\\tfor (var i = 1; tempNode != null && i < width; i++)\\n\\t\\t\\t\\ttempNode = tempNode.next;\\n\\t\\t\\t// precaution purposes. :]\\n\\t\\t\\tif (tempNode == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t// initialize the direction list\\'s starting point.\\n\\t\\t\\tvar right = tempNode.next;\\n\\t\\t\\t// this will happen if the current node is in an odd pair i.e.\\n\\t\\t\\t// has no direction node/list to pair with.\\n\\t\\t\\tif (right == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t// we want segregate/partition the left and direction sub-lists to\\n\\t\\t\\t// make merging slightly easier (and less messy IMO).\\n\\t\\t\\t// so, the last node of the left list will point to NOTHING\\n\\t\\t\\t// instead of the original starting point of the direction list.\\n\\t\\t\\ttempNode.next = null;\\n\\t\\t\\t// this portion of the code is dedicated to segregating the\\n\\t\\t\\t// direction list from the REST of the list so that we can assume\\n\\t\\t\\t// the left and direction sub-lists to be self-contained.\\n\\t\\t\\t// don\\'t worry, we\\'ll attach them back later!\\n\\t\\t\\tListNode remainders = null;\\n\\t\\t\\tif (right.next != null) {\\n\\t\\t\\t\\t// contains the (starting point of) sub-lists that come\\n\\t\\t\\t\\t// after the direction\\n\\t\\t\\t\\t// sub-list.\\n\\t\\t\\t\\tremainders = right.next;\\n\\t\\t\\t\\tvar beforeRemainder = right;\\n\\t\\t\\t\\tfor (var i = 1; remainders != null && i < width; i++) {\\n\\t\\t\\t\\t\\tbeforeRemainder = beforeRemainder.next;\\n\\t\\t\\t\\t\\tremainders = remainders.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// last node of the direction sub-list points to nothing.\\n\\t\\t\\t\\tbeforeRemainder.next = null;\\n\\t\\t\\t}\\n\\t\\t\\t// merge the left and direction sub-lists together!\\n\\t\\t\\t// this operation is exactly the same as the one that is done in\\n\\t\\t\\t// the top-down/recursive merge sort algorithm.\\n\\t\\t\\tvar mergedList = mergeTwoLists(left, right);\\n\\t\\t\\t// We want to iterate to the last node of the now merged/sorted\\n\\t\\t\\t// sub-list so that we can re-attach the previously detached\\n\\t\\t\\t// (direction-side/back) sub-list back to the merged sub-list.\\n\\t\\t\\t// remember? :]\\n\\t\\t\\ttempNode = mergedList;\\n\\t\\t\\twhile (tempNode.next != null)\\n\\t\\t\\t\\ttempNode = tempNode.next;\\n\\t\\t\\ttempNode.next = remainders;\\n\\t\\t\\t// we also want to re-attach the previously detached\\n\\t\\t\\t// (left-side/front) sub-list back to the FRONT of the merged\\n\\t\\t\\t// sub-list. remember?! :]\\n\\t\\t\\tif (beforeCurrMergedList != null)\\n\\t\\t\\t\\tbeforeCurrMergedList.next = mergedList;\\n\\t\\t\\t// now, the pointer for the to-be detached left-side/front\\n\\t\\t\\t// sub-list is updated to the end of the now merged/sorted\\n\\t\\t\\t// sub-list. Why at the last node? This is so that we can call\\n\\t\\t\\t// .next easily later on! (when doing the re-attachment)\\n\\t\\t\\tbeforeCurrMergedList = tempNode;\\n\\t\\t\\t// We then update the left sub-list to be the starting point of\\n\\t\\t\\t// the next pair of nodes (again, this is all according to the\\n\\t\\t\\t// width) -- and the cycle continues...\\n\\t\\t\\tleft = tempNode.next;\\n\\t\\t\\tif (j == 0)\\n\\t\\t\\t\\t// We want the newHead of the entire list to be updated at all\\n\\t\\t\\t\\t// times.\\n\\t\\t\\t\\t// things might shift around during the mergeSort operation.\\n\\t\\t\\t\\t// of course, it is updated only during the FIRST iteration\\n\\t\\t\\t\\t// of the inner loop.\\n\\t\\t\\t\\t// updating during subsequent iterations is unnecessary\\n\\t\\t\\t\\t// since the left/mergedList has shifted towards the\\n\\t\\t\\t\\t// back of the list as the loop goes on.\\n\\t\\t\\t\\tdummyHead.next = mergedList;\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.next;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode sortList(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn head;\\n\\tvar mid = mid(head);\\n\\tvar l1 = sortList(head);\\n\\tvar l2 = sortList(mid);\\n\\treturn merge(l1, l2);\\n}\\n\\nprivate ListNode mid(ListNode head) {\\n\\tListNode prev = null;\\n\\tvar slow = head;\\n\\tvar fast = head;\\n\\n\\twhile (fast != null && fast.next != null) {\\n\\t\\tprev = slow;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\n\\tprev.next = null; // detach first half from the second\\n\\treturn slow;\\n}\\n\\nprivate ListNode merge(ListNode l1, ListNode l2) {\\n\\tif (l1 == null)\\n\\t\\treturn l2;\\n\\tif (l2 == null)\\n\\t\\treturn l1;\\n\\tif (l1.val < l2.val) {\\n\\t\\tl1.next = merge(l1.next, l2);\\n\\t\\treturn l1;\\n\\t}\\n\\tl2.next = merge(l1, l2.next);\\n\\treturn l2;\\n}\\n```\n```\\npublic ListNode sortList(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn head;\\n\\tvar len = sizeOfLL(head);\\n\\tvar dummyHead = new ListNode(0, head);\\n\\t// width = width * 2 ==> because we want to mergeSort nodes in pairs/at\\n\\t// power of 2s -- starting from 1. e.g. 1 -> 2 -> 4 -> 8 -> ...\\n\\t// so...the initial iteration will be mergeSorting the nodes 1-by-1 then\\n\\t// 2-by-2 then etc.\\n\\tfor (var width = 1; width < len; width *= 2) {\\n\\t\\t// re-initialize left (back to the newHead!) whenever the width is\\n\\t\\t// updated - we want to\\n\\t\\t// iterate through the list again from the beginning but\\n\\t\\t// this time is a different pair width/size.\\n\\t\\tvar left = dummyHead.next;\\n\\t\\t// this var is meant to keep track of sub-lists that come before the\\n\\t\\t// sub-list/pair that we are about to merge/sort (in the\\n\\t\\t// inner-loop).\\n\\t\\t// after merging, they are linked back together again.\\n\\t\\t// e.g. 1->2->4->3 ==> 1->2 merge(4, 3) ==> 1->2->3->4\\n\\t\\tListNode beforeCurrMergedList = null;\\n\\t\\t// This (inner) loop will be doing the traversal of the list with\\n\\t\\t// respect to the size of the width!\\n\\t\\t// j = width * 2 ==> 0 + 1*2 == 2 -> 2 + 1*2 == 4 ==> we are sliding\\n\\t\\t// through the list within the specified window/width!\\n\\t\\t// so, if we have a list of 4 nodes and if the current width is 1,\\n\\t\\t// this loop will only be iterating twice.\\n\\t\\t// within this loop, each width/pair will be handled accordingly.\\n\\t\\t// e.g. if the current width is 1 and this is the first iteration of\\n\\t\\t// the inner loop, the first two nodes will be sorted. {left = 1st\\n\\t\\t// node and direction = 2nd node}\\n\\t\\t// so, when we are out of an iteration, we can assume that the\\n\\t\\t// current pair has been sorted and we are now moving to the next\\n\\t\\t// set of pairs.\\n\\t\\tfor (var j = 0; j < len; j = j + width * 2) {\\n\\t\\t\\t// We have the starting left node/list -- we need to get the\\n\\t\\t\\t// direction node/list.\\n\\t\\t\\t// This is done w.r.t the current width.\\n\\t\\t\\tvar tempNode = left;\\n\\t\\t\\t// we stop direction BEFORE the beginning of the direction node/list.\\n\\t\\t\\tfor (var i = 1; tempNode != null && i < width; i++)\\n\\t\\t\\t\\ttempNode = tempNode.next;\\n\\t\\t\\t// precaution purposes. :]\\n\\t\\t\\tif (tempNode == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t// initialize the direction list\\'s starting point.\\n\\t\\t\\tvar right = tempNode.next;\\n\\t\\t\\t// this will happen if the current node is in an odd pair i.e.\\n\\t\\t\\t// has no direction node/list to pair with.\\n\\t\\t\\tif (right == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t// we want segregate/partition the left and direction sub-lists to\\n\\t\\t\\t// make merging slightly easier (and less messy IMO).\\n\\t\\t\\t// so, the last node of the left list will point to NOTHING\\n\\t\\t\\t// instead of the original starting point of the direction list.\\n\\t\\t\\ttempNode.next = null;\\n\\t\\t\\t// this portion of the code is dedicated to segregating the\\n\\t\\t\\t// direction list from the REST of the list so that we can assume\\n\\t\\t\\t// the left and direction sub-lists to be self-contained.\\n\\t\\t\\t// don\\'t worry, we\\'ll attach them back later!\\n\\t\\t\\tListNode remainders = null;\\n\\t\\t\\tif (right.next != null) {\\n\\t\\t\\t\\t// contains the (starting point of) sub-lists that come\\n\\t\\t\\t\\t// after the direction\\n\\t\\t\\t\\t// sub-list.\\n\\t\\t\\t\\tremainders = right.next;\\n\\t\\t\\t\\tvar beforeRemainder = right;\\n\\t\\t\\t\\tfor (var i = 1; remainders != null && i < width; i++) {\\n\\t\\t\\t\\t\\tbeforeRemainder = beforeRemainder.next;\\n\\t\\t\\t\\t\\tremainders = remainders.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// last node of the direction sub-list points to nothing.\\n\\t\\t\\t\\tbeforeRemainder.next = null;\\n\\t\\t\\t}\\n\\t\\t\\t// merge the left and direction sub-lists together!\\n\\t\\t\\t// this operation is exactly the same as the one that is done in\\n\\t\\t\\t// the top-down/recursive merge sort algorithm.\\n\\t\\t\\tvar mergedList = mergeTwoLists(left, right);\\n\\t\\t\\t// We want to iterate to the last node of the now merged/sorted\\n\\t\\t\\t// sub-list so that we can re-attach the previously detached\\n\\t\\t\\t// (direction-side/back) sub-list back to the merged sub-list.\\n\\t\\t\\t// remember? :]\\n\\t\\t\\ttempNode = mergedList;\\n\\t\\t\\twhile (tempNode.next != null)\\n\\t\\t\\t\\ttempNode = tempNode.next;\\n\\t\\t\\ttempNode.next = remainders;\\n\\t\\t\\t// we also want to re-attach the previously detached\\n\\t\\t\\t// (left-side/front) sub-list back to the FRONT of the merged\\n\\t\\t\\t// sub-list. remember?! :]\\n\\t\\t\\tif (beforeCurrMergedList != null)\\n\\t\\t\\t\\tbeforeCurrMergedList.next = mergedList;\\n\\t\\t\\t// now, the pointer for the to-be detached left-side/front\\n\\t\\t\\t// sub-list is updated to the end of the now merged/sorted\\n\\t\\t\\t// sub-list. Why at the last node? This is so that we can call\\n\\t\\t\\t// .next easily later on! (when doing the re-attachment)\\n\\t\\t\\tbeforeCurrMergedList = tempNode;\\n\\t\\t\\t// We then update the left sub-list to be the starting point of\\n\\t\\t\\t// the next pair of nodes (again, this is all according to the\\n\\t\\t\\t// width) -- and the cycle continues...\\n\\t\\t\\tleft = tempNode.next;\\n\\t\\t\\tif (j == 0)\\n\\t\\t\\t\\t// We want the newHead of the entire list to be updated at all\\n\\t\\t\\t\\t// times.\\n\\t\\t\\t\\t// things might shift around during the mergeSort operation.\\n\\t\\t\\t\\t// of course, it is updated only during the FIRST iteration\\n\\t\\t\\t\\t// of the inner loop.\\n\\t\\t\\t\\t// updating during subsequent iterations is unnecessary\\n\\t\\t\\t\\t// since the left/mergedList has shifted towards the\\n\\t\\t\\t\\t// back of the list as the loop goes on.\\n\\t\\t\\t\\tdummyHead.next = mergedList;\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795600,
                "title": "simple-java-solution-with-comments-merge-sort",
                "content": "apply merge sort.\\n1. find middle of linked lust\\n2. recursively call sort method again with head and mid next again.\\n3. when single node left return node.(base case)\\n4. after that call mergeSortedLinkedList method which will merge two sorted list into one.\\nTime - o(nlogn)\\nspace - o(logn)\\n\\n```\\npublic ListNode sortList(ListNode head) {\\n\\t\\t// base case.\\n\\t\\tif (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t// find middle of linked list\\n\\t\\tListNode mid = findMiddle(head);\\n\\t\\t// get mid next as it will be starting point of second list\\n\\t\\tListNode midNext = mid.next;\\n\\t\\t// remove mid next node. now list is divided into two halfs one with head and\\n\\t\\t// other with midNext\\n\\t\\tmid.next = null;\\n\\t\\t// call recursively to divide list further\\n\\t\\tListNode left = sortList(head);\\n\\t\\tListNode right = sortList(midNext);\\n\\t\\t// merge two sorted list\\n\\t\\treturn mergeSortedList(left, right);\\n\\t}\\n\\n\\tprivate ListNode mergeSortedList(ListNode head1, ListNode head2) {\\n\\t\\t// take dummy to avoid additional checks\\n\\t\\tListNode dummy = new ListNode(-1);\\n\\t\\tListNode head = dummy;\\n\\t\\t// normal merge logic of two sorted list\\n\\t\\twhile (head1 != null && head2 != null) {\\n\\t\\t\\tif (head1.val < head2.val) {\\n\\t\\t\\t\\tdummy.next = head1;\\n\\t\\t\\t\\thead1 = head1.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdummy.next = head2;\\n\\t\\t\\t\\thead2 = head2.next;\\n\\t\\t\\t}\\n\\t\\t\\tdummy = dummy.next;\\n\\t\\t}\\n\\t\\t// set remaining list out of two to dummy.next\\n\\t\\tdummy.next = head1 == null ? head2 : head1;\\n\\t\\t// head returned\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\t// find middle element of list. we are returning 1 node before centre as we need\\n\\t// to divide it in two halfs\\n\\tprivate ListNode findMiddle(ListNode head) {\\n\\t\\tListNode slow = head;\\n\\t\\tListNode fast = head;\\n\\t\\twhile (fast != null && fast.next != null && fast.next.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t}\\n\\t\\treturn slow;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\npublic ListNode sortList(ListNode head) {\\n\\t\\t// base case.\\n\\t\\tif (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t// find middle of linked list\\n\\t\\tListNode mid = findMiddle(head);\\n\\t\\t// get mid next as it will be starting point of second list\\n\\t\\tListNode midNext = mid.next;\\n\\t\\t// remove mid next node. now list is divided into two halfs one with head and\\n\\t\\t// other with midNext\\n\\t\\tmid.next = null;\\n\\t\\t// call recursively to divide list further\\n\\t\\tListNode left = sortList(head);\\n\\t\\tListNode right = sortList(midNext);\\n\\t\\t// merge two sorted list\\n\\t\\treturn mergeSortedList(left, right);\\n\\t}\\n\\n\\tprivate ListNode mergeSortedList(ListNode head1, ListNode head2) {\\n\\t\\t// take dummy to avoid additional checks\\n\\t\\tListNode dummy = new ListNode(-1);\\n\\t\\tListNode head = dummy;\\n\\t\\t// normal merge logic of two sorted list\\n\\t\\twhile (head1 != null && head2 != null) {\\n\\t\\t\\tif (head1.val < head2.val) {\\n\\t\\t\\t\\tdummy.next = head1;\\n\\t\\t\\t\\thead1 = head1.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdummy.next = head2;\\n\\t\\t\\t\\thead2 = head2.next;\\n\\t\\t\\t}\\n\\t\\t\\tdummy = dummy.next;\\n\\t\\t}\\n\\t\\t// set remaining list out of two to dummy.next\\n\\t\\tdummy.next = head1 == null ? head2 : head1;\\n\\t\\t// head returned\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\t// find middle element of list. we are returning 1 node before centre as we need\\n\\t// to divide it in two halfs\\n\\tprivate ListNode findMiddle(ListNode head) {\\n\\t\\tListNode slow = head;\\n\\t\\tListNode fast = head;\\n\\t\\twhile (fast != null && fast.next != null && fast.next.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t}\\n\\t\\treturn slow;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795162,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    List<int> nums;\\n    public ListNode SortList(ListNode head) {\\n        nums = new List<int>();\\n        ListNode temp = head;\\n        \\n        while (temp != null) {\\n            nums.Add(temp.val);\\n            temp = temp.next;\\n        }\\n        \\n        nums.Sort();\\n        temp = head;\\n        int counter = 0;\\n        \\n        while (temp != null) {\\n            temp.val = nums[counter++];\\n            temp = temp.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    List<int> nums;\\n    public ListNode SortList(ListNode head) {\\n        nums = new List<int>();\\n        ListNode temp = head;\\n        \\n        while (temp != null) {\\n            nums.Add(temp.val);\\n            temp = temp.next;\\n        }\\n        \\n        nums.Sort();\\n        temp = head;\\n        int counter = 0;\\n        \\n        while (temp != null) {\\n            temp.val = nums[counter++];\\n            temp = temp.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728488,
                "title": "python-o-n-space-and-o-nlogn-time-fastest-solution",
                "content": "The idea is simple to create a list of all nodes sort it according to the values and then reaarange it to make a sorted list\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        l=[]\\n        if head is None:\\n            return None\\n        while temp is not None:\\n            l.append(temp)\\n            temp=temp.next\\n        l.sort(key=lambda x:x.val) \\n        new_head=l[0]\\n        temp=new_head\\n        for i in range(1,len(l)):\\n            temp.next=l[i]\\n            temp=temp.next\\n        temp.next=None\\n        return new_head\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "The idea is simple to create a list of all nodes sort it according to the values and then reaarange it to make a sorted list\\n```\\nclass Solution:\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        l=[]\\n        if head is None:\\n            return None\\n        while temp is not None:\\n            l.append(temp)\\n            temp=temp.next\\n        l.sort(key=lambda x:x.val) \\n        new_head=l[0]\\n        temp=new_head\\n        for i in range(1,len(l)):\\n            temp.next=l[i]\\n            temp=temp.next\\n        temp.next=None\\n        return new_head\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1701247,
                "title": "c-fast-slow-pointer-merge-sort-2-pointer-approach-sort-list",
                "content": "# Sort List\\n**KNOCKCAT**\\n```\\n1. 2 Pointer Approach / Fast Slow (Turtle-Hare Algorithm) Finding the Middle Element.\\n2. Simple Merge Sort Logic , As we Handle in Case of Array.\\n3. Explanation as Comments.\\n4. Plese Upvote if it Helps.\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //If List Contain a Single or 0 Node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        \\n        ListNode *temp = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(fast !=  NULL && fast -> next != NULL)\\n        {\\n            temp = slow;\\n            slow = slow->next;          //slow increment by 1\\n            fast = fast ->next ->next;  //fast incremented by 2\\n            \\n        }   \\n        temp -> next = NULL;            //end of first left half\\n        \\n        ListNode* l1 = sortList(head);    //left half recursive call\\n        ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n        return mergelist(l1, l2);         //mergelist Function call\\n            \\n    }\\n    \\n    //MergeSort Function O(n*logn)\\n    ListNode* mergelist(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ptr = new ListNode(0);\\n        ListNode *curr = ptr;\\n        \\n        while(l1 != NULL && l2 != NULL)\\n        {\\n            if(l1->val <= l2->val)\\n            {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }\\n            else\\n            {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n        \\n        curr = curr ->next;\\n        \\n        }\\n        \\n        //for unqual length linked list\\n        \\n        if(l1 != NULL)\\n        {\\n            curr -> next = l1;\\n            l1 = l1->next;\\n        }\\n        \\n        if(l2 != NULL)\\n        {\\n            curr -> next = l2;\\n            l2 = l2 ->next;\\n        }\\n        \\n        return ptr->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. 2 Pointer Approach / Fast Slow (Turtle-Hare Algorithm) Finding the Middle Element.\\n2. Simple Merge Sort Logic , As we Handle in Case of Array.\\n3. Explanation as Comments.\\n4. Plese Upvote if it Helps.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        //If List Contain a Single or 0 Node\\n        if(head == NULL || head ->next == NULL)\\n            return head;\\n        \\n        \\n        ListNode *temp = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\\n        while(fast !=  NULL && fast -> next != NULL)\\n        {\\n            temp = slow;\\n            slow = slow->next;          //slow increment by 1\\n            fast = fast ->next ->next;  //fast incremented by 2\\n            \\n        }   \\n        temp -> next = NULL;            //end of first left half\\n        \\n        ListNode* l1 = sortList(head);    //left half recursive call\\n        ListNode* l2 = sortList(slow);    //right half recursive call\\n        \\n        return mergelist(l1, l2);         //mergelist Function call\\n            \\n    }\\n    \\n    //MergeSort Function O(n*logn)\\n    ListNode* mergelist(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ptr = new ListNode(0);\\n        ListNode *curr = ptr;\\n        \\n        while(l1 != NULL && l2 != NULL)\\n        {\\n            if(l1->val <= l2->val)\\n            {\\n                curr -> next = l1;\\n                l1 = l1 -> next;\\n            }\\n            else\\n            {\\n                curr -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n        \\n        curr = curr ->next;\\n        \\n        }\\n        \\n        //for unqual length linked list\\n        \\n        if(l1 != NULL)\\n        {\\n            curr -> next = l1;\\n            l1 = l1->next;\\n        }\\n        \\n        if(l2 != NULL)\\n        {\\n            curr -> next = l2;\\n            l2 = l2 ->next;\\n        }\\n        \\n        return ptr->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637531,
                "title": "python-solution-merge-sort-inplace-suitable-comments",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def getMid(self, head: ListNode):\\n        \\'\\'\\'\\n        Get the middle node via using slow/fast pointer\\n        \\'\\'\\'\\n        slow, fast = head, head.next\\n\\n        while fast and fast.next:\\n            slow = slow.next       # step by 1\\n            fast = fast.next.next  # step by 2\\n\\n        return slow  # at the end slow will be pointing to middle node of linked list\\n\\n    def merge(self, ll1: ListNode, ll2: ListNode):\\n        \\'\\'\\'\\n        :param ll1 :- linked list 1\\n        :param ll2 :- linked list 2\\n        Merge the 2 linked lists, both being sorted already into single sorted linked list\\n        T.C = O(n)\\n        \\'\\'\\'\\n        tail = head = ListNode() # in case to handle empty node in either of list\\n\\n        while ll1 and ll2:\\n            if ll1.val > ll2.val:\\n                tail.next = ll2  # append smaller {ll2} to tail of final linked list\\n                ll2 = ll2.next \\n            else:\\n                tail.next = ll1  # append smaller {ll1} to tail of final linked list\\n                ll1 = ll1.next \\n            tail = tail.next  # update {tail} as 1 element gets being added in current loop\\n        \\n        # if elements left in {ll1} add all to end ie {tail}\\n        if ll1:\\n            tail.next = ll1\\n        # if elements left in {ll2} add all to end ie {tail}\\n        if ll2:\\n            tail.next = ll2 \\n        \\n        return head.next\\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\'\\'\\'\\n        As we have linkedList so it can be done easily in O(1) Space Complexity\\n        T.C = O(n*logn)\\n        S.C = O(1)\\n        (Inplace sorting)\\n        \\'\\'\\'\\n        if not head or not head.next: # 0 or 1 node only in linkedlist\\n            return head \\n        \\n        # 1. split the Linked List into 2 half\\n        mid = self.getMid(head) # mid will be the last node of left part\\n        left = head\\n        right = mid.next  # as the right half will start immediate next to mid\\n        mid.next = None  # seperate out the first half\\n\\n        # 2. sort the halves\\n        l = self.sortList(left)  # head of left part after sorted\\n        r = self.sortList(right) # head of right part after sorted\\n\\n        # 3. merge the halves\\n        return self.merge(l, r)\\n\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def getMid(self, head: ListNode):\\n        \\'\\'\\'\\n        Get the middle node via using slow/fast pointer\\n        \\'\\'\\'\\n        slow, fast = head, head.next\\n\\n        while fast and fast.next:\\n            slow = slow.next       # step by 1\\n            fast = fast.next.next  # step by 2\\n\\n        return slow  # at the end slow will be pointing to middle node of linked list\\n\\n    def merge(self, ll1: ListNode, ll2: ListNode):\\n        \\'\\'\\'\\n        :param ll1 :- linked list 1\\n        :param ll2 :- linked list 2\\n        Merge the 2 linked lists, both being sorted already into single sorted linked list\\n        T.C = O(n)\\n        \\'\\'\\'\\n        tail = head = ListNode() # in case to handle empty node in either of list\\n\\n        while ll1 and ll2:\\n            if ll1.val > ll2.val:\\n                tail.next = ll2  # append smaller {ll2} to tail of final linked list\\n                ll2 = ll2.next \\n            else:\\n                tail.next = ll1  # append smaller {ll1} to tail of final linked list\\n                ll1 = ll1.next \\n            tail = tail.next  # update {tail} as 1 element gets being added in current loop\\n        \\n        # if elements left in {ll1} add all to end ie {tail}\\n        if ll1:\\n            tail.next = ll1\\n        # if elements left in {ll2} add all to end ie {tail}\\n        if ll2:\\n            tail.next = ll2 \\n        \\n        return head.next\\n    \\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\'\\'\\'\\n        As we have linkedList so it can be done easily in O(1) Space Complexity\\n        T.C = O(n*logn)\\n        S.C = O(1)\\n        (Inplace sorting)\\n        \\'\\'\\'\\n        if not head or not head.next: # 0 or 1 node only in linkedlist\\n            return head \\n        \\n        # 1. split the Linked List into 2 half\\n        mid = self.getMid(head) # mid will be the last node of left part\\n        left = head\\n        right = mid.next  # as the right half will start immediate next to mid\\n        mid.next = None  # seperate out the first half\\n\\n        # 2. sort the halves\\n        l = self.sortList(left)  # head of left part after sorted\\n        r = self.sortList(right) # head of right part after sorted\\n\\n        # 3. merge the halves\\n        return self.merge(l, r)\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630013,
                "title": "c-don-t-try-to-reinvent-the-wheel-beats-98",
                "content": "My good advise here would be - do not try to reinvent the wheel. \\nAlways try  build-in functions whenever possible because in 99% cases they are fast and very well tested...\\n![image](https://assets.leetcode.com/users/images/8ce17d96-1126-4471-8abd-bf69e86ff58b_1639571354.2534208.png)\\n\\n```\\npublic class Solution {\\n    public ListNode SortList(ListNode head) {\\n        if(head == null)\\n            return null;\\n\\n        var sorted = ToSortedList(head);\\n        return BuildList(sorted);\\n    }\\n    \\n    private List<int> ToSortedList(ListNode head)\\n    {\\n        var res = new List<int>();\\n        while(head != null)\\n        {\\n            res.Add(head.val);\\n            head = head.next;\\n        }\\n        res.Sort();\\n        return res;\\n    }\\n    \\n    private ListNode BuildList(List<int> list)\\n    {\\n        var root = new ListNode(list[0]);\\n        var curr = root;\\n        for(int i=1; i<list.Count; i++)\\n        {\\n            curr.next = new ListNode(list[i]);\\n            curr = curr.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode SortList(ListNode head) {\\n        if(head == null)\\n            return null;\\n\\n        var sorted = ToSortedList(head);\\n        return BuildList(sorted);\\n    }\\n    \\n    private List<int> ToSortedList(ListNode head)\\n    {\\n        var res = new List<int>();\\n        while(head != null)\\n        {\\n            res.Add(head.val);\\n            head = head.next;\\n        }\\n        res.Sort();\\n        return res;\\n    }\\n    \\n    private ListNode BuildList(List<int> list)\\n    {\\n        var root = new ListNode(list[0]);\\n        var curr = root;\\n        for(int i=1; i<list.Count; i++)\\n        {\\n            curr.next = new ListNode(list[i]);\\n            curr = curr.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566242,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1566598,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1565428,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1776500,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1571321,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1567104,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1568977,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1925431,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1786180,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1571324,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1566242,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1566598,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1565428,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1776500,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1571321,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1567104,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1568977,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1925431,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1786180,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 1571324,
                "content": [
                    {
                        "username": "ghost89413",
                        "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?"
                    },
                    {
                        "username": "z_acc",
                        "content": "Merge sort can be done in place on linked lists technically you can do it in place in arrays too but it\\'s more complicated."
                    },
                    {
                        "username": "keenox",
                        "content": "[@mcthouacbb](/mcthouacbb) How? You would still need to keep an array of iterators/pointers. You can use merge sort inplace for continuous memory regions, which is not the case for lists. If you create a separate array for this, it will still be O(n), not O(1)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@mohammedmsbah191](/mohammedmsbah191) This has an O(n^2) run time."
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        //Selection Sort\\n        for(ListNode temp=head;temp!=null;temp=temp.next){\\n            ListNode  min=temp;\\n            ListNode j=temp.next;\\n            while (j!=null ){\\n                if(min.val>j.val){\\n                    int t=min.val;\\n                    min.val=j.val;\\n                    j.val=t;}//if\\n                j=j.next;\\n            }//while\\n        }//for\\n        return head;\\n    }//func\\n"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Merge sort does not always require extra space. You can use bottom up merge sort and sort it in with constant space. "
                    },
                    {
                        "username": "sawdemil",
                        "content": "[@progress](/progress) worst case O(n*n)"
                    },
                    {
                        "username": "progress",
                        "content": "Actually, space complexity for quick sort is O(logn) because max height of stack is logn"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?"
                    },
                    {
                        "username": "aalmos",
                        "content": "Correct. It\\'s a pattern on LC that people claim recursive solutions O(1) memory."
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "You are 100% right. Even if we call function without any params, we still put it to stack. It means O(log*N) space complexity for merge sort."
                    },
                    {
                        "username": "McGar",
                        "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?"
                    },
                    {
                        "username": "heavensxu",
                        "content": "No recursion should be used."
                    },
                    {
                        "username": "davidtn",
                        "content": "Recursion is at least O(N) space because of recursion stack. Correct me if I'm wrong. EDIT: I just read solution and learned the recursion tree can be O(logN) space\n\nIf you want to aim for O(1) space, forget recursion. \n\n\nHowever it's just a followup "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Recursion effects time complexity"
                    },
                    {
                        "username": "aesteve",
                        "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n"
                    },
                    {
                        "username": "dluiscosta",
                        "content": "I don\\'t believe you, I think you\\'re a myth"
                    },
                    {
                        "username": "qwer111",
                        "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Merge Sort\n\n  \n**Approach 2:** Bottom Up Merge Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuaGua",
                        "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?"
                    },
                    {
                        "username": "steventanxd",
                        "content": "[@salmansaeed964](/salmansaeed964) hahaha"
                    },
                    {
                        "username": "salmansaeed964",
                        "content": "[@mcthouacbb](/mcthouacbb)  you give very quick reply of said question after 8 years xD"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "There\\'s no requirement for it to be constant space. It\\'s just a follow-up(basically bonus points)."
                    },
                    {
                        "username": "Rajat_Shukla",
                        "content": "Its a follow up question. The main question\\'s solution does not need to be O(1) space."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Testcase #30?\\nI do not understand Testcase #30?\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified."
                    },
                    {
                        "username": "paltiw018",
                        "content": " i have tried it and produced same result please look into it @leetcode"
                    },
                    {
                        "username": "waerte",
                        "content": "Hi folks,\\nI received a runtime error : Last executed input: {}. what does this mean, and what is the desired output for this input in this problem? \\nThanks!"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Is it about Testcase #30?\\nI do not understand this case\\n\\nhead =\\n\\nWhat does it mean?\\nIs it nullptr or something else?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Man, I have a feeling I\\'m too late, but it means {} sort of broke your code down."
                    }
                ]
            },
            {
                "id": 2001490,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1978850,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1818690,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1689532,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1573268,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1572086,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1571322,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1571323,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1569597,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 1568976,
                "content": [
                    {
                        "username": "hemanth0010",
                        "content": "I was getting stackoverflow error \\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n        return head; \\n    }\\n\\n    ListNode mid = middle(head);\\n    ListNode head2 = mid.next;\\n    mid.next = null;\\n\\n    ListNode newHead1 = sortList(head);\\n    ListNode newHead2 = sortList(head2);\\n\\n    ListNode merged = merge(newHead1, newHead2);\\n    return merged; \\n    }\\n    \\n    private ListNode middle(ListNode head)\\n    {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return slow;\\n    }\\n    public ListNode merge(ListNode list1,ListNode list2)\\n    {\\n        if(list1 == null && list2 == null)\\n        {\\n            return null;\\n        }\\n        if(list1 != null && list2 == null)\\n            return list1;\\n        if(list1 == null && list2 != null)\\n            return list2;\\n        ListNode dummy=new ListNode(0);\\n        ListNode t=dummy;\\n        while(list1 != null && list2 != null)\\n        {\\n            if(list1.val > list2.val)\\n            {\\n                t.next=list2;\\n                list2=list2.next;\\n            }\\n            else\\n            {\\n                t.next=list1;\\n                list1=list1.next;\\n            }\\n            t=t.next;\\n        }\\n        if(list1 != null)\\n        {\\n            t.next=list1;\\n        }\\n        if(list2 != null)\\n        {\\n            t.next=list2;\\n        }\\n        return dummy.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Am I the only one who sloved this Qs using hashmap"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "help !! its showing runtime error\\n class Solution {\\npublic:\\n    ListNode* getmid(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!= NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            // if(fast != NULL){\\n                fast=fast->next;\\n            // }\\n        }return slow;\\n    }\\n    ListNode* merge(ListNode* left,ListNode* right){\\n        if(left == NULL){\\n            return right;\\n        }\\n        if(right == NULL){\\n            return left;\\n        }\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* temp=ans;\\n        while(left != NULL && right != NULL){\\n            if(left->val <= right->val){\\n                temp->next=left;\\n                temp=left;\\n                left=left->next;\\n                }\\n            else{\\n                temp->next=right;\\n                temp=right;\\n                right=right->next;\\n            }\\n            // while(right == NULL){\\n            //     temp->next=left;\\n            //     temp=left;\\n            //     left=left->next;\\n            // }while(right == NULL){\\n            //     temp->next=right;\\n            //     temp=right;\\n            //     right=right->next;\\n            // }\\n            if(left != NULL){\\n                temp->next=left;\\n                left=left->next;\\n            }\\n            if(right != NULL){\\n                temp->next=right;\\n                right=right->next;\\n            }\\n        }ans=ans->next;\\n        return ans;\\n\\n\\n\\n    }\\n    ListNode* sortList(ListNode* head) {\\n        if(head == NULL && head->next == NULL){\\n            return head;\\n        }\\n        ListNode* mid= getmid(head);\\n        ListNode* left=head;\\n        ListNode* right=mid->next;\\n        mid->next=  NULL;\\n\\n        left  = sortList(left);\\n        right = sortList(right);\\n        ListNode* res= merge(left,right);\\n        return res;\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Agrawal_Nabhi",
                        "content": "hey !! did you got any solution ?? "
                    },
                    {
                        "username": "indra_kumar16",
                        "content": "Very sort and simple code : ) \\n\\n class Solution {\\n    public ListNode sortList(ListNode head) {\\n\\n        PriorityQueue<Integer> pq  = new PriorityQueue<>();\\n        ListNode cur = head;\\n\\n        while(cur!=null){\\n            pq.add(cur.val);\\n            cur = cur.next;\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n         cur = ans;\\n         while(!pq.isEmpty()){\\n             ListNode add= new ListNode(pq.poll());\\n             ans.next = add;\\n             ans = ans.next;\\n         }\\n\\n        return cur.next;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "john68",
                        "content": "With the given data structures, I tried implementing this, but I am having a hard time doing so. Did anybody submit a rust solution?"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "in C++, see forwar_list member function sort. That\\'s exactly what this problem asked for."
                    },
                    {
                        "username": "clark3",
                        "content": "I know it breaks the requirement of constant space, but my quick sort keeps time out on the bad cases."
                    },
                    {
                        "username": "lllxin037",
                        "content": "In each value of count, there are nested iterations. To create *left* and *right*, it need the O(n/count), and the merge one is O(count). So, the complexity is still like O(n/count) * O(count) = O(n) ?\\n\\nI am not good at the algorithm. That's the reason I don't know how to calculate the complexity."
                    },
                    {
                        "username": "sin1080",
                        "content": "If your solution contains recursive calls then you violated the requirement of O(1) space since the recursive tree height is almost always O(logN) for a O(NlogN) sorting algorithm. For a true constant space solution not ever a single recursion is allowed."
                    },
                    {
                        "username": "dinkywink",
                        "content": "careful, a constant amount of recursions would still be O(1) space! take an iterative exponent function \"exp(n)\", if I am given a negative value I will return 1 / exp(-1 * n) and this would still be O(1) space :)"
                    },
                    {
                        "username": "ivveius",
                        "content": "Should I contain the ListNode declaration inside my code? I encounter unreasonable errors to me when I submit my code either containing or not containing the ListNode part. After modifying the code several times now the error is \"AttributeError: class ListNode has no attribute 'deserialize'\".\\n\\nSince there is no sample input, I do not know how to 'deserialize' it and I cannot test the code by myself. Would someone pleased to provide a sample?"
                    }
                ]
            },
            {
                "id": 2052805,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 2034011,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1991557,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1965480,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1964314,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1931760,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1892155,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1865928,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1856446,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1795641,
                "content": [
                    {
                        "username": "tucha",
                        "content": "Is it possible to solve this problem with O(1) memory?\n\nAs others said we recursive functions aren't O(1) memory. And we can't use HashMap or other structures to sort. \n\nHow we can do it? For me, it appears that it is not possible. So is that an answer? "
                    },
                    {
                        "username": "dporwal985",
                        "content": "> Getting Error: `RecursionError: maximum recursion depth exceeded`.\\n\\n> I think problems must be solved within `O(nlogn)` time and constant space. That\\'s why I\\'m getting errors. Help me to correct this.\\n\\nCode:\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def midPointLL(self, head):\\n\\n        fast = head\\n        slow = head\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        return slow\\n\\n    def mergeTwoSortedLL(self,head1, head2):\\n\\n        current = ListNode()\\n        head = current\\n\\n        while head1 and head2:\\n\\n            if head1.val < head2.val:\\n                head.next = head1\\n                head1 = head1.next\\n            else:\\n                head.next = head2\\n                head2 = head2.next\\n            head = head.next\\n        \\n        head.next = head1 or head2\\n\\n        return current.next\\n\\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        mid = self.midPointLL(head)\\n\\n        midNext = mid.next\\n        mid.next = None\\n\\n        head1 = self.sortList(head)\\n        head2 = self.sortList(midNext)\\n\\n        current = self.mergeTwoSortedLL(head1, head2)\\n\\n        return current\\n```\\n\\n## Approach\\n\\n1. **Midpoint Calculation (Finding Middle Element)**:\\n   The `midPointLL` method uses the two-pointer technique to find the midpoint of a linked list. The fast pointer advances by two steps for every step of the slow pointer. When the fast pointer reaches the end, the slow pointer will be at the midpoint. This is used to split the linked list into two halves for sorting.\\n\\n2. **Merge Two Sorted Linked Lists (Merge Step)**:\\n   The `mergeTwoSortedLL` method merges two sorted linked lists in a way that maintains the sorted order. It uses a dummy node and iterates through both linked lists while comparing the elements. The elements are merged into the new list in a sorted manner.\\n\\n3. **Sort List (Recursive Merge Sort)**:\\n   The `sortList` method is the main entry point for sorting the linked list using merge sort. It first checks the base cases: if the linked list is empty or contains only one element, it\\'s already sorted, so the original list is returned. Otherwise, it finds the midpoint using the `midPointLL` method, then recursively sorts the left and right halves using `sortList`. Finally, it merges the two sorted halves using the `mergeTwoSortedLL` method.\\n\\n"
                    },
                    {
                        "username": "ravih19",
                        "content": "Unlike many people here I solved this problem using a vector, Although the time complexity is O(nlogn) the space complexity becomes O(n).\\n1. Push the list values onto the vector.\\n2. Sort the vector using sort function.\\n3. assign the sorted values to the list from the vector.\\nThis solution to the problem beats 99% runtime and 81% in memory space. I used C++ and i am beginner.\\n\\n"
                    },
                    {
                        "username": "keenox",
                        "content": "Is allocating 5 * 10^4 space every time considered constant space? Else I don\\'t see how you would get both the time and memory complexities to nlogn and 1."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "Hi everyone,\\nI believe that using the merge sort approach for sorting linked lists is an excellent choice for this problem. This algorithm has a time complexity of O(nlogn), where n represents the number of nodes in the linked list. \\n\\nThe merge sort approach also provides the advantage of achieving the desired time complexity with constant space. Unlike quicksort or heapsort, merge sort does not require additional space proportional to the input size. Instead, it utilizes the existing structure of the linked list, making it a suitable choice for scenarios where memory usage is a concern. It balances both time and space complexity, making it a recommended choice for sorting\\xA0linked\\xA0lists.\\n\\nThank you!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "people using a vector to get the ans are getting better time and space complexity  :)"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it a requirement to do it inplace? It would be super easy to just read all the values and to put it into a list and than to sort it."
                    },
                    {
                        "username": "user0897DS",
                        "content": "From my understanding what this question means by 0(1) memory is that we don\\'t declare an array, add list\\'s element to it, sort it and then return back them to the list."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "// Will anyone help  me Why my code is wrong?\\n\\nListNode* sortList(ListNode* head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        } // now slow = mid;\\n        \\n        // we have to make two halves of the same linked list\\n        ListNode *sec_Head = slow->next;\\n        slow->next = NULL;\\n\\n        sortList(head);\\n        sortList(sec_Head);\\n\\n        ListNode *sortedList = merge(head, sec_Head);\\n        return sortedList;\\n    }\\n\\npublic:\\n    ListNode* merge(ListNode* head, ListNode* sec_Head) {\\n    if (head == NULL) return sec_Head;\\n    if (sec_Head == NULL) return head;\\n\\n    ListNode* newList = new ListNode(0);\\n    ListNode* ptr = newList;\\n    while (head != NULL && sec_Head != NULL) {\\n        if (head->val < sec_Head->val) {\\n            ptr->next = head;\\n            head = head->next;\\n        }\\n        else {\\n            ptr->next = sec_Head;\\n            sec_Head = sec_Head->next;\\n        }\\n        ptr = ptr->next;\\n    }\\n\\n    if (head != NULL) {\\n        ptr->next = head;\\n    }\\n    else {\\n        ptr->next = sec_Head;\\n    }\\n\\n    ptr = newList->next;\\n    delete newList;\\n    return ptr;\\n}\\n                     "
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "Can anyone explain why this code is giving a runtime error?\n\n```class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        ListNode mid = getMid(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n        \n    }\n    \n    public static ListNode merge(ListNode list1, ListNode list2){\n        \n        ListNode dummyHead = new ListNode();\n        ListNode tail = dummyHead;\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n                tail = tail.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n                tail = tail.next;\n            }\n        }\n        tail.next = (list1 != null) ? list1 : list2;\n        return dummyHead.next;\n    }\n    \n    public static ListNode getMid(ListNode head){\n\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n        slow.next = null;\n        return slow;\n    }\n} ```"
                    },
                    {
                        "username": "Vinayaka_07",
                        "content": "[@BOOMeranGG](/BOOMeranGG) Oh yeah, should maintain a midPrev element(element previous to mid, slow in this case) and make midPrev.next =  null. \\nThank you"
                    },
                    {
                        "username": "BOOMeranGG",
                        "content": "In the ::getMid function you did \n```slow.next = null;```\nWhat's wrong? Lets see an example below:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> null\n```\n\nFirst you call ::getMid. It returns 3, that's correct. But also it does:\nslow.next = null;\n\nAnd now we have:\n```\n1 -> 2 -> 3 -> null\n```\nAnd also:\n```\nmid = 3;\n```\n\n4 -> 5 were lost!\n\nYou have a good idea, just little fix needed. Hope you got it :)"
                    }
                ]
            },
            {
                "id": 1794452,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1787779,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1785910,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1776662,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1772379,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1761027,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1755555,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1754386,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1742807,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            },
            {
                "id": 1727754,
                "content": [
                    {
                        "username": "Zakaria02",
                        "content": "I was trying to find out the middle node of the linked list to apply merge sort. When I am using this below function,  StackOverflowError is being shown.\n\npublic ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode midPrev = head;\n        while (head != null && head.next != null) {\n            midPrev = midPrev.next;\n            head = head.next.next;\n        }\n        ListNode mid = midPrev.next;\n        midPrev.next = null;\n        return mid;\n    }\n\nBut it is working well for the below function.\n\npublic ListNode findMid(ListNode head) {\n        ListNode node = null;\n        while (head != null && head.next != null) {\n            node = (node == null) ? head : node.next;\n            head = head.next.next;\n        }\n        ListNode mid = node.next;\n        node.next = null;\n        return mid;\n    }\n\nI cannot find out the reason. Both the functions are doing same, isn't it? Please, explain the reason. Thank you."
                    },
                    {
                        "username": "user2017ra",
                        "content": "Using array I was able to solve this problem but I want to learn without extra space in constant space then how can I ,anyone ?"
                    },
                    {
                        "username": "mohammedmsbah191",
                        "content": "\\nclass Solution {\\n    //insrtion sort by recursion\\n    //by recurcive sorted linked list T o(n), S o(n) for recursion\\n    public ListNode sortList(ListNode head) {\\n            sort(head);\\n            return head;\\n    }\\n    private void sort(ListNode min) {\\n        if (min==null) return;\\n        for(ListNode temp=min.next;temp!=null;temp=temp.next) {\\n                if (min.val > temp.val){\\n                    int t=min.val;\\n                    min.val=temp.val;\\n                    temp.val=t;\\n                }//if\\n            }//for\\n        sort(min.next);\\n    }//func\\n        \\n    \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dheerajdhsm",
                        "content": "why my code is givig stackoverflow\\n\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        ListNode temp =head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!= null){\\n            slow = slow.next;\\n            fast= fast.next.next;\\n            temp = slow;\\n        }\\n        temp.next=null;\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        return merge(l1, l2);\\n    }\\n    public ListNode merge(ListNode l1 , ListNode l2){\\n        ListNode sortedTemp = new ListNode(0);\\n        ListNode current = sortedTemp;\\n        while(l1 != null && l2!= null){\\n            if(l1.val<=l2.val){\\n                current.next = l1;\\n                l1=l1.next;\\n            }\\n            else{\\n                current.next = l2;\\n                l2= l2.next;\\n            }\\n            current = current.next;\\n        }\\n        if(l1 != null){\\n            current.next = l1;\\n            l1=l1.next;\\n        }\\n        if(l2 != null){\\n            current.next = l2;\\n            l2=l2.next;\\n        }\\n        return sortedTemp.next;\\n    }\\n}"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Bubble Sort give TLE in case 26 so don\\'t use bubble sort\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "\n\nwhy does this exceed time limit?? I don't understand what I am doing wrong...\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        left_pointer,mid_pointer = self.getMid(head)\n        left = self.sortList(left_pointer)\n        right = self.sortList(mid_pointer)\n        return self.mergeSort(left,right)\n    \n    def mergeSort(self,left,right):\n        seek,target = (left,right) if left.val<right.val else (right,left)\n        answer = seek\n        while(seek.next!=None):\n            if seek.next.val>=target.val:\n                temp = seek.next\n                seek.next = target\n                target = temp\n            else:\n                seek = seek.next\n        seek.next = target\n        return answer\n        \n    def getMid(self,head):\n        curr=head\n        midPrev=None\n        while(curr!=None and curr.next!=None):\n            if midPrev==None: \n                midPrev=head\n            else:\n                midPrev = midPrev.next\n            curr = curr.next.next\n        mid = midPrev.next\n        midPrev.next = None\n        return head,mid\n\n\n\n"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "It is the mergeSort function but I don\\'t know why? Anyone thoughts?"
                    },
                    {
                        "username": "pika25",
                        "content": "how is this a medium level question.........."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "Anshul_patel",
                        "content": "can we add our own funtions to the code?\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Strobogrammatic Number III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571491,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "My code was ACed but it cannot pass \"9695\"\\n\"9697\"."
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Tic-Tac-Toe",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571621,
                "content": [
                    {
                        "username": "kaidul",
                        "content": "Again \"Run Code\" button is not working. Please fix this :)"
                    },
                    {
                        "username": "junhuangli",
                        "content": "[\"TicTacToe\",\"move\",\"move\",\"move\"]\\n[[2],[0,0,2],[0,1,1],[1,1,2]]\\n\\nThis test case failed when I submit my solution, but it passed if I use \"Run Code\""
                    },
                    {
                        "username": "marcuscop",
                        "content": "Pretty sure there is an issue with this test case. It\\'s impossible to win after 1, and 2 respective moves. A player needs 3 total moves to win."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Bruteforced my way through it."
                    },
                    {
                        "username": "ursat",
                        "content": "```\\nFollow-up: Could you do better than O(n2) per move() operation?\\n```\\nI guess that means the space complexity because non of the solution mentioned is O(n2) in time"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "[Overview Section of Editorial](https://leetcode.com/problems/design-tic-tac-toe/editorial/) briefly discusses the solution with $O(n^2)$ per `move()` operation.\\n\\n> The brute force approach to solve this problem is to iterate over the entire board of size n * n and check if the current player has marked any row, column, diagonal or anti-diagonal.\\n\\n"
                    }
                ]
            },
            {
                "id": 1569092,
                "content": [
                    {
                        "username": "kaidul",
                        "content": "Again \"Run Code\" button is not working. Please fix this :)"
                    },
                    {
                        "username": "junhuangli",
                        "content": "[\"TicTacToe\",\"move\",\"move\",\"move\"]\\n[[2],[0,0,2],[0,1,1],[1,1,2]]\\n\\nThis test case failed when I submit my solution, but it passed if I use \"Run Code\""
                    },
                    {
                        "username": "marcuscop",
                        "content": "Pretty sure there is an issue with this test case. It\\'s impossible to win after 1, and 2 respective moves. A player needs 3 total moves to win."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Bruteforced my way through it."
                    },
                    {
                        "username": "ursat",
                        "content": "```\\nFollow-up: Could you do better than O(n2) per move() operation?\\n```\\nI guess that means the space complexity because non of the solution mentioned is O(n2) in time"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "[Overview Section of Editorial](https://leetcode.com/problems/design-tic-tac-toe/editorial/) briefly discusses the solution with $O(n^2)$ per `move()` operation.\\n\\n> The brute force approach to solve this problem is to iterate over the entire board of size n * n and check if the current player has marked any row, column, diagonal or anti-diagonal.\\n\\n"
                    }
                ]
            },
            {
                "id": 1909528,
                "content": [
                    {
                        "username": "kaidul",
                        "content": "Again \"Run Code\" button is not working. Please fix this :)"
                    },
                    {
                        "username": "junhuangli",
                        "content": "[\"TicTacToe\",\"move\",\"move\",\"move\"]\\n[[2],[0,0,2],[0,1,1],[1,1,2]]\\n\\nThis test case failed when I submit my solution, but it passed if I use \"Run Code\""
                    },
                    {
                        "username": "marcuscop",
                        "content": "Pretty sure there is an issue with this test case. It\\'s impossible to win after 1, and 2 respective moves. A player needs 3 total moves to win."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Bruteforced my way through it."
                    },
                    {
                        "username": "ursat",
                        "content": "```\\nFollow-up: Could you do better than O(n2) per move() operation?\\n```\\nI guess that means the space complexity because non of the solution mentioned is O(n2) in time"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "[Overview Section of Editorial](https://leetcode.com/problems/design-tic-tac-toe/editorial/) briefly discusses the solution with $O(n^2)$ per `move()` operation.\\n\\n> The brute force approach to solve this problem is to iterate over the entire board of size n * n and check if the current player has marked any row, column, diagonal or anti-diagonal.\\n\\n"
                    }
                ]
            },
            {
                "id": 1909515,
                "content": [
                    {
                        "username": "kaidul",
                        "content": "Again \"Run Code\" button is not working. Please fix this :)"
                    },
                    {
                        "username": "junhuangli",
                        "content": "[\"TicTacToe\",\"move\",\"move\",\"move\"]\\n[[2],[0,0,2],[0,1,1],[1,1,2]]\\n\\nThis test case failed when I submit my solution, but it passed if I use \"Run Code\""
                    },
                    {
                        "username": "marcuscop",
                        "content": "Pretty sure there is an issue with this test case. It\\'s impossible to win after 1, and 2 respective moves. A player needs 3 total moves to win."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Bruteforced my way through it."
                    },
                    {
                        "username": "ursat",
                        "content": "```\\nFollow-up: Could you do better than O(n2) per move() operation?\\n```\\nI guess that means the space complexity because non of the solution mentioned is O(n2) in time"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "[Overview Section of Editorial](https://leetcode.com/problems/design-tic-tac-toe/editorial/) briefly discusses the solution with $O(n^2)$ per `move()` operation.\\n\\n> The brute force approach to solve this problem is to iterate over the entire board of size n * n and check if the current player has marked any row, column, diagonal or anti-diagonal.\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find All Numbers Disappeared in an Array",
        "question_content": "<p>Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return <em>an array of all the integers in the range</em> <code>[1, n]</code> <em>that do not appear in</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,3,2,7,8,2,3,1]\n<strong>Output:</strong> [5,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1]\n<strong>Output:</strong> [2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it without extra space and in <code>O(n)</code> runtime? You may assume the returned list does not count as extra space.</p>\n",
        "solutions": [
            {
                "id": 92955,
                "title": "python-4-lines-with-short-explanation",
                "content": "For each number i in nums,\\nwe mark the number that i points as negative.\\nThen we filter the list, get all the indexes\\nwho points to a positive number.\\nSince those indexes are not visited.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # For each number i in nums,\\n        # we mark the number that i points as negative.\\n        # Then we filter the list, get all the indexes\\n        # who points to a positive number\\n        for i in xrange(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = - abs(nums[index])\\n\\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # For each number i in nums,\\n        # we mark the number that i points as negative.\\n        # Then we filter the list, get all the indexes\\n        # who points to a positive number\\n        for i in xrange(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = - abs(nums[index])\\n\\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344583,
                "title": "python-o-1-space-solution",
                "content": "The idea is to use the original array to keep track of the numbers visited. Since all the numbers are positive intergers, for every number visited we mark the presence of that number by negating the number at the index equal to the current number. Since Python follows 0-indexing, the index we mark is actually `number - 1`. If the number at that index is already negated we do nothing. In the end, we just return the indices `(index + 1 for the number)` where there are still postive numbers.\\n\\nStill confused?? I hope the following example will make it clearer:\\nLet `nums = [4, 3, 2, 7, 8, 2, 3, 1]`. Now let\\'s iterate through the array `nums`.\\n\\nAt `iter = 0`,\\n`current number: |4|` `(|.| here refers to taking the absolute value)`\\n`number at index = 3 (current number - 1): 7` \\nAfter negation: `nums = [4, 3, 2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 1`\\n`current number: |3|`\\n`number at index = 2: 2` \\nAfter negation: `nums = [4, 3, -2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 2`\\n`current number: |-2|`\\n`number at index = 1: 3` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 3`\\n`current number: |-7|`\\n`number at index = 6: 3` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, -3, 1]`\\n\\nAt `iter = 4`\\n`current number: |8|`\\n`number at index = 7: 1` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 5`\\n`current number: |2|`\\n`number at index = 1: -3` \\nArray stays unchanged: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 6`\\n`current number: |-3|`\\n`number at index = 2: -2` \\nArray stays unchanged: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 7`\\n`current number: |-1|`\\n`number at index = 0: 4` \\nAfter negation: `nums = [-4, -3, -2, -7, 8, 2, -3, -1]`\\t\\t\\t\\t \\n\\nNow the indices at which there are still positive numbers are the numbers (index+1) that weren\\'t present in the array.\\n\\n```Python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):\\n            temp = abs(nums[i]) - 1\\n            if nums[temp] > 0:\\n                nums[temp] *= -1\\n        \\n        res = []\\n        for i,n in enumerate(nums):\\n            if n > 0:\\n                res.append(i+1)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):\\n            temp = abs(nums[i]) - 1\\n            if nums[temp] > 0:\\n                nums[temp] *= -1\\n        \\n        res = []\\n        for i,n in enumerate(nums):\\n            if n > 0:\\n                res.append(i+1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583736,
                "title": "c-python-all-6-solutions-w-explanations-binary-search-hashset-2x-o-1-space-approach",
                "content": "We are given an array `nums` of size `n`. We need to return an array `ans` containing all elements in range `[1, n]` that are not present in `nums`.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nA brute-force way to solve this question is to take each number in range `[1, n]` and push it into `ans` array if it doesn\\'t occur in `nums`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        return [i for i in range(1, len(nums)+1) if i not in nums]\\n```\\n\\n***Time Complexity :*** **<code>O(n<sup>2</sup>)</code>**, we iterate over the range `[1, n]` which takes `O(n)` and for each iteration, we check if that element occurs in `nums` which takes another `O(n)` giving total time of <code>O(n<sup>2</sup>)</code>\\n***Space Complexity :*** **<code>O(1)</code>**, excluding the space required for the output vector, we only use constant extra space. The output space is generally not included in the space complexity.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Sort & Binary-Search)***\\n\\nInstead of linear-searching if every element in range `[1, n]` is present in `nums` or not, we could instead sort `nums` and then apply binary-search every time. If the element is not found in `nums`, we include it in `ans`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        nums.sort()\\n        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]\\n```\\n\\n***Time Complexity :*** **<code>O(nlogn)</code>**, we iterate over the range `[1, n]` which takes `O(n)` and for each iteration, we check if that element occurs in `nums` using binary search which takes another `O(logn)` giving a total time of <code>O(nlogn)</code>\\n***Space Complexity :*** **<code>O(sort)</code>**, the only extra space required is the one used in internal sorting algorithm. Ignoring that space, we can say it to be `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (HashSet)***\\n\\nWe can do even better if we just insert every element from `nums` into a hashset and then iterate over the range `[1, n]` and only add those elements to `ans` and are not present in hashset.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums), end(nums));   // insert every nums[i] in hashset\\n        vector<int> ans(size(nums) - size(s));\\n        for(int i = 1, j = 0; i <= size(nums); i++)  \\n            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        s = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in s]\\n```\\n\\n***Time Complexity :*** **<code>O(n)</code>**, we require `O(n)` time to insert all elements into hashset and another `O(n)` time to iterate over range and insert elements not present in hashset into `ans`, thus giving a total time of `O(n)`.\\n***Space Complexity :*** **<code>O(n)</code>**, required to maintain the hashset.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Boolean array)***\\n\\nWe can slightly optimize previous approach by using an boolean array of size `n` instead of hashset, since the range is known to be `[1, n]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<bool> seen(size(nums)+1);\\n        vector<int> ans;\\n        for(auto c : nums) seen[c] = true;\\n        for(int i = 1; i <= size(nums); i++)\\n            if(!seen[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        ans, seen = [], [False]*(len(nums)+1)\\n        for c in nums: seen[c] = True\\n        for i in range(1, len(nums)+1):\\n            if not seen[i]:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** **<code>O(n)</code>**\\n***Space Complexity :*** **<code>O(n)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Placing Elements at Correct Index - Space Optimized)***\\n\\nThis solution involves placing all possible elements at their right index place. By that, I mean every possible index `i` should be occupied by correct element `i+1`, i.e, `num[i] = i+1`. This allows us to check if a number `j` from range `[1, n]` exists in `nums` or not. \\n* The numbers `j` will be present in `nums` only if the number `j` itself is present at `nums[j-1]` which is its correct index place. \\n* The numbers `j\\'` that are not present in `nums` wont have correct element (which is `j\\'` itself) at its correct index place `nums[j\\'-1]`.\\n\\nThe numbers `j` that are not in `nums` wont have correct element  at their right index place (`nums[i-1]`) and that index place would be occupied by some other element.\\n\\n**Now, Can we do this linearly using constant space? Yes!**\\n1. We will iterate over each element of `nums`.\\n2. For each element `c`, if the correct index place of `c`, i.e, `nums[c-1]` is not occupied by `c`, then we place `c` at its correct index place. But we dont want to lose number which was already present at `nums[c-1]`. So we swap it instead so the number at `nums[c-1]` occupies current element `c` & vice-versa.\\n3. We placed original current element `c` at its correct place but now we have another element as `c` for which we need to place it at its correct place. So, repeat above step till `c` is at its correct place in `nums`.\\n4. The steps 2 & 3 are repeated for all elements of `nums` so that we ensure every possible index is occupied by correct element. At last, the index not occupied by correct element are once which dont occur in `nums`.\\n\\n```python\\nLet nums = [4,3,2,7,8,2,3,1]. The steps take place as -\\n\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n\\nIndex 4 & 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing\\n```\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto& c : nums) \\n            while(nums[c-1] != c) \\n\\t\\t\\t\\tswap(c, nums[c-1]);               // swap till correct index place of c is not occupied by c itself\\n        for(int i = 1; i <= size(nums); i++)\\n            if(i != nums[i-1]) ans.push_back(i);  // correct index place of i is not occupied by i itself\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        for i in range(len(nums)):\\n            while nums[nums[i]-1] != nums[i]: \\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n        return [i for i in range(1, len(nums)+1) if i != nums[i-1]]\\n```\\n\\n**Is Infinite loop possible in while statement?**\\nNo. This is because each time we take an element and swap it with element at its right index. Each element will be placed at its right index only once. So, the while loop is bound to terminate within `O(n)`\\n\\n***Time Complexity :*** **`O(n)`**, the first loop places each possible element at its correct index place only once. Thus the for loop and its inner while loop run for atmost `O(n)`.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used except for the output `ans`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VI (Mark as seen by Negation - Space Optimized)***\\n\\nThere\\'s another way that we can compute `ans` without using any extra space (except the output `ans`). We know that **`nums` is of size is `n`** and it contains **only elements from `[1, n]`.** We can map each element of the range `[1, n]` to the indices of `nums` from `[0, n-1]`.\\n\\nThus, the above property can be used to mark if an element from range `[1, n]` is present in `nums` or not. \\n\\n**How?**\\nWe can iterate over `nums` and for each element, we know it can be mapped to index `nums[i]-1`. We can therefore **mark the element `nums[i]` as present in `nums` by making the element at index `nums[i]-1` negative**. Thus after iterating the array, we have -\\n\\n* `nums[i] < 0` or `nums[i]` is  negative only if the element `i+1` is present in the array.\\n* `nums[i] > 0` or `nums[i]` is positive only if the element `i+1` is not present in the array\\n\\nFor eg. Consider the following example -\\n```python\\nnums = [4,3,2,7,8,2,3,1]\\n1. \\'4\\' is present in nums. Mark as present by negating nums[4-1] = nums[3].  Thus, nums[3] = -7\\n   => nums = [4,3,2,-7,8,2,3,1]\\n\\t\\n2. \\'3\\' is present in nums. Mark as present by negating nums[3-1] = nums[2].  Thus, nums[2] = -2\\n   => nums = [4,3,-2,-7,8,2,3,1]\\n\\n3. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,3,1]\\n   \\n4. \\'7\\' is present in nums. Thus, nums[6] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,1]\\n\\n5. \\'8\\' is present in nums. Thus, nums[7] = -1\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]\\n   \\n6. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n  \\n7. \\'3\\' is present in nums. Thus, nums[2] = -2\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n\\n7. \\'1\\' is present in nums. Thus, nums[0] = -4\\n   => nums = [-4,-3,-2,-7,8,2,-3,-1]   \\n\\nNow, the only elements nums[i] which are positive are those where \\'i+1\\' is not found in nums\\nThese are => nums[4] and nums[5].\\nThat means 5 and 6 an not present in the initial nums array\\n```\\n\\nWe need to take care that some elements may already be negated. Thus, to avoid negative indexing or converting a negative element back to positive,  we use `abs()` to get the absolute value of elements.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto c : nums)\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1]);   // mark c is present by negating nums[c-1]\\n        for(int i = 0; i < size(nums); i++) \\n            if(nums[i] > 0) ans.push_back(i+1);      // nums[i] > 0 means i+1 isnt present in nums\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ans = []\\n        for c in nums:\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1])\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```\\n\\n***Time Complexity :*** **`O(n)`**, we only iterate `nums` twice each taking `O(n)` time atmost.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used except for the output `ans`.\\n\\n\\uD83D\\uDCA1**Note :** \\n1. If input modification is not allowed, we can even restore the `nums` back to its original form before returning. We just need to convert every negative number back to positive again.\\n2. The above solution works for all `nums` of length `n` consisting of elements in range `[k, k+n]`, where `k > 0`.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        return [i for i in range(1, len(nums)+1) if i not in nums]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        nums.sort()\\n        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums), end(nums));   // insert every nums[i] in hashset\\n        vector<int> ans(size(nums) - size(s));\\n        for(int i = 1, j = 0; i <= size(nums); i++)  \\n            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        s = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in s]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<bool> seen(size(nums)+1);\\n        vector<int> ans;\\n        for(auto c : nums) seen[c] = true;\\n        for(int i = 1; i <= size(nums); i++)\\n            if(!seen[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        ans, seen = [], [False]*(len(nums)+1)\\n        for c in nums: seen[c] = True\\n        for i in range(1, len(nums)+1):\\n            if not seen[i]:\\n                ans.append(i)\\n        return ans\\n```\n```python\\nLet nums = [4,3,2,7,8,2,3,1]. The steps take place as -\\n\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n\\nIndex 4 & 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto& c : nums) \\n            while(nums[c-1] != c) \\n\\t\\t\\t\\tswap(c, nums[c-1]);               // swap till correct index place of c is not occupied by c itself\\n        for(int i = 1; i <= size(nums); i++)\\n            if(i != nums[i-1]) ans.push_back(i);  // correct index place of i is not occupied by i itself\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        for i in range(len(nums)):\\n            while nums[nums[i]-1] != nums[i]: \\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n        return [i for i in range(1, len(nums)+1) if i != nums[i-1]]\\n```\n```python\\nnums = [4,3,2,7,8,2,3,1]\\n1. \\'4\\' is present in nums. Mark as present by negating nums[4-1] = nums[3].  Thus, nums[3] = -7\\n   => nums = [4,3,2,-7,8,2,3,1]\\n\\t\\n2. \\'3\\' is present in nums. Mark as present by negating nums[3-1] = nums[2].  Thus, nums[2] = -2\\n   => nums = [4,3,-2,-7,8,2,3,1]\\n\\n3. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,3,1]\\n   \\n4. \\'7\\' is present in nums. Thus, nums[6] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,1]\\n\\n5. \\'8\\' is present in nums. Thus, nums[7] = -1\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]\\n   \\n6. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n  \\n7. \\'3\\' is present in nums. Thus, nums[2] = -2\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n\\n7. \\'1\\' is present in nums. Thus, nums[0] = -4\\n   => nums = [-4,-3,-2,-7,8,2,-3,-1]   \\n\\nNow, the only elements nums[i] which are positive are those where \\'i+1\\' is not found in nums\\nThese are => nums[4] and nums[5].\\nThat means 5 and 6 an not present in the initial nums array\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto c : nums)\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1]);   // mark c is present by negating nums[c-1]\\n        for(int i = 0; i < size(nums); i++) \\n            if(nums[i] > 0) ans.push_back(i+1);      // nums[i] > 0 means i+1 isnt present in nums\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ans = []\\n        for c in nums:\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1])\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92958,
                "title": "c-solution-o-1-space",
                "content": "The idea is very similar to problem 442. Find All Duplicates in an Array: https://leetcode.com/problems/find-all-duplicates-in-an-array/.\\n\\nFirst iteration to negate values at position whose equal to values appear in array. Second iteration to collect all position whose value is positive, which are the missing values. Complexity is O(n) Time and O(1) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int len = nums.size();\\n        for(int i=0; i<len; i++) {\\n            int m = abs(nums[i])-1; // index start from 0\\n            nums[m] = nums[m]>0 ? -nums[m] : nums[m];\\n        }\\n        vector<int> res;\\n        for(int i = 0; i<len; i++) {\\n            if(nums[i] > 0) res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int len = nums.size();\\n        for(int i=0; i<len; i++) {\\n            int m = abs(nums[i])-1; // index start from 0\\n            nums[m] = nums[m]>0 ? -nums[m] : nums[m];\\n        }\\n        vector<int> res;\\n        for(int i = 0; i<len; i++) {\\n            if(nums[i] > 0) res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583741,
                "title": "time-o-n-space-o-1",
                "content": "For each value in the array mark its presence by making the number negative at that place in array \\neg. if you hae array [3,1,4,1] for 3, i will go to index 2 and make its value negative ie. now nums[2] becomes -4. present array: [3,1,-4,1]\\nfor 1, i will go to index 0 and make its value negative ie. now nums[0] becomes -3. present array: [-3,1,-4,1]\\nfor 4, (take abs value), i will go to index 3 and make its value negative ie. now nums[3] becomes -1. present array: [-3,1,-4,-1]\\nfor 1 take abs value), i will go to index 0 as it is already -ve do nothing. present array: [-3,1,-4,-1]\\nAt last I will have [-3,1,-4,-1]. now i will iterate over the array, whichever idx has positive value that number will not be in the array so as we have nums[1]>0 so 2 is not in the list.\\n\\n**PLEASE UPVOTE** if you liked the solution, comment for any queries\\n\\n```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                idx = nums[i]*-1-1;\\n            }else{\\n                idx = nums[i]-1;\\n            }\\n            \\n            if(nums[idx]>0){\\n                nums[idx] = -nums[idx];\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > 0){\\n                list.add(i+1);\\n            };\\n            \\n        }\\n        \\n        return list;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                idx = nums[i]*-1-1;\\n            }else{\\n                idx = nums[i]-1;\\n            }\\n            \\n            if(nums[idx]>0){\\n                nums[idx] = -nums[idx];\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > 0){\\n                list.add(i+1);\\n            };\\n            \\n        }\\n        \\n        return list;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 93007,
                "title": "simple-java-in-place-sort-solution",
                "content": "The idea is simple, if nums[i] != i + 1 and nums[i] != nums[nums[i] - 1], then we swap nums[i] with nums[nums[i] - 1], for example, nums[0] = 4 and nums[3] = 7, then we swap nums[0] with nums[3]. So In the end the array will be sorted and if nums[i] != i + 1, then i + 1 is missing.\\nThe example run as follows\\n```\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n```\\n\\nSince every swap we put at least one number to its correct position, the time is O(n)\\n\\n```java\\npublic class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {\\n                int tmp = nums[i];\\n                nums[i] = nums[tmp - 1];\\n                nums[tmp - 1] = tmp;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n```\n```java\\npublic class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {\\n                int tmp = nums[i];\\n                nums[i] = nums[tmp - 1];\\n                nums[tmp - 1] = tmp;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375581,
                "title": "c-easy-to-understand-comments-negate-seen-elements",
                "content": "1st for loop: for each value x, negate the element at xth position\\n2nd for loop: get all the positions that has a positive element. These are the missing values to return.\\n\\n```\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n        // 1st for loop: nums = [4,3,2,7,8,2,3,1]\\n        for(int i = 0; i < nums.size(); i++)  // each iteration:\\n        {                                     // i = 0              i = 1               i = 2                ... i = 7\\n            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1\\n            temp = (temp > 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1\\n            if(nums[temp-1] > 0)              // nums[3] > 0        nums[2] > 0         nums[1] > 0          ... nums[0] > 0\\n                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]\\n        } \\n\\t\\t\\n\\t\\t// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > 0)         // the 4th & 5th indexes are positive\\n                ans.push_back(i+1); // ans = [5,6]\\n\\t\\t\\t\\t\\n        return ans;\\n    }\\n```\\nUpvote if my comments helped. Have fun coding!",
                "solutionTags": [],
                "code": "```\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n        // 1st for loop: nums = [4,3,2,7,8,2,3,1]\\n        for(int i = 0; i < nums.size(); i++)  // each iteration:\\n        {                                     // i = 0              i = 1               i = 2                ... i = 7\\n            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1\\n            temp = (temp > 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1\\n            if(nums[temp-1] > 0)              // nums[3] > 0        nums[2] > 0         nums[1] > 0          ... nums[0] > 0\\n                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]\\n        } \\n\\t\\t\\n\\t\\t// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > 0)         // the 4th & 5th indexes are positive\\n                ans.push_back(i+1); // ans = [5,6]\\n\\t\\t\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777978,
                "title": "java-time-o-n-space-o-1",
                "content": "The solution works because `1 \\u2264 a[i] \\u2264 n (n = size of array)`\\nAs we walk through all elements in the array, we can use the current element as an index and flag its value (in place). All numbers are > 0, so we can use a negative number.\\nIn the end, the indexes of all positive numbers in the array are the missing values.\\n\\nThe input: [4, 3, 2, 7, 8, 2, 3, 1]\\nBecomes: [-4, -3, -2, -7, 8, 2, -3, -1]\\n\\nStarting from 1, the missing values are 5 and 6.\\n\\n```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i : nums) {\\n            int index = Math.abs(i);\\n            if (nums[index - 1] > 0) {\\n                nums[index - 1] *= -1;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i : nums) {\\n            int index = Math.abs(i);\\n            if (nums[index - 1] > 0) {\\n                nums[index - 1] *= -1;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92980,
                "title": "5-line-java-easy-understanding",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for (int i = 0; i < nums.length; i ++) nums[(nums[i]-1) % n] += n;\\n        for (int i = 0; i < nums.length; i ++) if (nums[i] <= n) res.add(i+1);\\n        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for (int i = 0; i < nums.length; i ++) nums[(nums[i]-1) % n] += n;\\n        for (int i = 0; i < nums.length; i ++) if (nums[i] <= n) res.add(i+1);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1583705,
                "title": "c-easy-intuitive-solution-2-approach-frequency-array-negation-technique",
                "content": "Hello everyone, I hope you all are doing great!\\n***Note: Please do upvote if you found this post helpful***\\n\\nSo, we have vector of size `N` which consists of values in the range `[1, N]`. And we need to return the vector consisting of missing elements.\\n\\n**Approach 1: (Frequency Array)**\\n1. First, I\\'ll keep a frequency vector of size `N+1` to directly hash the elements of `nums` vector to the indices of my frequency vector. (This will help us to keep the track of frequency of each element in `nums` vector in the range `[1, N]`).\\n\\n2. Then, we iterate the `nums` vector and compute the frequency of each element.\\n\\n3. Then, we iterate on our frequency vector, and check whose frequency is `0` and add the corresponding element to our result vector since such elements would be our missing elements.\\n\\n**Below is the code for my appraoch:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); // frequency vector\\n\\t\\tvector<int>res{}; // result vec\\n        \\n\\t\\t// Compute frequency\\n        for(auto num: nums){\\n            freq[num]++;\\n        }\\n        \\n\\t\\t// Compute missing elements\\n        for(int i{1}; i<=n; ++i){\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(2N) ~ O(N)***\\n**Space Complexity:** ***O(N)*** because we are using frequency vector.\\n\\n**Approach 2: (Negation Technique)** Now we will optimize the space complexity, and try to remove the frequency array here.\\n\\n**Observation:** Observe that if our array would be like this: `[4, 3, 2, 7, 8, 2, 3,1]`, then our frequency array woulde be like:\\n```\\nfreq:     [1, 2, 2, 1, 0, 0, 1, 1]\\nindex:     0  1  2  3  4  5  6  7\\nelement:   1  2  3  4  5  6  7  8\\nHere 5 and 6 are missing because they have zero frequence.\\n```\\nSo, my idea is instead of having frequency arrays, we can make changes to the original array itself to make it resemble to look like our frequency array (But without storing the frequency).\\n\\nSo, now observe that the frequency array above looks like `[x x x x 0 0 x x]`, so instead we will have changes like freq array in our nums array as below:\\n`[- - - - + + - -]`. (The indexes where numbers are positive, that `(index+1)` (since 0-based indexing) is the elment which is missing).\\nFor example:\\n```\\nnums: [4, 3, 2, 7, 8, 2, 3,1]\\nNow iterate through nums array\\n```\\n\\n**Iteration 1:**\\n```\\nindex: 0  1  2  3  4  5  6  7\\nnums: [4, 3, 2, 7, 8, 2, 3, 1]\\n       \\uD83D\\uDC46\\n```\\nSince we have found `4`, we will mark it as found, we will mark it by negating the value at position `4-1 = 3` (Since 0-based indexing). So we will make `7` to `-7`\\n\\n**Iteration 2:**\\n```\\nindex: 0  1  2   3  4  5  6  7\\nnums: [4, 3, 2, -7, 8, 2, 3, 1]\\n          \\uD83D\\uDC46\\n```\\nNow, we found `3` we will mark it has found by negating the value at position `3 - 1 = 2` (Since, 0 based indexing). So we will make `2` to `-2`.\\n\\n**Iteration 3:**\\n```\\nindex: 0  1   2   3  4  5  6  7\\nnums: [4, 3, -2, -7, 8, 2, 3, 1]\\n             \\uD83D\\uDC46\\n```\\nNow, we have `2` (remember negative is just done to mark indexes found, so we will take the absolute value of element to view them), we will mark `2` has found by negating the value at position `2 - 1 = 1` (Since, 0-based indexing). So we will make `3` to `-3`.\\n\\n**Iteration 4:**\\n```\\nindex: 0   1   2   3  4  5  6  7\\nnums: [4, -3, -2, -7, 8, 2, 3, 1]\\n                  \\uD83D\\uDC46\\n```\\nNow, we found `7` so we mark is as found by negating the value at position `7 - 1 = 6` (Since 0-based indexing). So we will make `3` to `-3` at position `6`\\n\\n**Iteration 5:**\\n```\\nindex: 0   1   2   3  4  5   6  7\\nnums: [4, -3, -2, -7, 8, 2, -3, 1]\\n                     \\uD83D\\uDC46\\n```\\nNow, we have `8` so we mark it as found by negating the value at position `8-1=7`. So we make `1` to `-1`.\\n\\n**Iteration 6:**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                         \\uD83D\\uDC46\\n```\\nNow, we have `2` so we mark it as found by negating the value at position `2-1=1` (since 0-based indexing). But the value at position `1` is already negative, that means we have already found the elemetn `2` before, so we leave it as negative and move forward.\\n\\n**Iteration 7**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                            \\uD83D\\uDC46\\n```\\nNow, we have `3`, so we will make it found by negating the value at position `3-1=2` (Since 0-based indexing). But the value at position `2` is already negative, that means we have already found the elemetn `3` before, so we leave it as negative and move forward.\\n\\n**Iteration 8:**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                                \\uD83D\\uDC46\\n```\\nNow, we have `1` so we will mark it as founf by negating the value at position `1-1=0` (since 0 based indexing). So we make `4` to `-4`.\\n\\n**End of Iterations:**\\n```\\nindex:  0   1   2   3  4  5   6   7\\nnums: [-4, -3, -2, -7, 8, 2, -3, -1]\\n                                    \\uD83D\\uDC46\\n```\\nHere we have only indices `4` and `5` as the positive indices, that measn element `[4+1, 5+1] = [5, 6]` (since 0 based indexing) are the missing element.\\n\\n**Below is the code for the approach mentioned above:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        \\n\\t\\t// Negative elements (Marking foud)\\n        for(int i{}; i<n; ++i){\\n            \\n            int idx = abs(nums[i]) - 1; // since 0-based indexing\\n            nums[idx] = (nums[idx]>0)? -nums[idx]:nums[idx];\\n        }\\n        \\n\\t\\t// Store positive index+1 as missing elements\\n        for(int i{}; i<n; ++i){\\n            if(nums[i] > 0)\\n                res.push_back(i+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(2N) ~ O(N)***\\n**Space Complexity:** ***O(1)***\\n\\n***Note: Please do \\uD83D\\uDD3C Upvote, if you found this post helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); // frequency vector\\n\\t\\tvector<int>res{}; // result vec\\n        \\n\\t\\t// Compute frequency\\n        for(auto num: nums){\\n            freq[num]++;\\n        }\\n        \\n\\t\\t// Compute missing elements\\n        for(int i{1}; i<=n; ++i){\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nfreq:     [1, 2, 2, 1, 0, 0, 1, 1]\\nindex:     0  1  2  3  4  5  6  7\\nelement:   1  2  3  4  5  6  7  8\\nHere 5 and 6 are missing because they have zero frequence.\\n```\n```\\nnums: [4, 3, 2, 7, 8, 2, 3,1]\\nNow iterate through nums array\\n```\n```\\nindex: 0  1  2  3  4  5  6  7\\nnums: [4, 3, 2, 7, 8, 2, 3, 1]\\n       \\uD83D\\uDC46\\n```\n```\\nindex: 0  1  2   3  4  5  6  7\\nnums: [4, 3, 2, -7, 8, 2, 3, 1]\\n          \\uD83D\\uDC46\\n```\n```\\nindex: 0  1   2   3  4  5  6  7\\nnums: [4, 3, -2, -7, 8, 2, 3, 1]\\n             \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5  6  7\\nnums: [4, -3, -2, -7, 8, 2, 3, 1]\\n                  \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6  7\\nnums: [4, -3, -2, -7, 8, 2, -3, 1]\\n                     \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                         \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                            \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                                \\uD83D\\uDC46\\n```\n```\\nindex:  0   1   2   3  4  5   6   7\\nnums: [-4, -3, -2, -7, 8, 2, -3, -1]\\n                                    \\uD83D\\uDC46\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        \\n\\t\\t// Negative elements (Marking foud)\\n        for(int i{}; i<n; ++i){\\n            \\n            int idx = abs(nums[i]) - 1; // since 0-based indexing\\n            nums[idx] = (nums[idx]>0)? -nums[idx]:nums[idx];\\n        }\\n        \\n\\t\\t// Store positive index+1 as missing elements\\n        for(int i{}; i<n; ++i){\\n            if(nums[i] > 0)\\n                res.push_back(i+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92957,
                "title": "2ms-o-n-in-space-java",
                "content": "Think we surely have to negate anytime we are given an array with values from 1 to the length of array. If anyone has a better idea, will be happy to hear.\\n\\nThe steps followed in this is:\\n1. Negate each number while traversing\\n2. Run again and find the index that is not negated. \\n\\n``` public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for( int i=0;i< nums.length; i++){\\n            int index = nums[i];\\n            if(nums[Math.abs(index)-1] > 0){\\n                nums[Math.abs(index)-1]= -nums[Math.abs(index)-1];\\n            }\\n        }\\n        \\n        for(int j =1 ;j <= nums.length ; j++){\\n            if(nums[j-1] > 0){\\n                result.add(j);\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "solutionTags": [],
                "code": "Think we surely have to negate anytime we are given an array with values from 1 to the length of array. If anyone has a better idea, will be happy to hear.\\n\\nThe steps followed in this is:\\n1. Negate each number while traversing\\n2. Run again and find the index that is not negated. \\n\\n``` public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for( int i=0;i< nums.length; i++){\\n            int index = nums[i];\\n            if(nums[Math.abs(index)-1] > 0){\\n                nums[Math.abs(index)-1]= -nums[Math.abs(index)-1];\\n            }\\n        }\\n        \\n        for(int j =1 ;j <= nums.length ; j++){\\n            if(nums[j-1] > 0){\\n                result.add(j);\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1583652,
                "title": "c-short-solution-python-one-liner-explained-no-extra-space",
                "content": "**Solution I:**\\nWe know that all the numbers are in the range [1, n].\\nSo we mark all the indices of the numbers we saw by making the number negative.\\nThen, we iterate through the array again and each number that is positive - we know we never saw that index and we can add it to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) \\n            nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);\\n        \\n        vector<int> res;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Solutoin II:**\\nONE LINER!\\nWe use simple set subtraction\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return set(range(1, len(nums)+1)) - set(nums)\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) \\n            nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);\\n        \\n        vector<int> res;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return set(range(1, len(nums)+1)) - set(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313703,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for n in nums:\\n            a = abs(n) - 1\\n            if nums[a] > 0: nums[a] *= -1\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThank you!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for n in nums:\\n            a = abs(n) - 1\\n            if nums[a] > 0: nums[a] *= -1\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212505,
                "title": "o-n-constant-space-javascript-solution-with-explanation",
                "content": "So the trick here is that the input array is as long as the set of numbers we want to have in there. \\n\\nSo if the input array has a length of 8, we want it to contain the numbers [1,8] (one through eight - including both one and eight). \\n\\nWhen we work with arrays, we technically have two sets of values available: we have the values in the array (in this case, just integers), *and* we can work with the indices of the array itself. \\n\\nSo take a five-element array: `[1, 4, 5, 3, 3]`\\n\\nWe have the numbers `1, 4, 5, 3, 3` in the values itself. But we *also have* the numbers `0, 1, 2, 3, 4` as indices of the array. If you add one to each of those indices, we would have `1, 2, 3, 4, 5`. Those are the numbers we\\'re looking for in an ideal scenario. \\n\\nSo what we can do is use those indices and \"flag\" them in some way to say \"Hey, we saw this index in the values of the array\". To do that, we look at each actual value (1, 4, 5, 3, and 3). Then we subtract one from it to get its corresponding array index. Then we modify the array to flag it. We multiply the value at that index by -1 to make it negative. \\n\\nYou\\'ll see in the code that we have to be careful, if we\\'ve already visited an index, it will be negative, and when we subtract 1 to find the index, we\\'ll have a problem. So we actually take the absolute value. Don\\'t worry if this is hard to follow, there\\'s a comment in the code about it. \\n\\nThen we loop through the array again and build a result. We check each index (again, we don\\'t care about the actual absolute value of the number there, we\\'re just looking for our flag - the negative sign). If it\\'s positive, it means we never visited that index, so we know that\\'s one of the \"disappeared\" numbers.\\n\\n**Solution:**\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    // Loop through each number in nums\\n    nums.forEach(number => {\\n        \\n        // Now we choose an index in the nums array based on the value we\\'re currently looking at.\\n        // We do have to use Math.abs on it first, in case we\\'ve already visited this index and made it negative.\\n        // Then, since arrays are 0 indexed, subtract 1 from it\\n        const indexBasedOnThisValue = Math.abs(number) - 1\\n        \\n        // Then, look at the input array. Multiply it by -1 to mark it negative\\n        // We don\\'t want to do this if we\\'ve already done so, which is why we check that it\\'s greater than 0.\\n        if (nums[indexBasedOnThisValue] > 0) {\\n            nums[indexBasedOnThisValue] = nums[indexBasedOnThisValue] * -1\\n        }\\n    })\\n    \\n    // Now that we\\'ve marked the array with negative numbers, loop through it again.\\n    // This time, we\\'ll be building our result\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        // Check if the number at this position is positive or negative.\\n        // It doesn\\'t matter what the number is necessarily, we just want to use the index of this value to check what we visited.\\n        // And again, since arrays are 0-indexed, we\\'ll be off by one, so add 1 when we push to results.\\n        if (nums[i] > 0) {\\n            result.push(i + 1)\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    // Loop through each number in nums\\n    nums.forEach(number => {\\n        \\n        // Now we choose an index in the nums array based on the value we\\'re currently looking at.\\n        // We do have to use Math.abs on it first, in case we\\'ve already visited this index and made it negative.\\n        // Then, since arrays are 0 indexed, subtract 1 from it\\n        const indexBasedOnThisValue = Math.abs(number) - 1\\n        \\n        // Then, look at the input array. Multiply it by -1 to mark it negative\\n        // We don\\'t want to do this if we\\'ve already done so, which is why we check that it\\'s greater than 0.\\n        if (nums[indexBasedOnThisValue] > 0) {\\n            nums[indexBasedOnThisValue] = nums[indexBasedOnThisValue] * -1\\n        }\\n    })\\n    \\n    // Now that we\\'ve marked the array with negative numbers, loop through it again.\\n    // This time, we\\'ll be building our result\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        // Check if the number at this position is positive or negative.\\n        // It doesn\\'t matter what the number is necessarily, we just want to use the index of this value to check what we visited.\\n        // And again, since arrays are 0-indexed, we\\'ll be off by one, so add 1 when we push to results.\\n        if (nums[i] > 0) {\\n            result.push(i + 1)\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419876,
                "title": "easy-c-with-explanation-o-n-running-time-o-1-space",
                "content": "**Algorithm**\\n\\nWe know that all the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array.\\nWe know that all the values in the array are positive, so we can signal the presence of a value by changing its index (or better still, like in my implementation, the index minus 1, to avoid the \\'special case\\' of values that equal n, which has no vector element) to be negative.\\nWe then loop over the vector, and any positive index indicates that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n\\n**Complexity**\\n\\nWe loop over the array twice, so the running time is O(2N), which is O(N).\\nWe use the original vector for keeping count of which values appear in the array, so we use O(1) space.\\n\\n\\n**The Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> results;\\n        \\n        // Set contents of all indices (minus 1) that appear in the array to be negative\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n\\t\\t\\t// Note that we have to use the absolute value in the next 2 lines, to avoid trying to access a negative index in some cases\\n            if (nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        \\n        // A positive element means that the element (index + 1) does not appear in the array, so save it\\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] > 0)\\n                results.push_back(i + 1);\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> results;\\n        \\n        // Set contents of all indices (minus 1) that appear in the array to be negative\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n\\t\\t\\t// Note that we have to use the absolute value in the next 2 lines, to avoid trying to access a negative index in some cases\\n            if (nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        \\n        // A positive element means that the element (index + 1) does not appear in the array, so save it\\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] > 0)\\n                results.push_back(i + 1);\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108814,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse HashSet to Remove Duplicates and search whether the it contains all the Elements from 1 to n.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e4f1e2a8-b10b-46db-9ce6-9c2562a1a933_1674945307.2145095.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952453,
                "title": "o-n-o-1-js-solution",
                "content": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = Math.abs(nums[i]);\\n        let idx = num-1;\\n        nums[idx] = Math.abs(nums[idx]) * -1;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) res.push(i+1);\\n    }\\n    return res;\\n    // Time Complexity: O(N)\\n    // Space Complexity: O(1)\\n};\\n/*\\nWe will scan through the input array and for every number we will use its value as an index and\\nnegate the number at the index. For example, if we encounter 4, we will negate the number at index 3.\\nThe reason the index is not four is because the array is zero-indexed.\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = Math.abs(nums[i]);\\n        let idx = num-1;\\n        nums[idx] = Math.abs(nums[idx]) * -1;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) res.push(i+1);\\n    }\\n    return res;\\n    // Time Complexity: O(N)\\n    // Space Complexity: O(1)\\n};\\n/*\\nWe will scan through the input array and for every number we will use its value as an index and\\nnegate the number at the index. For example, if we encounter 4, we will negate the number at index 3.\\nThe reason the index is not four is because the array is zero-indexed.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584384,
                "title": "java-solution-100",
                "content": "I simply allocated a separate index for each number, then checked which indexes are zero - these are our numbers we are looking for.\\n\\n```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\tint[] res = new int[nums.length + 1];\\n\\n\\tfor (int num : nums) {\\n\\t\\tres[num] = num;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>(res.length);\\n\\tfor (int i = 1; i < res.length; i++) {\\n\\t\\tif (res[i] == 0) {\\n\\t\\t\\tresult.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\tint[] res = new int[nums.length + 1];\\n\\n\\tfor (int num : nums) {\\n\\t\\tres[num] = num;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>(res.length);\\n\\tfor (int i = 1; i < res.length; i++) {\\n\\t\\tif (res[i] == 0) {\\n\\t\\t\\tresult.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93153,
                "title": "step-by-step-detailed-explanation-python-solution",
                "content": "**Solution using Extra Space**\\n* Use a set (hash-map) and add all the numbers in this set. The set consists of all unique values within nums.\\n* Iterate from [1 to N] and add to result list if i is not in the marked set.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\\n\\n**Solution without using Extra Space**\\n* Can we avoid the set and somehow mark the input array which tells us what numbers are seen and what are not? We have additional information that the numbers are positive and numbers lie between 1 and N.\\n* Approach 1: Iterate the array and mark the position implied by every element as negative. Then in the second iteration, we simply need to report the positive numbers.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\\n* Approach 2: Iterate the array and add N to the existing number at the position implied by every element. This means that positions implied by the numbers present in the array will be strictly more than N (smallest number is 1 and 1+N > N).  Therefore. in the second iteration, we simply need to report the numbers less than equal to N to return the missing numbers..\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            nums[(nums[i]%N)-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            nums[(nums[i]%N)-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682857,
                "title": "python-3-solutions-o-1-sc-one-line-solution",
                "content": "**Python :**\\n\\n\\nTime complexity : *O(n)*\\nSpace complexity : *O(n)*\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tallNums = [0] * len(nums)\\n\\tfor i in nums:\\n\\t\\tallNums[i - 1] = i\\n\\n\\treturn [i + 1 for i in range(len(allNums)) if allNums[i] == 0]\\n```\\n\\nTime complexity : *O(n)*\\nSpace complexity : *O(1)*\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            nums[abs(i) - 1]  = -abs(nums[abs(i) - 1])\\n            \\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n```\\n\\nTricky one line solution :\\n\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\treturn set(range(1, len(nums) + 1)) - set(nums)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tallNums = [0] * len(nums)\\n\\tfor i in nums:\\n\\t\\tallNums[i - 1] = i\\n\\n\\treturn [i + 1 for i in range(len(allNums)) if allNums[i] == 0]\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            nums[abs(i) - 1]  = -abs(nums[abs(i) - 1])\\n            \\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\treturn set(range(1, len(nums) + 1)) - set(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 985924,
                "title": "python3-one-liner-with-step-by-step-explanation",
                "content": "Faster than 91.27% , Memory Usage: 25.3 MB, less than 10.18% \\n\\n**To Find All Numbers Disappeared in an Array**\\n```\\nreturn list(set(range(1,len(nums)+1))-set(nums)))\\n```\\n\\n*Explanation:-*\\n1.  len(nums)+1               -> To get range of list\\n2.  range(1,len(nums)+1) -> range from 1 to n\\n3.  set(range(1,len(nums)+1)) -> set values of range \\n4.  set(nums) -> Given Nums to set \\n5.  set(range(1,len(nums)+1)) - set(nums) -> The missing elements from (1,n)\\n6.  list(set(range(1,len(nums)+1))-set(nums) -> Coversion dict to list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn list(set(range(1,len(nums)+1))-set(nums)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186633,
                "title": "c-o-n-in-place-with-explanation",
                "content": "Since, each element in the array is in range [1,n], it means we can use array elements as index for the same array.\\n\\nSo the idea is to use array element as indexes, and mark those indexes, somehow, so we know, which all indexes are present in the array.\\n\\nIn the end, unmarked indexes will indicate that these elements are missing in the array.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        \\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            int n = abs(nums[i]); \\n            if(nums[n-1] > 0)\\n                nums[n-1] = -nums[n-1]; // marking -ve\\n        }\\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf this helped you, an upvote would be awesome. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        \\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            int n = abs(nums[i]); \\n            if(nums[n-1] > 0)\\n                nums[n-1] = -nums[n-1]; // marking -ve\\n        }\\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297895,
                "title": "easy-to-understand-python-3-1-line",
                "content": "*range(1, len(nums) + 1)* is just a list of elements from 1 -> length of the array.\\nBy subtracting set(nums), or the **unique** elements in nums, we get a set of the numbers that were not in our range.\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list((set(range(1, len(nums) + 1))) - (set(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list((set(range(1, len(nums) + 1))) - (set(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545609,
                "title": "c-using-o-1-space-o-n-runtime",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.Length; i++) {\\n            int index = Math.Abs(nums[i]) - 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        List<int> result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (nums[i] > 0) result.Add(i+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.Length; i++) {\\n            int index = Math.Abs(nums[i]) - 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        List<int> result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (nums[i] > 0) result.Add(i+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121580,
                "title": "java-easy-solution-with-explanation-comments-inlcuded",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        //since we have to find the missing numbers from\\n        //store the  valuses of all array elments in map\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1);\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        //now check the given array \\n        //nums from 1 to nums.length(incusive) if\\n        //it the i is not in map means it is missing\\n        //add to ans list\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n\\t\\t//please upvote if you found helpful it will give some motivation\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        //since we have to find the missing numbers from\\n        //store the  valuses of all array elments in map\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1);\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        //now check the given array \\n        //nums from 1 to nums.length(incusive) if\\n        //it the i is not in map means it is missing\\n        //add to ans list\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n\\t\\t//please upvote if you found helpful it will give some motivation\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472775,
                "title": "c-o-1-space-o-n-time-easiest-explanation",
                "content": "# LOGIC (When you take extra space)\\n* You can easily solve this problem using the extra space by taking an unordered_map. \\n\\n<iframe src=\"https://leetcode.com/playground/mPLQNXBs/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n---\\n\\n# LOGIC (When you take constant space)\\n* As the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array. As all the values in the array are positive, for every value we will make it\\'s equivalent index position negative. Remember that we will take the (index-1) position to avoid the case when the value of the element is equal to n. \\n* If statement in the first for loop make sure that whenever there are more than one occurrence of the element( it will for sure, [THINK ABOUT IT]) then we don\\'t want to change our signal back to the positive value and that\\'s why we just ignore that case.\\n* We then loop over the vector, and any positive index shows that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n<iframe src=\"https://leetcode.com/playground/7FwVRQgr/shared\" frameBorder=\"0\" width=\"1000\" height=\"250\"></iframe>\\n\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC3C\\uD83D\\uDCBB If there are any suggestions / questions / mistakes in my post, please do let me know by comments: \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "# LOGIC (When you take extra space)\\n* You can easily solve this problem using the extra space by taking an unordered_map. \\n\\n<iframe src=\"https://leetcode.com/playground/mPLQNXBs/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n---\\n\\n# LOGIC (When you take constant space)\\n* As the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array. As all the values in the array are positive, for every value we will make it\\'s equivalent index position negative. Remember that we will take the (index-1) position to avoid the case when the value of the element is equal to n. \\n* If statement in the first for loop make sure that whenever there are more than one occurrence of the element( it will for sure, [THINK ABOUT IT]) then we don\\'t want to change our signal back to the positive value and that\\'s why we just ignore that case.\\n* We then loop over the vector, and any positive index shows that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n<iframe src=\"https://leetcode.com/playground/7FwVRQgr/shared\" frameBorder=\"0\" width=\"1000\" height=\"250\"></iframe>\\n\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC3C\\uD83D\\uDCBB If there are any suggestions / questions / mistakes in my post, please do let me know by comments: \\uD83D\\uDC47",
                "codeTag": "Unknown"
            },
            {
                "id": 479225,
                "title": "python-js-java-c-go-o-n-sol-by-sign-flip-visualization",
                "content": "**Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/98f6e027-b824-4527-a095-de93e48a55ac_1665849439.905402.png)\\n\\n---\\n\\n**Implementation**\\n\\nPython O( n ) sol. based on sign flipping.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\n        for number in nums:\\n\\n            present_indx = abs(number)-1\\n            if nums[present_indx] > 0 :\\n                # use negative number to mark number is presented in array\\n                nums[present_indx] = -nums[present_indx]\\n\\n\\n\\n        # the disappeared numbers are those grids which are still with positive value\\n        return [ i+1 for i, num in enumerate(nums) if num > 0 ]\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    for( let number of nums){\\n        \\n        let presentIndex = Math.abs( number ) - 1;\\n        \\n        if( nums[presentIndex] > 0){\\n            \\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex];\\n        }\\n    }\\n    \\n    \\n    // the disappeared numbers are those grids which are still with positive value\\n    let missingNumber = [];\\n    for( const [idx, number] of nums.entries() ){\\n        \\n        if( number > 0 ){\\n            missingNumber.push( idx+1 );\\n        }\\n    }\\n    \\n    return missingNumber;\\n};\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for( int number : nums){\\n            \\n            int presentIndex = Math.abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        List<Integer> missingNumber = new ArrayList<Integer>();\\n        for( int i = 0 ; i < nums.length ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.add( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        for( int& number : nums){\\n            \\n            int presentIndex = abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        vector<int> missingNumber;\\n        for( size_t i = 0 ; i < nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.emplace_back( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc IntegerAbs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}\\n\\nfunc findDisappearedNumbers(nums []int) []int {\\n     \\n    for _, number := range nums{\\n\\n        presentIndex := IntegerAbs(number)-1\\n\\n        if( nums[presentIndex] > 0 ){\\n\\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex]\\n        }\\n    }\\n\\n    // the disappeared numbers are those grids which are still with positive value\\n    missingNumber := make( []int, 0)\\n    for i := 0 ; i < len(nums) ; i++ {\\n\\n        if( nums[i] > 0 ){\\n            missingNumber = append(missingNumber, i+1 )\\n        }\\n    }\\n\\n    return missingNumber\\n}\\n```\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #442 Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)\\n\\n[2] [Leetcode #287 Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\n        for number in nums:\\n\\n            present_indx = abs(number)-1\\n            if nums[present_indx] > 0 :\\n                # use negative number to mark number is presented in array\\n                nums[present_indx] = -nums[present_indx]\\n\\n\\n\\n        # the disappeared numbers are those grids which are still with positive value\\n        return [ i+1 for i, num in enumerate(nums) if num > 0 ]\\n```\n```\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    for( let number of nums){\\n        \\n        let presentIndex = Math.abs( number ) - 1;\\n        \\n        if( nums[presentIndex] > 0){\\n            \\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex];\\n        }\\n    }\\n    \\n    \\n    // the disappeared numbers are those grids which are still with positive value\\n    let missingNumber = [];\\n    for( const [idx, number] of nums.entries() ){\\n        \\n        if( number > 0 ){\\n            missingNumber.push( idx+1 );\\n        }\\n    }\\n    \\n    return missingNumber;\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for( int number : nums){\\n            \\n            int presentIndex = Math.abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        List<Integer> missingNumber = new ArrayList<Integer>();\\n        for( int i = 0 ; i < nums.length ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.add( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        for( int& number : nums){\\n            \\n            int presentIndex = abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        vector<int> missingNumber;\\n        for( size_t i = 0 ; i < nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.emplace_back( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n};\\n```\n```\\nfunc IntegerAbs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}\\n\\nfunc findDisappearedNumbers(nums []int) []int {\\n     \\n    for _, number := range nums{\\n\\n        presentIndex := IntegerAbs(number)-1\\n\\n        if( nums[presentIndex] > 0 ){\\n\\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex]\\n        }\\n    }\\n\\n    // the disappeared numbers are those grids which are still with positive value\\n    missingNumber := make( []int, 0)\\n    for i := 0 ; i < len(nums) ; i++ {\\n\\n        if( nums[i] > 0 ){\\n            missingNumber = append(missingNumber, i+1 )\\n        }\\n    }\\n\\n    return missingNumber\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93098,
                "title": "python-solution-without-using-abs",
                "content": "Basically the same idea a lot of previous solutions implement. I was thinking whether we could get rid of the abs operation around the index to make the code faster. I exploited the fact that each repeating elements don't appear more than twice so I set the increment to 0.4 as to maintain the value of the index when being floored.\\n\\nThe funny thing is the code actually ran slower LOL. However just want to share with you guys my idea.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for v in nums:\\n            index = int(v) - 1\\n            nums[index] += 0.4\\n        return [i+1 for i in xrange(len(nums)) if nums[i] == int(nums[i])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for v in nums:\\n            index = int(v) - 1\\n            nums[index] += 0.4\\n        return [i+1 for i in xrange(len(nums)) if nums[i] == int(nums[i])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503704,
                "title": "python-easy-solution",
                "content": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]: # nums = [4,3,2,7,8,2,3,1]\\n        full_list = [i for i in range(1,len(nums)+1)] # [1, 2, 3, 4, 5, 6, 7, 8]\\n        return list(set(full_list) - set(nums)) # {1, 2, 3, 4, 5, 6, 7, 8} - {1, 2, 3, 4, 7, 8} = [5,6]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]: # nums = [4,3,2,7,8,2,3,1]\\n        full_list = [i for i in range(1,len(nums)+1)] # [1, 2, 3, 4, 5, 6, 7, 8]\\n        return list(set(full_list) - set(nums)) # {1, 2, 3, 4, 5, 6, 7, 8} - {1, 2, 3, 4, 7, 8} = [5,6]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1584201,
                "title": "python-short-solution-explained",
                "content": "See similar Problems 0041: First Missing positive and 0442: Find All Duplicates in an Array. We an either swap elements, or use trick where we add `n` to all values of already found elements and then return indexes of elements which are `<= n`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, additional space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        n = len(nums)\\n        for num in nums:\\n            nums[(num-1) % n] += n\\n            \\n        return [i+1 for i in range(n) if nums[i] <= n]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        n = len(nums)\\n        for num in nums:\\n            nums[(num-1) % n] += n\\n            \\n        return [i+1 for i in range(n) if nums[i] <= n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261617,
                "title": "java-logic-explained-in-simple-english-o-n-o-1",
                "content": "# This pattern can be used when you have items in the range of 1 - n (where n = elements in array).\\n\\nBasically the idea is to set each element at its correct position while iterating the array.\\n\\n1. Start from the first element. This item is at it correct position if a[i] == i+1\\n\\n 2. If the item is not at its correct position, we will try to put it at the correct position, so now lets look at its correct position i.e. a[a[i] - 1]. ( 4 has to be placed at index 3)\\n\\n3. Now two conditions arise from here, either the item is at a[a[i]-1] is equal to a[i] or it is not equal to a[i]\\n\\n\\ta. If it is equal to a[i], it means the item is duplicated we will leave the item as is and move further. Later we will use this item to find out that item which was supposed to it at this index is missing. \\n\\n\\tb. If it is not equal to a[i], then lets swap it with a[i],** and check again from STEP 2**\\n\\n\\n4. Perform the same thing for each item in the array.\\n\\n\\nAt the end of the loop, Items which are not repeated will be at its correct place, and item which are duplicated, will be at its correct place and other duplicates will be occupying some other places. \\n\\nWe can check the places where item is not at its correct place and add the item to the item, which is supposed to be there.\\n\\n# **Please leave a short comment, if you like the explaination, I will try to write more such posts.**\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        \\n        List<Integer> list = new LinkedList<Integer>();\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            \\n            while(a[i] != i+1 && a[i] != a[a[i] -1]) {\\n                \\n                swap(a, i , a[i]-1);\\n            }\\n        }\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            if(a[i] != i+1) list.add(i+1);\\n        }\\n        \\n        \\n        return list;\\n        \\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        \\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        \\n        List<Integer> list = new LinkedList<Integer>();\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            \\n            while(a[i] != i+1 && a[i] != a[a[i] -1]) {\\n                \\n                swap(a, i , a[i]-1);\\n            }\\n        }\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            if(a[i] != i+1) list.add(i+1);\\n        }\\n        \\n        \\n        return list;\\n        \\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        \\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019411,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const map = new Map();\\n  nums.forEach((num, i) => map.set(num, i));\\n\\n  const result = [];\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!map.has(i)) result.push(i);\\n  }\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const map = new Map();\\n  nums.forEach((num, i) => map.set(num, i));\\n\\n  const result = [];\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!map.has(i)) result.push(i);\\n  }\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666176,
                "title": "easy-solution-java-85-faster",
                "content": "***Please Upvote***\\n\\n...\\n\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] temp=new int[nums.length+1];\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp[nums[i]]=nums[i];\\n        }\\n        \\n        for(int i=1;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n              list.add(i);\\n        }\\n        return list;\\n    }\\n\\n...",
                "solutionTags": [
                    "Java"
                ],
                "code": "***Please Upvote***\\n\\n...\\n\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] temp=new int[nums.length+1];\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp[nums[i]]=nums[i];\\n        }\\n        \\n        for(int i=1;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n              list.add(i);\\n        }\\n        return list;\\n    }\\n\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 790951,
                "title": "golang-solution-beats-99-runtime",
                "content": "```\\nfunc findDisappearedNumbers(nums []int) []int {\\n    length := len(nums)\\n    if length == 0 { return nil }\\n    res := make([]int, length)\\n    for _, v := range nums {\\n        res[v-1] = v\\n    }\\n    j := 0\\n    for i := 0; i < length; i++ {\\n        if res[i] == 0 { \\n            res[j] = i + 1\\n            j++\\n        }\\n    } \\n    return res[:j]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findDisappearedNumbers(nums []int) []int {\\n    length := len(nums)\\n    if length == 0 { return nil }\\n    res := make([]int, length)\\n    for _, v := range nums {\\n        res[v-1] = v\\n    }\\n    j := 0\\n    for i := 0; i < length; i++ {\\n        if res[i] == 0 { \\n            res[j] = i + 1\\n            j++\\n        }\\n    } \\n    return res[:j]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680663,
                "title": "python-without-extra-space-and-in-o-n-runtime",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        lenn = len(nums)\\n        for i in range(lenn):\\n            val = abs(nums[i]) - 1\\n            nums[val] = abs(nums[val]) * -1\\n        res = []\\n        for i in range(lenn):\\n            if nums[i] > 0:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        lenn = len(nums)\\n        for i in range(lenn):\\n            val = abs(nums[i]) - 1\\n            nums[val] = abs(nums[val]) * -1\\n        res = []\\n        for i in range(lenn):\\n            if nums[i] > 0:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584655,
                "title": "beats-99-45-tc-python-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nBeats 99.45%\\n\\n# Do Upvote if you like it :)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set_nums = set(nums)\\n        missing = []\\n\\n        for i in range(1,len(nums)+1):\\n            if i not in set_nums:\\n                missing.append(i)\\n\\n        return missing\\n# Do upvote if you like it\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set_nums = set(nums)\\n        missing = []\\n\\n        for i in range(1,len(nums)+1):\\n            if i not in set_nums:\\n                missing.append(i)\\n\\n        return missing\\n# Do upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122639,
                "title": "javascript-solution-116ms",
                "content": "Firstly I use the solution whose time complexity is O(n^2). It costs 5756ms, and it only beats 26%.\\n```js\\nvar findDisappearedNumbers = function(nums) {\\n  let arr = Array.from({length:nums.length}, (v, i) => i+1)\\n  let newNum = Array.from(nums.reduce((set, cur) => set.add(cur), new Set()))\\n  return arr.filter( i=> !newNum.includes(i))\\n};\\n```\\n\\nThen I optimize my solution which could be my best solution. Now the time complexity is O(n), and it beats 95%\\n```js\\nvar findDisappearedNumbers = function (nums) {\\n  let length = nums.length\\n  let arr = []\\n  for (let i = 0; i < length; i++) {\\n    arr[i] = i+1\\n  }\\n  for (v of nums) {\\n    arr[v-1] = -1\\n  }\\n  return arr.filter( i => (i > 0) )\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar findDisappearedNumbers = function(nums) {\\n  let arr = Array.from({length:nums.length}, (v, i) => i+1)\\n  let newNum = Array.from(nums.reduce((set, cur) => set.add(cur), new Set()))\\n  return arr.filter( i=> !newNum.includes(i))\\n};\\n```\n```js\\nvar findDisappearedNumbers = function (nums) {\\n  let length = nums.length\\n  let arr = []\\n  for (let i = 0; i < length; i++) {\\n    arr[i] = i+1\\n  }\\n  for (v of nums) {\\n    arr[v-1] = -1\\n  }\\n  return arr.filter( i => (i > 0) )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954066,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=abs(nums[i])-1;\\n            if(nums[j]>0)\\n            nums[j]*=-1;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=abs(nums[i])-1;\\n            if(nums[j]>0)\\n            nums[j]*=-1;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028043,
                "title": "python-3-lines-beats-90-with-comments",
                "content": "* Three passes, O(n)\\n* Constant space if you count the returning array/list as O(1) space as the question mentions\\n\\t* *\"You may assume the returned list does not count as extra space.\"*\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:                        \\n        result = [i for i in range(0, len(nums)+1)] # build an array (0, 1, 2, 3, ..., n)\\n        for i in nums: result[i] = 0 # we index this array, setting \"found\" elements to zero\\n        return [i for i in result if i != 0] # we return results that aren\\'t zero\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:                        \\n        result = [i for i in range(0, len(nums)+1)] # build an array (0, 1, 2, 3, ..., n)\\n        for i in nums: result[i] = 0 # we index this array, setting \"found\" elements to zero\\n        return [i for i in result if i != 0] # we return results that aren\\'t zero\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538304,
                "title": "java-use-negative-to-mark-exisits",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // nums[n - 1] = n;  //can not do this, since you will override the origin node.\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (nums[idx] > 0) nums[idx] = - nums[idx];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res.add(i + 1);\\n        }\\n        return res;\\n    }\\n```\\nRef: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution\\n",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // nums[n - 1] = n;  //can not do this, since you will override the origin node.\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (nums[idx] > 0) nums[idx] = - nums[idx];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res.add(i + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144795,
                "title": "python-simple-o-n-no-space-solution",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ret = []\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            if nums[index] > 0:\\n                nums[index] = -nums[index]\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ret.append(i + 1)\\n        return ret",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ret = []\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            if nums[index] > 0:\\n                nums[index] = -nums[index]\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ret.append(i + 1)\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 142717,
                "title": "java-simple-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0 ; i != nums.length ; i++) {\\n            nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]);\\n        }\\n        for (int i = 0 ; i != nums.length; i++) {\\n            if (nums[i] >= 0) res.add(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0 ; i != nums.length ; i++) {\\n            nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]);\\n        }\\n        for (int i = 0 ; i != nums.length; i++) {\\n            if (nums[i] >= 0) res.add(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93054,
                "title": "solution-in-c",
                "content": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int m;\\n    for (int c = 0; c < numsSize; c++) {\\n        m = abs(nums[c]) - 1;\\n        nums[m] = -1 * abs(nums[m]);\\n    }\\n\\n    *returnSize = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            (*returnSize)++;\\n    \\n    int *ret = (int *) calloc (*returnSize, sizeof (int));\\n    int s = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            ret[s++] = c + 1;\\n    \\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int m;\\n    for (int c = 0; c < numsSize; c++) {\\n        m = abs(nums[c]) - 1;\\n        nums[m] = -1 * abs(nums[m]);\\n    }\\n\\n    *returnSize = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            (*returnSize)++;\\n    \\n    int *ret = (int *) calloc (*returnSize, sizeof (int));\\n    int s = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            ret[s++] = c + 1;\\n    \\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868358,
                "title": "python-3",
                "content": "- Runtime: 316 ms, faster than 99.93% of Python3 online submissions for Find All Numbers Disappeared in an Array.\\n- Memory Usage: 25 MB, less than 7.37% of Python3 online submissions for Find All Numbers Disappeared in an Array.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return None\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return None\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 307741,
                "title": "cyclic-sort-in-o-n",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return result;\\n        \\n        int idx = 0;\\n        \\n        while (idx < nums.length) {\\n            if (nums[idx] != nums[nums[idx] - 1]) {\\n                swap(nums, idx, nums[idx] - 1);\\n            } else {\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                result.add(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int x, int y) {\\n        int temp = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = temp;\\n    }\\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return result;\\n        \\n        int idx = 0;\\n        \\n        while (idx < nums.length) {\\n            if (nums[idx] != nums[nums[idx] - 1]) {\\n                swap(nums, idx, nums[idx] - 1);\\n            } else {\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                result.add(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int x, int y) {\\n        int temp = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = temp;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 307041,
                "title": "java-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> missing = new ArrayList<>();\\n        if(nums.length == 0)\\n            return missing;\\n        \\n        /*The index of the current num is num[i]-1\\n          We Math.abs the current num because \\n          we may have made it negative before\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] > 0)\\n                nums[index] = -nums[index];\\n        }\\n        /*Now every index value that has a negative number exists\\n          in nums. But the index values with positive numbers do not\\n          exist. We know this is the case because if we saw X, \\n          then we would have made nums[X-1] a negative value. \\n          We can get these missing numbers with index+1.\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            //This index i does not exist in nums, since the value is +\\n            if (nums[i] > 0)\\n                missing.add(i+1);\\n        }\\n        \\n        return missing;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> missing = new ArrayList<>();\\n        if(nums.length == 0)\\n            return missing;\\n        \\n        /*The index of the current num is num[i]-1\\n          We Math.abs the current num because \\n          we may have made it negative before\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] > 0)\\n                nums[index] = -nums[index];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 160034,
                "title": "o-n-swap",
                "content": "Verry simple solution. Iterate throught the array and put every number in it\\'s \"spot\". I.E. if the number is 1 put it int he 1st spot 2, 2nd etc. This will be done in O(n) because you will perform at most n swaps.\\n\\nAfter, simply check which places are missing their corresponding number and return that list.\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i<nums.length; i++){\\n            while(nums[i] != i + 1 && nums[i] != nums[nums[i]-1]){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != i + 1){\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i<nums.length; i++){\\n            while(nums[i] != i + 1 && nums[i] != nums[nums[i]-1]){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != i + 1){\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274699,
                "title": "448-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Iterate through the input list nums, and for each element nums[i]:\\na. Calculate the index of nums[i] in the list by taking the absolute value of nums[i] and subtracting 1. This is because the input list contains integers in the range [1, n].\\nb. Update the value at the calculated index to its negative absolute value using nums[index] = -abs(nums[index]). This is because the input list can contain duplicates, so we need to mark the value as visited using its absolute value.\\n3. Iterate through the updated list nums, and for each element nums[i]:\\na. If the value at index i is positive, it means that the number i+1 did not appear in the input list. Append i+1 to the list of missing numbers.\\n3. Return the list of missing numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        # iterate through the input list and mark the values as visited\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = -abs(nums[index])\\n        \\n        # collect the missing values which are still positive\\n        missing = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                missing.append(i+1)\\n        \\n        return missing\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        # iterate through the input list and mark the values as visited\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = -abs(nums[index])\\n        \\n        # collect the missing values which are still positive\\n        missing = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                missing.append(i+1)\\n        \\n        return missing\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045499,
                "title": "java-2-line-code-100-faster-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        Set<Integer> set = new HashSet<>();\\n        ArrayList<Integer> result = new ArrayList<>();\\n\\n        for (int i : a) set.add(i); // removing duplicate elements\\n\\n       for(int i = 1; i <= a.length; i++){\\n           if(!set.contains(i)) result.add(i);\\n       }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        Set<Integer> set = new HashSet<>();\\n        ArrayList<Integer> result = new ArrayList<>();\\n\\n        for (int i : a) set.add(i); // removing duplicate elements\\n\\n       for(int i = 1; i <= a.length; i++){\\n           if(!set.contains(i)) result.add(i);\\n       }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584684,
                "title": "general-approach-for-the-problems-like-this-with-code-and-detailed-comments",
                "content": "**Please Upvote,it helps a lot**\\n\\n```\\n/* Whenever we get a array Question like this where elements are in a particular Contiguous range like(1 to n) then its best solution always comes from the help of\\narray indices. In all such cases array indices can be used a  marker for these \\nelements. for ex here to mark that element 5 is there in array just make element \\nat 4th index as negative . But Caution because as some elements are missing \\nfrom array some may be repeated too. so if there is already negative element at the marker then don\\'t make it negative.\\n*/\\n\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for(int i = 0;i<nums.length;i++){\\n            int val = Math.abs(nums[i]);\\n            nums[val -1] = nums[val - 1] < 0 ? nums[val - 1] : -1 * nums[val - 1];\\n        }\\n        \\n        List<Integer> list  = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i] > 0) list.add(i + 1);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* Whenever we get a array Question like this where elements are in a particular Contiguous range like(1 to n) then its best solution always comes from the help of\\narray indices. In all such cases array indices can be used a  marker for these \\nelements. for ex here to mark that element 5 is there in array just make element \\nat 4th index as negative . But Caution because as some elements are missing \\nfrom array some may be repeated too. so if there is already negative element at the marker then don\\'t make it negative.\\n*/\\n\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for(int i = 0;i<nums.length;i++){\\n            int val = Math.abs(nums[i]);\\n            nums[val -1] = nums[val - 1] < 0 ? nums[val - 1] : -1 * nums[val - 1];\\n        }\\n        \\n        List<Integer> list  = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i] > 0) list.add(i + 1);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584006,
                "title": "python-short-and-simple-o-n-time-2-pass-o-1-space-no-hash-needed",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you liked the solution.\\n**Idea**: Since numbers are in the range [1, n], we can store whether we\\'ve seen a number at index num-1 (indices are in the range [0, n-1]) by making the value negative eg. For array [3, 1, 4, 2], when I see the first value 3, I flip the number at index 3-1=2 and the array becomes [3, 1, -4, 2] and so on...\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tfor num in nums:\\n\\t\\t# Haven\\'t seen before\\n\\t\\tif nums[abs(num)-1]>0:\\n\\t\\t\\t# Store the fact that it has now been seen\\n\\t\\t\\tnums[abs(num)-1] *= -1\\n\\n\\t# The numbers that weren\\'t seen\\n\\treturn [i+1 for i, num in enumerate(nums) if num>0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tfor num in nums:\\n\\t\\t# Haven\\'t seen before\\n\\t\\tif nums[abs(num)-1]>0:\\n\\t\\t\\t# Store the fact that it has now been seen\\n\\t\\t\\tnums[abs(num)-1] *= -1\\n\\n\\t# The numbers that weren\\'t seen\\n\\treturn [i+1 for i, num in enumerate(nums) if num>0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 991922,
                "title": "3-liner-in-python-without-extra-space-and-o-n-runtime-easy-to-understand",
                "content": "\\n\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        # 3 liner in Python\\n        # without extra space and O(n) runtime\\n        # 82% Memory Usage\\n\\t\\t#If we go through an array, in the place of the given value, we can change its sign. \\n\\t\\t#With this information, one can find where the index has not changed.\\n        for i in range(len(nums)):\\n            nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1])\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        # 3 liner in Python\\n        # without extra space and O(n) runtime\\n        # 82% Memory Usage\\n\\t\\t#If we go through an array, in the place of the given value, we can change its sign. \\n\\t\\t#With this information, one can find where the index has not changed.\\n        for i in range(len(nums)):\\n            nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1])\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]",
                "codeTag": "Python3"
            },
            {
                "id": 714196,
                "title": "easy-c-solution-with-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int index=abs(nums[i])-1;\\n            if(nums[index]>0) nums[index] = -nums[index];\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>0) ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int index=abs(nums[i])-1;\\n            if(nums[index]>0) nums[index] = -nums[index];\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>0) ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93084,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Find All Numbers Disappeared in an Array** https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\n**Solution using Extra Space**\\n* Use a set (hash-map) and add all the numbers in this set. The set consists of all unique values within nums.\\n* Iterate from [1 to N] and add to result list if i is not in the marked set.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\\n\\n**Solution without using Extra Space**\\n* Can we avoid the set and somehow mark the input array which tells us what numbers are seen and what are not? We have additional information that the numbers are positive and numbers lie between 1 and N.\\n\\n* Approach 1: Iterate the array and mark the position implied by every element as negative. Then in the second iteration, we simply need to report the positive numbers.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\\n\\n* Approach 2: Iterate the array and add N to the existing number at the position implied by every element. This means that positions implied by the numbers present in the array will be strictly more than N (smallest number is 1 and 1+N > N).  Therefore. in the second iteration, we simply need to report the numbers less than equal to N to return the missing numbers..\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            x = nums[i] % N\\n            nums[x-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            x = nums[i] % N\\n            nums[x-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583657,
                "title": "c-o-n-solution-using-hash-array",
                "content": "Runtime: 48 ms, faster than 84.87% of C++ online submissions for Find All Numbers Disappeared in an Array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n  =nums.size();\\n        vector<int>hash(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            hash[nums[i]]++;\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=1;i<=n;i++)\\n            if(hash[i]==0)\\n                ans.push_back(i);\\n        \\n        return ans;\\n        // Please Upvote if You Liked It.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n  =nums.size();\\n        vector<int>hash(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            hash[nums[i]]++;\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=1;i<=n;i++)\\n            if(hash[i]==0)\\n                ans.push_back(i);\\n        \\n        return ans;\\n        // Please Upvote if You Liked It.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505514,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int index = Math.abs(nums[i]) -1;\\n            if(nums[index]>=0) nums[index] = -nums[index];\\n        }\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]>=0) list.add(i+1);\\n            \\n        }\\n        return list;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int index = Math.abs(nums[i]) -1;\\n            if(nums[index]>=0) nums[index] = -nums[index];\\n        }\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]>=0) list.add(i+1);\\n            \\n        }\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990393,
                "title": "set-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& v) {\\n        set<int> s(v.begin(),v.end());        // copying all the values of vector in set\\n        vector<int> c;\\n        for(int i=1;i<=v.size();i++)\\n        {\\n            if(s.count(i)==0)              // to check if the element is already present or not\\n                c.push_back(i);\\n        }\\n        \\n        return c;\\n    }\\n};\\n```             \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0APlease do UPVOTE if my code helps you \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& v) {\\n        set<int> s(v.begin(),v.end());        // copying all the values of vector in set\\n        vector<int> c;\\n        for(int i=1;i<=v.size();i++)\\n        {\\n            if(s.count(i)==0)              // to check if the element is already present or not\\n                c.push_back(i);\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523295,
                "title": "python-solution-in-place-in-o-n-time",
                "content": "I see a lot of Python solutions posted here that are ignoring the space complexity.  Clearly in Python it would be easy to use a collection like a Counter, a dictonary, another list, or even a set.  But that is ignoring the whole point of this problem, which is solving it in place.\\n\\nGiven that the list only contains positive values in the same range as the size of the list (1..N vs. 0..N-1), that was a big clue as far as what the solution might be.  You can iterate through the list, and take advantage of these facts.  For each item in the list that you find, you set the value at its index to a negative value.  This will indicate that the index value was found in the list.\\n\\nThis involves two list iterations, plus updating the list by index, which happens in constant time.  So although it is more like 3*N, that still qualifies as O(N).  This uses no extra space, as specified, other than the space for the return list, which is also ok per the specifications.  My simple solution is below.\\n\\n```class Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for x in nums:\\n            y = abs(x)\\n            nums[y - 1] = 0 - abs(nums[y - 1])\\n            \\n        r = []\\n        for i, x in enumerate(nums):\\n            if x > 0:\\n                r.append(i + 1)\\n        return r\\n ```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for x in nums:\\n            y = abs(x)\\n            nums[y - 1] = 0 - abs(nums[y - 1])\\n            \\n        r = []\\n        for i, x in enumerate(nums):\\n            if x > 0:\\n                r.append(i + 1)\\n        return r\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 316499,
                "title": "approaches-to-solve-this-problem-to-discuss-in-an-interview",
                "content": "#### 1st approach : Brute force\\n```\\nFor each i in [1, n]:\\n\\tlinearly search i in nums\\n\\tif not found:\\n\\t\\tresult.add(i)\\n```\\n**Time: O(N^2) - Space: O(1)**\\n_____________________________________________\\n#### 2nd approach : Sort\\n```\\nsort the array in place\\nfor each i in [0, len(array)-1]:\\n\\tif nums[i+1] - nums[i] > 1:\\n\\t\\tresult.add(elements strictly between nums[i] and nums[i+1]\\n```\\n**Time : O(Nlog(N), Space : O(1)**\\n_____________________________________________\\n#### 3rd approach : Use HashSet\\n```\\nstore the array\\'s elements in a set\\nfor each i in [1, n]:\\n\\tif i not in the set:\\n\\t\\tresult.add(i)\\n```\\n**Time : O(N) - Space : O(N)**\\n_____________________________________________\\n#### 4th approach : Use another array to store elements in their correct positions\\n```\\nhelper_array = [False]*n\\nfor element in nums:\\n\\thelper_array[element-1] = True\\n\\nfor i in [1, n]:\\n\\tif helper_array[i-1] == False:\\n\\t\\tresult.add(i)\\n```\\n**Time : O(N) - Space : O(N)**\\n_____________________________________________\\n#### 5th approach : Store elements in their correct positions in place\\nThe idea is to iterate and store each element in its correct position (for example 1 needs to be at the first position). If an element appears twice and its first occurence has been stored in its correct position, ignore it and continue iterating.\\nIterate for a second time, and for each i in [1, len(nums)]:\\n&nbsp;&nbsp;&nbsp;&nbsp;if nums[i] != i+1:\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(i+1)\\n**Time : O(N) - Space : O(1)**\\n\\nHere is my code in python :\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\ti, res = 0, []\\n\\n\\twhile i < len(nums):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tif nums[i]-1 >= len(nums) or nums[nums[i]-1] == nums[i]:   \\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:    \\n\\t\\t\\t\\ttmp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n\\t\\t\\t\\tnums[i] = tmp\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tres.append(i+1)\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\nFor each i in [1, n]:\\n\\tlinearly search i in nums\\n\\tif not found:\\n\\t\\tresult.add(i)\\n```\n```\\nsort the array in place\\nfor each i in [0, len(array)-1]:\\n\\tif nums[i+1] - nums[i] > 1:\\n\\t\\tresult.add(elements strictly between nums[i] and nums[i+1]\\n```\n```\\nstore the array\\'s elements in a set\\nfor each i in [1, n]:\\n\\tif i not in the set:\\n\\t\\tresult.add(i)\\n```\n```\\nhelper_array = [False]*n\\nfor element in nums:\\n\\thelper_array[element-1] = True\\n\\nfor i in [1, n]:\\n\\tif helper_array[i-1] == False:\\n\\t\\tresult.add(i)\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\ti, res = 0, []\\n\\n\\twhile i < len(nums):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tif nums[i]-1 >= len(nums) or nums[nums[i]-1] == nums[i]:   \\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:    \\n\\t\\t\\t\\ttmp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n\\t\\t\\t\\tnums[i] = tmp\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tres.append(i+1)\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 271085,
                "title": "javascript-in-place-method",
                "content": "[ 4, 3, 2, 7, 8, 2, 3, 1 ]\\n[ 7, 3, 2, 4, 8, 2, 3, 1 ]\\n[ 3, 3, 2, 4, 8, 2, 7, 1 ]\\n[ 2, 3, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 1, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    /**\\n     * swap i and j for nums\\n     * @param i\\n     * @param j\\n     */\\n    var swap = function (i, j) {\\n        const t = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = t;\\n    }\\n    const N = nums.length;\\n    for (let i = 0; i < N;) {\\n        const cur = nums[i] - 1;\\n        // if current value is in the right place,\\n        // or its right place has been set by other same value\\n        // go to next index\\n        if (cur === i || nums[i] === nums[cur]) {\\n            i++;\\n        } else {\\n            // swap current value to the right place it should be\\n            swap(i, cur);\\n        }\\n    }\\n    const res = [];\\n    for (let i = 0; i < N; i++) {\\n        // if current idx don\\'t have correct value,\\n        // push this idx to result array\\n        if (nums[i] - 1 !== i) res.push(i + 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    /**\\n     * swap i and j for nums\\n     * @param i\\n     * @param j\\n     */\\n    var swap = function (i, j) {\\n        const t = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = t;\\n    }\\n    const N = nums.length;\\n    for (let i = 0; i < N;) {\\n        const cur = nums[i] - 1;\\n        // if current value is in the right place,\\n        // or its right place has been set by other same value\\n        // go to next index\\n        if (cur === i || nums[i] === nums[cur]) {\\n            i++;\\n        } else {\\n            // swap current value to the right place it should be\\n            swap(i, cur);\\n        }\\n    }\\n    const res = [];\\n    for (let i = 0; i < N; i++) {\\n        // if current idx don\\'t have correct value,\\n        // push this idx to result array\\n        if (nums[i] - 1 !== i) res.push(i + 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238213,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Using Set**\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(N)`\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();             // List of Missing Elements in [1 .. N]\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 1; i <= A.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n**Solution 2: Negative Marking**\\n\\n**Intuition:**\\n- Given that, All the elements are in the range `[1, N]`\\n- So, we can make use of the input array itself to somehow `mark visited` numbers and then find the missing numbers.\\n- We will be negating the numbers seen in the array and use the sign of each of the numbers for finding the missing numbers. We will be treating numbers in the array as indices and mark corresponding locations in the array as negative.\\n\\n**Algorithm:**\\n1. For each element `A[i]`, mark the element at the corresponding location as negative if it is not already marked. So i.e. `A[A[i] - 1]` * \\u22121. In this way, all the numbers that we have seen will be marked as `negative`. \\n1. In the second iteration, if a value is not marked as `negative`, it implies we have never seen that `index` before, so it will be added to the return list\\n1. Since the elements in the Array are from `1` to `N`, so subtracting one will be `0` to `N - 1` which are the `indexes` of the array.\\n1. For example, input array `A = [4, 3, 2, 7, 8, 2, 3, 1]` and by subtracting `1` from each element it becomes an array of indexes `[3, 2, 1, 6, 7, 1, 2, 0]`.\\n\\n**For Example:**\\n\\nFor the first iteration\\n```\\nwhen i = 0, array becomes [ 4,  3,  2, -7,  8,  2,  3,  1]    // Marked `A[3]` as negative\\nwhen i = 1, array becomes [ 4,  3, -2, -7,  8,  2,  3,  1]    // Marked `A[2]` as negative\\nwhen i = 2, array becomes [ 4, -3, -2, -7,  8,  2,  3,  1]    // Marked `A[1]` as negative\\nwhen i = 3, array becomes [ 4, -3, -2, -7,  8,  2, -3,  1]    // Marked `A[6]` as negative\\nwhen i = 4, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[7]` as negative\\nwhen i = 5, array becomes [ 4,  3, -2, -7,  8,  2, -3, -1]    // No change since `A[1]` is already marked as negative\\nwhen i = 6, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // No change since `A[2]` is already marked as negative\\nwhen i = 7, array becomes [-4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[3]` as negative\\n```\\n\\nFor the second iteration\\nWe can see, `A[4] = 8` and `A[5] = 2` which are greater than `0`, which means `4` and `5` are not in the indexes array `[3, 2, 1, 6, 7, 1, 2, 0]`. So by adding one, we can say that `5` and `6` are not in the input `[4, 3, 2, 7, 8, 2, 3, 1]`\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < A.length; i++) {\\n            int newIndex = Math.abs(A[i]) - 1;\\n\\n            if (A[newIndex] > 0) {\\n                A[newIndex] *= -1;\\n            }\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] > 0) {\\n                list.add(i + 1);                // If A[i] is positive, means i + 1 is missing.\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();             // List of Missing Elements in [1 .. N]\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 1; i <= A.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\n```\\nwhen i = 0, array becomes [ 4,  3,  2, -7,  8,  2,  3,  1]    // Marked `A[3]` as negative\\nwhen i = 1, array becomes [ 4,  3, -2, -7,  8,  2,  3,  1]    // Marked `A[2]` as negative\\nwhen i = 2, array becomes [ 4, -3, -2, -7,  8,  2,  3,  1]    // Marked `A[1]` as negative\\nwhen i = 3, array becomes [ 4, -3, -2, -7,  8,  2, -3,  1]    // Marked `A[6]` as negative\\nwhen i = 4, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[7]` as negative\\nwhen i = 5, array becomes [ 4,  3, -2, -7,  8,  2, -3, -1]    // No change since `A[1]` is already marked as negative\\nwhen i = 6, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // No change since `A[2]` is already marked as negative\\nwhen i = 7, array becomes [-4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[3]` as negative\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < A.length; i++) {\\n            int newIndex = Math.abs(A[i]) - 1;\\n\\n            if (A[newIndex] > 0) {\\n                A[newIndex] *= -1;\\n            }\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] > 0) {\\n                list.add(i + 1);                // If A[i] is positive, means i + 1 is missing.\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190195,
                "title": "java-solution-in-o-n-without-extra-spaces",
                "content": "I call this algorithm Find Your Own Position.\n\nSet each number to its own position, number 1 should go to index 0, 2 should go to index 1 etc.\n\nIf a number's expected position is ocupied with same number, stop. If the positon is ocupied with another number, let that number find its own positon until each number find its positon. As each number will find its own positon only once. The running time will be O(n)\n\n```\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n           int val=nums[i];\n            while(val!=nums[val-1]){\n                int tmp=nums[val-1];\n                nums[val-1]=val;\n                val=tmp;\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            if(i+1!=nums[i]){\n                res.add(i+1);\n            }\n        }\n        return res;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n           int val=nums[i];\n            while(val!=nums[val-1]){\n                int tmp=nums[val-1];\n                nums[val-1]=val;\n                val=tmp;\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            if(i+1!=nums[i]){\n                res.add(i+1);\n            }\n        }\n        return res;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432831,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        while (i < nums.length) {\\n            int position = nums[i] - 1;\\n            if (nums[i] != nums[position]) {\\n                int temp = nums[i];\\n                nums[i] = nums[position];\\n                nums[position] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                list.add(i + 1);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        while (i < nums.length) {\\n            int position = nums[i] - 1;\\n            if (nums[i] != nums[position]) {\\n                int temp = nums[i];\\n                nums[i] = nums[position];\\n                nums[position] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                list.add(i + 1);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723236,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n    List<Integer> result = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        int val = Math.abs(nums[i]) - 1;\\n        if (nums[val] > 0)\\n            nums[val] = -nums[val];\\n    }\\n\\n    for (int i = 0; i < nums.length; i++)\\n        if (nums[i] > 0)\\n            result.add(i+1);\\n    return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n    List<Integer> result = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        int val = Math.abs(nums[i]) - 1;\\n        if (nums[val] > 0)\\n            nums[val] = -nums[val];\\n    }\\n\\n    for (int i = 0; i < nums.length; i++)\\n        if (nums[i] > 0)\\n            result.add(i+1);\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468452,
                "title": "javascript-solution-faster-than-90",
                "content": "```\\nconst findDisappearedNumbers = nums => {\\n    const set = new Set(nums);    \\n    const newArr = [];\\n    \\n    for (let i = 0; i < nums.length; i += 1) {\\n\\t\\tif(!set.has(i + 1)){\\n\\t\\t\\tnewArr.push(i + 1);\\n\\t\\t}\\n    }\\n    \\n    return newArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findDisappearedNumbers = nums => {\\n    const set = new Set(nums);    \\n    const newArr = [];\\n    \\n    for (let i = 0; i < nums.length; i += 1) {\\n\\t\\tif(!set.has(i + 1)){\\n\\t\\t\\tnewArr.push(i + 1);\\n\\t\\t}\\n    }\\n    \\n    return newArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584213,
                "title": "tc-o-n-sc-o-1-5ms-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n    \\n        // since all numbers are between [1,n], we go to nums[i]-1 th index and multiply it by -1. \\n\\t\\t// if it is already negative(has previously been visited) we leave it as it is\\n        \\n        // Example, nums = [4,3,2,7,8,2,3,1] becomes\\n        //          nums = [-4,-3,-2,-7,-8,2,3,-1]\\n        for(int i=0; i<nums.length; i++){\\n            int num = Math.abs(nums[i]) - 1;\\n            \\n            nums[num] = nums[num] < 0 ? nums[num] : - nums[num];\\n        }\\n        \\n        // finally we check if there are positive numbers in nums, which indicates that number is \\n\\t\\t// missing(hasn\\'t been multiplied by -1). And then add their index + 1(b/c array is 0 indexed) \\n\\t\\t// to our result list.\\n        for(int i=0; i< nums.length; i++){\\n            if(nums[i] > 0){\\n                result.add(i+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n    \\n        // since all numbers are between [1,n], we go to nums[i]-1 th index and multiply it by -1. \\n\\t\\t// if it is already negative(has previously been visited) we leave it as it is\\n        \\n        // Example, nums = [4,3,2,7,8,2,3,1] becomes\\n        //          nums = [-4,-3,-2,-7,-8,2,3,-1]\\n        for(int i=0; i<nums.length; i++){\\n            int num = Math.abs(nums[i]) - 1;\\n            \\n            nums[num] = nums[num] < 0 ? nums[num] : - nums[num];\\n        }\\n        \\n        // finally we check if there are positive numbers in nums, which indicates that number is \\n\\t\\t// missing(hasn\\'t been multiplied by -1). And then add their index + 1(b/c array is 0 indexed) \\n\\t\\t// to our result list.\\n        for(int i=0; i< nums.length; i++){\\n            if(nums[i] > 0){\\n                result.add(i+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313866,
                "title": "c-solution-2-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i = 0; i < n; i++){\\n            int idx = abs(nums[i]); \\n            if(nums[idx-1] > 0) nums[idx-1] = -nums[idx-1]; // marking -ve    \\n        }\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\\n**Using Unordered map**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int>ans;\\n        unordered_map<int, bool>mp;\\n        for(int i = 0; i < n; i++) mp[nums[i]] = true;\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(mp.find(i) == mp.end()) ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i = 0; i < n; i++){\\n            int idx = abs(nums[i]); \\n            if(nums[idx-1] > 0) nums[idx-1] = -nums[idx-1]; // marking -ve    \\n        }\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int>ans;\\n        unordered_map<int, bool>mp;\\n        for(int i = 0; i < n; i++) mp[nums[i]] = true;\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(mp.find(i) == mp.end()) ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482313,
                "title": "elegant-swift-solution",
                "content": "It is not optimal and using extra memory, but fun :)\\n\\n```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        if nums.isEmpty {\\n            return nums\\n        }\\n        \\n        return Array(\\n            Set(1...nums.count).subtracting(nums)\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        if nums.isEmpty {\\n            return nums\\n        }\\n        \\n        return Array(\\n            Set(1...nums.count).subtracting(nums)\\n        )\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92976,
                "title": "c-time-o-n-space-o-1",
                "content": "I use in-place change and the index of vector is from 0 -> n-1.\\n\\n    class Solution {\\n    public:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.empty()) return res;\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            while(nums[nums[i]-1] != nums[i]){\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] != i+1){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.empty()) return res;\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            while(nums[nums[i]-1] != nums[i]){\\n                swap(nums[nums[i]-1], nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3741667,
                "title": "cyclic-sort-be-saving-life-fr-java",
                "content": "\\n### Intuition\\nThe problem aims to find the missing numbers in an array of integers from 1 to n. The intuition behind the solution is to use cyclic sort to arrange the elements in their correct positions. After that, we can iterate through the sorted array and identify the missing numbers.\\n\\n### Approach\\n1. We start by initializing variables `n` as the length of the array `nums`, `i` as 0, and creating an empty ArrayList called `ans` to store the missing numbers.\\n2. We perform a cyclic sort on the `nums` array. The goal is to move each number to its correct index position by swapping elements. If the current number is not equal to the number at its correct index, we perform the swap.\\n3. After the cyclic sort, we iterate through the array again to find the missing numbers. If the number at index `i` is not equal to `i+1`, it means `i+1` is a missing number. We add it to the `ans` ArrayList.\\n4. Finally, we return the `ans` ArrayList, which contains the missing numbers.\\n\\n### Complexity\\n- Time complexity: The time complexity is O(n), where n is the length of the `nums` array. The cyclic sort and the subsequent iteration take linear time.\\n- Space complexity: The space complexity is O(1) since the extra space used is only for the variables `n`, `i`, and the `ans` ArrayList, which are of constant size.\\n\\n### Code\\n```java\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        int n = nums.length;\\n        int i = 0 ; \\n        List<Integer> ans = new ArrayList();\\n\\n        if (n < 2) return new ArrayList<Integer>(1);\\n\\n        while (i < n) {\\n            int correctIndex = nums[i] - 1;\\n\\n            if (nums[i] != nums[correctIndex]) {\\n                if (correctIndex < n) {\\n                    swap(nums, i, correctIndex);\\n                } else {\\n                    i++;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                ans.add(i + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n\\nI hope this explanation helps you understand the solution. If you have any further questions, feel free to ask!\\n\\n![upvotekaro1.jpeg](https://assets.leetcode.com/users/images/6f3e46a6-ac51-463b-be4b-56fa16ec0075_1688918097.433203.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        int n = nums.length;\\n        int i = 0 ; \\n        List<Integer> ans = new ArrayList();\\n\\n        if (n < 2) return new ArrayList<Integer>(1);\\n\\n        while (i < n) {\\n            int correctIndex = nums[i] - 1;\\n\\n            if (nums[i] != nums[correctIndex]) {\\n                if (correctIndex < n) {\\n                    swap(nums, i, correctIndex);\\n                } else {\\n                    i++;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                ans.add(i + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491390,
                "title": "java-cycle-sort-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i=0;\\n        while(i<nums.length){\\n            int correct = nums[i]-1;\\n            if(nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else i++;\\n        }\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i=0;\\n        while(i<nums.length){\\n            int correct = nums[i]-1;\\n            if(nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else i++;\\n        }\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871915,
                "title": "simple-and-easy-approach-to-understand-using-vector-and-set-o-nlogn",
                "content": "# Intuition\\nWE need to find all the elements that are not present in array upto n\\nwhich is size of array.\\n\\n# Approach\\nI have taken A set and inserted all the elemnets  which is  given to us.\\nNow i have taken a vector(V) in which  I am pushing all the elements upto n  regardless of their presence in vector  given i.e nums.\\n\\nNOW we will check through loop if the  element present in our vector (V) is present in set or  not if not found then we will push into vector v1    and return it.\\n\\nlike [1,1,2,2] given here value of  n is 4\\nso we will push 1,2,3,4 into vector v\\n```\\nfor(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n```\\nSO V have  v[1,2,3,4]\\nand set have s {1,2}\\nNOW we will check if v[i] is present in set if not then push it into v1 so v1 have [3,4] and  this is our result\\n```\\n    for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n```\\n\\n\\n# Complexity\\n- Time complexy: $O(nlogn)\\n\\n-\\n-  Space complexity:\\n\\n$O(n)\\n#### if any doubt or confusion regarding the code ask in comment section I will try to reply as soon as possible\\n# IF IT\\'S HELPFUL UPVOTE IT\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      int n=nums.size();\\n      int max=*max_element(nums.begin(), nums.end());\\n      vector<int> v,v1;\\n      set<int>s;\\n      for(int i=0; i<n; i++){\\n        s.insert(nums[i]);\\n      }\\n      for(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n       for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n       return v1;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nfor(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n```\n```\\n    for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      int n=nums.size();\\n      int max=*max_element(nums.begin(), nums.end());\\n      vector<int> v,v1;\\n      set<int>s;\\n      for(int i=0; i<n; i++){\\n        s.insert(nums[i]);\\n      }\\n      for(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n       for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n       return v1;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687300,
                "title": "easy-c-set-method",
                "content": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      \\n\\t  int n = nums.size();\\n        vector<int> ans;\\n        unordered_set<int> temp;\\n        for(auto x:nums) \\n        {   temp.insert(x);\\n        }\\n        for(int i=1;i<=n;i++)\\n            // iterate from 1->n, and find if the number is not present in the set                  and store it in the ans.\\n        {\\n            if(temp.find(i)==temp.end())\\n            {\\n               ans.push_back(i); \\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      \\n\\t  int n = nums.size();\\n        vector<int> ans;\\n        unordered_set<int> temp;\\n        for(auto x:nums) \\n        {   temp.insert(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1616425,
                "title": "cyclic-sort-method-time-o-n-and-space-o-1",
                "content": "Disclaimer: This question is very easy if you use simple hashmap, but get\\'s slightly tricky if you have a restriction of O(1) space, and that\\'s where the interviewer strikes :)\\n\\nLet us solve a simpler question:\\ngiven an array of size n and values between 1 and n , how can we sort it in O(n) complexity with O(1) space complexity?\\nAnswer is cyclic sort, read about it [here](https://emre.me/coding-patterns/cyclic-sort/).\\n\\nHere is my implementation of cyclic sort:\\n```\\n    vector<int>A = {4, 3, 1, 2};\\n    int n = A.size();\\n    for(int i=0; i<n; ++i) {\\n        while(i != A[i]-1) {\\n            swap(A[i], A[A[i]-1]);\\n        }\\n    }\\n\\t// A is now sorted\\n```\\n\\nNow once you are done with cyclic sort, this question will be cakewalk, try it yourself, below is my implementation:\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i) {\\n            while(i != (nums[i]-1) && nums[i] != nums[nums[i]-1]) {\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]-1!=i) {\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<int>A = {4, 3, 1, 2};\\n    int n = A.size();\\n    for(int i=0; i<n; ++i) {\\n        while(i != A[i]-1) {\\n            swap(A[i], A[A[i]-1]);\\n        }\\n    }\\n\\t// A is now sorted\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i) {\\n            while(i != (nums[i]-1) && nums[i] != nums[nums[i]-1]) {\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]-1!=i) {\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583712,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for v in nums:            \\n            nums[abs(v) - 1] = -abs(nums[abs(v) - 1])\\n                \\n        return [ i + 1 for i, v in enumerate(nums) if v >= 1 ]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for v in nums:            \\n            nums[abs(v) - 1] = -abs(nums[abs(v) - 1])\\n                \\n        return [ i + 1 for i, v in enumerate(nums) if v >= 1 ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759565,
                "title": "javascript-solution-448",
                "content": "```\\nlet findDisappearedNumbers = function(nums1) {\\n    let ans=[];\\n    let diff=0;\\n    let start=0;\\n    nums1.sort(function(a,b){\\n        return (a-b)\\n    });\\n    for (let i=1;i<=nums1.length;i++){\\n        if(!nums1.includes(i)){\\n            ans.push(i);\\n        }\\n    }\\n    return ans;\\n\\n        };\\n```\\n\\n**Runtime: 9068 ms, faster than 5.05% of JavaScript online submissions for Find All Numbers Disappeared in an Array.\\nMemory Usage: 46.5 MB, less than 48.95% of JavaScript online submissions for Find All Numbers Disappeared in an Array.**",
                "solutionTags": [],
                "code": "```\\nlet findDisappearedNumbers = function(nums1) {\\n    let ans=[];\\n    let diff=0;\\n    let start=0;\\n    nums1.sort(function(a,b){\\n        return (a-b)\\n    });\\n    for (let i=1;i<=nums1.length;i++){\\n        if(!nums1.includes(i)){\\n            ans.push(i);\\n        }\\n    }\\n    return ans;\\n\\n        };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656108,
                "title": "swift-solution-optimal-96",
                "content": "This clean swift solution uses O(n) time and O(1) space.\\n\\n**Explanation**\\nTo signify that the number `n` exists with O(1) space, we make `nums[n - 1]` negative. We must be careful to make it negative only once which is why we have the if condition around the assignment. Also, we use `n - 1` instead of `n` to avoid an array index out of bounds error since `n` ranges from `1 ... n`\\n\\n**Be Aware**\\nTechnically this problem cannot be done in O(1) space in Swift since we must create a new array. This could be done in O(1) space only if we had `_ nums: inout [Int]` in the method signature. \\n\\n**Solution**\\n```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        // If the current number is \"n\", then make index \"n-1\" negative to signify \"n\" exists\\n        var nums = nums \\n        for i in 0 ..< nums.count {\\n            let n = abs(nums[i])\\n            if nums[n - 1] >= 0 {\\n                nums[n - 1] = -nums[n - 1]\\n            }\\n        }\\n        \\n        // If the number at index \"i\" is positive, then number \"i+1\" was missing\\n        var missing = [Int]()\\n        for i in 0 ..< nums.count {\\n            if nums[i] >= 0 {\\n                missing.append(i+1)\\n            }\\n        }\\n        return missing\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        // If the current number is \"n\", then make index \"n-1\" negative to signify \"n\" exists\\n        var nums = nums \\n        for i in 0 ..< nums.count {\\n            let n = abs(nums[i])\\n            if nums[n - 1] >= 0 {\\n                nums[n - 1] = -nums[n - 1]\\n            }\\n        }\\n        \\n        // If the number at index \"i\" is positive, then number \"i+1\" was missing\\n        var missing = [Int]()\\n        for i in 0 ..< nums.count {\\n            if nums[i] >= 0 {\\n                missing.append(i+1)\\n            }\\n        }\\n        return missing\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585334,
                "title": "c-basic-solution",
                "content": "```\\n  public IList<int> FindDisappearedNumbers(int[] nums)\\n        {\\n            //creating required range.\\n            //for example, nums = new[] { 4, 3, 2, 7, 8, 2, 3, 1 }; in this case range is 1-10. \\n            //by default all arrays start from 0, that is why we need [nums.Length + 1] for getting proper range\\n            bool[] values = new bool[nums.Length + 1];\\n\\n            //By default value if false, if we found value in our required range set value true\\n            foreach (var t in nums)\\n            {\\n                values[t] = true;\\n            }\\n\\n            //collect all values which is not found in required range\\n            var result = new List<int>();\\n            for (int i = 1; i < values.Length; i++)\\n            {\\n                if (values[i] == false)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n  public IList<int> FindDisappearedNumbers(int[] nums)\\n        {\\n            //creating required range.\\n            //for example, nums = new[] { 4, 3, 2, 7, 8, 2, 3, 1 }; in this case range is 1-10. \\n            //by default all arrays start from 0, that is why we need [nums.Length + 1] for getting proper range\\n            bool[] values = new bool[nums.Length + 1];\\n\\n            //By default value if false, if we found value in our required range set value true\\n            foreach (var t in nums)\\n            {\\n                values[t] = true;\\n            }\\n\\n            //collect all values which is not found in required range\\n            var result = new List<int>();\\n            for (int i = 1; i < values.Length; i++)\\n            {\\n                if (values[i] == false)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336437,
                "title": "solution-in-python-3-five-lines-o-n-time-o-1-space",
                "content": "_1) O(n) speed and O(1) space Solution:_\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n        i, L = 0, len(n)\\n        while i != L:\\n        \\tif n[i] in [i + 1, n[n[i] - 1]]: i += 1\\n        \\telse: n[n[i] - 1], n[i] = n[i], n[n[i] - 1]\\n        return [i + 1 for i in range(L) if n[i] != i + 1]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n_2) Fast Solution (beats ~99%):_\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n    \\tN = set(n)\\n    \\treturn [i for i in range(1, len(n) + 1) if i not in N]\\n\\n- Python 3\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n        i, L = 0, len(n)\\n        while i != L:\\n        \\tif n[i] in [i + 1, n[n[i] - 1]]: i += 1\\n        \\telse: n[n[i] - 1], n[i] = n[i], n[n[i] - 1]\\n        return [i + 1 for i in range(L) if n[i] != i + 1]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324205,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    let res = []\\n    nums.forEach((val, ind, arr) => {\\n        let tmp = Math.abs(arr[ind]) - 1;\\n        if (arr[tmp] > 0)\\n            arr[tmp] *= -1;\\n    })\\n    nums.forEach((val, ind) => {\\n        if (val > 0)\\n            res.push(ind + 1)\\n    })\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    let res = []\\n    nums.forEach((val, ind, arr) => {\\n        let tmp = Math.abs(arr[ind]) - 1;\\n        if (arr[tmp] > 0)\\n            arr[tmp] *= -1;\\n    })\\n    nums.forEach((val, ind) => {\\n        if (val > 0)\\n            res.push(ind + 1)\\n    })\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273792,
                "title": "javascript-solution",
                "content": "```\\nvar findDisappearedNumbers = function(nums) {\\n    var s = {};\\n    for (let i =1; i< nums.length+1; i++) {\\n        s[i] = 1;\\n    }\\n    \\n    nums.forEach(n=> {\\n        delete s[n];\\n    })\\n    \\n   return Object.keys(s)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    var s = {};\\n    for (let i =1; i< nums.length+1; i++) {\\n        s[i] = 1;\\n    }\\n    \\n    nums.forEach(n=> {\\n        delete s[n];\\n    })\\n    \\n   return Object.keys(s)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231325,
                "title": "python-solution",
                "content": "Idea: change `nums[n-1]` to `-1` for all `n` in `nums`, meaning that we have seen `n` in `nums`. Then we traverse `nums` once more, and record all indices `idx` such that `nums[idx] != -1`. Each `idx+1` will be a number that disappears in `nums`. \\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                while n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = -1\\n                    n = tmp\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] >= 0:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                while n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = -1\\n                    n = tmp\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] >= 0:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209665,
                "title": "short-python-beats-76",
                "content": "```\\ndef findDisappearedNumbers(self, nums):\\n\\tfor num in nums:\\n\\t\\tnum = abs(num)\\n\\t\\tif nums[num-1] >0:\\n\\t\\t\\tnums[num-1] *=-1\\n\\treturn [i+1 for i,x in enumerate(nums) if x>0]",
                "solutionTags": [],
                "code": "```\\ndef findDisappearedNumbers(self, nums):\\n\\tfor num in nums:\\n\\t\\tnum = abs(num)\\n\\t\\tif nums[num-1] >0:\\n\\t\\t\\tnums[num-1] *=-1\\n\\treturn [i+1 for i,x in enumerate(nums) if x>0]",
                "codeTag": "Python3"
            },
            {
                "id": 92959,
                "title": "c-solution-o-n-and-no-additional-space",
                "content": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int* histogram = (int*) malloc(sizeof(int) * (numsSize + 1)); \\n    memset(histogram, 0, sizeof(int) * numsSize);\\n\\n    for (int index = 0; index < numsSize; index++) {\\n        histogram[nums[index]]++;\\n    }\\n\\n    histogram[0] = 1;\\n    for (int index = 1; index <= numsSize; index++) {\\n        if (histogram[index] == 0) {\\n            histogram[histogram[0]] = index;\\n            histogram[0]++;\\n        }\\n    }\\n    *returnSize = histogram[0] - 1;\\n    return &histogram[1];\\n}\\n```\\nKeeping a histogram array, and later traversing the histogram to return elements with 0 values allows us to solve this problem with O(n) complexity. Index 0 of the histogram was used to store the number of missing numbers.",
                "solutionTags": [],
                "code": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int* histogram = (int*) malloc(sizeof(int) * (numsSize + 1)); \\n    memset(histogram, 0, sizeof(int) * numsSize);\\n\\n    for (int index = 0; index < numsSize; index++) {\\n        histogram[nums[index]]++;\\n    }\\n\\n    histogram[0] = 1;\\n    for (int index = 1; index <= numsSize; index++) {\\n        if (histogram[index] == 0) {\\n            histogram[histogram[0]] = index;\\n            histogram[0]++;\\n        }\\n    }\\n    *returnSize = histogram[0] - 1;\\n    return &histogram[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393596,
                "title": "find-all-numbers-disappeared-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            m[i+1]++;\\n            m[nums[i]]++;\\n        }\\n        nums.clear();\\n        for( auto it:m)\\n        {\\n            if(it.second==1)\\n            {\\n                nums.push_back(it.first);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            m[i+1]++;\\n            m[nums[i]]++;\\n        }\\n        nums.clear();\\n        for( auto it:m)\\n        {\\n            if(it.second==1)\\n            {\\n                nums.push_back(it.first);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659032,
                "title": "c-solution-simple-and-precise-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> v;\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        for(int i=1;i<=nums.size();i++)\\n        {\\n            if(m[i]==0) v.push_back(i); \\n        }\\n        return v;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> v;\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        for(int i=1;i<=nums.size();i++)\\n        {\\n            if(m[i]==0) v.push_back(i); \\n        }\\n        return v;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643134,
                "title": "easy-c-sol-for-beginners-o-n-time-complexity-and-o-1-space-complexity",
                "content": "Basically what we are trying to do is \\n1) Given range 1 to n\\n2) Range of array 0 to n-1\\n3) So we are trying to traverse every element of nums and replace the index nums[i]-1 with negative value (the values can some times already be negative so we are using abs() to make sure it is not changed back to positive value if we encounter the same element again)\\n4) After travesing the nums array we will one again traverse to check which values are +ve (Because +ve values means they are not encountered earlier)\\n5) Finally we will add (index of positive values +1) to vector and return the vector (why +1 -> Remember that the difference between range of values and array index is 1 so we need to add this 1 to cover the difference)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n=nums.size(), loc;\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            loc = abs(nums[i])-1;\\n            nums[loc] = abs(nums[loc])*(-1);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHope this helps!\\nThank you!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n=nums.size(), loc;\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            loc = abs(nums[i])-1;\\n            nums[loc] = abs(nums[loc])*(-1);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990280,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Check in HashSet**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        seen = set(nums)\\n        res = []\\n        for num in range(1, n+1):\\n            if num not in seen:\\n                res.append(num)\\n        return res\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reuse index**\\n- Since value are in range `[1..n]`, we can mark number as seen by marking the number at that index as negative.\\n- Finally, iterate `i = [0..n-1]`, if `nums[i] > 0` then `i+1` is missing.\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for num in nums:\\n            idx = abs(num) - 1\\n            nums[idx] = -abs(nums[idx])\\n            \\n        ans = []\\n        for i in range(n):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        seen = set(nums)\\n        res = []\\n        for num in range(1, n+1):\\n            if num not in seen:\\n                res.append(num)\\n        return res\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for num in nums:\\n            idx = abs(num) - 1\\n            nums[idx] = -abs(nums[idx])\\n            \\n        ans = []\\n        for i in range(n):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849912,
                "title": "python-one-liner-simple-and-elegant",
                "content": "**Solution**:\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        return set(range(1,len(nums)+1)) - set(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        return set(range(1,len(nums)+1)) - set(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584902,
                "title": "java-solution-o-n-time-o-1-space-100-faster",
                "content": "**Complexity Explanation:**\\n* O(N) Time: We pass through the array 2 times\\n* O(1) Space: Constant space used\\n\\n---\\n\\n**Algorithm Explanation:**\\n\\nThis array has the special property of only containing numbers between 1 and the array length\\n\\nThis means that we can easily record in the input array if we have seen that number already\\n\\nWhenever we visit an element, we visit the index of the element, and make the index negative, to show that we visited\\n\\nBy making it negative, we can clearly see that it was changed, without changing it\\'s numerical value\\n\\nAfter the array has been iterated, all indexes that have negative elements will have their indexes as elements in the array themselves.\\n\\nPositive elements mean that the index never appeared in the array, and so we add that index to our output/result.\\n\\n---\\n**Example:**\\n\\n\\nInput Array: [**4**,3,2,7,8,2,3,1]\\n\\nFirst element is 4, we make the 4th index negative\\n\\nNew Array: [4,**3**,2,-7,8,2,3,1]\\n\\nSecond element is 3, we make the 3rd index negative\\n\\nNew Array: [4,3,**-2**,-7,8,2,3,1]\\n\\nThird element is -2, but it\\'s numerical value is 2, so we make the 2nd element negative\\n\\nNew Array: [4,-3,-2,**-7**,8,2,3,1]\\n\\nFourth element is -7, but it\\'s numerical value is 7, so we make the 7th element negative\\n\\nNew Array: [4,-3,-2,-7,**8**,2,-3,1]\\n\\nFifth element, is 8, so we make the 8th element negative\\n\\nNew Array: [4,-3,-2,-7,8,**2**,-3,-1]\\n\\nsixth element is 2, so we make the 2nd element negative\\n\\nSince it is already negative, we make no change\\n\\nNew Array: [4,-3,-2,-7,8,2,**-3**,-1]\\n\\nseventh element is -3, which has a numerical value of 3, so we make the 3rd element negative\\n\\nSince it is already negative, we make no change\\n\\nNew Array: [4,-3,-2,-7,8,2,-3,**-1**]\\n\\neighth element is -1, which has a numerical value of 1, so we make the 1st element negative\\n\\n**Final Array:** [-4,-3,-2,-7,8,2,-3,-1]\\n\\nThe 5th and 6th element is positive, meaning that those indexes were not present in the array\\n\\nWe return 5 and 6 in a List, and finish our code :)\\n\\n---\\n\\n**The Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[Math.abs(nums[idx])-1]>0){\\n                nums[Math.abs(nums[idx])-1]*=-1;\\n            }\\n        }\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[idx] > 0){\\n                result.add(idx+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nIf you found this solution interesting or useful, please upvote :)\\n\\nIf this explanation is still unclear, please comment so that I may further explain it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[Math.abs(nums[idx])-1]>0){\\n                nums[Math.abs(nums[idx])-1]*=-1;\\n            }\\n        }\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[idx] > 0){\\n                result.add(idx+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377234,
                "title": "easy-java-solution-3-ms-faster-than-100-00-of-java-online",
                "content": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int [] a = new int[nums.length+1];\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<nums.length; i++)\\n            a[nums[i]]++;\\n        \\n        for(int i =1; i<nums.length+1; i++)\\n            if(a[i] == 0)\\n                list.add(i);\\n            \\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int [] a = new int[nums.length+1];\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<nums.length; i++)\\n            a[nums[i]]++;\\n        \\n        for(int i =1; i<nums.length+1; i++)\\n            if(a[i] == 0)\\n                list.add(i);\\n            \\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1238204,
                "title": "java-o-n-time-and-both-o-1-and-o-n-space",
                "content": "**Solution 1: O(n) space**\\nInitialize a new array `tmp` of the same length as `nums`.  By default all elements are 0. Now iterate over `nums` and for\\nfor each element k in `nums`, increment the element at the corresponding index of tmp by 1. For elements within `1,...,n`that are not present in `nums`, the corresponding 0-indexed element in `tmp` will remain zero, since those numbers are not encountered while iterating over `nums`.\\n\\nNext, iterate over `tmp` and add only those indexes to list, whose value is 0. Note that `l.add(i+1)` is done to account for 0-indexing.\\n\\n**Solution 2: O(1) space**\\nSInce all elements are less than or equal to `n = nums.length`, let us first send all elements one by one to their correct positions. Here correct position means 1 should be at index 0, 2 should be at index 1, k should be at index k-1.\\nLet\\'s see how this is done: \\n\\nWe start at the first element 4. `[4,3,2,7,8,2,3,1]` becomes `[7,3,2,4,8,2,3,1]` as the 1st element 4 is sent to index 3 and replaced with 7, which was on index 3. This is carried out until we have element 1 at index 0, or we find a duplicate element. The process goes like:\\n\\n`[7,3,2,4,8,2,3,1]` - >`[3,3,2,4,8,2,7,1]` - > `[2,3,3,4,8,2,7,1]` - > `[3,2,3,4,8,2,7,1]` where we find a duplicate element. Here we shift to the next element which is 2 and repeat the process, until we reach the end of the array, where we\\'re left with `nums = [1,2,3,4,3,2,7,8]`. We can see that the elements that are not in their correct position are 3 at index  4 and 2 at index 5, where 5 and 6 should have been, respectively.\\n\\nHence we return a list containing the elements 5 and 6.\\n\\n```\\n**Solution 1: O(n) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] tmp = new int[nums.length];\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n            tmp[nums[i] - 1]++;\\n        }\\n        for(int i = 0; i < tmp.length; i++){\\n            if(tmp[i] == 0) l.add(i+1);\\n        }\\n        return l;\\n    }\\n\\n**Solution 2: O(1) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        List<Integer> l = new ArrayList<Integer>();\\n        while(i < nums.length){\\n            if(nums[i] != i+1){\\n                if(nums[i] == nums[nums[i] - 1]) {\\n                    i++;\\n                }else{\\n                    int tmp = nums[i];\\n                    nums[i] = nums[nums[i] - 1];\\n                    nums[tmp - 1] = tmp;\\n                }\\n            } else i++;\\n        }\\n        for(i = 0; i < nums.length; i++){\\n            if(nums[i] != i + 1) l.add(i+1);\\n        }\\n        return l;   \\n    }",
                "solutionTags": [],
                "code": "**Solution 1: O(n) space**\\nInitialize a new array `tmp` of the same length as `nums`.  By default all elements are 0. Now iterate over `nums` and for\\nfor each element k in `nums`, increment the element at the corresponding index of tmp by 1. For elements within `1,...,n`that are not present in `nums`, the corresponding 0-indexed element in `tmp` will remain zero, since those numbers are not encountered while iterating over `nums`.\\n\\nNext, iterate over `tmp` and add only those indexes to list, whose value is 0. Note that `l.add(i+1)` is done to account for 0-indexing.\\n\\n**Solution 2: O(1) space**\\nSInce all elements are less than or equal to `n = nums.length`, let us first send all elements one by one to their correct positions. Here correct position means 1 should be at index 0, 2 should be at index 1, k should be at index k-1.\\nLet\\'s see how this is done: \\n\\nWe start at the first element 4. `[4,3,2,7,8,2,3,1]` becomes `[7,3,2,4,8,2,3,1]` as the 1st element 4 is sent to index 3 and replaced with 7, which was on index 3. This is carried out until we have element 1 at index 0, or we find a duplicate element. The process goes like:\\n\\n`[7,3,2,4,8,2,3,1]` - >`[3,3,2,4,8,2,7,1]` - > `[2,3,3,4,8,2,7,1]` - > `[3,2,3,4,8,2,7,1]` where we find a duplicate element. Here we shift to the next element which is 2 and repeat the process, until we reach the end of the array, where we\\'re left with `nums = [1,2,3,4,3,2,7,8]`. We can see that the elements that are not in their correct position are 3 at index  4 and 2 at index 5, where 5 and 6 should have been, respectively.\\n\\nHence we return a list containing the elements 5 and 6.\\n\\n```\\n**Solution 1: O(n) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] tmp = new int[nums.length];\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n            tmp[nums[i] - 1]++;\\n        }\\n        for(int i = 0; i < tmp.length; i++){\\n            if(tmp[i] == 0) l.add(i+1);\\n        }\\n        return l;\\n    }\\n\\n**Solution 2: O(1) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        List<Integer> l = new ArrayList<Integer>();\\n        while(i < nums.length){\\n            if(nums[i] != i+1){\\n                if(nums[i] == nums[nums[i] - 1]) {\\n                    i++;\\n                }else{\\n                    int tmp = nums[i];\\n                    nums[i] = nums[nums[i] - 1];\\n                    nums[tmp - 1] = tmp;\\n                }\\n            } else i++;\\n        }\\n        for(i = 0; i < nums.length; i++){\\n            if(nums[i] != i + 1) l.add(i+1);\\n        }\\n        return l;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1195628,
                "title": "two-approaches-java-faster-than-100",
                "content": "**O(n) - Time\\nNo Extra Space**\\n1. Traverse the array,and find out index corresponding to given element.(Since we have 0 based index in arrays, so index = abs(nums[i]-1))\\n2. Make the element at that index negative, to mark its presence.\\n3. Traverse the array again to determine the disappeared numbers.\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int index = Math.abs(nums[i])-1;\\n            if(nums[index] > 0)\\n                nums[index] = -1*nums[index];\\n        }\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] > 0)\\n                arr.add(i+1);\\n        }\\n        return arr;\\n    }\\n}\\n\\n```\\n\\n**Using O(N) space **\\n\\n1. Traverse the array, and maintain the count/ frequency of each element that is occuring.\\n2. Then traverse the count array, and check the elements whose frequency is still 0, and add it to the ans list.\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int n = nums.length;  \\n        List<Integer>  ans = new ArrayList<>();\\n        int count[] = new int[n+1];\\n        for(int i : nums)\\n        {\\n           count[i]++;\\n        }\\n        \\n        for(int i =1;i<n+1;i++)\\n        {\\n            if(count[i] == 0)\\n              ans.add(i);    \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int index = Math.abs(nums[i])-1;\\n            if(nums[index] > 0)\\n                nums[index] = -1*nums[index];\\n        }\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] > 0)\\n                arr.add(i+1);\\n        }\\n        return arr;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int n = nums.length;  \\n        List<Integer>  ans = new ArrayList<>();\\n        int count[] = new int[n+1];\\n        for(int i : nums)\\n        {\\n           count[i]++;\\n        }\\n        \\n        for(int i =1;i<n+1;i++)\\n        {\\n            if(count[i] == 0)\\n              ans.add(i);    \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139900,
                "title": "simple-java-linear-time-solution-o-1-space",
                "content": "As numbers are between [1,N], so for each number we can make number at index (num - 1) negative and the numbers which are missing  wouldn\\'t  be able to make their indices negative so we will traverse array again and see positive indices and add them into list \\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(nums.length == 0 || nums == null) return result;\\n        \\n        for(int num : nums){\\n            int index = Math.abs(num);\\n            \\n            if(nums[index - 1] > 0){\\n                nums[index - 1] = -nums[index - 1];\\n            }\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(nums[i - 1] > 0){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(nums.length == 0 || nums == null) return result;\\n        \\n        for(int num : nums){\\n            int index = Math.abs(num);\\n            \\n            if(nums[index - 1] > 0){\\n                nums[index - 1] = -nums[index - 1];\\n            }\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(nums[i - 1] > 0){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741568,
                "title": "java-set-approach",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        //add all unique elements in the set\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        \\n        //iterate through 1 to n and check if it is not present in the set\\n        List<Integer> missing = new ArrayList<>();\\n        for(int i = 1; i <= nums.length; i++)\\n            if(!set.contains(i))\\n                missing.add(i);\\n        \\n        \\n        return missing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        //add all unique elements in the set\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        \\n        //iterate through 1 to n and check if it is not present in the set\\n        List<Integer> missing = new ArrayList<>();\\n        for(int i = 1; i <= nums.length; i++)\\n            if(!set.contains(i))\\n                missing.add(i);\\n        \\n        \\n        return missing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442512,
                "title": "easy-solution-using-hashset-c",
                "content": "```\\npublic IList<int> FindDisappearedNumbers(int[] nums) {\\n            var set = new HashSet<int>(Enumerable.Range(1, nums.Length));\\n            foreach (var num in nums)\\n                set.Remove(num);\\n\\n            return set.ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<int> FindDisappearedNumbers(int[] nums) {\\n            var set = new HashSet<int>(Enumerable.Range(1, nums.Length));\\n            foreach (var num in nums)\\n                set.Remove(num);\\n\\n            return set.ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313578,
                "title": "easy-python-1-line-using-set-95",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290039,
                "title": "python-8-lines-in-place-changes-can-be-undone-o-n-runtime-o-1-space",
                "content": "Based on  [this solution](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92957/2ms-O(n)-In-Space-Javattp://)\\nKeep track of which numbers have been seen, by numbers at the positions of the original array to be negative. For example if we saw the number 1, we set the 1st element of the original array to be negative.\\n\\nThen just return all the indexes where the numbers are positive\\n```\\n\\tfor i in range(len(nums)):\\n\\t\\tn = abs(nums[i])\\n\\t\\tnums[n-1] = -abs(nums[n-1])\\n\\tans = []\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > 0 :\\n\\t\\t\\tans.append(i+1)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfor i in range(len(nums)):\\n\\t\\tn = abs(nums[i])\\n\\t\\tnums[n-1] = -abs(nums[n-1])\\n\\tans = []\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > 0 :\\n\\t\\t\\tans.append(i+1)\\n\\treturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223645,
                "title": "o-1-space-and-o-n-time-beats-97-22-cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\t\\t\\t\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            int temp = nums[i] ; \\n            temp = (temp > 0) ? temp : -temp ; \\n            \\n            temp-- ; \\n            \\n            if(nums[temp] > 0)\\n            {\\n                nums[temp] *= -1 ; \\n            }\\n        }\\n        \\n        vector<int> res ;\\n        \\n        \\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(nums[i] > 0 )\\n            {\\n                res.push_back(i+1) ;\\n            }\\n        }\\n        \\n        \\n        return res; \\n        \\n        \\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\t\\t\\t\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            int temp = nums[i] ; \\n            temp = (temp > 0) ? temp : -temp ; \\n            \\n            temp-- ; \\n            \\n            if(nums[temp] > 0)\\n            {\\n                nums[temp] *= -1 ; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 92996,
                "title": "python-simple-solution",
                "content": "Obviously, the solution is to take the difference set of two sets\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        l = set(sorted(nums))\\n        u = range(1,len(nums)+1)\\n        if len(l) > 0:\\n            return list(set(u) - l)\\n        else:\\n            return []\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        l = set(sorted(nums))\\n        u = range(1,len(nums)+1)\\n        if len(l) > 0:\\n            return list(set(u) - l)\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93031,
                "title": "c-one-liner",
                "content": "```\\nusing System.Linq;\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        return Enumerable.Range(1,nums.Length).Except(nums.Distinct()).ToList();\\n    }\\n}\\n```\\nCan anyone tell me why my solution beats only 37.67% of C# submissions?\\n\\nHow does LINQ work internally?\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "```\\nusing System.Linq;\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        return Enumerable.Range(1,nums.Length).Except(nums.Distinct()).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93008,
                "title": "java-using-counter-to-solve",
                "content": "```\\n List<Integer> result = new ArrayList<Integer>();\\n        int n = nums.length;\\n        int a[] = new int [n + 1];\\n        for(int i =0 ; i <= n; i++)\\n           a[i] = 0;\\n        for( int i =0; i < n;i++)\\n           a[nums[i]]++;\\n        \\n        for( int i=1; i <= n;i++){\\n            if(a[i]==0)\\n               result.add(i);\\n        }\\n        \\n        return result;",
                "solutionTags": [],
                "code": "```\\n List<Integer> result = new ArrayList<Integer>();\\n        int n = nums.length;\\n        int a[] = new int [n + 1];\\n        for(int i =0 ; i <= n; i++)\\n           a[i] = 0;\\n        for( int i =0; i < n;i++)\\n           a[nums[i]]++;\\n        \\n        for( int i=1; i <= n;i++){\\n            if(a[i]==0)\\n               result.add(i);\\n        }\\n        \\n        return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 3960130,
                "title": "easy-hashset-solution-in-java",
                "content": "# Approach\\nFirst, we create a HashSet to store all the unique elements from our **nums** array. Once we\\'ve added the items to this set, we proceed to iterate through all the values in the range of **[1, nums.length]** to determine if they already exist in the set. If a value doesn\\'t exist, we include it in an ArrayList of missing values. Finally, we return this ArrayList containing the missing values.\\n\\n*Please drop an upvote and make me happy!* \\uD83D\\uDC4D\\uD83C\\uDFFF\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83C\\uDFFD\\uD83D\\uDC4D\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity is $$O(n)$$.\\n- Space complexity is also $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\\n        ArrayList<Integer> missingNumbers = new ArrayList<>();\\n\\n        for (int num : nums)\\n        {\\n            uniqueNumbers.add(num);\\n        }\\n\\n        for (int i = 1; i <= nums.length; i++)\\n        {\\n            if (!uniqueNumbers.contains(i))\\n            {\\n                missingNumbers.add(i);\\n            }\\n        }\\n\\n        return missingNumbers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\\n        ArrayList<Integer> missingNumbers = new ArrayList<>();\\n\\n        for (int num : nums)\\n        {\\n            uniqueNumbers.add(num);\\n        }\\n\\n        for (int i = 1; i <= nums.length; i++)\\n        {\\n            if (!uniqueNumbers.contains(i))\\n            {\\n                missingNumbers.add(i);\\n            }\\n        }\\n\\n        return missingNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414251,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{}; \\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        } \\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{}; \\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        } \\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414238,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{};\\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        }\\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{};\\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        }\\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788910,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++){\\n            freq[nums[i]]++;\\n        } \\n       for(int i=1;i<=n;i++){\\n           if(freq[i]==0) ans.push_back(i);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++){\\n            freq[nums[i]]++;\\n        } \\n       for(int i=1;i<=n;i++){\\n           if(freq[i]==0) ans.push_back(i);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701204,
                "title": "python-simple-solution-in-o-n-without-using-extra-space",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        a,n=[],len(nums)\\n        for i in nums:\\n            j=abs(i)-1\\n            nums[j]=-1*abs(nums[j])\\n        for i in range(n):\\n            if nums[i]>0:\\n                a.append(i+1)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        a,n=[],len(nums)\\n        for i in nums:\\n            j=abs(i)-1\\n            nums[j]=-1*abs(nums[j])\\n        for i in range(n):\\n            if nums[i]>0:\\n                a.append(i+1)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039287,
                "title": "just-cyclic-sort-o-n-very-simple-code",
                "content": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        while(i<nums.length)\\n        {\\n            int index = nums[i]-1;\\n            if(nums[i]!=nums[index]){\\n                int temp = nums[i];\\n                nums[i]=nums[index];\\n                nums[index]=temp;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ls = new ArrayList<>();\\n        for(int j = 0 ; j<nums.length ; j++){\\n            if(nums[j]!=j+1){\\n                ls.add(j+1);\\n            }\\n        }\\n        return ls;\\n    }\\n\\t\\n    }\\n\\t\\n# \\tHope you  find it useful. don\\'t forget to press the upvote",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        while(i<nums.length)\\n        {\\n            int index = nums[i]-1;\\n            if(nums[i]!=nums[index]){\\n                int temp = nums[i];\\n                nums[i]=nums[index];\\n                nums[index]=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1659047,
                "title": "python-1-line-solution-with-set",
                "content": "\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\t\\t\\treturn list(set(range(1, len(nums)+1))-set(nums))\\n\\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\t\\t\\treturn list(set(range(1, len(nums)+1))-set(nums))\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 1584989,
                "title": "c-simple-approach-maps-and-swap-sort",
                "content": "```\\nMethod 1 - Using maps\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int x=1;\\n        unordered_map<int,int>mp;\\n        for(auto s:nums){\\n            mp[s]++;\\n        }\\n        for(auto s:nums){\\n            if(mp[x]==0) ans.push_back(x);\\n            x++;\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\nMethod 2 - using swap sort \\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i] != nums[nums[i]-1])  {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            else\\n                i++;\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != i+1){\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nIf you like it then please upvote it.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nMethod 1 - Using maps\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int x=1;\\n        unordered_map<int,int>mp;\\n        for(auto s:nums){\\n            mp[s]++;\\n        }\\n        for(auto s:nums){\\n            if(mp[x]==0) ans.push_back(x);\\n            x++;\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\nMethod 2 - using swap sort \\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i] != nums[nums[i]-1])  {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            else\\n                i++;\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != i+1){\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nIf you like it then please upvote it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072801,
                "title": "javascript-solution",
                "content": "A solution using Javascript with O(n) time complexity and O(1) space complexity:\\n```\\nvar findDisappearedNumbers = function(nums) {\\n    let result = []\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let index = Math.abs(nums[i]) -1\\n        if(nums[index] > 0) {\\n            nums[index] *= -1\\n        }\\n    }\\n    \\n    for(let i=1; i<=nums.length; i++) {\\n        if(nums[i-1] > 0) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let result = []\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let index = Math.abs(nums[i]) -1\\n        if(nums[index] > 0) {\\n            nums[index] *= -1\\n        }\\n    }\\n    \\n    for(let i=1; i<=nums.length; i++) {\\n        if(nums[i-1] > 0) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1043291,
                "title": "different-o-1-space-solution",
                "content": "We swap elements whose values aren\\'t equal to their indices until we reach the end of the array, then return elements whose indices and values aren\\'t equal.\\n```python\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l = 0\\n        while l < len(nums):\\n            pos = nums[l]-1\\n            if nums[l] == nums[pos]:\\n                l += 1\\n            else:\\n                nums[l], nums[pos] = nums[pos], nums[l]\\n        return [i+1 for i,e in enumerate(nums) if i+1 != e]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l = 0\\n        while l < len(nums):\\n            pos = nums[l]-1\\n            if nums[l] == nums[pos]:\\n                l += 1\\n            else:\\n                nums[l], nums[pos] = nums[pos], nums[l]\\n        return [i+1 for i,e in enumerate(nums) if i+1 != e]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1014522,
                "title": "using-cyclic-sort-c",
                "content": "If we are at `i` , we should try to place current element in correct position in array.\\nIf its already at correct position, we should increment i.\\n##### Time complexity \\nThe time complexity of the above algorithm is O(n).\\n\\n##### Space complexity\\nIgnoring the space required for the output array, the algorithm runs in constant space O(1).\\n\\n```\\n    void swap(vector<int> &arr, int a, int b) {\\n\\tint temp = arr[a];\\n\\tarr[a] = arr[b];\\n\\tarr[b] = temp;\\n}\\nvector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0;\\n\\twhile (i < n) {\\n\\t\\tif (nums[i] == i + 1) i++; //already correct position so increment i\\n\\t\\telse {\\n\\t\\t\\tint correctPosn = nums[i] - 1;\\n\\t\\t\\tif (nums[correctPosn] == nums[i]) i++; //already present at that position\\n\\t\\t\\telse swap(nums, i, correctPosn); //swap\\n\\t\\t}\\n\\t}\\n\\tvector<int> res;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1) res.push_back(i + 1);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    void swap(vector<int> &arr, int a, int b) {\\n\\tint temp = arr[a];\\n\\tarr[a] = arr[b];\\n\\tarr[b] = temp;\\n}\\nvector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0;\\n\\twhile (i < n) {\\n\\t\\tif (nums[i] == i + 1) i++; //already correct position so increment i\\n\\t\\telse {\\n\\t\\t\\tint correctPosn = nums[i] - 1;\\n\\t\\t\\tif (nums[correctPosn] == nums[i]) i++; //already present at that position\\n\\t\\t\\telse swap(nums, i, correctPosn); //swap\\n\\t\\t}\\n\\t}\\n\\tvector<int> res;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1) res.push_back(i + 1);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 839002,
                "title": "two-solutions-in-python-hash-map-and-set-operation",
                "content": "## Solution 1: Hash Map\\n### Python 3\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        hash_table = {}\\n        result = []\\n        \\n        for num in nums:\\n          hash_table[num] = 1\\n        \\n        for num in range(1, len(nums) + 1):\\n          if num not in hash_table:\\n            result.append(num)\\n        \\n        return result\\n```\\n### Complexity Analysis \\n- Time comlexity: O(N)\\n- Space complexity: O(N)\\n\\n## Solution 2: Set Operation\\n### Python 3\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        nums_set = set(nums)\\n        ideal_set = set(range(1, len(nums) + 1))\\n        result = list(ideal_set - nums_set)\\n        \\n        return result\\n```\\n### Complexity Analysis \\n- Time comlexity: O(N)\\n- Space complexity: O(N)\\n",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        hash_table = {}\\n        result = []\\n        \\n        for num in nums:\\n          hash_table[num] = 1\\n        \\n        for num in range(1, len(nums) + 1):\\n          if num not in hash_table:\\n            result.append(num)\\n        \\n        return result\\n```\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        nums_set = set(nums)\\n        ideal_set = set(range(1, len(nums) + 1))\\n        result = list(ideal_set - nums_set)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789861,
                "title": "c-optimal-solution-85-99",
                "content": "First, the naive solution, using an extra collection, as a hashset:\\n\\n```\\n    var res=new HashSet<int>(Enumerable.Range(1,nums.Length));\\n    foreach (var item in nums)\\n        res.Remove(item);\\n    return res.ToArray()\\n```\\n\\nExplanation:  You create a hashset of numbers 1-n, and then remove numbers already at the original array.  Using hashset instead of list makes runtime faster, as hashsets are the fastest dynamic collection.\\n\\nHowever, the description asked to use the least memory possible. To do so, we must use the original array only, both for processing and as result array. Code gets way uglier, tho. The trick here is iterate the array backwards, and swapping each number to its correct position, which is \"nums[i+1]\". Then we scan the array again, and check which number is not present (meaning it was a disappeared number).\\n\\n```\\n    for (int i=nums.Length-1;i>=0;i--)  \\n        {\\n        while (nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]) \\n            (nums[i],nums[nums[i]-1])=(nums[nums[i]-1],nums[i]); \\n        } \\n    int idx=0; \\n    for (int i=0;i<nums.Length;i++) \\n        if (nums[i]!=i+1) nums[idx++]=i+1; \\n    return nums[0..idx]; \\n```\\nExplanation:\\n// Iterates array backwards.\\n// check if number is in correct position\\n// swap number with its correct position, with \"tuple swap\"\\n// now we will move all wrong (missing) numbers to the beginning of the array. \\n// iterate array again \\n// if number is misplaced (disappeared), move it to beginning of the array, increment index\\n// return wrong numbers, using C# 8.0 index range (\"split\") function\\n\\nAbove solution will only use 1 int of extra memory, which is the variable idx. Every operation is done at the original array.",
                "solutionTags": [],
                "code": "```\\n    var res=new HashSet<int>(Enumerable.Range(1,nums.Length));\\n    foreach (var item in nums)\\n        res.Remove(item);\\n    return res.ToArray()\\n```\n```\\n    for (int i=nums.Length-1;i>=0;i--)  \\n        {\\n        while (nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]) \\n            (nums[i],nums[nums[i]-1])=(nums[nums[i]-1],nums[i]); \\n        } \\n    int idx=0; \\n    for (int i=0;i<nums.Length;i++) \\n        if (nums[i]!=i+1) nums[idx++]=i+1; \\n    return nums[0..idx]; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768769,
                "title": "easy-to-understand-python-solution-3-liner-beats-95",
                "content": "```\\n\\t\\tn = len(nums)\\n\\t\\ta = [i + 1 for i in range(n)]\\n        return list(set(a) - set(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tn = len(nums)\\n\\t\\ta = [i + 1 for i in range(n)]\\n        return list(set(a) - set(nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661425,
                "title": "rust-8-ms-2-7-mb-three-lines-functional-programming-iterators-essay-explanation",
                "content": "```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter().for_each(|num| seq[(num-1) as usize] += 1);\\n        seq.into_iter().enumerate().filter(|&(x, y)| y == 0).map(|(x, y)| (x+1) as i32).collect::<Vec<i32>>()\\n    }\\n}\\n```\\nIf you test this code, you\\'ll see that it brings 8 ms and 2.7 MB, which are 100% better than all Rust submissions (as scored).  But, if you format the code properly:\\n\\n```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter()\\n            .for_each(|num|\\n\\t\\t\\t\\tseq[(num - 1) as usize] += 1\\n\\t\\t\\t);\\n        seq.into_iter()\\n            .enumerate()\\n            .filter(|&(index, count)| count == 0)\\n            .map(|(index, _)| (index + 1) as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\\n... this code will bring you 12 ms and 2.5 MB.\\n\\nAnyway, the idea is to keep an array that works as a sort of HashMap for number sequences.  The index of the array is a number that appears in the sequence; the value at the index is the count of how many times it appears.\\nSince the array\\'s numbers are in the range of its size, we create an array (integer hashmap) that holds the indexes of the numbers we are looking for.\\n\\nWe pass through the array with `for_each(|num| seq[num...] += 1)` to keep a count of nums.  Notice that since arrays are 0-indexed but the sequence is annoyingly 1-indexed, we must subtract 1, and that Rust must use usize to index, so we must cast.  You can use a simple for loop instead of `for_each()`, and indeed, the Rust docs say that it is more idiomatic; but we want to save lines and look cool with a functional style, so we do this.\\n\\nSince we use `into_iter()` instead of `iter()`, we are moving values into iterators, and thus destroying what we don\\'t need; we can also do this because the function passes in arguments by move (rather un-Rust-like).  I don\\'t know if it reduces memory usage at all, but it at least minimizes it - on principle, don\\'t pay for what you don\\'t use.\\n\\n(Note that in general, moving and modifying a vector [temporarily allocates new space](https://users.rust-lang.org/t/into-iter-from-vec-vec-memory-consumption/35778/4) for it.)\\n\\nWe take the hashmap/array and `enumerate()` it to be able to see at what index each value lies.  We `filter()` to find all elements where the count value is 0; then `map()` to acquire the index part of the tuple (destructure the tuple).  We then `collect()` into a vector of i32 and return the vector expression-wise.\\n\\n-==-\\n\\nIn Rust, iterators are lazy (and their implementation is abstracted to the source code), so it becomes challenging to describe the complexity of the program.  At the very least, the time complexity of the solution is O(n).  Each iterator encapsulates a single pass over the collection, so we might conjecture that the complexity is O(2n), with one complete pass over the array `nums` of length `n`, and one worst-case pass over `seq` over `n-1` elements.\\n\\nThe memory usage is also strange, since it\\'s unclear how memory use is calculated.  Does leetcode consider the peak of memory usage in the lifetime of the solution?  Or does it consider the memory still allocated by the very end of the scope?  Or does it average out memory usage over time, or something weird.  No one knows.\\n\\nAt the least, we know that we can allocate one extra array (as described in the problem).  So the space complexity of this problem varies alongside our axioms and knowledge of iterator allocation (which you can find yourself by googling, or looking at the source code, both of which I have done but not accepted):\\n\\nIf we do not count the result vector we allocated, we have O(1); \\nIf we count the result vector, we have O(n); \\nIf we discover that moving a vector into an iterator and collecting again into a vector does consume more memory, we have O(2n), which degrades to O(n);\\nIf we discover that discovery, but not count the result vector, we might claim that the extra allocation caused by `iterator -> collect`  is another vector, thus giving us O(n).\\n\\nOverall, the solution is probably O(n) | O(n), which is embarassing since there are in-place solutions out there.  But  none of them are as flashy or as elegant as just calling a few functions.  Realistically, you\\'d want to get it done quickly, simply (idiomatically/structurally), and readably; well, this is good enough, I suppose.  Plenty of linear algebra libraries use cache-ignorant matrix operations... welp!",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter().for_each(|num| seq[(num-1) as usize] += 1);\\n        seq.into_iter().enumerate().filter(|&(x, y)| y == 0).map(|(x, y)| (x+1) as i32).collect::<Vec<i32>>()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter()\\n            .for_each(|num|\\n\\t\\t\\t\\tseq[(num - 1) as usize] += 1\\n\\t\\t\\t);\\n        seq.into_iter()\\n            .enumerate()\\n            .filter(|&(index, count)| count == 0)\\n            .map(|(index, _)| (index + 1) as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540609,
                "title": "python-one-liner-better-than-94",
                "content": "``` \\n\\treturn list(set(range(1,len(nums)+1))-set(nums))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\n\\treturn list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500498,
                "title": "easy-java-solution-no-extra-space-11-lines",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {        \\n\\t\\tArrays.sort(nums);\\n        int q=nums.length;\\n        List<Integer> lista = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(0>Arrays.binarySearch(nums, q--))\\n                lista.add(q+1);\\n        }\\n        return lista;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {        \\n\\t\\tArrays.sort(nums);\\n        int q=nums.length;\\n        List<Integer> lista = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(0>Arrays.binarySearch(nums, q--))\\n                lista.add(q+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 413215,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j= Math.abs(nums[i]) - 1;\\n            nums[j]=-1*Math.abs(nums[j]); //make negative\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n      for(int i=0;i<nums.length;i++)\\n      {\\n          if(nums[i]>0){\\n              res.add(i+1);\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nmaking numbers index negative if that number is present(Mark them visited/present)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j= Math.abs(nums[i]) - 1;\\n            nums[j]=-1*Math.abs(nums[j]); //make negative\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n      for(int i=0;i<nums.length;i++)\\n      {\\n          if(nums[i]>0){\\n              res.add(i+1);\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233405,
                "title": "python-6-line-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        l, ans, length = 0, [], len(nums)\\n        while l < length:\\n            while nums[nums[l] - 1] != nums[l]:\\n                nums[nums[l] - 1], nums[l] = nums[l], nums[nums[l] - 1]\\n            l += 1\\n        return [i + 1 for i in range(length) if nums[i] != i + 1]\\n```\\n\\nThe main idea of my solution is to try to put each number to the cell with the index = number. For example, having array 4, 1, 2, 7, 3, 5, 6, firstly we will put the first number 4 to the fourth cell, swapping it with 7: 7, 1, 2, 4, 3, 5, 6. Then we do the same thing with 7. When should we stop? We will stop when we\\'ll try to put number to the cell, which already contains the same number. For example, 4, 1, 2, 4, 5, 5: we wouldn\\'t swap 4 with 4 because it will lead to the cycle. In this case we should consider next number (here it\\'s 1) and repeat same things with it. So, we will store a pointer to the current number we are working with (it\\'s l in my solution) and try to change it with the cell which index = number while it\\'s possible and then increment out pointer. At the end we\\'ll have an array in which if the number isn\\'t equal to the index of the cell in which it\\'s situated it will mean that number with the value = this index is missed and we have to add it to the answer. \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        l, ans, length = 0, [], len(nums)\\n        while l < length:\\n            while nums[nums[l] - 1] != nums[l]:\\n                nums[nums[l] - 1], nums[l] = nums[l], nums[nums[l] - 1]\\n            l += 1\\n        return [i + 1 for i in range(length) if nums[i] != i + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161861,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n==0 :return []\\n        for i in range(n):\\n            num = nums[i]\\n            while num != -1:\\n                tmp = nums[num-1]\\n                nums[num-1] = -1\\n                num = tmp\\n        return [i+1 for i in range(n) if nums[i]!=-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n==0 :return []\\n        for i in range(n):\\n            num = nums[i]\\n            while num != -1:\\n                tmp = nums[num-1]\\n                nums[num-1] = -1\\n                num = tmp\\n        return [i+1 for i in range(n) if nums[i]!=-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140737,
                "title": "python-o-n-time-no-extra-space-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for n in nums:\\n            nums[abs(n) - 1] = - abs(nums[abs(n) - 1])\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                output.append(i+1)\\n        return output",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for n in nums:\\n            nums[abs(n) - 1] = - abs(nums[abs(n) - 1])\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                output.append(i+1)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 3684183,
                "title": "swap-sort-concept-time-complexity-o-n-space-complexity-o-1",
                "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423491,
                "title": "set-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have number 1 to n and find missing numbers in between\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaking a set and after that running a loop 1 to n and checking value have inside of set or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n   let n = nums.length;\\n    let ans = new Set(nums);\\n    let array = [];\\n    for (let i = 1; i <= n; i++) {\\n        if (!ans.has(i)) {\\n           array.push(i);\\n        }\\n    }\\n    return array;\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n   let n = nums.length;\\n    let ans = new Set(nums);\\n    let array = [];\\n    for (let i = 1; i <= n; i++) {\\n        if (!ans.has(i)) {\\n           array.push(i);\\n        }\\n    }\\n    return array;\\n}\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3384080,
                "title": "easy-js-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let i=0; i<nums.length; i++) {\\n        const curr = Math.abs(nums[i]);\\n        if(nums[curr-1] >0) {\\n            nums[curr-1] *=-1;\\n        }\\n    }\\n\\n    let idx = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] > 0) {\\n            nums[idx] = i+1;\\n            idx++;\\n        }\\n    }\\n    return nums.slice(0,idx);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let i=0; i<nums.length; i++) {\\n        const curr = Math.abs(nums[i]);\\n        if(nums[curr-1] >0) {\\n            nums[curr-1] *=-1;\\n        }\\n    }\\n\\n    let idx = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] > 0) {\\n            nums[idx] = i+1;\\n            idx++;\\n        }\\n    }\\n    return nums.slice(0,idx);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3226683,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const uniqueValues = new Set(nums);\\n  const result = [];\\n\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!uniqueValues.has(i)) {\\n      result.push(i);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const uniqueValues = new Set(nums);\\n  const result = [];\\n\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!uniqueValues.has(i)) {\\n      result.push(i);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095191,
                "title": "java-o-n-time-o-1-space-complete-dry-run-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {      \\n        // sorting when the numbers are from 1 to n \\n\\t\\t// we are checking i+1 as range is from 1 to n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] != i+1 && nums[i] != nums[nums[i] - 1])\\n            {\\n                //swap\\n                int temp =  nums[i];\\n                nums[i] = nums[temp-1];\\n                nums[temp-1] = temp;\\n                // to check the current ith pos\\'n again so that the correct value is here\\n                i--;\\n            }           \\n        }\\n        //the values which are not in their correct posn should be checked here and inserted into the list \\n        List<Integer> list = new ArrayList<>();\\n        for(int i =0;i<nums.length; i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                list.add(i+1);\\n            }\\n        }       \\n        return list; \\n    }\\n}\\n// the following dry run can explain the sorting happening \\n/*\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n*/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {      \\n        // sorting when the numbers are from 1 to n \\n\\t\\t// we are checking i+1 as range is from 1 to n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] != i+1 && nums[i] != nums[nums[i] - 1])\\n            {\\n                //swap\\n                int temp =  nums[i];\\n                nums[i] = nums[temp-1];\\n                nums[temp-1] = temp;\\n                // to check the current ith pos\\'n again so that the correct value is here\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3077181,
                "title": "ts-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findDisappearedNumbers(nums: number[]): number[] {\\n   let set = new Set(nums) , result = []\\n    for (let i = 1; i < nums.length+1; i++) { \\n        if (!set.has(i)){\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findDisappearedNumbers(nums: number[]): number[] {\\n   let set = new Set(nums) , result = []\\n    for (let i = 1; i < nums.length+1; i++) { \\n        if (!set.has(i)){\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058614,
                "title": "python-set-concept",
                "content": "# Intuition\\ncreate two sets a and b , a with numbers ranged from 1 to n and b with nums, just return the (a-b) with typecasting to list\\n\\n# Approach\\nsubtraction of sets\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        a = set(range(1,len(nums)+1))\\n        b = set(nums)\\n        return list(a-b)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        a = set(range(1,len(nums)+1))\\n        b = set(nums)\\n        return list(a-b)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837907,
                "title": "easy-and-fast-sol-100-beats-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0;i<nums.length;++i){\\n            int n=Math.abs(nums[i]);\\n            if (nums[n-1]>0)nums[n-1]=-1*nums[n-1];\\n        }\\n        for (int i=0;i<nums.length;++i){\\n            if(nums[i]>0) list.add(i+1);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0;i<nums.length;++i){\\n            int n=Math.abs(nums[i]);\\n            if (nums[n-1]>0)nums[n-1]=-1*nums[n-1];\\n        }\\n        for (int i=0;i<nums.length;++i){\\n            if(nums[i]>0) list.add(i+1);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833240,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(auto x: nums) mp[x]++;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++) {\\n            if(!mp[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(auto x: nums) mp[x]++;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++) {\\n            if(!mp[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718075,
                "title": "python-easy-code-o-n-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        res = []\\n        for x in nums:\\n            if nums[abs(x)-1] > 0:\\n                nums[abs(x)-1]*=-1\\n        for i, x in enumerate(nums):\\n            if x> 0:\\n                res.append(i+1)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        res = []\\n        for x in nums:\\n            if nums[abs(x)-1] > 0:\\n                nums[abs(x)-1]*=-1\\n        for i, x in enumerate(nums):\\n            if x> 0:\\n                res.append(i+1)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2687862,
                "title": "python-simple-solution-in-6-lines-faster-90-32",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        arr=set(nums)\\n        a,n=[],len(nums)\\n        for i in range(1,n+1):\\n            if i not in arr:\\n                a.append(i)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        arr=set(nums)\\n        a,n=[],len(nums)\\n        for i in range(1,n+1):\\n            if i not in arr:\\n                a.append(i)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675430,
                "title": "python-with-explanation",
                "content": "```\\n\"\"\"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\"\"\"\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            index=abs(i)-1\\n            nums[index]=-1 * abs(nums[index])\\n        res=[]\\n        for i,n in enumerate(nums):\\n            if n>0:\\n                res.append(i+1)\\n        return res\\n    \\n# EXPLANATION\\n    # First we will iterate through the array and change the element at indexes of present element to negative\\n    # (We will use abs because the value might be negative only once we have changed but we go to that element second time also\\n    # We will map element to their corresponding index here, like if we find 4, we will turn elelment at 3rd index to be negative. If we find 2, we will change element at 1st index to be negative. By doing so, we will change all the indexes corresponding to elements as negative and only absend element\\'s index will be positive)\\n    # We will run another loop and if number in our array is positive, then we will add the element corresponding to its index in the result array\\n    #  ( for example, if element at index 2 is positive, we will add 3 in our result array)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\"\"\"\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            index=abs(i)-1\\n            nums[index]=-1 * abs(nums[index])\\n        res=[]\\n        for i,n in enumerate(nums):\\n            if n>0:\\n                res.append(i+1)\\n        return res\\n    \\n# EXPLANATION\\n    # First we will iterate through the array and change the element at indexes of present element to negative\\n    # (We will use abs because the value might be negative only once we have changed but we go to that element second time also\\n    # We will map element to their corresponding index here, like if we find 4, we will turn elelment at 3rd index to be negative. If we find 2, we will change element at 1st index to be negative. By doing so, we will change all the indexes corresponding to elements as negative and only absend element\\'s index will be positive)\\n    # We will run another loop and if number in our array is positive, then we will add the element corresponding to its index in the result array\\n    #  ( for example, if element at index 2 is positive, we will add 3 in our result array)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663914,
                "title": "java-solution-using-hashset",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\t\\t\\tList<Integer>list=new ArrayList<>();\\n\\t\\t\\tHashSet<Integer>li=new HashSet<>();\\n\\t\\t\\tfor(int i=1;i<=nums.length;i++)\\n\\t\\t\\t\\tli.add(i);\\n\\t\\t\\tfor(int j=0;j<nums.length;j++)\\n\\t\\t\\t\\tif(li.contains(nums[j]))\\n\\t\\t\\t\\t\\tli.remove(nums[j]);\\n\\t\\t\\tlist.addAll(li);\\n\\t\\t\\treturn list;\\n\\n\\t\\t  }\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\t\\t\\tList<Integer>list=new ArrayList<>();\\n\\t\\t\\tHashSet<Integer>li=new HashSet<>();\\n\\t\\t\\tfor(int i=1;i<=nums.length;i++)\\n\\t\\t\\t\\tli.add(i);\\n\\t\\t\\tfor(int j=0;j<nums.length;j++)\\n\\t\\t\\t\\tif(li.contains(nums[j]))\\n\\t\\t\\t\\t\\tli.remove(nums[j]);\\n\\t\\t\\tlist.addAll(li);\\n\\t\\t\\treturn list;\\n\\n\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 2405996,
                "title": "time-o-n-space-o-1-no-extra-space-used-faster-than-97-99-memory-less-than-98-21",
                "content": "1.  Iterating the given array, taking each element(index=abs(element)-1) and changing the sign of that value to neagative at this index for the 1 st time.\\n2.  Iterating again through the array to find the positive numbers. That means the index+1 of that positive number is not present in array.\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i : nums){\\n            int index = Math.abs(i)-1;\\n            if(nums[index]>0){\\n                nums[index]=-nums[index];\\n            }\\n        }\\n        for(int i=0; i<nums.length ; i++){\\n            if(nums[i]>=0){\\n                l.add(i+1);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i : nums){\\n            int index = Math.abs(i)-1;\\n            if(nums[index]>0){\\n                nums[index]=-nums[index];\\n            }\\n        }\\n        for(int i=0; i<nums.length ; i++){\\n            if(nums[i]>=0){\\n                l.add(i+1);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285662,
                "title": "faster-than-90-c-in-place-solution-tc-o-n",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int t = abs(nums[i]);\\n            if(nums[t-1] > 0) nums[t-1] *= (-1);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8c19e752-431b-4322-8ec5-4d843a61e458_1657883756.0280447.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int t = abs(nums[i]);\\n            if(nums[t-1] > 0) nums[t-1] *= (-1);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255749,
                "title": "python-simple-solution-using-logic-with-detailed-explanation",
                "content": "\"\"\"\\nRuntime Complexity:\\nO(n) - because we run a for loop and take the absolute of indices and subract 1 from each element. Because array of length 8 contains\\n8 elements and if you subract 8 with 1, we get 7 which is the last index in our array since it starts from 0 index. We traverse and subract 1 with\\nevery element and go to the particular index and set it to negative. We do this for \\'n\\' elements and we finally run a for loop\\nto check the positive numbers and append it to result array. We then finally return the result.\\nSpace Complexity: O(1) - because the array length is fixed and missing numbers are always less than \\'n\\' so we append only few elements to it. Worst case can be O(N) if all elements are added to result array.\\n\"\"\"\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if len(nums)==0:\\n            return []\\n        n = len(nums)\\n        result = []\\n        for i in range(0,n):\\n            index = abs(nums[i])-1\\n            if nums[index]>0:\\n                nums[index] = nums[index]*-1\\n            else:\\n                continue\\n        print(nums)\\n        for i in range(0,n):\\n            if nums[i]>0:\\n                result.append(i+1)\\n            else:\\n                nums[i] = nums[i] *-1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if len(nums)==0:\\n            return []\\n        n = len(nums)\\n        result = []\\n        for i in range(0,n):\\n            index = abs(nums[i])-1\\n            if nums[index]>0:\\n                nums[index] = nums[index]*-1\\n            else:\\n                continue\\n        print(nums)\\n        for i in range(0,n):\\n            if nums[i]>0:\\n                result.append(i+1)\\n            else:\\n                nums[i] = nums[i] *-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153854,
                "title": "easy-c-sol-naive-efficient-approach-time-o-n-aux-space-o-1",
                "content": "```\\n// Naive Solution :: Time : O(N) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        vector<int> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i=1;i<=n;i++){\\n            s.insert(i);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(s.find(nums[i]) != s.end()){\\n                s.erase(nums[i]);\\n            }\\n        }\\n        \\n        for(auto x: s){\\n            res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[abs(nums[i])-1] > 0){\\n                nums[abs(nums[i])-1]  *= (-1);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i] > 0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        vector<int> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i=1;i<=n;i++){\\n            s.insert(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2037235,
                "title": "java-solution-using-hashmap-and-hashset-o-n-time-complexity",
                "content": "**Code using HashMap**\\n```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        List<Integer> arr = new ArrayList();\\n        for(int i=0; i<nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(map.get(i) == null) arr.add(i);\\n        }\\n        \\n        return arr;\\n    }\\n```\\n\\n\\n**Code using HashSet**\\n```\\n\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n         HashSet<Integer> set = new HashSet();\\n         List<Integer> arr = new ArrayList();\\n         for(int i=0; i<nums.length; i++) set.add(nums[i]);\\n         for(int i=1; i<=nums.length; i++){\\n             if(!set.contains(i)) arr.add(i);\\n         }\\n        return arr;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        List<Integer> arr = new ArrayList();\\n        for(int i=0; i<nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(map.get(i) == null) arr.add(i);\\n        }\\n        \\n        return arr;\\n    }\\n```\n```\\n\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n         HashSet<Integer> set = new HashSet();\\n         List<Integer> arr = new ArrayList();\\n         for(int i=0; i<nums.length; i++) set.add(nums[i]);\\n         for(int i=1; i<=nums.length; i++){\\n             if(!set.contains(i)) arr.add(i);\\n         }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983319,
                "title": "c-optimized-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr=abs(nums[i]);          //taking absolute value of the element at index i\\n            nums[curr-1]=-abs(nums[curr-1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr=abs(nums[i]);          //taking absolute value of the element at index i\\n            nums[curr-1]=-abs(nums[curr-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952520,
                "title": "java-2-methods-simple",
                "content": "\\n//------------------using Hashset--------------------------------------------------\\n    //--------------time comp: O(n)------------------------------------------\\n    //-------------space comp: O(n)------------------------------------------------------\\n```\\n    public static List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> set=new HashSet<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(!set.contains(i))\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n\\t```\\n\\t//--------------------using Cyclic sort----------------------------------------\\n    //-------------time comp: O(n)------------------------------------\\n    //-------------space comp: O(1)---------------------------------------\\n\\t\\n\\t```\\n\\tpublic static List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correctIndex=nums[i]-1;\\n            if(nums[i]!=nums[correctIndex])\\n                swap(nums,i,correctIndex);\\n            else\\n                i++;\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n                list.add(j+1);\\n        }\\n        return list;\\n        \\n    }\\n     public static void swap(int arr[],int j,int m)\\n    {\\n        int temp=arr[j];\\n        arr[j]=arr[m];\\n        arr[m]=temp;\\n    }\\n\\n}\\n```\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    public static List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> set=new HashSet<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(!set.contains(i))\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n\\t```\n```\\n\\tpublic static List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correctIndex=nums[i]-1;\\n            if(nums[i]!=nums[correctIndex])\\n                swap(nums,i,correctIndex);\\n            else\\n                i++;\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n                list.add(j+1);\\n        }\\n        return list;\\n        \\n    }\\n     public static void swap(int arr[],int j,int m)\\n    {\\n        int temp=arr[j];\\n        arr[j]=arr[m];\\n        arr[m]=temp;\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894122,
                "title": "python-faster-than-95-o-n",
                "content": "# Please upvote if it helps\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]: \\n        i = 1\\n        res = []\\n        j = len(nums)\\n        nums = set(nums)\\n        \\n        while i<=j:\\n            \\n            if not i in nums:\\n                res.append(i) \\n            \\n            i +=1\\n        \\n        return res\\n        \\n```\\n\\n![image](https://assets.leetcode.com/users/images/0040f25e-3c7e-40a1-8852-001f9b8fd833_1648656721.145055.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]: \\n        i = 1\\n        res = []\\n        j = len(nums)\\n        nums = set(nums)\\n        \\n        while i<=j:\\n            \\n            if not i in nums:\\n                res.append(i) \\n            \\n            i +=1\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758963,
                "title": "o-n-time-and-o-n-space-solution",
                "content": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n   \\n        nums_1 = set(nums)\\n        res = []\\n        for i in range(1,len(nums)+1):\\n            if i not in nums_1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n   \\n        nums_1 = set(nums)\\n        res = []\\n        for i in range(1,len(nums)+1):\\n            if i not in nums_1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746321,
                "title": "simple-cyclic-sort-problem",
                "content": "\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        brute force is to implement cyclic sort\\n        we will start with examples\\n        [4,3,2,7,8,2,3,1]\\n        \\n        n = 8 means array should contain all the values from 1 to 8\\n        means each no is stored on n - 1 idx\\n        [1,2,3,4, , , 7,8]\\n        \\n        our first pointer will graze over array\\n            then we will take val at first ptr\\n            if nums[first ptr] != nums[val at first ptr - 1]\\n                then swap\\n            else \\n                inc first ptr\\n        \\n        firstPtr        valAtFirstPtr           arr\\n        0               4                     [4,3,2,7,8,2,3,1]\\n                                              [7,3,2,4,8,2,3,1]\\n                         7                    [7,3,2,4,8,2,3,1]\\n                                              [1,3,2,4,8,2,3,7]\\n        1                3                    [1,3,2,4,8,2,3,7]\\n                                              [1,2,3,4,8,2,3,7]\\n        2                 3                    [1,2,3,4,8,2,3,7]\\n        3                 4                      [1,2,3,4,8,2,3,7]\\n        4                 8                     [1,2,3,4,7,2,3,8]\\n        4                 7                     [1,2,3,4,3,2,7,8]\\n        4                 3                     [1,2,3,4,3,2,7,8]\\n        5                 2                      [1,2,3,4,3,2,7,8]\\n        6                  7                    [1,2,3,4,3,2,7,8]\\n        7                  8                    [1,2,3,4,3,2,7,8]\\n\\n    now at last check which idx value doesnt match\\n    tc = O(n)\\n    sc = O(1)\\n        \"\"\"\\n        def cyclicSort(nums):\\n            n = len(nums)\\n            firstPtr = 0\\n            while firstPtr < n:\\n                valAtFirstPtr = nums[firstPtr]\\n                if nums[firstPtr] != nums[valAtFirstPtr - 1]:\\n                    nums[firstPtr],nums[valAtFirstPtr - 1] = nums[valAtFirstPtr - 1],nums[firstPtr]\\n                else:\\n                    firstPtr += 1\\n                    \\n        def findMissingNo(nums):\\n            missingNo = []\\n            n = len(nums)\\n            for i in range(n):\\n                if nums[i] != i + 1:\\n                    missingNo.append(i + 1)\\n            return missingNo\\n        \\n        cyclicSort(nums)\\n        return findMissingNo(nums)\\n        \\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        brute force is to implement cyclic sort\\n        we will start with examples\\n        [4,3,2,7,8,2,3,1]\\n        \\n        n = 8 means array should contain all the values from 1 to 8\\n        means each no is stored on n - 1 idx\\n        [1,2,3,4, , , 7,8]\\n        \\n        our first pointer will graze over array\\n            then we will take val at first ptr\\n            if nums[first ptr] != nums[val at first ptr - 1]\\n                then swap\\n            else \\n                inc first ptr\\n        \\n        firstPtr        valAtFirstPtr           arr\\n        0               4                     [4,3,2,7,8,2,3,1]\\n                                              [7,3,2,4,8,2,3,1]\\n                         7                    [7,3,2,4,8,2,3,1]\\n                                              [1,3,2,4,8,2,3,7]\\n        1                3                    [1,3,2,4,8,2,3,7]\\n                                              [1,2,3,4,8,2,3,7]\\n        2                 3                    [1,2,3,4,8,2,3,7]\\n        3                 4                      [1,2,3,4,8,2,3,7]\\n        4                 8                     [1,2,3,4,7,2,3,8]\\n        4                 7                     [1,2,3,4,3,2,7,8]\\n        4                 3                     [1,2,3,4,3,2,7,8]\\n        5                 2                      [1,2,3,4,3,2,7,8]\\n        6                  7                    [1,2,3,4,3,2,7,8]\\n        7                  8                    [1,2,3,4,3,2,7,8]\\n\\n    now at last check which idx value doesnt match\\n    tc = O(n)\\n    sc = O(1)\\n        \"\"\"\\n        def cyclicSort(nums):\\n            n = len(nums)\\n            firstPtr = 0\\n            while firstPtr < n:\\n                valAtFirstPtr = nums[firstPtr]\\n                if nums[firstPtr] != nums[valAtFirstPtr - 1]:\\n                    nums[firstPtr],nums[valAtFirstPtr - 1] = nums[valAtFirstPtr - 1],nums[firstPtr]\\n                else:\\n                    firstPtr += 1\\n                    \\n        def findMissingNo(nums):\\n            missingNo = []\\n            n = len(nums)\\n            for i in range(n):\\n                if nums[i] != i + 1:\\n                    missingNo.append(i + 1)\\n            return missingNo\\n        \\n        cyclicSort(nums)\\n        return findMissingNo(nums)\\n        \\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1724267,
                "title": "python-99-55-faster-39-59-better-memory",
                "content": "1. We have to consider the range `[1,n]`, ie infinite series of natural numbers.\\n2. Put all values in a set\\n3. If `l + 1` (remember range `[1,n]`) is not in our set, simply append to our result array, `res`\\n4. Increament counter\\n5. return result array\\n\\n`O(1)` look-up for `if l+1 not in unique`\\n`O(n)` for iteration\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)\\n        res = []\\n        unique = set(nums)\\n\\n        while l < r:\\n            if l+1 not in unique:\\n                res.append(l+1)\\n            l += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)\\n        res = []\\n        unique = set(nums)\\n\\n        while l < r:\\n            if l+1 not in unique:\\n                res.append(l+1)\\n            l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673641,
                "title": "js-solution-fast-space-efficient",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let n of nums) {\\n        const idx = Math.abs(n) - 1\\n        if (nums[idx] > 0) nums[idx] *= -1\\n    }\\n    let result = []\\n    for(let i=0; i< nums.length; i++) {\\n        if(nums[i] > 0) result.push(i+1)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let n of nums) {\\n        const idx = Math.abs(n) - 1\\n        if (nums[idx] > 0) nums[idx] *= -1\\n    }\\n    let result = []\\n    for(let i=0; i< nums.length; i++) {\\n        if(nums[i] > 0) result.push(i+1)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655177,
                "title": "easy-java-100-fast-solution",
                "content": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]-1]++;\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(arr[i]==0)\\n                ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]-1]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646161,
                "title": "c-o-n-o-1-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        int l = nums.size();\\n        for (int i = 0; i < l; i++) {\\n            int index = abs(nums[i]) - 1;\\n            if (nums[index] > 0) {\\n                nums[index] *= -1;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n           if (nums[i] > 0) {\\n               res.push_back(i + 1);\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        int l = nums.size();\\n        for (int i = 0; i < l; i++) {\\n            int index = abs(nums[i]) - 1;\\n            if (nums[index] > 0) {\\n                nums[index] *= -1;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n           if (nums[i] > 0) {\\n               res.push_back(i + 1);\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564965,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1570677,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1565203,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1569361,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574524,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571974,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571712,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1921352,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1576391,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574446,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1564965,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1570677,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1565203,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1569361,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574524,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571974,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571712,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1921352,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1576391,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574446,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1572879,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1786431,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1750947,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1720675,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1573272,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1571710,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2047092,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2046718,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2046385,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1957215,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1920607,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1812339,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1801716,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1781075,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1763628,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1731022,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1729957,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1726469,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1725514,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1723963,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            }
        ]
    },
    {
        "title": "Split Array with Equal Sum",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]